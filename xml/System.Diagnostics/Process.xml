<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata><Meta Name="ms.openlocfilehash" Value="eebf0c874b21eaa1f27366a322efad2f43dce7ae" /><Meta Name="ms.sourcegitcommit" Value="d273738f2e9a7125fddf20a2da56406d86290ce9" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/10/2019" /><Meta Name="ms.locfileid" Value="67725139" /></Metadata><TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht den Zugriff auf lokale Prozesse und Remoteprozesse und das Starten und Anhalten lokaler Systemprozesse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Diagnostics.Process> Komponente ermöglicht den Zugriff auf einen Prozess, der auf einem Computer ausgeführt wird. Ein Prozess ist, die einfach gesagt, eine ausgeführte app. Ein Thread ist die grundlegende Einheit, die zu der das Betriebssystem Prozessorzeit zuweist. Ein Thread kann einen beliebigen Teil der Code des Prozesses, einschließlich der Bereiche, die derzeit ausgeführt wird, von einem anderen Thread ausgeführt werden.  
  
 Die <xref:System.Diagnostics.Process> Komponente ist ein nützliches Tool zum Starten, anhalten, steuern und Überwachen von apps. Sie können die <xref:System.Diagnostics.Process> Komponente, um eine Liste der Prozesse abzurufen, die ausgeführt werden, oder Sie können einen neuen Prozess starten. Ein <xref:System.Diagnostics.Process> Komponente wird verwendet, um Systemprozesse zugreifen. Nach einem <xref:System.Diagnostics.Process> Komponente initialisiert wurde, sondern die verwendet werden kann, um Informationen zum ausgeführten Prozess zu erhalten. Diese Informationen beinhalten den Satz von Threads, die geladenen Module (DLL- und .exe-Dateien) und Leistungsinformationen, z. B. die Größe des Arbeitsspeichers des Prozesses verwendet.  
  
 Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle. Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen. Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`finally`-Block auf. Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.  
  
> [!NOTE]
>  32-Bit-Prozesse können nicht die Module eines 64-Bit-Prozesses zugreifen. Wenn Sie versuchen, erhalten Informationen zu einem 64-Bit-Prozess von einem 32-Bit-Prozess, erhalten Sie eine <xref:System.ComponentModel.Win32Exception> Ausnahme. Ein 64-Bit-Prozess kann die Module ein 32-Bit-Prozess auf der anderen Seite zugreifen.  
  
 Die Process-Komponente ruft Informationen zu einer Gruppe von Eigenschaften, die alle auf einmal ab. Nach der <xref:System.Diagnostics.Process> Komponente Informationen über ein Mitglied einer Gruppe abgerufen hat, wird die Werte für die anderen Eigenschaften in dieser Gruppe Zwischenspeichern und neue Informationen über die anderen Mitglieder der Gruppe nicht abgerufen werden, bis zum Aufruf der <xref:System.Diagnostics.Process.Refresh%2A> Methode. Aus diesem Grund ein Eigenschaftswert wird nicht unbedingt aktueller als beim letzten Aufruf von der <xref:System.Diagnostics.Process.Refresh%2A> Methode. Die Einteilung der Gruppen sind abhängig vom Betriebssystem.  
  
 Wenn Sie eine Pfadvariable in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie diesen Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad befindet, und unter Verwendung von Anführungszeichen hinzugefügt werden: `path = %path%;"c:\mypath"`, müssen Sie alle Prozesse in vollständig qualifizieren `c:\mypath` beim Starten.  
  
 Ein Systemprozess ist auf das System durch die Prozess-ID eindeutig identifiziert. Wie viele Windows-Ressourcen wird ein Prozess auch von seinem Handle identifiziert, der möglicherweise nicht auf dem Computer eindeutig. Ein Handle ist der Oberbegriff für einen Bezeichner einer Ressource. Das Betriebssystem behält das Prozesshandle, die über zugegriffen wird die <xref:System.Diagnostics.Process.Handle%2A> Eigenschaft der <xref:System.Diagnostics.Process> Komponente, auch wenn der Prozess beendet wurde. Daher erhalten Sie die Informationen des Prozesses administrative, wie z. B. die <xref:System.Diagnostics.Process.ExitCode%2A> (in der Regel entweder 0 (null) für den Erfolg oder ein Fehlercode ungleich null) und die <xref:System.Diagnostics.Process.ExitTime%2A>. Handles sind eine äußerst nützliche Ressource, daher Verlust von Handles mehr bösartig als Speicherverlust.  
  
> [!NOTE]
>  Diese Klasse enthält einen Linkaufruf und einer vererbungsanforderung auf Klassenebene, die für alle Elemente gilt. Ein <xref:System.Security.SecurityException> wird ausgelöst, wenn Sie entweder den unmittelbaren Aufrufer oder die abgeleitete Klasse nicht über volle Vertrauenswürdigkeit verfügt. Weitere Informationen zu sicherheitsanforderungen, finden Sie unter [Verknüpfungsaufrufe](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Anmerkungen zu dieser Version  
 In .NET Framework die <xref:System.Diagnostics.Process> Klasse verwendet standardmäßig <xref:System.Console> Codierungen, die in der Regel sind code codepagecodierungen, für die Eingabe, Ausgabe und Fehler Streams. Beispielcode, auf Systemen, die mit der Kultur Englisch (Vereinigte Staaten) ist, wird die Codepage 437 die standardcodierung für die <xref:System.Console> Klasse. Allerdings [!INCLUDE[net_core](~/includes/net-core-md.md)] kann nur eine beschränkte Teilmenge dieser Codierungen zur Verfügung stellen. Wenn dies der Fall ist, wird <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> als die standardcodierung.  
  
 Wenn eine <xref:System.Diagnostics.Process> Objekt abhängig ist, auf bestimmte codepagecodierungen, können Sie weiterhin diese verfügbar machen, indem Sie die folgenden *vor* rufen Sie alle <xref:System.Diagnostics.Process> Methoden:  
  
1.  Fügen Sie dem Projekt einen Verweis auf die Assembly System.Text.Encoding.CodePages.dll hinzu.  
  
2.  Abrufen der <xref:System.Text.EncodingProvider> -Objekt aus der <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> Eigenschaft.  
  
3.  Übergeben Sie die <xref:System.Text.EncodingProvider> -Objekt an die <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> Methode, um die zusätzlichen Codierungen, die von der Codierung der verfügbaren Anbieter unterstützt werden.  
  
 Die <xref:System.Diagnostics.Process> Klasse automatisch verwendet dann das System standardcodierung statt UTF8, vorausgesetzt, dass Sie den encoding-Anbieter registriert haben, bevor er einen <xref:System.Diagnostics.Process> Methoden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von der <xref:System.Diagnostics.Process> Klasse, um einen Prozess zu starten.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 Im folgenden Beispiel wird die <xref:System.Diagnostics.Process> Klasse selbst und eine statische <xref:System.Diagnostics.Process.Start%2A> Methode zum Starten eines Prozesses.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 Die folgenden F# Beispiel definiert eine `runProc` -Funktion, die einen Prozess startet alle Ausgabe- und Informationen erfasst und zeichnet die Anzahl der Millisekunden, die der Prozess ausgeführt wurde.  Die `runProc` Funktion verfügt über drei Parameter: den Namen der Anwendung zu starten, die Argumente, die die Anwendung, und das Startverzeichnis bereitgestellt.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 Der Code für die `runProc` Funktion wurde von geschrieben [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) und finden Sie unter den [Microsoft Public License](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Diese Klasse kann nicht von teilweise vertrauenswürdigem Code verwendet werden.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Diese Klasse kann nicht von teilweise vertrauenswürdigem Code nicht geerbt werden.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">Mithilfe der Prozessklasse für .NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.Process" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie keinen angeben der <xref:System.Diagnostics.Process.MachineName%2A> -Eigenschaft, die Standardeinstellung ist der lokale Computer (".").  
  
 Sie haben zwei Optionen für die Zuordnung ein neues <xref:System.Diagnostics.Process> Komponente mit dem ein Prozess auf dem Computer. Die erste Option ist die Verwendung den Konstruktor zum Erstellen der <xref:System.Diagnostics.Process> Komponentensatz, der entsprechenden Member der der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, und rufen <xref:System.Diagnostics.Process.Start%2A> Zuordnen der <xref:System.Diagnostics.Process> mit einem neuen Systemprozess. Ordnen Sie die zweite Option ist die <xref:System.Diagnostics.Process> mit einem laufenden Systemprozess mit <xref:System.Diagnostics.Process.GetProcessById%2A> mindestens eine der <xref:System.Diagnostics.Process.GetProcesses%2A> geben Werte zurück.  
  
 Bei Verwendung einer `static` Überladung von der <xref:System.Diagnostics.Process.Start%2A> Methode zum Starten eines neuen System-Prozesses, die Methode erstellt ein neues <xref:System.Diagnostics.Process> Komponente und ordnet sie den Prozess.  
  
 Wenn die <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> -Eigenschaftensatz auf den Standardwert `true`, können Sie Anwendungen und Dokumente in einer Weise, wie beim Verwenden von starten die `Run` im Dialogfeld die Windows `Start` im Menü. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> ist `false`, können Sie nur ausführbare Dateien gestartet.  
  
 Jede ausführbare Datei, die über die Befehlszeile aufgerufen werden kann, kann auf zwei Arten gestartet werden: durch Festlegen der entsprechenden Member der der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft ab, und rufen die <xref:System.Diagnostics.Process.Start%2A> Methode ohne Parameter oder durch Übergeben des entsprechenden Parameters an das `static` <xref:System.Diagnostics.Process.Start%2A> Member.  
  
 Sie erstellen eine <xref:System.Diagnostics.Process> Komponente mithilfe des Konstruktors, die statische <xref:System.Diagnostics.Process.Start%2A> Überladungen oder eines der <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, oder <xref:System.Diagnostics.Process.GetProcessesByName%2A> Methoden. Wenn Sie dies getan haben, müssen Sie einen Einblick in den zugeordneten Prozess. Dies ist es nicht um eine dynamische Ansicht, die sich selbst automatisch aktualisiert, wenn die Prozesseigenschaften im Speicher geändert wurden. Sie müssen stattdessen Aufrufen <xref:System.Diagnostics.Process.Refresh%2A> für die zu aktualisierende Komponente der <xref:System.Diagnostics.Process> Eigenschafteninformationen, die in Ihrer Anwendung.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Basispriorität des zugeordneten Prozesses ab.</summary>
        <value>Die Basispriorität, die anhand der <see cref="P:System.Diagnostics.Process.PriorityClass" /> des zugeordneten Prozesses berechnet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.BasePriority%2A> des Prozesses ist die Startpriorität für Threads, die innerhalb des zugeordneten Prozesses erstellt. Sie können Informationen über die Basispriorität, die über den Systemmonitor Priorität Basisindikator anzeigen.  
  
 Basierend auf der Zeit, die verstrichene oder andere steigert, das Betriebssystem die Basispriorität ändern können, wenn ein Prozess vor anderen platziert werden soll.  
  
 Die <xref:System.Diagnostics.Process.BasePriority%2A> Eigenschaft können Sie anzeigen, die Priorität an einen Prozess ab. Aber da es schreibgeschützt ist, können keine der <xref:System.Diagnostics.Process.BasePriority%2A> zum Festlegen der Priorität des Prozesses. Verwenden Sie zum Ändern der Priorität der <xref:System.Diagnostics.Process.PriorityClass%2A> Eigenschaft. Der <xref:System.Diagnostics.Process.BasePriority%2A> angezeigt werden mit dem Systemmonitor, zwar die <xref:System.Diagnostics.Process.PriorityClass%2A> nicht. Sowohl die <xref:System.Diagnostics.Process.BasePriority%2A> und <xref:System.Diagnostics.Process.PriorityClass%2A> programmgesteuert angezeigt werden können. Die folgende Tabelle zeigt die Beziehung zwischen <xref:System.Diagnostics.Process.BasePriority%2A> Werte und <xref:System.Diagnostics.Process.PriorityClass%2A> Werte.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde beendet.  
  
 - oder -  
  
 Der Prozess wurde nicht gestartet, daher gibt es keine Prozess-ID.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet asynchrone Lesevorgänge im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardError" />-Stream der Anwendung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.StandardError%2A> Stream synchron oder asynchron gelesen werden kann. Methoden, z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, und <xref:System.IO.StreamReader.ReadToEnd%2A> synchrone Lesevorgänge den Fehlerausgabestream des Prozesses führen. Diese synchrone gelesen, bis der zugeordneten Vorgänge nicht vollständig <xref:System.Diagnostics.Process> schreibt in seine <xref:System.Diagnostics.Process.StandardError%2A> streamen oder schließt den Stream.  
  
 Im Gegensatz dazu <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> startet asynchrone Lesevorgänge auf dem <xref:System.Diagnostics.Process.StandardError%2A> Stream. Diese Methode ermöglicht es dem angegebenen Ereignishandler für die Streamausgabe und gibt sofort zurück, an den Aufrufer und der andere Aufgaben durchführen kann, während die Streamausgabe an den Ereignishandler geleitet wird.  
  
 Führen Sie folgende Schritte für asynchrone Lesevorgänge ausführen <xref:System.Diagnostics.Process.StandardError%2A> für eine <xref:System.Diagnostics.Process> :  
  
1.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> auf `false` fest.  
  
2.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> auf `true` fest.  
  
3.  Fügen Sie Ihren Ereignishandler die <xref:System.Diagnostics.Process.ErrorDataReceived> Ereignis. Der Ereignishandler übereinstimmen muss die <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> Signatur des Delegaten.  
  
4.  Starten Sie den <xref:System.Diagnostics.Process>.  
  
5.  Rufen Sie <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> für die <xref:System.Diagnostics.Process>. Dieser Aufruf startet asynchrone Lesevorgänge auf <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Wenn asynchrone Lesevorgänge starten, der Ereignishandler aufgerufen wird jedes Mal, wenn die zugeordnete <xref:System.Diagnostics.Process> schreibt eine Textzeile, dessen <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Sie können einen asynchronen Lesevorgang Abbrechen, durch den Aufruf <xref:System.Diagnostics.Process.CancelErrorRead%2A>. Der Lesevorgang kann vom Aufrufer oder vom Ereignishandler abgebrochen werden. Sie können nach dem Abbruch Aufrufen <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> erneut aus, um asynchrone Lesevorgänge fortzusetzen.  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge in einem umgeleiteten Stream nicht mischen. Einmal im umgeleiteten Stream, der eine <xref:System.Diagnostics.Process> wird geöffnet, in asynchronen oder synchronen Modus alle weiteren Lesevorgänge Operationen in diesem Stream muss sich im gleichen Modus. Führen Sie beispielsweise nicht <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> mit einem Aufruf von <xref:System.IO.StreamReader.ReadLine%2A> auf die <xref:System.Diagnostics.Process.StandardError%2A> Stream oder umgekehrt. Sie können jedoch zwei verschiedenen Streams in unterschiedlichen Modi lesen. Sie können z. B. Aufrufen <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> und rufen dann <xref:System.IO.StreamReader.ReadLine%2A> für die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `net view` Befehl aus, um die Liste der verfügbaren Netzwerkressourcen auf einem Remotecomputer befindet. Der Benutzer gibt den Namen des Zielcomputers als Befehlszeilenargument. Benutzer kann auch einen Dateinamen für die Fehlerausgabe angeben. Das Beispiel erfasst die Ausgabe des Befehls "net", wartet der Prozess abgeschlossen, und schreibt die Ausgabe an die Konsole führt. Wenn der Benutzer die optionale Fehlerdatei, das Beispiel schreibt die Fehler in der Datei gibt.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />-Eigenschaft ist <see langword="false" />.  
  
- oder - 
Für den <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wird bereits ein asynchroner Lesevorgang ausgeführt.  
  
- oder - 
Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wurde von einem synchronen Lesevorgang verwendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet asynchrone Lesevorgänge im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream der Anwendung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream synchron oder asynchron gelesen werden kann. Methoden, z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, und <xref:System.IO.StreamReader.ReadToEnd%2A> synchrone Lesevorgänge in den Ausgabestream des Prozesses führen. Diese synchrone gelesen, bis der zugeordneten Vorgänge nicht vollständig <xref:System.Diagnostics.Process> schreibt in seine <xref:System.Diagnostics.Process.StandardOutput%2A> streamen oder schließt den Stream.  
  
 Im Gegensatz dazu <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> startet asynchrone Lesevorgänge auf dem <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Diese Methode ermöglicht es einen angegebenen Ereignishandler für die Streamausgabe und gibt sofort zurück, an den Aufrufer und der andere Aufgaben durchführen kann, während die Streamausgabe an den Ereignishandler geleitet wird.  
  
 Führen Sie folgende Schritte für asynchrone Lesevorgänge ausführen <xref:System.Diagnostics.Process.StandardOutput%2A> für eine <xref:System.Diagnostics.Process> :  
  
1.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> auf `false` fest.  
  
2.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> auf `true` fest.  
  
3.  Fügen Sie Ihren Ereignishandler die <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis. Der Ereignishandler übereinstimmen muss die <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> Signatur des Delegaten.  
  
4.  Starten Sie den <xref:System.Diagnostics.Process>.  
  
5.  Rufen Sie <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> für die <xref:System.Diagnostics.Process>. Dieser Aufruf startet asynchrone Lesevorgänge auf <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Wenn asynchrone Lesevorgänge starten, der Ereignishandler aufgerufen wird jedes Mal, wenn die zugeordnete <xref:System.Diagnostics.Process> schreibt eine Textzeile, dessen <xref:System.Diagnostics.Process.StandardOutput%2A> Stream.  
  
 Sie können einen asynchronen Lesevorgang Abbrechen, durch den Aufruf <xref:System.Diagnostics.Process.CancelOutputRead%2A>. Der Lesevorgang kann vom Aufrufer oder vom Ereignishandler abgebrochen werden. Sie können nach dem Abbruch Aufrufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> erneut aus, um asynchrone Lesevorgänge fortzusetzen.  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge in einem umgeleiteten Stream nicht mischen. Einmal im umgeleiteten Stream, der eine <xref:System.Diagnostics.Process> wird geöffnet, in asynchronen oder synchronen Modus alle weiteren Lesevorgänge Operationen in diesem Stream muss sich im gleichen Modus. Führen Sie beispielsweise nicht <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> mit einem Aufruf von <xref:System.IO.StreamReader.ReadLine%2A> auf die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream oder umgekehrt. Sie können jedoch zwei verschiedenen Streams in unterschiedlichen Modi lesen. Sie können z. B. Aufrufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> und rufen dann <xref:System.IO.StreamReader.ReadLine%2A> für die <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie asynchrone Lesevorgänge im umgeleiteten auszuführenden <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, der die `sort` Befehl. Die `sort` Befehl ist eine Konsolenanwendung, die gelesen und Texteingabe sortiert.  
  
 Das Beispiel erstellt einen Delegaten für die `SortOutputHandler` -Ereignishandler und ordnet ihn dem <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis. Der Ereignishandler empfängt Textzeilen aus dem umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, den Text formatiert und schreibt den Text auf dem Bildschirm.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />-Eigenschaft ist <see langword="false" />.  
  
- oder - 
Für den <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wird bereits ein asynchroner Lesevorgang ausgeführt.  
  
- oder - 
Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wurde von einem synchronen Lesevorgang verwendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht den asynchronen Lesevorgang im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardError" />-Stream einer Anwendung ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Startet einen asynchronen Lesevorgang auf der <xref:System.Diagnostics.Process.StandardError%2A> Stream. <xref:System.Diagnostics.Process.CancelErrorRead%2A> beendet den asynchronen Lesevorgang.  
  
 Nach dem Abbrechen, können Sie den asynchronen Lesevorgang fortsetzen, durch den Aufruf <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> erneut aus.  
  
 Beim Aufruf <xref:System.Diagnostics.Process.CancelErrorRead%2A>, werden alle in Bearbeitung befindlichen Lesevorgänge für <xref:System.Diagnostics.Process.StandardError%2A> werden abgeschlossen, und klicken Sie dann der Ereignishandler deaktiviert ist. Alle weiteren Ausgabe umgeleitet <xref:System.Diagnostics.Process.StandardError%2A> gehen verloren. Wenn Sie den Ereignishandler durch einen Aufruf erneut aktivieren <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, zum asynchronen Lesen-Vorgängen fortzufahren. Wenn Sie den Ereignishandler zu ändern, bevor die asynchrone Lesevorgänge fortsetzen möchten, müssen Sie den vorhandenen Ereignishandler entfernen, bevor Sie den neuen Ereignishandler hinzufügen:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Sie können nicht vermischt werden asynchrone und synchrone Lesevorgänge im umgeleiteten <xref:System.Diagnostics.Process.StandardError%2A> Stream. Einmal im umgeleiteten Stream, der eine <xref:System.Diagnostics.Process> wird geöffnet, in asynchronen oder synchronen Modus alle weiteren Lesevorgänge Operationen in diesem Stream muss sich im gleichen Modus. Wenn Sie Abbrechen eines asynchronen Lesevorgang auf <xref:System.Diagnostics.Process.StandardError%2A> , und klicken Sie dann aus dem Stream gelesene in diesem Fall müssen Sie verwenden möchten <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> asynchrone Lesevorgänge fortgesetzt. Führen Sie nicht <xref:System.Diagnostics.Process.CancelErrorRead%2A> durch Aufrufen von synchronen Methoden für das Lesen von <xref:System.Diagnostics.Process.StandardError%2A> wie z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, oder <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel startet der `nmake` -Befehl mit der Benutzer die angegebenen Argumente. Die Fehler und die Ausgabe-Streams werden asynchron gelesen werden. die erfassten Textzeilen werden in der Konsole angezeigt sowie in eine Protokolldatei geschrieben. Wenn die Befehlsausgabe eine angegebene Anzahl von Zeilen überschreitet, werden die asynchrone Lesevorgänge abgebrochen.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream ist nicht für asynchrone Lesevorgänge aktiviert.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht den asynchronen Lesevorgang im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream einer Anwendung ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Startet einen asynchronen Lesevorgang auf der <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. <xref:System.Diagnostics.Process.CancelOutputRead%2A> beendet den asynchronen Lesevorgang.  
  
 Sie können asynchrone Lesevorgänge durch Aufrufen von fortsetzen, nach dem Abbruch <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> erneut aus.  
  
 Beim Aufruf <xref:System.Diagnostics.Process.CancelOutputRead%2A>, werden alle in Bearbeitung befindlichen Lesevorgänge für <xref:System.Diagnostics.Process.StandardOutput%2A> werden abgeschlossen, und klicken Sie dann der Ereignishandler deaktiviert ist. Alle weiteren Ausgabe umgeleitet <xref:System.Diagnostics.Process.StandardOutput%2A> in einem Puffer gespeichert ist. Wenn Sie den Ereignishandler durch einen Aufruf erneut aktivieren <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, erhält jedes Mal die gespeicherte Ausgabe an den Ereignishandler und asynchrone Lesevorgänge fortzusetzen. Wenn Sie den Ereignishandler zu ändern, bevor die asynchrone Lesevorgänge fortsetzen möchten, müssen Sie den vorhandenen Ereignishandler entfernen, bevor Sie den neuen Ereignishandler hinzufügen:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Sie können nicht vermischt werden asynchrone und synchrone Lesevorgänge im umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Einmal im umgeleiteten Stream, der eine <xref:System.Diagnostics.Process> wird geöffnet, in asynchronen oder synchronen Modus alle weiteren Lesevorgänge Operationen in diesem Stream muss sich im gleichen Modus. Wenn Sie Abbrechen eines asynchronen Lesevorgang auf <xref:System.Diagnostics.Process.StandardOutput%2A> , und klicken Sie dann aus dem Stream gelesene in diesem Fall müssen Sie verwenden möchten <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> asynchrone Lesevorgänge fortgesetzt. Führen Sie nicht <xref:System.Diagnostics.Process.CancelOutputRead%2A> durch Aufrufen von synchronen Methoden für das Lesen von <xref:System.Diagnostics.Process.StandardOutput%2A> wie z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, oder <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel startet der `nmake` -Befehl mit der Benutzer die angegebenen Argumente. Die Fehler und die Ausgabe-Streams werden asynchron gelesen werden. die erfassten Textzeilen werden in der Konsole angezeigt sowie in eine Protokolldatei geschrieben. Wenn die Befehlsausgabe eine angegebene Anzahl von Zeilen überschreitet, werden die asynchrone Lesevorgänge abgebrochen.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream ist nicht für asynchrone Lesevorgänge aktiviert.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle dieser Komponente zugeordneten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.Close%2A> Methode bewirkt, dass der Vorgang zum Beenden, Warten beenden, wenn er gewartet hat, schließt das Prozesshandle und löscht Prozess-spezifische Eigenschaften. <xref:System.Diagnostics.Process.Close%2A> standard-Eingabe, Ausgabe und Fehler Reader und Writer schließt nicht für den Fall, dass sie extern verwiesen wird.  
  
> [!NOTE]
>  Die <xref:System.Diagnostics.Process.Dispose%2A>-Methode ruft <xref:System.Diagnostics.Process.Close%2A> auf. Platzieren der <xref:System.Diagnostics.Process> -Objekt in ein `using` Block löscht Ressourcen aufrufen, ohne <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Klicken Sie dann in 2-Sekunden-Intervallen für maximal 10 Sekunden die Auslastung des physikalischen Speichers des zugeordneten Prozesses abgerufen. Dabei wird ermittelt, ob der Prozess beendet wird, bevor 10 Sekunden vergangen sind. Im Beispiel wird der Prozess geschlossen, wenn er immer noch nach 10 Sekunden ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt einen Prozess mit einer Benutzeroberfläche, indem eine Meldung zum Schließen an das Hauptfenster gesendet wird.</summary>
        <returns><see langword="true" />, wenn die Meldung zum Schließen erfolgreich gesendet wurde. <see langword="false" />, wenn der zugeordnete Prozess nicht über ein Hauptfenster verfügt oder wenn das Hauptfenster deaktiviert ist (z. B., wenn ein modales Dialogfeld angezeigt wird).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Prozess ausgeführt wird, ist die Meldungsschleife im Wartezustand befinden. Die Nachrichtenschleife führt jedes Mal, wenn eine Windows-Nachricht an den Prozess durch das Betriebssystem gesendet wird. Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> sendet eine Anforderung zum Schließen des Hauptfensters, die in eine wohlgeformte Anwendung wird das untergeordnete Fenster geschlossen, und hebt alle aktiven Nachrichtenschleifen für die Anwendung. Die Anforderung zum Beenden des Prozesses durch den Aufruf <xref:System.Diagnostics.Process.CloseMainWindow%2A> erzwingt nicht die Anwendung zu beenden. Überprüfung vor dem Beenden des Benutzers kann die Anwendung anfordern, oder es ablehnen kann, um den Vorgang abzubrechen. Um die Anwendung erzwingen, verwenden Sie die <xref:System.Diagnostics.Process.Kill%2A> Methode. Das Verhalten der <xref:System.Diagnostics.Process.CloseMainWindow%2A> ist identisch mit dem ein Benutzer einer Anwendung im Hauptfenster mit das Systemmenü schließt. Aus diesem Grund erzwingt die Anforderung zum Beenden des Prozesses, indem Sie das Hauptfenster schließen nicht die Anwendung sofort beendet.  
  
 Daten, die bearbeitet werden, indem der Prozess oder an den Prozess zugeordnete Ressourcen können verloren, wenn Sie aufrufen <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> bewirkt, dass eine nicht ordnungsgemäße Beendigung und sollte nur bei Bedarf verwendet werden. <xref:System.Diagnostics.Process.CloseMainWindow%2A> ermöglicht eine ordnungsgemäße Beendigung des Prozesses, und alle Fenster geschlossen wird, damit es sich vorzugsweise für Anwendungen mit einer Schnittstelle ist. Wenn <xref:System.Diagnostics.Process.CloseMainWindow%2A> ein Fehler auftritt, können Sie <xref:System.Diagnostics.Process.Kill%2A> zum Beenden des Prozesses. <xref:System.Diagnostics.Process.Kill%2A> ist die einzige Möglichkeit, Prozesse zu beenden, die keine grafische Benutzeroberflächen haben.  
  
 Rufen Sie <xref:System.Diagnostics.Process.Kill%2A> und <xref:System.Diagnostics.Process.CloseMainWindow%2A> nur für Prozesse, die auf dem lokalen Computer ausgeführt werden. Sie können nicht dazu führen, dass Prozesse auf Remotecomputern zu beenden. Sie können nur Informationen für Prozesse, die auf Remotecomputern anzeigen.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Klicken Sie dann in 2-Sekunden-Intervallen für maximal 10 Sekunden die Auslastung des physikalischen Speichers des zugeordneten Prozesses abgerufen. Dabei wird ermittelt, ob der Prozess beendet wird, bevor 10 Sekunden vergangen sind. Im Beispiel wird der Prozess geschlossen, wenn er immer noch nach 10 Sekunden ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde bereits beendet.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt alle von diesem Prozess verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob beim Beenden des Prozesses das <see cref="E:System.Diagnostics.Process.Exited" />-Ereignis ausgelöst werden soll.</summary>
        <value><see langword="true" />, wenn das <see cref="E:System.Diagnostics.Process.Exited" />-Ereignis ausgelöst werden soll, wenn der zugeordnete Prozess beendet wird (entweder durch Beenden oder einen Aufruf von <see cref="M:System.Diagnostics.Process.Kill" />), andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />. Beachten Sie, dass die <see cref="E:System.Diagnostics.Process.Exited" /> Ereignis wird ausgelöst, selbst wenn der Wert des <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> ist <see langword="false" /> oder wenn während der Prozess beendet wird, bevor der Benutzer ausführt eine <see cref="P:System.Diagnostics.Process.HasExited" /> überprüfen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft schlägt vor, ob die Komponente benachrichtigt werden soll, wenn das Betriebssystem einen Prozess beendet wurde. Die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft wird bei der asynchronen Verarbeitung verwendet, um Ihre Anwendung zu benachrichtigen, die ein Prozess beendet wurde. Um zu erzwingen, dass Ihre Anwendung synchron eine Beendigungsereignis warten (wodurch die Verarbeitung der Anwendung, bis das Exit-Ereignis aufgetreten ist), verwenden die <xref:System.Diagnostics.Process.WaitForExit%2A> Methode.

> [!NOTE]
> Wenn Sie Visual Studio verwenden, und doppelklicken Sie auf eine <xref:System.Diagnostics.Process> -Komponente in Ihrem Projekt eine <xref:System.Diagnostics.Process.Exited> Ereignisdelegaten und Ereignishandler werden automatisch generiert. Zusätzlicher Code legt die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft `false`. Sie müssen diese Eigenschaft ändern `true` für Ihren Ereignishandler ausgeführt wird, wenn der zugeordnete Prozess beendet wird.

Wenn der Komponente <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Wert `true`, oder wenn <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> ist `false` und <xref:System.Diagnostics.Process.HasExited%2A> überprüfen, die von der Komponente aufgerufen wird, die Komponente kann die administrative Informationen für den zugeordneten Prozess, die bleibt zugreifen vom Betriebssystem gespeichert. Diese Informationen beinhalten den <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.ExitCode%2A>.

Nach dem der zugeordnete Prozess beendet wird, wird die <xref:System.Diagnostics.Process.Handle%2A> nicht mehr von der Komponente verweist, auf eine vorhandene Prozessressource. Stattdessen können sie nur verwendet werden Zugriff auf das Betriebssystem-Informationen über der Prozessressource. Das Betriebssystem ist, beachten Sie, dass die Handles für beendete Prozesse, die von freigegeben wurden, noch nicht vorhanden sind <xref:System.Diagnostics.Process> Komponenten, sodass er hält die <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.Handle%2A> Informationen im Arbeitsspeicher.

Es gibt eine Kosten im Zusammenhang mit überwachen für einen Prozess zu beenden. Wenn <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> ist `true`, <xref:System.Diagnostics.Process.Exited> Ereignis wird ausgelöst, wenn der zugeordnete Prozess beendet wird. Die Prozeduren für die <xref:System.Diagnostics.Process.Exited> Ereignis zu diesem Zeitpunkt ausführen.

In einigen Fällen wird Ihre Anwendung startet einen Prozess, aber erfordert keine Benachrichtigung über dessen Abschluss. Ihre Anwendung kann z. B. Editor, um dem Benutzer ermöglichen, führen Sie die Text-Bearbeitung jedoch nicht weiter verwenden, die der Editor-Anwendung starten. Sie können auch Benachrichtigungen zu vermeiden, wenn der Prozess beendet wird, da er nicht für den fortgesetzten Betrieb der Anwendung relevant ist. Festlegen von <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> zu `false` können Systemressourcen speichern.

## Examples  
Das folgende Codebeispiel erstellt einen Prozess, der eine Datei ausgibt. Wird die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft dazu führen, dass den Prozess zum Auslösen der <xref:System.Diagnostics.Process.Exited> Ereignis aus, wenn er beendet wird. Die <xref:System.Diagnostics.Process.Exited> Ereignishandler zeigt Prozessinformationen.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versetzt durch Aktivieren der systemeigenen <see cref="T:System.Diagnostics.Process" />-Eigenschaft für den aktuellen Thread eine <see langword="SeDebugPrivilege" />-Komponente in einen Zustand, in dem sie mit Betriebssystemprozessen interagieren kann, die in einem speziellen Modus ausgeführt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Betriebssystem-Prozesse, die in einem speziellen Modus ausgeführt werden. Es wird versucht, der Eigenschaften der oder das Anfügen an diese Prozesse ist nicht möglich, es sei denn, Sie aufgerufen haben <xref:System.Diagnostics.Process.EnterDebugMode%2A> für die Komponente. Rufen Sie <xref:System.Diagnostics.Process.LeaveDebugMode%2A> Wenn Sie nicht mehr benötigen Zugriff auf diese Prozesse, die in speziellen Modus ausgeführt.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Anwendung in ihren umgeleiteten <see cref="P:System.Diagnostics.Process.StandardError" />-Stream schreibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.ErrorDataReceived> Ereignis weist darauf hin, dass der zugeordnete Prozess in seinen umgeleiteten geschrieben hat <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Das Ereignis tritt nur während der asynchrone Lesevorgänge auf <xref:System.Diagnostics.Process.StandardError%2A>. Um asynchrone Lesevorgänge zu starten, müssen Sie Umleiten der <xref:System.Diagnostics.Process.StandardError%2A> Datenstrom von einer <xref:System.Diagnostics.Process>, den Ereignishandler zum Hinzufügen der <xref:System.Diagnostics.Process.ErrorDataReceived> -Ereignis, und rufen <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. Danach die <xref:System.Diagnostics.Process.ErrorDataReceived> Ereignissignale jedes Mal, die der Prozess eine Zeile in der umgeleiteten schreibt <xref:System.Diagnostics.Process.StandardError%2A> streamen, bis der Prozess beendet wird, oder ruft <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  Die Anwendung, die die asynchrone Ausgabe verarbeitet aufrufen, sollte die <xref:System.Diagnostics.Process.WaitForExit> Methode, um sicherzustellen, dass der Ausgabepuffer geleert wurde. Beachten Sie, dass die Angabe eines Timeouts mit der <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> Überladung ist *nicht* stellen Sie sicher, der Ausgabepuffer wurde geleert wurden.
  
   
  
## Examples  
 Im folgenden Beispiel wird die `net view` Befehl aus, um die Liste der verfügbaren Netzwerkressourcen auf einem Remotecomputer befindet. Der Benutzer gibt den Namen des Zielcomputers als Befehlszeilenargument. Benutzer kann auch einen Dateinamen für die Fehlerausgabe angeben. Das Beispiel erfasst die Ausgabe des Befehls "net", wartet der Prozess abgeschlossen, und schreibt die Ausgabe an die Konsole führt. Wenn der Benutzer die optionale Fehlerdatei, das Beispiel schreibt die Fehler in der Datei gibt.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der vom zugeordneten Prozess beim Beenden angegeben wurde.</summary>
        <value>Der Code, der vom zugeordneten Prozess beim Beenden angegeben wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Diagnostics.Process.ExitCode%2A> zum Abrufen des Status, die der Systemprozess zurückgegeben, wenn er beendet. Sie können den Exitcode viel verwenden, wie eine ganze Zahl Rückgabewert aus einem `main()` Verfahren.  
  
 Die <xref:System.Diagnostics.Process.ExitCode%2A> Wert für ein Prozess auf die spezifische Konvention, die vom Anwendungsentwickler für diesen Prozess implementiert widerspiegelt. Wenn Sie den Exitcodewert, um Entscheidungen zu treffen, in Ihrem Code verwenden, achten Sie darauf, dass Sie wissen, dass die beenden-Code-Konvention, die von der der Anwendungsprozess verwendet.  
  
 Entwickler weisen normalerweise darauf hin eine erfolgreiche Beendigung von einem <xref:System.Diagnostics.Process.ExitCode%2A> Wert 0 (null) und Stellvertreter Fehler durch Werte, die die aufrufende Methode verwenden können, um die Ursache für eine nicht ordnungsgemäße Beendigung zu identifizieren. Es ist nicht notwendig, diese Richtlinien zu befolgen, aber sie sind der Konvention.  
  
 Wenn Sie versuchen, erhalten die <xref:System.Diagnostics.Process.ExitCode%2A> , bevor der Prozess beendet wurde, löst der Versuch eine Ausnahme aus. Überprüfen Sie die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft zunächst zu überprüfen, ob der zugeordnete Prozess beendet wurde.  
  
> [!NOTE]
>  Standard-Ausgabedatenstrom an asynchrone Ereignishandler umgeleitet wurde, es ist möglich, dass die Verarbeitung der Ausgabe nicht abgeschlossen, wenn <xref:System.Diagnostics.Process.HasExited%2A> gibt `true`. Um sicherzustellen, dass die asynchrone Ereignisverarbeitung abgeschlossen wurde, rufen die <xref:System.Diagnostics.Process.WaitForExit> Überladung, die vor der Überprüfung keine Parameter akzeptiert <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Können Sie die <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A> Methode, um die dazu führen, dass einen zugeordneten Prozess beendet.  
  
 Es gibt zwei Möglichkeiten, benachrichtigt wird, wenn der zugeordnete Prozess beendet wird: synchron und asynchron. Synchrone Benachrichtigung beruht auf Aufrufen der <xref:System.Diagnostics.Process.WaitForExit%2A> Methode, um die Verarbeitung Ihrer Anwendung anhalten, bis die zugeordnete Komponente beendet wird. Asynchrone Benachrichtigung beruht auf der <xref:System.Diagnostics.Process.Exited> Ereignis. Bei Verwendung von asynchronen Benachrichtigungen <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> muss festgelegt werden, um `true` für die <xref:System.Diagnostics.Process> Komponente, um Benachrichtigungen zu erhalten, die der Prozess beendet wurde.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht beendet.  
  
- oder - 
Der Prozess <see cref="P:System.Diagnostics.Process.Handle" /> ist ungültig.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.ExitCode" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Beenden eines Prozesses ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.Exited> Ereignis weist darauf hin, dass der zugeordnete Prozess beendet. Dieses Ereignis bedeutet, dass entweder, dass den Prozess beendet (abgebrochen) oder erfolgreich beendet wurde. Dieses Ereignis kann auftreten, nur dann, wenn der Wert des der <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft `true`.  
  
 Es gibt zwei Möglichkeiten, benachrichtigt wird, wenn der zugeordnete Prozess beendet wird: synchron und asynchron. Synchrone Benachrichtigung bedeutet Aufrufen der <xref:System.Diagnostics.Process.WaitForExit%2A> Methode, um den aktuellen Thread blockieren, bis der Prozess beendet wird. Asynchrone Benachrichtigung verwendet die <xref:System.Diagnostics.Process.Exited> -Ereignis, das der aufrufende Thread die Ausführung in der Zwischenzeit fortsetzen kann. Im letzteren Fall <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> muss festgelegt werden, um `true` für die aufrufende Anwendung das Ereignis Exited zu erhalten.  
  
 Wenn das Betriebssystem einen Prozess heruntergefahren wird, benachrichtigt er alle anderen Prozesse, die Handler für das Ereignis Exited registriert haben. Zu diesem Zeitpunkt das Handle des Prozesses, der gerade beendet kann verwendet werden, um einige Eigenschaften zugreifen, z.B. <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.HasExited%2A> , dass das Betriebssystem verwaltet, bis es vollständig dieses Handle frei.  
  
> [!NOTE]
>  Auch wenn Sie ein Handle für einen beendeten Prozess verfügen, Sie nicht aufrufen, <xref:System.Diagnostics.Process.Start%2A> erneut eine Verbindung mit den gleichen Prozess herzustellen. Aufrufen von <xref:System.Diagnostics.Process.Start%2A> automatisch der zugeordnete Prozess freigegeben und eine Verbindung mit einem Prozess mit derselben Datei, aber einer völlig neuen <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Weitere Informationen über die Verwendung der <xref:System.Diagnostics.Process.Exited> Ereignis in Windows Forms-Anwendungen finden Sie unter der <xref:System.Diagnostics.Process.SynchronizingObject%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Prozess, der eine Datei ausgibt. Es wird ausgelöst, die <xref:System.Diagnostics.Process.Exited> Ereignis aus, wenn der Prozess beendet wird, da die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> -Eigenschaft wurde festgelegt, wenn der Prozess erstellt wurde. Die <xref:System.Diagnostics.Process.Exited> Ereignishandler zeigt Prozessinformationen.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zeitpunkt ab, zu dem der zugeordnete Prozess beendet wurde.</summary>
        <value>Eine <see cref="T:System.DateTime" />, die angibt, wann der zugeordnete Prozess beendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Prozess nicht beendet wurde, wird beim Abrufen der <xref:System.Diagnostics.Process.ExitTime%2A> Eigenschaft löst eine Ausnahme aus. Verwendung <xref:System.Diagnostics.Process.HasExited%2A> vor dem Abrufen der <xref:System.Diagnostics.Process.ExitTime%2A> Eigenschaft, um zu bestimmen, ob der zugeordnete Prozess beendet wurde.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Prozess, der eine Datei ausgibt. Der Vorgang löst die <xref:System.Diagnostics.Process.Exited> Ereignis aus, wenn er beendet wird, und der Ereignishandler zeigt die <xref:System.Diagnostics.Process.ExitTime%2A> -Eigenschaft und andere Informationen verarbeiten.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.ExitTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine neue <see cref="T:System.Diagnostics.Process" />-Komponente ab und ordnet diese dem gegenwärtig aktiven Prozess zu.</summary>
        <returns>Eine neue <see cref="T:System.Diagnostics.Process" />-Komponente, die der Prozessressource zugeordnet ist, die die aufrufende Anwendung ausführt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Erstellen eines neuen <xref:System.Diagnostics.Process> Instanz, und ordnen Sie es mit der Prozessressource auf dem lokalen Computer.  
  
 Wie die ähnliche <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, und <xref:System.Diagnostics.Process.GetProcesses%2A> Methoden <xref:System.Diagnostics.Process.GetCurrentProcess%2A> ordnet eine vorhandene Ressource einer neuen <xref:System.Diagnostics.Process> Komponente.  
  
   
  
## Examples  
 Im folgende Beispiel ruft die Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Klicken Sie dann die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente und ordnet diese der angegebenen vorhandenen Prozessressource zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">Der systemweit eindeutige Bezeichner einer Prozessressource.</param>
        <summary>Gibt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente zurück, wenn der Bezeichner eines Prozesses auf dem lokalen Computer angegeben ist.</summary>
        <returns>Eine <see cref="T:System.Diagnostics.Process" />-Komponente, die der durch den <paramref name="processId" />-Parameter bezeichneten lokalen Prozessressource zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Erstellen eines neuen <xref:System.Diagnostics.Process> Komponente und eine Prozessressource auf dem lokalen Computer zuordnen. Die Prozessressource muss bereits auf dem Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> erstellt sich nicht auf eine Systemressource, sondern eine Ressource mit einer Anwendung generierten zuordnet <xref:System.Diagnostics.Process> Komponente. Ein Prozess <xref:System.Diagnostics.Process.Id%2A> abgerufen werden können, nur für einen Prozess, der derzeit auf dem Computer ausgeführt wird. Nach Beendigung des Prozesses, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> löst eine Ausnahme aus, wenn er einen abgelaufenen Bezeichner übergeben.  
  
 Auf jedem Computer ist der Bezeichner eines Prozesses eindeutig. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> gibt höchstens einen Prozess zurück. Wenn zum Abrufen der Prozesse, die für die Ausführung einer bestimmten Anwendung verwendet soll <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Wenn mehrere Prozesse auf dem Computer mit der angegebenen Anwendung vorhanden <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> gibt ein Array mit allen zugehörigen Prozessen zurück. Sie können jeder dieser Prozesse nacheinander für seinen Bezeichner abfragen. Die Prozess-ID angezeigt werden kann, der `Processes` Bereich des Windows Task-Managers. Die `PID` Spalte zeigt die Prozess-ID, die einem Prozess zugeordnet ist.  
  
 Die `processId` -Parameter ist ein <xref:System.Int32> (eine 32-Bit-Ganzzahl mit Vorzeichen), obwohl die zugrunde liegende Windows-API verwendet einen `DWORD` (eine vorzeichenlose 32-Bit-Ganzzahl) für ähnliche APIs. Dies ist historisch bedingt.
  
## Examples  
 Im folgende Beispiel ruft die Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Klicken Sie dann die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der durch den <paramref name="processId" />-Parameter angegebene Prozess wird nicht ausgeführt. Möglicherweise ist der Bezeichner abgelaufen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht von diesem Objekt gestartet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">Der systemweit eindeutige Bezeichner einer Prozessressource.</param>
        <param name="machineName">Der Name eines Computers im Netzwerk.</param>
        <summary>Gibt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente zurück, wenn die Prozess-ID und der Name des Computers im Netzwerk angegeben sind.</summary>
        <returns>Eine <see cref="T:System.Diagnostics.Process" />-Komponente, die der durch den <paramref name="processId" />-Parameter bezeichneten Remoteprozessressource zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Erstellen eines neuen <xref:System.Diagnostics.Process> Komponente und eine Prozessressource auf einem Remotecomputer im Netzwerk zuzuordnen. Die Prozessressource muss bereits auf dem angegebenen Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> erstellt sich nicht auf eine Systemressource, sondern eine Ressource mit einer Anwendung generierten zuordnet <xref:System.Diagnostics.Process> Komponente. Ein Prozess <xref:System.Diagnostics.Process.Id%2A> abgerufen werden können, nur für einen Prozess, der derzeit auf dem Computer ausgeführt wird. Nach Beendigung des Prozesses, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> löst eine Ausnahme aus, wenn er einen abgelaufenen Bezeichner übergeben.  
  
 Auf jedem Computer ist der Bezeichner eines Prozesses eindeutig. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> gibt höchstens einen Prozess zurück. Wenn zum Abrufen der Prozesse, die für die Ausführung einer bestimmten Anwendung verwendet soll <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Wenn mehrere Prozesse auf dem Computer mit der angegebenen Anwendung vorhanden <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> gibt ein Array mit allen zugehörigen Prozessen zurück. Sie können jeder dieser Prozesse nacheinander für seinen Bezeichner abfragen. Die Prozess-ID angezeigt werden kann, der `Processes` Bereich des Windows Task-Managers. Die `PID` Spalte zeigt die Prozess-ID, die einem Prozess zugeordnet ist.  
  
 Wenn Sie keinen angeben einer `machineName`, der lokale Computer verwendet wird. Alternativ können Sie den lokalen Computer angeben, durch Festlegen von `machineName` auf den Wert "." oder auf eine leere Zeichenfolge ("").  
  
 Die `processId` -Parameter ist ein <xref:System.Int32> (eine 32-Bit-Ganzzahl mit Vorzeichen), obwohl die zugrunde liegende Windows-API verwendet einen `DWORD` (eine vorzeichenlose 32-Bit-Ganzzahl) für ähnliche APIs. Dies ist historisch bedingt.   
  
## Examples  
 Im folgende Beispiel ruft die Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Klicken Sie dann die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der durch den <paramref name="processId" />-Parameter angegebene Prozess wird nicht ausgeführt. Möglicherweise ist der Bezeichner abgelaufen.  
  
- oder - 
Die Syntax des <paramref name="machineName" />-Parameters ist ungültig. Der Name kann die Länge 0 (null) haben.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="machineName" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht von diesem Objekt gestartet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Array neuer <see cref="T:System.Diagnostics.Process" />-Komponenten und ordnet diese den vorhandenen Prozessressourcen zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente für jede Prozessressource auf dem lokalen Computer.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das alle auf dem lokalen Computer ausgeführten Prozessressourcen darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Erstellen von neuen ein Array von <xref:System.Diagnostics.Process> Komponenten und allen Prozessressourcen auf dem lokalen Computer zugeordnet werden. Prozessressourcen müssen bereits auf dem lokalen Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcesses%2A> erstellt keine Systemressourcen, sondern Ressourcen durch die Anwendung generierte zuordnet <xref:System.Diagnostics.Process> Komponenten. Da das Betriebssystem selbst Hintergrundprozesse ausgeführt wird, ist dieses Array niemals leer.  
  
 Wenn Sie nicht, um alle auf dem Computer ausgeführten Prozesse abzurufen möchten, können Sie deren Anzahl einschränken, indem Sie mit der <xref:System.Diagnostics.Process.GetProcessById%2A> oder <xref:System.Diagnostics.Process.GetProcessesByName%2A> Methode. <xref:System.Diagnostics.Process.GetProcessById%2A> erstellt eine <xref:System.Diagnostics.Process> Komponente, mit dem Prozess, der auf dem System durch die Prozess-ID, die Sie an die Methode übergeben identifiziert zugeordnet ist. <xref:System.Diagnostics.Process.GetProcessesByName%2A> erstellt ein Array von <xref:System.Diagnostics.Process> -Komponenten, deren zugeordneten Prozessressourcen gemeinsam, die ausführbare Datei nutzen, die Sie an die Methode übergeben.  
  
> [!NOTE]
>  Mehrere Windows-Dienste können innerhalb der gleichen Instanz von der Service Host-Prozess (svchost.exe) geladen werden. GetProcesses identifiziert die einzelnen Dienste nicht; finden Sie unter <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel ruft die Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Klicken Sie dann die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Computer, von dem die Liste der Prozesse gelesen werden soll.</param>
        <summary>Erstellt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente für jede Prozessressource auf dem lokalen Computer.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das alle auf dem angegebenen Computer ausgeführten Prozessressourcen darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Erstellen von neuen ein Array von <xref:System.Diagnostics.Process> Komponenten und diese allen Prozessressourcen auf dem angegebenen (in der Regel remoten) Computer zuordnen. Prozessressourcen müssen bereits auf dem lokalen Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcesses%2A> erstellt keine Systemressourcen, sondern Ressourcen durch die Anwendung generierte zuordnet <xref:System.Diagnostics.Process> Komponenten. Da das Betriebssystem selbst Hintergrundprozesse ausgeführt wird, ist dieses Array niemals leer.  
  
 Wenn Sie nicht, um alle auf dem Computer ausgeführten Prozesse abzurufen möchten, können Sie deren Anzahl einschränken, indem Sie mit der <xref:System.Diagnostics.Process.GetProcessById%2A> oder <xref:System.Diagnostics.Process.GetProcessesByName%2A> Methode. <xref:System.Diagnostics.Process.GetProcessById%2A> erstellt eine <xref:System.Diagnostics.Process> Komponente, mit dem Prozess, der auf dem System durch die Prozess-ID, die Sie an die Methode übergeben identifiziert zugeordnet ist. <xref:System.Diagnostics.Process.GetProcessesByName%2A> erstellt ein Array von <xref:System.Diagnostics.Process> -Komponenten, deren zugeordneten Prozessressourcen gemeinsam, die ausführbare Datei nutzen, die Sie an die Methode übergeben.  
  
 Diese Überladung von der <xref:System.Diagnostics.Process.GetProcesses%2A> -Methode in der Regel verwendet, um die Liste der auf einem Remotecomputer im Netzwerk ausgeführten Prozessressourcen abrufen, aber Sie können den lokalen Computer angeben, durch das übergeben ".".  
  
> [!NOTE]
>  Mehrere Windows-Dienste können innerhalb der gleichen Instanz von der Service Host-Prozess (svchost.exe) geladen werden. GetProcesses identifiziert die einzelnen Dienste nicht; finden Sie unter <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel ruft die Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Klicken Sie dann die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="machineName" />-Parameters ist ungültig. Sie kann die Länge 0 (null) haben.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="machineName" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Betriebssystemplattform unterstützt diesen Vorgang nicht auf Remotecomputern.</exception>
        <exception cref="T:System.InvalidOperationException">Es gibt Probleme beim Zugriff auf die Leistungsindikator-APIs zum Abrufen von Prozessinformationen. Diese Ausnahme tritt nur unter Windows NT, Windows 2000 und Windows XP auf.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugriff auf eine zugrunde liegende System-API ist ein Problem aufgetreten.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Array neuer <see cref="T:System.Diagnostics.Process" />-Komponenten und ordnet diese den vorhandenen Prozessressourcen zu, die den angegebenen Prozessnamen gemeinsam verwenden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Der angezeigte Name des Prozesses.</param>
        <summary>Erstellt ein Array neuer <see cref="T:System.Diagnostics.Process" />-Komponenten und ordnet diese allen Prozessressourcen auf dem lokalen Computer zu, die den angegebenen Prozessnamen gemeinsam verwenden.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das die Prozessressourcen darstellt, die die angegebene Anwendung oder Datei ausführen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Erstellen von neuen ein Array von <xref:System.Diagnostics.Process> Komponenten und ordnen Sie diese allen Prozessressourcen auf, die die gleiche ausführbare Datei auf dem lokalen Computer ausgeführt werden. Prozessressourcen müssen bereits auf dem Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcessesByName%2A> erstellt Systemressourcen nicht aus, sondern stattdessen ordnet diese Anwendung generierte <xref:System.Diagnostics.Process> Komponenten. Ein `processName` kann angegeben werden, für eine ausführbare Datei, die derzeit nicht auf dem lokalen Computer ausgeführt wird, sodass das Array der Methodenrückgabe leer sein kann.  
  
 Der Name des Prozesses ist, einen Anzeigenamen für den Prozess, z. B. Outlook, die die Erweiterung .exe oder der Pfad nicht enthalten. <xref:System.Diagnostics.Process.GetProcessesByName%2A> ist hilfreich für das Abrufen und Bearbeiten aller Prozesse, die die gleichen ausführbaren Datei zugeordnet sind. Sie können z. B. den Namen einer ausführbaren Datei als übergeben die `processName` Parameter, um die ausgeführten Instanzen dieser ausführbaren Datei zu schließen.  
  
 Auch wenn ein Prozess <xref:System.Diagnostics.Process.Id%2A> ist eindeutig für eine einzelne Prozessressource auf dem System mehrere Prozesse auf dem lokalen Computer ausgeführt werden die angegebene Anwendung der `processName` Parameter. Aus diesem Grund <xref:System.Diagnostics.Process.GetProcessById%2A> gibt einen Prozess zurück, höchstens jedoch <xref:System.Diagnostics.Process.GetProcessesByName%2A> gibt ein Array mit allen zugehörigen Prozessen zurück. Wenn Sie den Prozess mit der API-Standardaufrufe bearbeiten müssen, können Sie jeder dieser Prozesse nacheinander für seinen Bezeichner abfragen. Sie keinen Zugriff auf Prozessressourcen, durch den Prozessnamen allein jedoch, nachdem Sie ein Array von abgerufen haben <xref:System.Diagnostics.Process> Komponenten, die zugeordnet wurden mit den Prozessressourcen starten, beenden und die Systemressourcen in anderer Weise bearbeitet.  
  
   
  
## Examples  
 Im folgende Beispiel ruft die Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Klicken Sie dann die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es gibt Probleme beim Zugriff auf die Leistungsindikator-APIs zum Abrufen von Prozessinformationen. Diese Ausnahme tritt nur unter Windows NT, Windows 2000 und Windows XP auf.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Der angezeigte Name des Prozesses.</param>
        <param name="machineName">Der Name eines Computers im Netzwerk.</param>
        <summary>Erstellt ein Array neuer <see cref="T:System.Diagnostics.Process" />-Komponenten und ordnet diese allen Prozessressourcen auf einem Remotecomputer zu, die den angegebenen Prozessnamen gemeinsam verwenden.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das die Prozessressourcen darstellt, die die angegebene Anwendung oder Datei ausführen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Erstellen von neuen ein Array von <xref:System.Diagnostics.Process> Komponenten und ordnen Sie diese allen Prozessressourcen auf, die die gleiche ausführbare Datei auf dem angegebenen Computer ausgeführt werden. Prozessressourcen müssen bereits auf dem Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcessesByName%2A> erstellt Systemressourcen nicht aus, sondern stattdessen ordnet diese Anwendung generierte <xref:System.Diagnostics.Process> Komponenten. Ein `processName` kann angegeben werden, für eine ausführbare Datei, die derzeit nicht auf dem lokalen Computer ausgeführt wird, sodass das Array der Methodenrückgabe leer sein kann.  
  
 Der Name des Prozesses ist, einen Anzeigenamen für den Prozess, z. B. Outlook, die die Erweiterung .exe oder der Pfad nicht enthalten. <xref:System.Diagnostics.Process.GetProcessesByName%2A> ist hilfreich für das Abrufen und Bearbeiten aller Prozesse, die die gleichen ausführbaren Datei zugeordnet sind. Sie können z. B. den Namen einer ausführbaren Datei als übergeben die `processName` Parameter, um die ausgeführten Instanzen dieser ausführbaren Datei zu schließen.  
  
 Auch wenn ein Prozess <xref:System.Diagnostics.Process.Id%2A> ist eindeutig für eine einzelne Prozessressource auf dem System mehrere Prozesse auf dem lokalen Computer ausgeführt werden die angegebene Anwendung der `processName` Parameter. Aus diesem Grund <xref:System.Diagnostics.Process.GetProcessById%2A> gibt einen Prozess zurück, höchstens jedoch <xref:System.Diagnostics.Process.GetProcessesByName%2A> gibt ein Array mit allen zugehörigen Prozessen zurück. Wenn Sie den Prozess mit der API-Standardaufrufe bearbeiten müssen, können Sie jeder dieser Prozesse nacheinander für seinen Bezeichner abfragen. Sie keinen Zugriff auf Prozessressourcen, durch den Prozessnamen allein jedoch, nachdem Sie ein Array von abgerufen haben <xref:System.Diagnostics.Process> Komponenten, die zugeordnet wurden mit den Prozessressourcen starten, beenden und die Systemressourcen in anderer Weise bearbeitet.  
  
 Sie können diese Überladung verwenden, um Prozesse auf dem lokalen Computer sowie auf einem Remotecomputer abzurufen. Verwenden "." auf den lokalen Computer anzugeben. Eine andere Überladung vorhanden ist, die den lokalen Computer in der Standardeinstellung verwendet.  
  
 Sie können die Prozesse auf Remotecomputern nur zum Anzeigen von Informationen zu den Prozessen, z. B. Statistiken zugreifen. Sie können nicht schließen, beenden (mit <xref:System.Diagnostics.Process.Kill%2A>), oder starten Sie Prozesse auf Remotecomputern.  
  
   
  
## Examples  
 Im folgende Beispiel ruft die Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Klicken Sie dann die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="machineName" />-Parameters ist ungültig. Sie kann die Länge 0 (null) haben.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="machineName" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Betriebssystemplattform unterstützt diesen Vorgang nicht auf Remotecomputern.</exception>
        <exception cref="T:System.InvalidOperationException">Der Versuch, eine Verbindung zu <paramref name="machineName" /> aufzubauen, ist fehlgeschlagen.

- oder - 
Es gibt Probleme beim Zugriff auf die Leistungsindikator-APIs zum Abrufen von Prozessinformationen. Diese Ausnahme tritt nur unter Windows NT, Windows 2000 und Windows XP auf.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugriff auf eine zugrunde liegende System-API ist ein Problem aufgetreten.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Handle des zugeordneten Prozesses ab.</summary>
        <value>Das Handle, das das Betriebssystem dem zugeordneten Prozess beim Starten des Prozesses zugewiesen hat. Das System verwendet dieses Handle zum Verfolgen der Prozessattribute.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung kann ein Handle für einen Prozess abrufen, die als Parameter für viele Funktionen von Prozessinformationen und -Steuerelement verwendet werden können. Können Sie dieses Handle zum Initialisieren einer <xref:System.Threading.WaitHandle> oder aufrufen native Methoden wird mit der Plattform aufgerufen.  
  
 Diese Prozesshandle ist privat zu einer Anwendung – das heißt, Handles können nicht gemeinsam genutzt werden. Ein Prozess verfügt auch über einen Prozess <xref:System.Diagnostics.Process.Id%2A> die, im Gegensatz zu den <xref:System.Diagnostics.Process.Handle%2A>, eindeutig ist und somit im gesamten System gültig.  
  
 Nur Prozesse gestartet wird, durch einen Aufruf von <xref:System.Diagnostics.Process.Start%2A> legen Sie die <xref:System.Diagnostics.Process.Handle%2A> -Eigenschaft des entsprechenden <xref:System.Diagnostics.Process> Instanzen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht gestartet oder wurde beendet. Die <see cref="P:System.Diagnostics.Process.Handle" />-Eigenschaft kann nicht gelesen werden, weil dieser <see cref="T:System.Diagnostics.Process" />-Instanz kein Prozess zugeordnet ist.  
  
- oder - 
Die <see cref="T:System.Diagnostics.Process" />-Instanz wurde einem aktiven Prozess zugeordnet, Sie haben aber nicht die erforderlichen Berechtigungen, um ein Handle mit vollen Zugriffsrechten abzurufen.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Handle" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der vom Prozess geöffneten Handles ab.</summary>
        <value>Die Anzahl der vom Prozess geöffneten Betriebssystemhandles.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Handles stellen eine Möglichkeit für einen Prozess zum Verweisen auf Objekte. Ein Prozess erhalten Handles für Dateien, Ressourcen, Nachrichtenwarteschlangen und zahlreiche andere Objekte des Betriebssystems. Das Betriebssystem freigegeben, den Arbeitsspeicher, der dem Prozess zugeordnet sind, nur, wenn die maximale Handleanzahl beträgt 0 (null) ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der zugehörige Prozess beendet wurde.</summary>
        <value><see langword="true" />, wenn der Betriebssystemprozess, auf den die <see cref="T:System.Diagnostics.Process" />-Komponente verweist, beendet wurde; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert `true` für <xref:System.Diagnostics.Process.HasExited%2A> gibt an, dass der zugeordnete Prozess, ordnungsgemäß oder nicht ordnungsgemäß beendet wurde. Sie können anfordern oder erzwingen, dass der zugeordneten Prozess beendet durch Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Wenn ein Handle für den Prozess geöffnet ist, gibt das Betriebssystem den Arbeitsspeicher frei, wenn der Prozess wurde beendet, jedoch administrative Informationen über den Prozess, z. B. das Handle, Exitcode und Zeitpunkt der Beendigung behält. Rufen Sie diese Informationen können Sie die <xref:System.Diagnostics.Process.ExitCode%2A> und <xref:System.Diagnostics.Process.ExitTime%2A> Eigenschaften. Diese Eigenschaften werden für Prozesse, die von dieser Komponente gestartet wurden, automatisch aufgefüllt. Die administrative Informationen wird freigegeben. wenn alle der <xref:System.Diagnostics.Process> Komponenten, die mit dem Systemprozess verknüpft sind, die zerstört werden und keine weiteren Handles für den beendeten Prozess.  
  
 Ein Prozess kann unabhängig von Ihrem Code beendet werden. Wenn Sie die Verwendung dieser Komponente gestartet wurde, aktualisiert das System den Wert der <xref:System.Diagnostics.Process.HasExited%2A> automatisch, auch wenn der zugeordnete Prozess, unabhängig voneinander beendet.  
  
> [!NOTE]
>  Standardausgabe an asynchrone Ereignishandler umgeleitet wurde, es ist möglich, dass die Verarbeitung der Ausgabe nicht abgeschlossen haben, wenn diese Eigenschaft gibt `true`. Um sicherzustellen, dass die asynchrone Ereignisverarbeitung abgeschlossen wurde, rufen die <xref:System.Diagnostics.Process.WaitForExit> Überladung, die vor der Überprüfung keine Parameter akzeptiert <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Klicken Sie dann in 2-Sekunden-Intervallen für maximal 10 Sekunden die Auslastung des physikalischen Speichers des zugeordneten Prozesses abgerufen. Dabei wird ermittelt, ob der Prozess beendet wird, bevor 10 Sekunden vergangen sind. Im Beispiel wird der Prozess geschlossen, wenn er immer noch nach 10 Sekunden ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diesem Objekt ist kein Prozess zugeordnet.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Der Exitcode für den Prozess konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.HasExited" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den eindeutigen Bezeichner für den zugeordneten Prozess ab.</summary>
        <value>Der vom System generierte eindeutige Bezeichner des Prozesses, auf den von dieser <see cref="T:System.Diagnostics.Process" />-Instanz verwiesen wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Prozess <xref:System.Diagnostics.Process.Id%2A> ist ungültig, wenn der zugeordnete Prozess nicht ausgeführt wird. Aus diesem Grund sollten Sie sicherstellen, dass es sich bei der Prozess ausgeführt wird, bevor Sie versuchen, die zum Abrufen der <xref:System.Diagnostics.Process.Id%2A> Eigenschaft. Bis der Prozess beendet wird, wird die Prozess-ID eindeutig identifiziert den Prozess im gesamten System.  
  
 Sie können einen Prozess, der auf einem Computer lokal oder remote auf einen neuen läuft verbinden <xref:System.Diagnostics.Process> Instanz, indem Sie die Prozess-ID übergeben die <xref:System.Diagnostics.Process.GetProcessById%2A> Methode. <xref:System.Diagnostics.Process.GetProcessById%2A> ist eine `static` -Methode, eine neue Komponente erstellt, und legt fest der <xref:System.Diagnostics.Process.Id%2A> -Eigenschaft für die neue <xref:System.Diagnostics.Process> -Instanz automatisch.  
  
 Prozess-IDs können vom System wiederverwendet werden. Die <xref:System.Diagnostics.Process.Id%2A> -Eigenschaftswert ist nur während der zugeordnete Prozess ausgeführt wird. Nachdem der Prozess beendet wurde, kann das System Wiederverwenden der <xref:System.Diagnostics.Process.Id%2A> Eigenschaftswert für einen nicht verwandten Prozess.  
  
 Da der Bezeichner im System eindeutig ist, können Sie es für andere Threads übergeben, als Alternative zum Übergeben einer <xref:System.Diagnostics.Process> Instanz. Dadurch kann Systemressourcen speichern dennoch sicherstellen, dass der Prozess korrekt identifiziert wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Abrufen der <xref:System.Diagnostics.Process.Id%2A> für alle ausgeführten Instanzen einer Anwendung. Der Code erstellt eine neue Instanz des Editors, listet alle Instanzen von Editor und dann kann der Benutzer zur Eingabe der <xref:System.Diagnostics.Process.Id%2A> an, die eine bestimmte Instanz zu entfernen.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.Process.Id" />-Eigenschaft des Prozesses wurde nicht festgelegt.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hält den zugeordneten Prozess sofort an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> Erzwingt die Beendigung des Prozesses während <xref:System.Diagnostics.Process.CloseMainWindow%2A> nur Anforderungen beenden. Wenn ein Prozess mit einer grafischen Benutzeroberfläche ausgeführt wird, ist die Meldungsschleife im Wartezustand befinden. Die Nachrichtenschleife führt jedes Mal, wenn eine Windows-Nachricht an den Prozess durch das Betriebssystem gesendet wird. Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> sendet eine Anforderung zum Schließen des Hauptfensters, die in eine wohlgeformte Anwendung wird das untergeordnete Fenster geschlossen, und hebt alle aktiven Nachrichtenschleifen für die Anwendung. Die Anforderung zum Beenden des Prozesses durch den Aufruf <xref:System.Diagnostics.Process.CloseMainWindow%2A> erzwingt nicht die Anwendung zu beenden. Überprüfung vor dem Beenden des Benutzers kann die Anwendung anfordern, oder es ablehnen kann, um den Vorgang abzubrechen. Um die Anwendung erzwingen, verwenden Sie die <xref:System.Diagnostics.Process.Kill%2A> Methode. Das Verhalten der <xref:System.Diagnostics.Process.CloseMainWindow%2A> ist identisch mit dem ein Benutzer einer Anwendung im Hauptfenster mit das Systemmenü schließt. Aus diesem Grund erzwingt die Anforderung zum Beenden des Prozesses, indem Sie das Hauptfenster schließen nicht die Anwendung sofort beendet.  
  
> [!NOTE]
>  Wenn die <xref:System.Diagnostics.Process.Kill%2A> Methode asynchron ausgeführt wird. Nach dem Aufruf der <xref:System.Diagnostics.Process.Kill%2A> -Methode, rufen die <xref:System.Diagnostics.Process.WaitForExit%2A> -Methode warten, damit der Prozess beendet wird, oder Überprüfen Sie die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft, um zu bestimmen, ob der Prozess beendet wurde.  
  
 Daten, die bearbeitet werden, indem der Prozess oder an den Prozess zugeordnete Ressourcen können verloren, wenn Sie aufrufen <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> bewirkt, dass eine nicht ordnungsgemäße Beendigung und sollte nur bei Bedarf verwendet werden. <xref:System.Diagnostics.Process.CloseMainWindow%2A> ermöglicht eine ordnungsgemäße Beendigung des Prozesses, und alle Fenster geschlossen wird, damit es sich vorzugsweise für Anwendungen mit einer Schnittstelle ist. Wenn <xref:System.Diagnostics.Process.CloseMainWindow%2A> ein Fehler auftritt, können Sie <xref:System.Diagnostics.Process.Kill%2A> zum Beenden des Prozesses. <xref:System.Diagnostics.Process.Kill%2A> ist die einzige Möglichkeit, Prozesse zu beenden, die keine grafische Benutzeroberflächen haben.  
  
 Rufen Sie <xref:System.Diagnostics.Process.Kill%2A> und <xref:System.Diagnostics.Process.CloseMainWindow%2A> nur für Prozesse, die auf dem lokalen Computer ausgeführt werden. Sie können nicht dazu führen, dass Prozesse auf Remotecomputern zu beenden. Sie können nur Informationen für Prozesse, die auf Remotecomputern anzeigen.  
  
> [!NOTE]
>  Wenn der Aufruf der <xref:System.Diagnostics.Process.Kill%2A> Methode erfolgt während der Prozess gerade beendet wird, eine <xref:System.ComponentModel.Win32Exception> wird ausgelöst, für den Zugriff verweigert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Der zugeordnete Prozess konnte nicht beendet werden.  
  
 - oder -  
  
 Der Prozess wird beendet.  
  
 - oder -  
  
 Der zugeordnete Prozess ist eine ausführbare Win16-Datei.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, <see cref="M:System.Diagnostics.Process.Kill" /> für einen Prozess aufzurufen, der auf einem Remotecomputer ausgeführt wird. Die Methode ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde bereits beendet.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill (bool entireProcessTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill(bool entireProcessTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (entireProcessTree As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill(bool entireProcessTree);" />
      <MemberSignature Language="F#" Value="member this.Kill : bool -&gt; unit" Usage="process.Kill entireProcessTree" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entireProcessTree" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="entireProcessTree">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet den Zustand einer <see cref="T:System.Diagnostics.Process" />-Komponente, in dem sie mit Betriebssystemprozessen interagieren kann, die in einem speziellen Modus ausgeführt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Betriebssystem-Prozesse, die in einem speziellen Modus ausgeführt werden. Es wird versucht, der Eigenschaften der oder das Anfügen an diese Prozesse ist nicht möglich, es sei denn, Sie aufgerufen haben <xref:System.Diagnostics.Process.EnterDebugMode%2A> für die Komponente. Rufen Sie <xref:System.Diagnostics.Process.LeaveDebugMode%2A> Wenn Sie nicht mehr benötigen Zugriff auf diese Prozesse, die in speziellen Modus ausgeführt.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Computers ab, auf dem der zugeordnete Prozess ausgeführt wird.</summary>
        <value>Der Name des Computers, auf dem der zugeordnete Prozess ausgeführt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Können Sie statistische Daten anzuzeigen und Prozessinformationen für Prozesse auf Remotecomputern, aber Sie kann nicht aufgerufen werden <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, oder <xref:System.Diagnostics.Process.Kill%2A> auf Remotecomputern.  
  
> [!NOTE]
>  Wenn der zugeordnete Prozess auf dem lokalen Computer ausgeführt wird, wird diese Eigenschaft gibt einen Punkt (".") für den Namen des Computers. Verwenden Sie die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft, um den richtigen Computernamen abzurufen.  
  
   
  
## Examples  
 Verwendung im folgende Beispiel müssen Sie zuerst mindestens eine Instanz des Editors auf einem Remotecomputer starten. Das Beispiel ruft den Namen des Remotecomputers auf dem Editor ausgeführt wird, und zeigt dann die entsprechenden <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, und <xref:System.Diagnostics.Process.MachineName%2A> Eigenschaften für jede Instanz.  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Hauptmodul für den zugeordneten Prozess ab.</summary>
        <value>Das zum Starten des Prozesses verwendete <see cref="T:System.Diagnostics.ProcessModule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Prozessmodul stellt eine DLL- oder .exe-Datei, die in einen bestimmten Prozess geladen wird. Die <xref:System.Diagnostics.Process.MainModule%2A> Eigenschaft können Sie anzeigen, Informationen über die ausführbare Datei, die zum Starten des Prozesses, einschließlich der Modulname, Dateiname und Details zum Arbeitsspeicher-Modul verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MainModule" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ein 32-Bit-Prozess versucht, auf die Module eines 64-Bit-Prozesses zuzugreifen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.  
  
- oder - 
Der Prozess wurde beendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Fensterhandle des Hauptfensters des zugeordneten Prozesses ab.</summary>
        <value>Das vom System generierte Fensterhandle des Hauptfensters des zugeordneten Prozesses.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Hauptfenster ist das Fenster geöffnet, die durch den Prozess, der gerade den Fokus besitzt (die <xref:System.Windows.Forms.Form.TopLevel%2A> Formular). Verwenden Sie die <xref:System.Diagnostics.Process.Refresh%2A> Methode zum Aktualisieren der <xref:System.Diagnostics.Process> Objekt, das das aktuelle Hauptfensterhandle zu erhalten, wenn es geändert hat. Im Allgemeinen verwenden, da das Fensterhandle zwischengespeichert wird, <xref:System.Diagnostics.Process.Refresh%2A> im voraus, um sicherzustellen, dass Sie das aktuelle Handle abgerufen werden.  
  
 Sie erhalten die <xref:System.Diagnostics.Process.MainWindowHandle%2A> Eigenschaft nur für Prozesse, die auf dem lokalen Computer ausgeführt werden. Die <xref:System.Diagnostics.Process.MainWindowHandle%2A> -Eigenschaft ist ein Wert, der das Fenster eindeutig bezeichnet, die dem Prozess zugeordnet ist.  
  
 Ein Prozess verfügt über ein Hauptfenster, die zugehörigen nur, wenn der Prozess über eine grafische Benutzeroberfläche verfügt. Wenn der zugeordnete Prozess nicht über ein Hauptfenster, verfügt die <xref:System.Diagnostics.Process.MainWindowHandle%2A> Wert ist 0 (null). Der Wert ist auch, dass 0 (null) für Prozesse, die ausgeblendet wurden, d. h. verarbeitet werden, die nicht in der Taskleiste sichtbar sind. Dies kann bei Prozessen der Fall sein, die als Symbole im Infobereich der Taskleiste, ganz rechts in der Taskleiste angezeigt werden.  
  
 Wenn Sie einen Prozess gestartet haben und das Hauptfensterhandle verwenden möchten, sollten Sie verwenden die <xref:System.Diagnostics.Process.WaitForInputIdle%2A> Methode, um den Prozess zu starten, beenden zuzulassen, sicherzustellen, dass das Hauptfensterhandle erstellt wurde. Andernfalls wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.MainWindowHandle" /> ist nicht definiert, da der Prozess beendet wurde.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> -Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Beschriftung des Hauptfensters des Prozesses ab.</summary>
        <value>Der Titel des Hauptfensters des Prozesses.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Prozess verfügt über ein Hauptfenster, die zugehörigen nur, wenn der Prozess über eine grafische Benutzeroberfläche verfügt. Wenn der zugeordnete Prozess nicht über ein Hauptfenster verfügt (sodass <xref:System.Diagnostics.Process.MainWindowHandle%2A> ist 0 (null)), <xref:System.Diagnostics.Process.MainWindowTitle%2A> ist eine leere Zeichenfolge (""). Wenn Sie einen Prozess gestartet haben und der Titel des Hauptfensters verwenden möchten, sollten Sie verwenden die <xref:System.Diagnostics.Process.WaitForInputIdle%2A> Methode, um den Prozess zu starten, beenden zuzulassen, sicherzustellen, dass das Hauptfensterhandle erstellt wurde. Andernfalls löst das System eine Ausnahme aus.  
  
> [!NOTE]
>  Das Hauptfenster ist das Fenster, das gegenwärtig den Fokus besitzt. Beachten Sie, dass dies nicht der primäre Fenster für den Prozess. Verwenden Sie die <xref:System.Diagnostics.Process.Refresh%2A> Methode zum Aktualisieren der <xref:System.Diagnostics.Process> Objekt, das das aktuelle Hauptfensterhandle zu erhalten, wenn es geändert hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet und ruft die Beschriftung des Hauptfensters des Prozesses.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.Process.MainWindowTitle" />-Eigenschaft ist nicht definiert, da der Prozess beendet wurde.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MainWindowTitle" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft, in Bytes, die maximal zulässige Workingsetgröße für den zugeordneten Prozess ab oder legt diese fest.</summary>
        <value>Die im Speicher maximal zulässige Workingsetgröße für den Prozess in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die derzeit sichtbar ist, an den Prozess physischen RAM-Speicher. Diese Seiten sind resident und verfügbar für eine Anwendung verwenden, ohne einen Seitenfehler auslösen.  
  
 Der Arbeitssatz enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die allen Anweisungen, die Ihre Anwendung ausgeführt wird enthalten, einschließlich der Seiten in "System.dll" Dateien und die DLL-Dateien. Das Workingset größer wird, erhöht sich Speicherbedarf.  
  
 Ein Prozess hat die Mindest- und Höchstwerte des Workingsets. Jedes Mal, wenn eine Prozessressource erstellt wird, reserviert das System die Größe des Arbeitsspeichers, die gleich der workingsetmindestgröße für den Prozess. Der virtuelle Speicher-Manager versucht, die mindestens die Mindestmenge an Arbeitsspeicher erhält vom residenten bei der Prozess aktiv ist, jedoch nie mehr als die maximale Größe.  
  
 Das System legt den Arbeitsseitengrößen festzulegen. Sie können diese Größen, die mithilfe der <xref:System.Diagnostics.Process.MaxWorkingSet%2A> und <xref:System.Diagnostics.Process.MinWorkingSet%2A> Member. Allerdings garantiert Festlegen dieser Werte nicht, dass der Arbeitsspeicher reserviert oder erhält vom residenten sein wird.  
  
> [!NOTE]
>  Wenn Sie die Größe der Arbeitsseiten eines Prozesses erhöhen, führen Sie physischen Arbeitsspeicher von der Rest des Systems. Stellen Sie sicher, dass Sie keine minimale oder maximale Workingsetgröße anfordern, der zu groß ist, da dies die Systemleistung beeinträchtigen kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die maximale Workingsetgröße ist ungültig. Sie muss größer gleich der Workingsetmindestgröße sein.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Workingsetinformationen können nicht aus der zugeordneten Prozessressource abgerufen werden  
  
 - oder -  
  
 Die Prozess-ID oder das Prozesshandle ist 0 (null), weil der Prozess nicht gestartet wurde.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MaxWorkingSet" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.  
  
- oder - 
Der Prozess wurde beendet.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft, in Bytes, die Workingsetmindestgröße für den zugeordneten Prozess ab oder legt diese fest.</summary>
        <value>Die im Speicher mindestens erforderliche Workingsetgröße für den Prozess in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die derzeit sichtbar ist, an den Prozess physischen RAM-Speicher. Diese Seiten sind resident und verfügbar für eine Anwendung verwenden, ohne einen Seitenfehler auslösen.  
  
 Der Arbeitssatz enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die allen Anweisungen, die Ihre Anwendung ausgeführt wird enthalten, einschließlich der Seiten in "System.dll" Dateien und die DLL-Dateien. Das Workingset größer wird, erhöht sich Speicherbedarf.  
  
 Ein Prozess hat die Mindest- und Höchstwerte des Workingsets. Jedes Mal, wenn eine Prozessressource erstellt wird, reserviert das System die Größe des Arbeitsspeichers, die gleich der workingsetmindestgröße für den Prozess. Der virtuelle Speicher-Manager versucht, die mindestens die Mindestmenge an Arbeitsspeicher erhält vom residenten bei der Prozess aktiv ist, jedoch nie mehr als die maximale Größe.  
  
 Das System legt den Arbeitsseitengrößen festzulegen. Sie können diese Größen, die mithilfe der <xref:System.Diagnostics.Process.MaxWorkingSet%2A> und <xref:System.Diagnostics.Process.MinWorkingSet%2A> Member. Allerdings garantiert Festlegen dieser Werte nicht, dass der Arbeitsspeicher reserviert oder erhält vom residenten sein wird.  
  
> [!NOTE]
>  Wenn Sie die Größe der Arbeitsseiten eines Prozesses erhöhen, führen Sie physischen Arbeitsspeicher von der Rest des Systems. Stellen Sie sicher, dass Sie keine minimale oder maximale Workingsetgröße anfordern, der zu groß ist, da dies die Systemleistung beeinträchtigen kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Workingsetmindestgröße ist ungültig. Sie muss kleiner gleich der maximalen Workingsetgröße sein.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Workingsetinformationen können nicht aus der zugeordneten Prozessressource abgerufen werden  
  
 - oder -  
  
 Die Prozess-ID oder das Prozesshandle ist 0 (null), weil der Prozess nicht gestartet wurde.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MinWorkingSet" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.  
  
- oder - 
Der Prozess wurde beendet.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Module ab, die vom zugeordneten Prozess geladen wurden.</summary>
        <value>Ein Array vom Typ <see cref="T:System.Diagnostics.ProcessModule" />, das die vom zugeordneten Prozess geladenen Module darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Prozessmodul stellt eine DLL- oder .exe-Datei, die in einen bestimmten Prozess geladen wird. Ein <xref:System.Diagnostics.ProcessModule> Instanz können Sie anzeigen, Informationen zu einem Modul, einschließlich der Modulname, Dateiname und Details zum Arbeitsspeicher-Modul.  
  
 Ein Prozess kann mehrere Module in den Arbeitsspeicher laden. Beispielsweise haben .exe-Dateien, die zusätzliche DLL-Dateien Laden mehrerer Module.  
  
 Nach dem Starten des Prozesses, ist diese Auflistung leer, bis das System den Prozess geladen wurden. Wenn der Prozess ein Hauptfenster verfügt, können Sie aufrufen <xref:System.Diagnostics.Process.WaitForInputIdle%2A> vor dem Abrufen dieser Eigenschaft, um sicherzustellen, dass die Auflistung nicht leer, wenn ist Sie die Liste abrufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Modules" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Modules" />-Eigenschaft für den Systemprozess oder den Leerlaufprozess zuzugreifen. Diese Prozesse verfügen über keine Module.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des für den zugeordneten Prozess belegten nicht ausgelagerten Systemspeichers in Bytes ab.</summary>
        <value>Der Arbeitsspeicher in Bytes, den das System für den zugehörigen Prozess belegt hat und der nicht in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des für den zugeordneten Prozess belegten nicht ausgelagerten Systemspeichers in Bytes ab.</summary>
        <value>Der Anteil am Systemspeicher in Bytes, der für den zugeordneten Prozess reserviert ist und der nicht in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des nicht ausgelagerten Systemspeichers, der durch den Prozess in Bytes dar. Systemspeicher ist die vom Betriebssystem verwendeten physischen Speichers und ist in den Durchschnittswert unterteilt. Nicht ausgelagerte Arbeitsspeicher zugewiesen im Arbeitsspeicher verbleiben und nicht die Auslagerungsdatei des virtuellen Arbeitsspeichers ausgelagert werden.  
  
 Diese Eigenschaft kann zur Überwachung der speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Den Wert der Eigenschaft entspricht der **nicht auslagerbare Poolbytes** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und zeigt die beenden-Code und Spitzenwerte Arbeitsspeicherstatistik.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst das <see cref="E:System.Diagnostics.Process.Exited" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> die API-Methode, die auslöst wird die <xref:System.Diagnostics.Process.Exited> Ereignis. Aufrufen von <xref:System.Diagnostics.Process.OnExited%2A> bewirkt, dass die <xref:System.Diagnostics.Process.Exited> Ereignis eintritt und ist die einzige Möglichkeit zum Auslösen das Ereignis mithilfe der <xref:System.Diagnostics.Process> Komponente. <xref:System.Diagnostics.Process.OnExited%2A> wird hauptsächlich verwendet, bei der Ableitung von Klassen von der Komponente.  
  
 Als Alternative zur <xref:System.Diagnostics.Process.OnExited%2A>, Sie können einen eigenen Ereignishandler schreiben. Erstellen Sie eigene Ereignishandlerdelegaten und eine eigene Methode zur Verarbeitung von Ereignissen.  
  
> [!NOTE]
>  Wenn Sie Visual Studio-Umgebung verwenden, ein Ereignishandlerdelegat (AddOnExited) und eine Methode zur Verarbeitung von Ereignissen (Process1_Exited) werden erstellt für Sie beim Ziehen einer <xref:System.Diagnostics.Process> Komponente in ein Formular, und doppelklicken Sie auf das Symbol. Der Code Sie erstellen, um die Ausführung der <xref:System.Diagnostics.Process.Exited> Ereignis tritt auf, in der Prozedur Process1_Exited eingegeben wird. Sie müssen nicht zum Erstellen der <xref:System.Diagnostics.Process.OnExited%2A> Member, da es für Sie implementiert wird.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Diagnostics.Process.OnExited%2A> -Methode in einer abgeleiteten Klasse.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt jedes Mal auf, wenn eine Anwendung eine Zeile in ihren umgeleiteten <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream schreibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis gibt an, dass die zugeordnete <xref:System.Diagnostics.Process> wurde geschrieben, eine Zeile mit einem neue Zeilenumbruchzeichen in seinen umgeleiteten beenden <xref:System.Diagnostics.Process.StandardOutput%2A> Stream.  
  
 Das Ereignis wird während der asynchrone Lesevorgänge aktiviert, auf <xref:System.Diagnostics.Process.StandardOutput%2A>. Um asynchrone Lesevorgänge zu starten, müssen Sie Umleiten der <xref:System.Diagnostics.Process.StandardOutput%2A> Datenstrom von einer <xref:System.Diagnostics.Process>, den Ereignishandler zum Hinzufügen der <xref:System.Diagnostics.Process.OutputDataReceived> -Ereignis, und rufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. Danach die <xref:System.Diagnostics.Process.OutputDataReceived> Ereignissignale jedes Mal, die der Prozess eine Zeile in der umgeleiteten schreibt <xref:System.Diagnostics.Process.StandardOutput%2A> streamen, bis der Prozess beendet wird, oder ruft <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  Die Anwendung, die die asynchrone Ausgabe verarbeitet aufrufen, sollte die <xref:System.Diagnostics.Process.WaitForExit%2A> Methode, um sicherzustellen, dass der Ausgabepuffer geleert wurde.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie asynchrone Lesevorgänge im umgeleiteten auszuführenden <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, der die `ipconfig` Befehl.  
  
 Das Beispiel erstellt einen Delegaten für die `OutputHandler` -Ereignishandler und ordnet ihn dem <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis. Der Ereignishandler empfängt Textzeilen aus dem umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream formatiert den Text, und speichert es in eine Ausgabezeichenfolge, die später in dem Beispiel-Konsolenfenster angezeigt wird.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des Auslagerungsspeichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Der Arbeitsspeicher in Bytes, den der zugehörige Prozess belegt und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des Auslagerungsspeichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Die Größe des Arbeitsspeichers in Bytes, der für den zugeordneten Prozess in der Auslagerungsdatei des virtuellen Arbeitsspeichers belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des Arbeitsspeichers in der Auslagerungsdatei des virtuellen Speichers ein, die den Prozess in Bytes dar. Das Betriebssystem verwendet die Auslagerungsdatei des virtuellen Speichers in Verbindung mit physischem Arbeitsspeicher zum Verwalten von virtuellen Adressraums für jeden Prozess. Wenn verwendete nicht ausgelagerte Arbeitsspeicher nicht verwendet wird, können sie die Auslagerungsdatei des virtuellen Arbeitsspeichers auf dem Datenträger übertragen werden. Verwenden Sie zum Abrufen der Größe des Arbeitsspeichers, die vom Betriebssystem verwendet wird, für den Prozess der <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> Eigenschaft.  
  
 Diese Eigenschaft kann zur Überwachung der speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Den Wert der Eigenschaft entspricht der **Seite Dateibytes** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird startet eine Instanz von Editor-Anwendung, und klicken Sie dann Ruft ab und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und zeigt die beenden-Code und Spitzenwerte Arbeitsspeicherstatistik.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des für den zugeordneten Prozess belegten auslagerbaren Systemspeichers in Bytes ab.</summary>
        <value>Der Arbeitsspeicher in Bytes, den das System für den zugehörigen Prozess belegt hat und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des für den zugeordneten Prozess belegten auslagerbaren Systemspeichers in Bytes ab.</summary>
        <value>Der Anteil am Systemspeicher in Bytes, der für den zugeordneten Prozess belegt wird und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der vom Wert Eigenschaft zurückgegebene Wert stellt die aktuelle Größe der auslagerbaren Systemspeichers, der durch den Prozess in Bytes dar. Systemspeicher ist die vom Betriebssystem verwendeten physischen Speichers und ist in den Durchschnittswert unterteilt. Wenn verwendete nicht ausgelagerte Arbeitsspeicher nicht verwendet wird, können sie die Auslagerungsdatei des virtuellen Arbeitsspeichers auf dem Datenträger übertragen werden. Verwenden Sie zum Abrufen der Anwendung im Arbeitsspeicher vom Prozess verwendet die <xref:System.Diagnostics.Process.PagedMemorySize64%2A> Eigenschaft.  
  
 Diese Eigenschaft kann zur Überwachung der speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Den Wert der Eigenschaft entspricht der **Auslagerungsseiten (Bytes) Pool** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und zeigt die beenden-Code und Spitzenwerte Arbeitsspeicherstatistik.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vom zugeordneten Prozess verwendeten maximalen Arbeitsspeicher in der Auslagerungsdatei des virtuellen Arbeitsspeichers in Bytes ab.</summary>
        <value>Der maximale Arbeitsspeicher in Bytes, den der zugehörige Prozess belegt und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vom zugeordneten Prozess verwendeten maximalen Arbeitsspeicher in der Auslagerungsdatei des virtuellen Arbeitsspeichers in Bytes ab.</summary>
        <value>Die maximale Größe des Arbeitsspeichers in Bytes, der seit dem Starten für den zugeordneten Prozess in der Auslagerungsdatei des virtuellen Arbeitsspeichers belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der vom Wert Eigenschaft zurückgegebene Wert stellt die maximale Größe des Arbeitsspeichers in der Auslagerungsdatei des virtuellen Speichers durch den Prozess verwendet werden, da er, in Bytes gestartet dar. Das Betriebssystem verwendet die Auslagerungsdatei des virtuellen Speichers in Verbindung mit physischem Arbeitsspeicher zum Verwalten von virtuellen Adressraums für jeden Prozess. Wenn verwendete nicht ausgelagerte Arbeitsspeicher nicht verwendet wird, können sie die Auslagerungsdatei des virtuellen Arbeitsspeichers auf dem Datenträger übertragen werden.  
  
 Diese Eigenschaft kann zur Überwachung der speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Den Wert der Eigenschaft entspricht der **Seite Datei Bytes (max.)** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und zeigt die beenden-Code und Spitzenwerte Arbeitsspeicherstatistik.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe des virtuellen Speichers (in Bytes) ab, der vom zugeordneten Prozess verwendet wird.</summary>
        <value>Die maximale virtuelle Speicher in Bytes, der vom zugehörigen Prozess angefordert wurde.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe des virtuellen Speichers (in Bytes) ab, der vom zugeordneten Prozess verwendet wird.</summary>
        <value>Die maximale Größe des virtuellen Arbeitsspeichers in Bytes, der für den zugeordneten Prozess seit dem Starten belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die maximale Größe des virtuellen Arbeitsspeichers, die vom Prozess verwendet werden, da er, in Bytes gestartet dar. Das Betriebssystem ordnet den virtuellen Adressraum für jeden Prozess, der entweder Seiten im physischen Speicher zu Seiten, die in der Auslagerungsdatei des virtuellen Speichers auf dem Datenträger gespeichert oder geladen.  
  
 Diese Eigenschaft kann zur Überwachung der speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Den Wert der Eigenschaft entspricht der **virtuelle Bytes (max.)** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und zeigt die beenden-Code und Spitzenwerte Arbeitsspeicherstatistik.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe des Workingsets für den zugeordneten Prozess in Bytes ab.</summary>
        <value>Die maximale Größe des physischen Speichers in Bytes, den der zugeordnete Prozess gleichzeitig angefordert hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die derzeit sichtbar ist, an den Prozess physischen RAM-Speicher. Diese Seiten sind resident und verfügbar für eine Anwendung verwenden, ohne einen Seitenfehler auslösen.  
  
 Der Arbeitssatz enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die allen Anweisungen, die der Prozess ausgeführt wird enthalten, einschließlich Prozessmodule und der Systembibliotheken.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe des physischen Speichers (in Bytes) ab, der vom zugeordneten Prozess verwendet wird.</summary>
        <value>Die maximale Größe des physischen Speichers in Bytes, der für den zugeordneten Prozess seit dem Starten belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die maximale Größe der Menge Arbeitsspeicher vom Prozess verwendet werden, da er, in Bytes gestartet dar. Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die derzeit sichtbar ist, an den Prozess physischen RAM-Speicher. Diese Seiten sind resident und verfügbar für eine Anwendung verwenden, ohne einen Seitenfehler auslösen.  
  
 Der Arbeitssatz enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die allen Anweisungen, die der Prozess ausgeführt wird enthalten, einschließlich Anweisungen über die Prozess-Module und der Systembibliotheken.  
  
 Diese Eigenschaft kann zur Überwachung der speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Den Wert der Eigenschaft entspricht der **maximale Größe der Arbeitsseiten** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und zeigt die beenden-Code und Spitzenwerte Arbeitsspeicherstatistik.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die zugeordnete Prozesspriorität durch das Betriebssystem vorübergehend erhöht werden soll, wenn das Hauptfenster den Fokus besitzt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Prozesspriorität eines Prozesses dynamisch erhöht werden soll, wenn dieser den Wartezustand verlässt; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Thread in einem Prozess für die die Prioritätsklasse verfügt über einer der Enumerationswerte dynamische Priorität ausgeführt wird (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, oder <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), im System erhöht die Priorität des Threads vorübergehend, wenn es einen Wartezustand versetzt wird. Dadurch wird verhindert, dass andere Prozesse die Verarbeitung des aktuellen Threads zu unterbrechen. Die <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Einstellung wirkt sich auf alle vorhandenen Threads sowie auf alle Threads, die anschließend durch den Prozess erstellt. Um das normale Verhalten wiederherzustellen, legen die <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Eigenschaft `false`.  
  
> [!NOTE]
>  Die Priorität zu stark angehoben, kann Ressourcen von wichtigen Betriebssystem- und Netzwerkfunktionen, verursacht Probleme mit anderer betriebssystemtasks abzuleiten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Es konnten keine Prozesserhöhungsinformationen von der zugeordneten Prozessressource abgerufen werden.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.  
  
 - oder -  
  
 Die Prozess-ID oder das Prozesshandle ist 0 (null). (Der Prozess wurde nicht gestartet.)</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die allgemeine Prioritätskategorie für den zugeordneten Prozess ab oder legt diese fest.</summary>
        <value>Die Prioritätskategorie für den zugeordneten Prozess, aus der die <see cref="P:System.Diagnostics.Process.BasePriority" /> des Prozesses berechnet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Prioritätsklasse des Prozesses umfasst einen Bereich von Prioritätsstufen für Threads. Threads mit unterschiedlichen Prioritäten, die im Prozess ausgeführt werden, die relativ zu die Prioritätsklasse des Prozesses ausgeführt werden. Win32 verwendet vier Prioritätsklassen mit sieben Basisprioritätsebenen pro Klasse. Dieser Prozess Prioritätsklassen in erfasst die <xref:System.Diagnostics.ProcessPriorityClass> -Enumeration, die Sie können die Prozesspriorität auf festgelegt <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, oder <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. Basierend auf der Zeit, die vom Betriebssystem verstrichene anderen Prozessen, die Basisprioritätsebene geändert werden können, wenn ein Prozess für den Zugriff an den Prozessor vorangestellt werden muss. Sie können außerdem festlegen der <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> vorübergehend die Prioritätsebene des Threads zu verstärken, die den Wartezustand ausgeführt wurden. Die Priorität wird immer dann zurückgesetzt, wenn der Prozess in den Wartezustand zurückkehrt.  
  
 Die <xref:System.Diagnostics.Process.BasePriority%2A> Eigenschaft können Sie die anzeigen, die einem Prozess zugeordnet ist. Aber da es schreibgeschützt ist, können keine der <xref:System.Diagnostics.Process.BasePriority%2A> Eigenschaft zum Festlegen der Priorität eines Prozesses. Verwenden Sie zum Ändern der Priorität der <xref:System.Diagnostics.Process.PriorityClass%2A> -Eigenschaft, die übernimmt oder bestimmt die allgemeine Prioritätskategorie für den Prozess.  
  
 Die Prioritätsklasse kann nicht mithilfe des Systemmonitors angezeigt werden. Die folgende Tabelle zeigt die Beziehung zwischen der <xref:System.Diagnostics.Process.BasePriority%2A> und <xref:System.Diagnostics.Process.PriorityClass%2A> Werte.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Es konnten keine Prozessprioritätsinformationen festgelegt oder von der zugeordneten Prozessressource abgerufen werden.  
  
 - oder -  
  
 Die Prozess-ID oder das Prozesshandle ist 0 (null). (Der Prozess wurde nicht gestartet.)</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.PriorityClass" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Sie haben bei Verwendung von Windows 98 oder Windows Millennium Edition (Windows Me) die <see cref="P:System.Diagnostics.Process.PriorityClass" /> auf <see langword="AboveNormal" /> oder <see langword="BelowNormal" /> festgelegt. Diese Plattformen unterstützen diese Werte für die Prioritätsklasse nicht.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die Prioritätsklasse kann nicht festgelegt werden, weil sie keinen gültigen Wert gemäß der Definition in der <see cref="T:System.Diagnostics.ProcessPriorityClass" />-Enumeration verwendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des privaten Speichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Die Anzahl der vom zugeordneten Prozess reservierten Bytes, die nicht mit anderen Prozessen gemeinsam genutzt werden können.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des privaten Speichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Die Größe des Speichers in Bytes, der für den zugeordneten Prozess belegt wird und nicht mit anderen Prozessen gemeinsam genutzt werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt dar, die aktuelle Größe des belegten, die durch den Prozess in Bytes, die nicht mit anderen Prozessen gemeinsam genutzt werden kann.  
  
 Diese Eigenschaft kann zur Überwachung der speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Den Wert der Eigenschaft entspricht der **Private Bytes** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und zeigt die beenden-Code und Spitzenwerte Arbeitsspeicherstatistik.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die privilegierte Prozessorzeit für diesen Prozess ab.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die angibt, wie lange der Prozess im Betriebssystemkern Code ausgeführt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> -Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Prozesses ab.</summary>
        <value>Der Name, mit dem das System den Prozess für den Benutzer kennzeichnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.ProcessName%2A> Eigenschaft enthält den Namen einer ausführbaren Datei an, wie z. B. Outlook, die die Erweiterung .exe oder der Pfad nicht enthalten. Es ist hilfreich für das Abrufen und Bearbeiten aller Prozesse, die die gleichen ausführbaren Datei zugeordnet sind.  
  
> [!NOTE]
>  Auf [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] Betriebssysteme, die <xref:System.Diagnostics.Process.ProcessName%2A> Eigenschaft möglicherweise und 15 Zeichen abgeschnitten, wenn die Prozessinformationen für das Modul nicht abgerufen werden kann.  
  
 Rufen Sie <xref:System.Diagnostics.Process.GetProcessesByName%2A>, und übergeben sie den Namen einer ausführbaren Datei an, um ein Array abzurufen, die alle ausgeführten Instanzen auf dem angegebenen Computer enthält. Sie können dieses Array ab und beispielsweise verwenden, um die ausgeführten Instanzen der ausführbaren Datei zu schließen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Für den Prozess ist kein Bezeichner vorhanden, oder dem <see cref="T:System.Diagnostics.Process" /> ist kein Prozess zugeordnet.  
  
- oder - 
Der zugeordnete Prozess wurde beendet.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <exception cref="T:System.NotSupportedException">Der Prozess ist auf diesem Computer nicht vorhanden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Prozessoren ab, auf denen die Ausführung der Threads in diesem Prozess geplant werden kann, oder legt diese fest.</summary>
        <value>Eine Bitmaske, die angibt, auf welchen Prozessoren die Threads im zugeordneten Prozess ausgeführt werden können. Der Standardwert hängt von der Anzahl der Prozessoren des Computers ab. Der Standardwert ist 2 <sup>n</sup> 1, wobei n die Anzahl der Prozessoren.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Windows 2000 und höher kann ein Thread in einem Prozess nach Prozessor, bei jeder Migration der Prozessorcache migrieren. Unter System stark ausgelastet kann angeben, welcher Prozessor einen bestimmten Thread ausgeführt werden soll Verbessern der Leistung durch Verringern der Anzahl der Häufigkeit, mit die Cache des Prozessors geladen wird. Die Zuordnung zwischen einem Prozessor und ein Thread wird als Prozessoraffinität bezeichnet.  
  
 Jeder Prozessor wird als Bitfeld dargestellt. Bit 0 stellt einen Prozessor, Bit 1 ist Prozessor 2 usw. Wenn Sie ein wenig auf den Wert 1 festlegen, wird der entsprechenden Prozessor für die Threadzuweisung ausgewählt. Beim Festlegen der <xref:System.Diagnostics.Process.ProcessorAffinity%2A> Wert 0 (null), das Betriebssystem den Satz von Algorithmen die Threadaffinität planen. Wenn die <xref:System.Diagnostics.Process.ProcessorAffinity%2A> Wert auf einen Wert ungleich NULL festgelegt ist, wird der Wert interpretiert, als eine Bitmaske, die die infrage kommenden Prozessoren angibt.  
  
 Die folgende Tabelle zeigt eine Liste verfügbarer <xref:System.Diagnostics.Process.ProcessorAffinity%2A> Werte für ein System mit acht Prozessoren.  
  
|Bitmaske|Binärwert|Verfügbare Prozessoren|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 und 2|  
|0x0007|00000000 00000111|1, 2 und 3|  
|0x0009|00000000 00001001|1 bis 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 und 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Es konnten keine <see cref="P:System.Diagnostics.Process.ProcessorAffinity" />-Informationen festgelegt oder von der zugeordneten Prozessressource abgerufen werden.  
  
- oder - 
Die Prozess-ID oder das Prozesshandle ist 0 (null). (Der Prozess wurde nicht gestartet.)</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.ProcessorAffinity" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> war nicht verfügbar.  
  
- oder - 
Der Prozess wurde beendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verwirft alle Informationen über den zugeordneten Prozess, die in der Prozesskomponente zwischengespeichert waren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem <xref:System.Diagnostics.Process.Refresh%2A> aufgerufen wird, die erste Anforderung für Informationen zu jeder Eigenschaft führt dazu, dass die Process-Komponente, um einen neuen Wert aus dem zugeordneten Prozess zu erhalten.  
  
 Wenn eine <xref:System.Diagnostics.Process> Komponente bezieht sich auf eine Prozessressource, die Eigenschaftswerte der <xref:System.Diagnostics.Process> werden sofort nach dem Status des zugeordneten Prozesses aufgefüllt. Wenn die Informationen zu den zugeordneten Prozess anschließend geändert wird, werden diese Änderungen nicht berücksichtigt die <xref:System.Diagnostics.Process> Komponente zwischengespeicherte Werte. Die <xref:System.Diagnostics.Process> Komponente ist eine Momentaufnahme der Prozessressource, die zum Zeitpunkt der sie zugeordnet sind. Um die aktuellen Werte für den zugeordneten Prozess anzuzeigen, rufen die <xref:System.Diagnostics.Process.Refresh%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Klicken Sie dann in 2-Sekunden-Intervallen für maximal 10 Sekunden die Auslastung des physikalischen Speichers des zugeordneten Prozesses abgerufen. Dabei wird ermittelt, ob der Prozess beendet wird, bevor 10 Sekunden vergangen sind. Im Beispiel wird der Prozess geschlossen, wenn er immer noch nach 10 Sekunden ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Benutzeroberfläche des Prozesses reagiert.</summary>
        <value><see langword="true" />, wenn die Benutzeroberfläche des zugeordneten Prozesses auf das System reagiert; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Prozess eine Benutzeroberfläche, verfügt die <xref:System.Diagnostics.Process.Responding%2A> Eigenschaft stellt der Benutzeroberfläche, um festzustellen, ob der Prozess auf eine Benutzereingabe reagiert. Wenn die Schnittstelle nicht sofort, antwortet der <xref:System.Diagnostics.Process.Responding%2A> -Eigenschaft gibt `false`. Verwenden Sie diese Eigenschaft, um zu bestimmen, ob die Schnittstelle des zugeordneten Prozesses reagiert.  
  
 Wenn der Vorgang keine <xref:System.Diagnostics.Process.MainWindowHandle%2A>, gibt diese Eigenschaft `true`.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <exception cref="T:System.InvalidOperationException">Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Responding" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Handle dieses Prozesses ab.</summary>
        <value>Das systemeigene Handle dieses Prozesses.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Handle ist nur verfügbar, wenn die aufrufende Komponente der Prozess gestartet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Terminaldienste-Sitzungs-ID für den zugeordneten Prozess ab.</summary>
        <value>Die Terminaldienste-Sitzungs-ID für den zugeordneten Prozess.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.SessionId%2A> identifiziert die Sitzung, in dem die Anwendung derzeit ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Diesem Prozess ist keine Sitzung zugeordnet.</exception>
        <exception cref="T:System.InvalidOperationException">Dieser Sitzungs-ID ist kein Prozess zugeordnet.  
  
 - oder -  
  
 Der zugeordnete Prozess befindet sich nicht auf diesem Computer.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="P:System.Diagnostics.Process.SessionId" />-Eigenschaft wird unter Windows 98 nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Stream ab, mit dem die Fehlerausgabe der Anwendung gelesen wird.</summary>
        <value>Ein <see cref="T:System.IO.StreamReader" /> zum Lesen des Standardfehlerstreams der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Diagnostics.Process> schreibt Text in der Standardfehlerstream Text normalerweise in der Konsole angezeigt wird. Durch das Umleiten der <xref:System.Diagnostics.Process.StandardError%2A> Stream können Sie bearbeiten oder die Fehlerausgabe eines Prozesses zu unterdrücken. Sie können z. B. den Text zu filtern, anders formatieren oder Schreiben der Ausgabe in der Konsole und einer angegebenen Protokolldatei.  
  
> [!NOTE]
>  Mit <xref:System.Diagnostics.Process.StandardError%2A>, müssen Sie festlegen, <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> zu `false`, und Sie müssen festlegen, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> zu `true`. Andernfalls Lesen aus der <xref:System.Diagnostics.Process.StandardError%2A> Datenstrom löst eine Ausnahme aus.  
  
 Im umgeleiteten <xref:System.Diagnostics.Process.StandardError%2A> Stream synchron oder asynchron gelesen werden kann. Methoden, z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, und <xref:System.IO.StreamReader.ReadToEnd%2A> synchrone Lesevorgänge den Fehlerausgabestream des Prozesses führen. Diese synchrone gelesen, bis der zugeordneten Vorgänge nicht vollständig <xref:System.Diagnostics.Process> schreibt in seine <xref:System.Diagnostics.Process.StandardError%2A> streamen oder schließt den Stream.  
  
 Im Gegensatz dazu <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> startet asynchrone Lesevorgänge auf dem <xref:System.Diagnostics.Process.StandardError%2A> Stream. Diese Methode ermöglicht es einen angegebenen Ereignishandler für die Streamausgabe und gibt sofort zurück, an den Aufrufer und der andere Aufgaben durchführen kann, während die Streamausgabe an den Ereignishandler geleitet wird.  
  
 Synchrone Lesevorgänge verursachen eine Abhängigkeit zwischen dem Aufrufer, die beim Lesen aus der <xref:System.Diagnostics.Process.StandardError%2A> Stream und dem untergeordneten Element verarbeitet das Schreiben in den Stream. Diese Abhängigkeiten können dazu führen, dass Deadlock-Bedingungen. Wenn der Aufrufer aus dem umgeleiteten Stream von einem untergeordneten Prozess liest, ist es das untergeordnete Element abhängig. Der Aufrufer wartet auf den Lesevorgang, bis das untergeordnete Element in den Stream schreibt oder den Stream schließt. Wenn der untergeordnete Prozess genügend Daten zum Füllen von seinen umgeleiteten-Streams schreibt, ist es vom übergeordneten Element abhängig. Der untergeordnete Prozess wartet auf der nächste Schreibvorgang auf, bis das übergeordnete Element aus der vollständige Stream gelesen oder den Stream schließt. Die Deadlockbedingung entsteht, wenn es sich bei dem Aufrufer und dem untergeordneten Prozess, untereinander warten, um einen Vorgang abzuschließen, und keines von beiden kann fortgesetzt werden. Sie können Deadlocks vermeiden, durch die Auswertung der Abhängigkeiten zwischen dem Aufrufer und dem untergeordneten Prozess.  

Die letzten beiden Beispiele in diesem Abschnitt verwenden die <xref:System.Diagnostics.Process.Start%2A> Methode zum Starten einer ausführbaren Datei mit dem Namen *Write500Lines.exe*. Das folgende Beispiel enthält Quellcode.

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

Das folgende Beispiel zeigt, wie aus einem Stream umgeleiteten Fehler lesen und warten Sie, bis des untergeordnete Prozess beendet wird. Es wird eine Deadlock-Bedingung vermieden, durch den Aufruf `p.StandardError.ReadToEnd` vor `p.WaitForExit`. Eine Deadlock-Bedingung kann dazu führen, wenn das übergeordnete Element Aufrufe verarbeiten `p.WaitForExit` vor `p.StandardError.ReadToEnd` und der untergeordneten Prozess genug Text zum Ausfüllen des umgeleiteten Streams schreibt. Der übergeordnete Prozess würde für den untergeordneten Prozess zu beenden, unbegrenzt warten. Der untergeordnete Prozess würde auf unbestimmte Zeit warten, für das übergeordnete Element zum Lesen aus der vollständigen <xref:System.Diagnostics.Process.StandardError%2A> Stream.   

[!code-csharp[Reading from the error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standarderror/stderror-sync.cs)]
[!code-vb[Reading from the error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standarderror/stderror-sync.vb)]  

Es ist ein ähnliches Problem auf, wenn es sich bei Sie gesamten Text sowohl die Standardausgabe und Standardfehlerstreams gelesen werden. Im folgenden Beispiel wird einen Lesevorgang für beide Streams. Es werden die Deadlockbedingung vermieden, indem asynchrone Lesevorgänge auf dem <xref:System.Diagnostics.Process.StandardError%2A> Stream. Eine Deadlock-Bedingung führt, wenn das übergeordnete Element Aufrufe verarbeiten `p.StandardOutput.ReadToEnd` gefolgt von `p.StandardError.ReadToEnd` und der untergeordneten Prozess schreibt genug Text zum Fehlerstreams zu füllen. Der übergeordnete Prozess würde auf unbestimmte Zeit warten, für den untergeordneten Prozess zu schließen die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Der untergeordnete Prozess würde auf unbestimmte Zeit warten, für das übergeordnete Element zum Lesen aus der vollständigen <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
[!code-csharp[Reading from both streams](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]
[!code-vb[Reading from both streams](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]  

Sie können asynchrone Lesevorgänge verwenden, um diese Abhängigkeiten und deren potenzielle Deadlocks zu vermeiden. Alternativ können Sie die Deadlockbedingung vermeiden, durch das Erstellen von zwei Threads, und Lesen der Ausgabe der einzelnen Datenströme in einem separaten Thread.  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge in einem umgeleiteten Stream nicht mischen. Einmal im umgeleiteten Stream, der eine <xref:System.Diagnostics.Process> wird geöffnet, in asynchronen oder synchronen Modus alle weiteren Lesevorgänge Operationen in diesem Stream muss sich im gleichen Modus. Führen Sie beispielsweise nicht <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> mit einem Aufruf von <xref:System.IO.StreamReader.ReadLine%2A> auf die <xref:System.Diagnostics.Process.StandardError%2A> Stream oder umgekehrt. Sie können jedoch zwei verschiedenen Streams in unterschiedlichen Modi lesen. Sie können z. B. Aufrufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> und rufen dann <xref:System.IO.StreamReader.ReadLine%2A> für die <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `net use` Befehl zusammen mit einem Benutzer bereitgestellte Argument eine Netzwerkressource zugeordnet. Anschließend den Standardfehlerstream des Befehls net liest und schreibt in die Konsole.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wurde nicht für die Umleitung definiert. Stellen Sie sicher, dass <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> auf <see langword="true" /> und <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> festgelegt ist.  
  
- oder - 
Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wurde für asynchrone Lesevorgänge mit <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> geöffnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Stream ab, in den die Eingaben der Anwendung geschrieben werden.</summary>
        <value>Ein <see cref="T:System.IO.StreamWriter" /> zum Schreiben des Standardeingabestreams der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Diagnostics.Process> können Sie die eingegebenen Text aus der standard-Eingabedatenstrom, in der Regel auf der Tastatur gelesen. Durch das Umleiten der <xref:System.Diagnostics.Process.StandardInput%2A> Stream können Sie programmgesteuert die Eingabe angeben. Beispielsweise können Sie anstelle von Tastatureingaben, Text aus dem Inhalt einer angegebenen Datei oder die Ausgabe aus einer anderen Anwendung bereitstellen.  
  
> [!NOTE]
>  Mit <xref:System.Diagnostics.Process.StandardInput%2A>, müssen Sie festlegen, <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> zu `false`, und Sie müssen festlegen, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> zu `true`. Andernfalls Schreiben in die <xref:System.Diagnostics.Process.StandardInput%2A> Datenstrom löst eine Ausnahme aus.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht, wie Sie die Umleitung der <xref:System.Diagnostics.Process.StandardInput%2A> Stream eines Prozesses. Das Beispiel beginnt die `sort` Befehl mit umgeleiteter Eingabe. Anschließend fordert den Benutzer für den Text, und übergibt dieses an die `sort` Prozess über den umgeleiteten <xref:System.Diagnostics.Process.StandardInput%2A> Stream. Die `sort` Ergebnisse werden an den Benutzer in der Konsole angezeigt.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardInput" />-Stream wurde nicht definiert, da <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> auf <see langword="false" /> festgelegt ist.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Stream ab, der dazu verwendet wird, die Textausgabe der Anwendung zu lesen.</summary>
        <value>Ein <see cref="T:System.IO.StreamReader" /> zum Lesen des Standardausgabestreams der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Diagnostics.Process> schreibt Text in den standard-Stream, dass Text normalerweise in der Konsole angezeigt wird. Durch das Umleiten der <xref:System.Diagnostics.Process.StandardOutput%2A> Stream können Sie bearbeiten oder die Ausgabe eines Prozesses zu unterdrücken. Sie können z. B. den Text zu filtern, anders formatieren oder Schreiben der Ausgabe in der Konsole und einer angegebenen Protokolldatei.  
  
> [!NOTE]
>  Mit <xref:System.Diagnostics.Process.StandardOutput%2A>, müssen Sie festlegen, <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> zu `false`, und Sie müssen festlegen, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> zu `true`. Andernfalls Lesen aus der <xref:System.Diagnostics.Process.StandardOutput%2A> Datenstrom löst eine Ausnahme aus.  
  
 Im umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream synchron oder asynchron gelesen werden kann. Methoden, z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, und <xref:System.IO.StreamReader.ReadToEnd%2A> synchrone Lesevorgänge in den Ausgabestream des Prozesses führen. Diese synchrone gelesen, bis der zugeordneten Vorgänge nicht vollständig <xref:System.Diagnostics.Process> schreibt in seine <xref:System.Diagnostics.Process.StandardOutput%2A> streamen oder schließt den Stream.  
  
 Im Gegensatz dazu <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> startet asynchrone Lesevorgänge auf dem <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Diese Methode ermöglicht es einen angegebenen Ereignishandler für die Streamausgabe und gibt sofort zurück, an den Aufrufer und der andere Aufgaben durchführen kann, während die Streamausgabe an den Ereignishandler geleitet wird.  
  
 Synchrone Lesevorgänge verursachen eine Abhängigkeit zwischen dem Aufrufer, die beim Lesen aus der <xref:System.Diagnostics.Process.StandardOutput%2A> Stream und dem untergeordneten Element verarbeitet das Schreiben in den Stream. Diese Abhängigkeiten können dazu führen, dass Deadlock-Bedingungen. Wenn der Aufrufer aus dem umgeleiteten Stream von einem untergeordneten Prozess liest, ist es das untergeordnete Element abhängig. Der Aufrufer wartet auf den Lesevorgang, bis das untergeordnete Element in den Stream schreibt oder den Stream schließt. Wenn der untergeordnete Prozess genügend Daten zum Füllen von seinen umgeleiteten-Streams schreibt, ist es vom übergeordneten Element abhängig. Der untergeordnete Prozess wartet auf der nächste Schreibvorgang auf, bis das übergeordnete Element aus der vollständige Stream gelesen oder den Stream schließt. Die Deadlockbedingung entsteht, wenn es sich bei dem Aufrufer und dem untergeordneten Prozess, untereinander warten, um einen Vorgang abzuschließen, und keines von beiden kann fortgesetzt werden. Sie können Deadlocks vermeiden, durch die Auswertung der Abhängigkeiten zwischen dem Aufrufer und dem untergeordneten Prozess.  

Die letzten beiden Beispiele in diesem Abschnitt verwenden die <xref:System.Diagnostics.Process.Start%2A> Methode zum Starten einer ausführbaren Datei mit dem Namen *Write500Lines.exe*. Das folgende Beispiel enthält Quellcode.

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

Das folgende Beispiel zeigt, wie aus einem umgeleiteten Stream zu lesen und zu warten, bis der untergeordnete Prozess beendet wird. Im Beispiel wird eine Deadlockbedingung vermieden, durch den Aufruf `p.StandardOutput.ReadToEnd` vor `p.WaitForExit`. Eine Deadlock-Bedingung kann dazu führen, wenn das übergeordnete Element Aufrufe verarbeiten `p.WaitForExit` vor `p.StandardOutput.ReadToEnd` und der untergeordneten Prozess genug Text zum Ausfüllen des umgeleiteten Streams schreibt. Der übergeordnete Prozess würde für den untergeordneten Prozess zu beenden, unbegrenzt warten. Der untergeordnete Prozess würde auf unbestimmte Zeit warten, für das übergeordnete Element zum Lesen aus der vollständigen <xref:System.Diagnostics.Process.StandardOutput%2A> Stream.  

[!code-csharp[Reading synchronously from a redirected output stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-sync.cs)]  
[!code-vb[Reading synchronously from a redirected output stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-sync.vb)]  

Es ist ein ähnliches Problem auf, wenn es sich bei Sie gesamten Text sowohl die Standardausgabe und Standardfehlerstreams gelesen werden. Im folgenden Beispiel wird einen Lesevorgang für beide Streams. Es werden die Deadlockbedingung vermieden, indem asynchrone Lesevorgänge auf dem <xref:System.Diagnostics.Process.StandardError%2A> Stream. Eine Deadlock-Bedingung führt, wenn das übergeordnete Element Aufrufe verarbeiten `p.StandardOutput.ReadToEnd` gefolgt von `p.StandardError.ReadToEnd` und der untergeordneten Prozess schreibt genug Text zum Fehlerstreams zu füllen. Der übergeordnete Prozess würde auf unbestimmte Zeit warten, für den untergeordneten Prozess zu schließen die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Der untergeordnete Prozess würde auf unbestimmte Zeit warten, für das übergeordnete Element zum Lesen aus der vollständigen <xref:System.Diagnostics.Process.StandardError%2A> Stream.   
[!code-csharp[Reading from a redirected output and error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]  
[!code-vb[Reading from a redirected output and error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]    
  
 Sie können asynchrone Lesevorgänge verwenden, um diese Abhängigkeiten und deren potenzielle Deadlocks zu vermeiden. Alternativ können Sie die Deadlockbedingung vermeiden, durch das Erstellen von zwei Threads, und Lesen der Ausgabe der einzelnen Datenströme in einem separaten Thread.  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge in einem umgeleiteten Stream nicht mischen. Einmal im umgeleiteten Stream, der eine <xref:System.Diagnostics.Process> wird geöffnet, in asynchronen oder synchronen Modus alle weiteren Lesevorgänge Operationen in diesem Stream muss sich im gleichen Modus. Führen Sie beispielsweise nicht <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> mit einem Aufruf von <xref:System.IO.StreamReader.ReadLine%2A> auf die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream oder umgekehrt. Sie können jedoch zwei verschiedenen Streams in unterschiedlichen Modi lesen. Sie können z. B. Aufrufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> und rufen dann <xref:System.IO.StreamReader.ReadLine%2A> für die <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
   
  
## Examples  
 Im folgende Beispiel wird der ipconfig.exe-Befehl ausgeführt und leitet die standard-Ausgabe in dem Beispiel-Konsolenfenster.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wurde nicht für die Umleitung definiert. Stellen Sie sicher, dass <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> auf <see langword="true" /> und <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> festgelegt ist.  
  
- oder - 
Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wurde für asynchrone Lesevorgänge mit <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> geöffnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet eine Prozessressource und ordnet sie einer <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet die von der <see cref="P:System.Diagnostics.Process.StartInfo" />-Eigenschaft dieser <see cref="T:System.Diagnostics.Process" />-Komponente angegebene Prozessressource (oder verwendet sie erneut) und ordnet diese der Komponente zu.</summary>
        <returns><see langword="true" />, wenn eine Prozessressource gestartet wird. <see langword="false" />, wenn keine neue Prozessressource gestartet wird, sondern z. B. eine vorhandene Prozessressource wiederverwendet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Überladung können Sie eine Prozessressource gestartet, und ordnen Sie es mit dem aktuellen <xref:System.Diagnostics.Process> Komponente. Der Rückgabewert `true` gibt an, dass eine neue Prozessressource gestartet wurde. Wenn die Prozessressource, wird angegeben die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Mitglied der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft bereits auf dem Computer ausgeführt wird, keine zusätzliche Prozessressource gestartet wird. Stattdessen die laufende Prozessressource wiederverwendet und `false` zurückgegeben wird.  
  
 Sie können eine ClickOnce-Anwendung starten, durch die Angabe des Speicherorts (z. B. eine Webadresse), von dem Sie die Anwendung ursprünglich installiert. Starten Sie eine ClickOnce-Anwendung nicht durch Angabe der entsprechenden Speicherort auf Ihrer Festplatte.  
  
> [!NOTE]
>  Bei Verwendung von Visual Studio diese Überladung von der <xref:System.Diagnostics.Process.Start%2A> Methode ist diejenige, die Sie in Ihren Code einfügen, nach dem Ziehen einer <xref:System.Diagnostics.Process> Komponente auf den Designer. Verwenden der `Properties` Fenster zu erweitern die `StartInfo` Kategorie und Schreiben Sie den entsprechenden Wert in der `FileName` Eigenschaft. Ihre Änderungen werden angezeigt, in der Form `InitializeComponent` Verfahren.  
  
 Diese Überladung der <xref:System.Diagnostics.Process.Start%2A> keine `static` Methode. Müssen Sie sie aus einer Instanz von Aufrufen der <xref:System.Diagnostics.Process> Klasse. Vor dem Aufruf <xref:System.Diagnostics.Process.Start%2A>, legen Sie zuerst <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschafteninformationen für diese <xref:System.Diagnostics.Process> -Instanz, da diese Informationen verwendet wird, um zu bestimmen, die Prozessressource gestartet.  
  
 Alle anderen Überladungen der der <xref:System.Diagnostics.Process.Start%2A> Methode `static` Member. Sie müssen nicht zum Erstellen einer Instanz von der <xref:System.Diagnostics.Process> Komponente vor dem Aufruf dieser Überladungen der Methode. Stattdessen rufen Sie <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Klasse selbst und eine neue <xref:System.Diagnostics.Process> Komponente erstellt wird, wenn der Prozess gestartet wurde. Oder, `null` wird zurückgegeben, wenn ein Prozess wiederverwendet wurde. Die Prozessressource wird automatisch zugeordnet ist, mit dem neuen <xref:System.Diagnostics.Process> -Komponente, die von zurückgegeben wird das <xref:System.Diagnostics.Process.Start%2A> Methode.  
  
 Die <xref:System.Diagnostics.Process.StartInfo%2A> Elemente verwendet werden können, wie die Funktionen des die `Run` im Dialogfeld die Windows `Start` Menü. Alle Elemente, die in einer Befehlszeile eingegeben werden können kann gestartet werden, durch Festlegen der entsprechenden Werte der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft. Die einzige <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft, die festgelegt werden muss, ist die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft. Die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft hat keine ausführbare Datei sein. Sie können einen beliebigen Dateityp werden für die die Erweiterung einer Anwendung zugeordnet wurde, die auf dem System installiert ist. Z. B. die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft kann die Erweiterung .txt haben, wenn Sie zugeordnet haben Textdateien in einem Editor wie Editor, oder es die Erweiterung .doc aufweisen kann, wenn Sie einem Textverarbeitungsprogramm wie Microsoft Word DOC-Dateien verfügen.  
  
 In der Befehlszeile können Sie Aktionen an, die für bestimmte Arten von Dateien angeben. Sie können z. B. Drucken von Dokumenten oder Textdateien bearbeiten. Geben Sie diese Aktionen unter Verwendung der <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Mitglied der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft. Sie können für andere Typen von Dateien, Befehlszeilenargumente angeben, wenn Sie die Datei aus starten die `Run` Dialogfeld. Angenommen, Sie können übergeben eine URL als Argument bei Angabe von Ihrem Browser als die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Diese Argumente können angegeben werden, der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Member.  
  
 Wenn Sie eine Pfadvariable in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie diesen Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad befindet, und unter Verwendung von Anführungszeichen hinzugefügt werden: `path = %path%;"c:\mypath"`, müssen Sie alle Prozesse in vollständig qualifizieren `c:\mypath` beim Starten.  
  
> [!NOTE]
>  Der Code für die Seiten- und Steuerelement ASP.NET-Webanwendung wird im Rahmen der Arbeitsprozess von ASP.NET auf dem Webserver ausgeführt.  Bei Verwendung der <xref:System.Diagnostics.Process.Start%2A> -Methode in einer ASP.NET-Webseite oder ein Serversteuerelement, der neue Prozess, die auf dem Webserver mit eingeschränkten Berechtigungen ausgeführt wird. Der Prozess wird im selben Kontext wie der Clientbrowser nicht gestartet, und hat keinen Zugriff auf dem Desktop des Benutzers.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen Sie möglicherweise schließen, oder Sie riskieren den Verlust von Systemressourcen. Schließen Prozesse, die mithilfe von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft.  
  
 Hier ist ein Hinweis zu Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true` in der Prozesskomponente <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, stellen Sie sicher, dass Sie für Ihre Anwendung ein Threadingmodell durch Festlegen des Attributs festgelegt haben `[STAThread]` auf die `main()` Methode. Andernfalls kann ein verwalteter Thread sein, eine `unknown` Zustand, oder fügen Sie in der `MTA` Zustand, wodurch ein Konflikt mit letztere <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> wird `true`. Einige Methoden erfordern, dass der Apartmentzustand nicht `unknown`. Wenn der Status nicht explizit festgelegt wird, wenn die Anwendung eine solche Methode trifft, wird standardmäßig `MTA`, und nach dem Festlegen nicht der Apartmentzustand geändert werden. Allerdings `MTA` löst eine Ausnahme ausgelöst wird, wenn Shell des Betriebssystems auf den Thread verwaltet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von der <xref:System.Diagnostics.Process> Klasse, um einen Prozess zu starten.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In <see cref="P:System.Diagnostics.Process.StartInfo" /> der Komponente <see cref="T:System.Diagnostics.Process" /> wurde kein Dateiname angegeben.
Oder das <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Member der <see cref="P:System.Diagnostics.Process.StartInfo" />-Eigenschaft ist <see langword="true" />, während <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> oder <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> <see langword="true" /> ist.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Methode, die von Betriebssystemen ohne Shellunterstützung wie z.B. Nano Server nicht unterstützt wird (nur .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">Die <see cref="T:System.Diagnostics.ProcessStartInfo" />, die die Informationen zum Starten des Prozesses enthält, einschließlich Dateiname und Befehlszeilenargumente.</param>
        <summary>Startet die Prozessressource, die durch den Parameter mit den Startinformationen für den Prozess angegeben wird (z. B. den Dateinamen des zu startenden Prozesses), und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Überladung können Sie starten eine Prozessressource durch Angeben einer <xref:System.Diagnostics.ProcessStartInfo> Instanz. Die Überladung ordnet die Ressource einer neuen <xref:System.Diagnostics.Process> Objekt.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei zu einer URL ist, wird der Prozess nicht gestartet und `null` zurückgegeben wird.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne vorherige Erstellung eines neuen <xref:System.Diagnostics.Process> Instanz. Mit dieser Überladung mit einer <xref:System.Diagnostics.ProcessStartInfo> Parameter ist eine Alternative zu den einzelnen Schritten beim Erstellen eines neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaften und Aufrufen von <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Mit einem <xref:System.Diagnostics.ProcessStartInfo> -Instanz als Parameter, die Sie aufrufen können <xref:System.Diagnostics.Process.Start%2A> mit die umfassendsten kontrollmöglichkeiten über was an den Aufruf zum Starten des Prozesses übergeben wird. Wenn Sie nur einen Dateinamen oder einen Dateinamen und Argumente übergeben müssen, ist es nicht erforderlich, zum Erstellen eines neuen <xref:System.Diagnostics.ProcessStartInfo> -Instanz, obwohl dies möglich ist. Die einzige <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> Eigenschaft, die festgelegt werden muss, ist die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft. Die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft muss nicht auf die ausführbare Datei darstellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung einer Anwendung zugeordnet wurde, die auf dem System installiert ist. Z. B. die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft kann die Erweiterung .txt haben, wenn Sie zugeordnet haben Textdateien in einem Editor wie Editor, oder es die Erweiterung .doc aufweisen kann, wenn Sie einem Textverarbeitungsprogramm wie Microsoft Word DOC-Dateien verfügen.  
  
 Sie können eine ClickOnce-Anwendung starten, durch die Angabe des Speicherorts (z. B. eine Webadresse), von dem Sie die Anwendung ursprünglich installiert. Starten Sie eine ClickOnce-Anwendung nicht durch Angabe der entsprechenden Speicherort auf Ihrer Festplatte.  
  
 Wenn die <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> und <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> Eigenschaften der <xref:System.Diagnostics.Process.StartInfo%2A> Instanz festgelegt sind, die nicht verwaltete `CreateProcessWithLogonW` Funktion wird aufgerufen, die den Prozess in einem neuen Fenster, selbst wenn startet die <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> Eigenschaftswert ist `true` oder die <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> Eigenschaftswert ist <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Wenn die <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> Eigenschaft `null`, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> -Eigenschaft muss im UPN-Format sein *Benutzer*@*DNS-Domänenname*.   
  
 Im Gegensatz zu anderen Überladungen, die Überladung von <xref:System.Diagnostics.Process.Start%2A> weist keine Parameter auf, die keinem `static` Member. Verwenden Sie diese Überladung, wenn Sie bereits erstellt haben eine <xref:System.Diagnostics.Process> , angegebenen Informationen (einschließlich des Dateinamens), sowie eine Prozessressource gestartet, und ordnen Sie es mit dem vorhandenen möchten <xref:System.Diagnostics.Process> Instanz. Gehen Sie die `static` überlädt, wenn Sie ein neues erstellen möchten <xref:System.Diagnostics.Process> Komponente, anstatt einen Prozess für eine vorhandene Komponente gestartet. Sowohl diese Überladung und die Überladung, die keine Parameter hat können Sie mithilfe der Informationen für der Prozessressource angeben einer <xref:System.Diagnostics.ProcessStartInfo> Instanz.  
  
 Wenn Sie eine Pfadvariable in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie diesen Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad befindet, und unter Verwendung von Anführungszeichen hinzugefügt werden: `path = %path%;"c:\mypath"`, müssen Sie alle Prozesse in vollständig qualifizieren `c:\mypath` beim Starten.  
  
> [!NOTE]
>  Der Code für die Seiten- und Steuerelement ASP.NET-Webanwendung wird im Rahmen der Arbeitsprozess von ASP.NET auf dem Webserver ausgeführt.  Bei Verwendung der <xref:System.Diagnostics.Process.Start%2A> -Methode in einer ASP.NET-Webseite oder ein Serversteuerelement, der neue Prozess, die auf dem Webserver mit eingeschränkten Berechtigungen ausgeführt wird. Der Prozess wird im selben Kontext wie der Clientbrowser nicht gestartet, und hat keinen Zugriff auf dem Desktop des Benutzers.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen Sie möglicherweise schließen, oder Sie riskieren den Verlust von Systemressourcen. Schließen Prozesse, die mithilfe von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft.  
  
 Hier ist ein Hinweis zu Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true` auf die `startInfo` Parameter, stellen Sie sicher, dass Sie für Ihre Anwendung ein Threadingmodell durch Festlegen des Attributs festgelegt haben `[STAThread]` auf die `main()` Methode. Andernfalls kann ein verwalteter Thread sein, eine `unknown` Zustand, oder fügen Sie in der `MTA` Zustand, wodurch ein Konflikt mit letztere <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> wird `true`. Einige Methoden erfordern, dass der Apartmentzustand nicht `unknown`. Wenn der Status nicht explizit festgelegt wird, wenn die Anwendung eine solche Methode trifft, wird standardmäßig `MTA`, und nach dem Festlegen nicht der Apartmentzustand geändert werden. Allerdings `MTA` löst eine Ausnahme ausgelöst wird, wenn Shell des Betriebssystems auf den Thread verwaltet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zunächst eine Instanz von Internet Explorer erstellt und zeigt den Inhalt der Ordner "Favoriten" im Browser. Klicken Sie dann weitere Instanzen von Internet Explorer gestartet, und bestimmte Seiten oder Standorte angezeigt. Schließlich wird die Internet Explorer gestartet, mit dem Fenster, die beim Navigieren zu einem bestimmten Standort minimiert wird.  
  
 Weitere Beispiele von anderen Benutzern dieser Methode finden Sie in die einzelnen Eigenschaften der <xref:System.Diagnostics.ProcessStartInfo> Klasse.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In der <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Eigenschaft des <paramref name="startInfo" />-Parameters wurde kein Dateiname angegeben.  
  
- oder - 
Die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft des <paramref name="startInfo" />-Parameters ist <see langword="true" />, und die <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />-, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />- oder <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />-Eigenschaft ist ebenfalls <see langword="true" />.  
  
- oder - 
Die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft des <paramref name="startInfo" />-Parameters ist <see langword="true" />, und die <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" />-Eigenschaft ist nicht <see langword="null" /> oder leer, oder die <see cref="P:System.Diagnostics.ProcessStartInfo.Password" />-Eigenschaft ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="startInfo" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die in der <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Eigenschaft des <paramref name="startInfo" />-Parameters angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.  
  
 - oder -  
  
 Die Summe aus der Länge der Argumente und der Länge des vollständigen Pfads des Prozesses überschreitet 2080. Die Fehlermeldung dieser Ausnahme kann eine der folgenden sein: „Der an einen Systemaufruf weitergegebene Datenbereich ist zu klein.“ oder "Zugriff verweigert".</exception>
        <exception cref="T:System.PlatformNotSupportedException">Methode, die von Betriebssystemen ohne Shellunterstützung wie z.B. Nano Server nicht unterstützt wird (nur .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name eines Dokuments oder einer Anwendungsdatei, das bzw. die im Prozess ausgeführt werden soll.</param>
        <summary>Startet eine Prozessressource, indem der Name eines Dokuments oder einer Anwendungsdatei angegeben wird, und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Prozessressource durch Angeben des Dateinamens zu starten. Die Überladung ordnet die Ressource einer neuen <xref:System.Diagnostics.Process> Objekt.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei zu einer URL ist, wird der Prozess nicht gestartet und `null` zurückgegeben wird.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne vorherige Erstellung eines neuen <xref:System.Diagnostics.Process> Instanz. Die Überladung ist eine Alternative zu den einzelnen Schritten beim Erstellen eines neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Mitglied der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft und Aufrufen von <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Sie können eine ClickOnce-Anwendung starten, indem die `fileName` Parameter, um den Speicherort (z. B. eine Webadresse), von dem Sie die Anwendung ursprünglich installiert haben. Starten Sie eine ClickOnce-Anwendung nicht durch Angabe der entsprechenden Speicherort auf Ihrer Festplatte.  
  
 Starten eines Prozesses, durch Angeben des Dateinamens ähnelt dem Eingeben der Informationen in den `Run` im Dialogfeld die Windows `Start` Menü. Aus diesem Grund muss der Dateiname nicht ausführbare Datei darstellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung mit einer Anwendung, die auf dem System installierten zugeordnet wurde. Kann z. B. der Dateinamen die Erweiterung .txt aufweisen, wenn Sie zugeordnet haben Textdateien in einem Editor wie Editor, oder es .doc aufweisen kann, wenn Sie einem Textverarbeitungsprogramm wie Microsoft Word DOC-Dateien verfügen. Auf ähnliche Weise, in der gleichen Weise wie die `Run` Dialogfeld akzeptiert den Namen einer ausführbaren Datei mit oder ohne die .exe-Erweiterung, die ".exe"-Erweiterung ist optional, in der `fileName` Parameter. Sie können z. B. Festlegen der `fileName` Parameter auf "Notepad.exe" oder "Notepad".  
  
 Diese Überladung lässt keine Befehlszeilenargumente für den Prozess. Wenn Sie eine oder mehrere Befehlszeilenargumente für den Prozess angeben müssen, verwenden Sie die <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> oder <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> Überladungen.  
  
 Im Gegensatz zu anderen Überladungen, die Überladung von <xref:System.Diagnostics.Process.Start%2A> weist keine Parameter auf, die keinem `static` Member. Verwenden Sie diese Überladung, wenn Sie bereits erstellt haben eine <xref:System.Diagnostics.Process> , angegebenen Informationen (einschließlich des Dateinamens), sowie eine Prozessressource gestartet, und ordnen Sie es mit dem vorhandenen möchten <xref:System.Diagnostics.Process> Instanz. Gehen Sie die `static` überlädt, wenn Sie ein neues erstellen möchten <xref:System.Diagnostics.Process> Komponente, anstatt einen Prozess für eine vorhandene Komponente gestartet. Sowohl diese Überladung der Überladung, die keine Parameter hat können Sie angeben, den Dateinamen der Prozessressource gestartet.  
  
 Wenn Sie eine Pfadvariable in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie diesen Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad befindet, und unter Verwendung von Anführungszeichen hinzugefügt werden: `path = %path%;"c:\mypath"`, müssen Sie alle Prozesse in vollständig qualifizieren `c:\mypath` beim Starten.  
  
> [!NOTE]
>  Der Code für die Seiten- und Steuerelement ASP.NET-Webanwendung wird im Rahmen der Arbeitsprozess von ASP.NET auf dem Webserver ausgeführt.  Bei Verwendung der <xref:System.Diagnostics.Process.Start%2A> -Methode in einer ASP.NET-Webseite oder ein Serversteuerelement, der neue Prozess, die auf dem Webserver mit eingeschränkten Berechtigungen ausgeführt wird. Der Prozess wird im selben Kontext wie der Clientbrowser nicht gestartet, und hat keinen Zugriff auf dem Desktop des Benutzers.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen Sie möglicherweise schließen, oder Sie riskieren den Verlust von Systemressourcen. Schließen Prozesse, die mithilfe von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft.  
  
 Hier ist ein Hinweis zu Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true` in der Prozesskomponente <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, stellen Sie sicher, dass Sie für Ihre Anwendung ein Threadingmodell durch Festlegen des Attributs festgelegt haben `[STAThread]` auf die `main()` Methode. Andernfalls kann ein verwalteter Thread sein, eine `unknown` Zustand, oder fügen Sie in der `MTA` Zustand, wodurch ein Konflikt mit letztere <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> wird `true`. Einige Methoden erfordern, dass der Apartmentzustand nicht `unknown`. Wenn der Status nicht explizit festgelegt wird, wenn die Anwendung eine solche Methode trifft, wird standardmäßig `MTA`, und nach dem Festlegen nicht der Apartmentzustand geändert werden. Allerdings `MTA` löst eine Ausnahme ausgelöst wird, wenn Shell des Betriebssystems auf den Thread verwaltet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zunächst eine Instanz von Internet Explorer erstellt und zeigt den Inhalt der Ordner "Favoriten" im Browser. Klicken Sie dann weitere Instanzen von Internet Explorer gestartet, und bestimmte Seiten oder Standorte angezeigt. Schließlich wird die Internet Explorer gestartet, mit dem Fenster, die beim Navigieren zu einem bestimmten Standort minimiert wird.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die PATH-Umgebungsvariable weist eine Zeichenfolge mit Anführungszeichen auf.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Anwendungsdatei, die in dem Prozess ausgeführt werden soll.</param>
        <param name="arguments">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
        <summary>Startet eine Prozessressource durch Angeben des Namens einer Anwendung und einer Reihe von Befehlszeilenargumenten und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Prozessressource durch Angeben des Dateinamens und Befehlszeilenargumente starten. Die Überladung ordnet die Ressource einer neuen <xref:System.Diagnostics.Process> Objekt.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei zu einer URL ist, wird der Prozess nicht gestartet und `null` zurückgegeben wird.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne vorherige Erstellung eines neuen <xref:System.Diagnostics.Process> Instanz. Die Überladung ist eine Alternative zu den einzelnen Schritten beim Erstellen eines neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> und <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Mitglied der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft und Aufrufen von <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Starten eines Prozesses durch Angabe des Dateinamens und der Argumente ist ähnlich, mit der Eingabe der Dateiname und Befehlszeilenargumente auf der `Run` im Dialogfeld die Windows `Start` Menü. Aus diesem Grund muss der Dateiname nicht ausführbare Datei darstellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung mit einer Anwendung, die auf dem System installierten zugeordnet wurde. Kann z. B. der Dateinamen die Erweiterung .txt aufweisen, wenn Sie zugeordnet haben Textdateien in einem Editor wie Editor, oder es .doc aufweisen kann, wenn Sie einem Textverarbeitungsprogramm wie Microsoft Word DOC-Dateien verfügen. Auf ähnliche Weise, in der gleichen Weise wie die `Run` Dialogfeld akzeptiert den Namen einer ausführbaren Datei mit oder ohne die .exe-Erweiterung, die ".exe"-Erweiterung ist optional, in der `fileName` Parameter. Sie können z. B. Festlegen der `fileName` Parameter auf "Notepad.exe" oder "Notepad". Wenn die `fileName` Parameter darstellt, eine ausführbare Datei, die `arguments` Darstellung Parameters kann eine Datei zu reagieren, wie z. B. die Textdatei in `Notepad.exe myfile.txt`. Wenn die `fileName` Parameter darstellt, eine Befehlsdatei (cmd), die `arguments` muss Parameter enthalten, entweder eine "`/c`"oder"`/k`" Argument, um anzugeben, ob das Befehlsfenster beendet wird, oder bleibt nach dem Abschluss.  
  
 Im Gegensatz zu anderen Überladungen, die Überladung von <xref:System.Diagnostics.Process.Start%2A> weist keine Parameter auf, die keinem `static` Member. Verwenden Sie diese Überladung, wenn Sie bereits erstellt haben eine <xref:System.Diagnostics.Process> , angegebenen Informationen (einschließlich des Dateinamens), sowie eine Prozessressource gestartet, und ordnen Sie es mit dem vorhandenen möchten <xref:System.Diagnostics.Process> Instanz. Gehen Sie die `static` überlädt, wenn Sie ein neues erstellen möchten <xref:System.Diagnostics.Process> Komponente, anstatt einen Prozess für eine vorhandene Komponente gestartet. Sowohl diese Überladung der Überladung, die keine Parameter hat können Sie angeben, den Dateinamen der Prozessressource gestartet und Befehlszeilenargumente übergeben.  
  
 Wenn Sie eine Pfadvariable in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie diesen Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad befindet, und unter Verwendung von Anführungszeichen hinzugefügt werden: `path = %path%;"c:\mypath"`, müssen Sie alle Prozesse in vollständig qualifizieren `c:\mypath` beim Starten.  
  
> [!NOTE]
>  Der Code für die Seiten- und Steuerelement ASP.NET-Webanwendung wird im Rahmen der Arbeitsprozess von ASP.NET auf dem Webserver ausgeführt.  Bei Verwendung der <xref:System.Diagnostics.Process.Start%2A> -Methode in einer ASP.NET-Webseite oder ein Serversteuerelement, der neue Prozess, die auf dem Webserver mit eingeschränkten Berechtigungen ausgeführt wird. Der Prozess wird im selben Kontext wie der Clientbrowser nicht gestartet, und hat keinen Zugriff auf dem Desktop des Benutzers.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen Sie möglicherweise schließen, oder Sie riskieren den Verlust von Systemressourcen. Schließen Prozesse, die mithilfe von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft. 
  
 Hier ist ein Hinweis zu Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true` in der Prozesskomponente <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, stellen Sie sicher, dass Sie für Ihre Anwendung ein Threadingmodell durch Festlegen des Attributs festgelegt haben `[STAThread]` auf die `main()` Methode. Andernfalls kann ein verwalteter Thread sein, eine `unknown` Zustand, oder fügen Sie in der `MTA` Zustand, wodurch ein Konflikt mit letztere <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> wird `true`. Einige Methoden erfordern, dass der Apartmentzustand nicht `unknown`. Wenn der Status nicht explizit festgelegt wird, wenn die Anwendung eine solche Methode trifft, wird standardmäßig `MTA`, und nach dem Festlegen nicht der Apartmentzustand geändert werden. Allerdings `MTA` löst eine Ausnahme ausgelöst wird, wenn Shell des Betriebssystems auf den Thread verwaltet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zunächst eine Instanz von Internet Explorer erstellt und zeigt den Inhalt der Ordner "Favoriten" im Browser. Klicken Sie dann weitere Instanzen von Internet Explorer gestartet, und bestimmte Seiten oder Standorte angezeigt. Schließlich wird die Internet Explorer gestartet, mit dem Fenster, die beim Navigieren zu einem bestimmten Standort minimiert wird.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <paramref name="fileName" />-Parameter oder der <paramref name="arguments" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.  
  
 - oder -  
  
 Die Summe aus der Länge der Argumente und der Länge des vollständigen Pfads des Prozesses überschreitet 2080. Die Fehlermeldung dieser Ausnahme kann eine der folgenden sein: „Der an einen Systemaufruf weitergegebene Datenbereich ist zu klein.“ oder "Zugriff verweigert".</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die PATH-Umgebungsvariable weist eine Zeichenfolge mit Anführungszeichen auf.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="userName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="domain" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Anwendungsdatei, die in dem Prozess ausgeführt werden soll.</param>
        <param name="userName">Der beim Starten des Prozesses zu verwendende Benutzername.</param>
        <param name="password">Eine <see cref="T:System.Security.SecureString" />, die das beim Starten des Prozesses zu verwendende Kennwort enthält.</param>
        <param name="domain">Die Domäne, die beim Starten des Prozesses verwendet werden soll.</param>
        <summary>Startet eine Prozessressource durch Angeben des Namens einer Anwendung, eines Benutzernamens und einer Domäne und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um einen neuen Prozess und des primären Threads zu erstellen, durch Angabe der Dateinamen, Benutzernamen, Kennwort und Domäne. Der neue Prozess wird die angegebene ausführbare Datei im Kontext der angegebenen Anmeldeinformationen (Benutzer, Domäne und Kennwort).  
  
> [!NOTE]
>  Wenn die ausführbare Datei auf einem remote-Laufwerk befindet, müssen Sie die Netzwerkfreigabe ein uniform Resource Identifier (URI), nicht auf einen verknüpften Laufwerkbuchstaben mit identifizieren.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei zu einer URL ist, wird der Prozess nicht gestartet und `null` zurückgegeben wird.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne vorherige Erstellung eines neuen <xref:System.Diagnostics.Process> Instanz. Die Überladung ist eine Alternative zu den einzelnen Schritten beim Erstellen eines neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, und <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> Eigenschaften der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft und Aufrufen von <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Auf ähnliche Weise, in der gleichen Weise wie die **ausführen** im Dialogfeld den Namen einer ausführbaren Datei mit oder ohne die ".exe"-Erweiterung akzeptiert, die ".exe"-Erweiterung ist optional, der `fileName` Parameter. Sie können z. B. Festlegen der `fileName` Parameter auf "Notepad.exe" oder "Notepad". Wenn die `fileName` Parameter darstellt, eine ausführbare Datei, die `arguments` Darstellung Parameters kann eine Datei zu reagieren, wie z. B. die Textdatei in `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Der Dateiname muss eine ausführbare Datei in darstellen der <xref:System.Diagnostics.Process.Start%2A> Überladungen mit `userName`, `password`, und `domain` Parameter.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen Sie möglicherweise schließen, oder Sie riskieren den Verlust von Systemressourcen. Schließen Prozesse, die mithilfe von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft. 
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieser Überladung zum Starten einer ausführbaren Datei und zeigt auch das Auslösen einer <xref:System.ComponentModel.Win32Exception> Wenn es wird versucht zum Starten einer Anwendung, die eine nicht ausführbare Datei zugeordnet ist.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde kein Dateiname angegeben.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Methode, die unter Linux oder macOS nicht unterstützt wird (nur .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arguments" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="userName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="domain" Type="System.String" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Anwendungsdatei, die in dem Prozess ausgeführt werden soll.</param>
        <param name="arguments">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
        <param name="userName">Der beim Starten des Prozesses zu verwendende Benutzername.</param>
        <param name="password">Eine <see cref="T:System.Security.SecureString" />, die das beim Starten des Prozesses zu verwendende Kennwort enthält.</param>
        <param name="domain">Die Domäne, die beim Starten des Prozesses verwendet werden soll.</param>
        <summary>Startet eine Prozessressource durch Angeben des Namens einer Anwendung und einer Reihe von Befehlszeilenargumenten, eines Benutzernamens, eines Kennworts und einer Domäne und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um einen neuen Prozess und des primären Threads zu erstellen, durch Angabe der Dateiname, Befehlszeilenargumente, Benutzername, Kennwort und Domäne. Der neue Prozess wird die angegebene ausführbare Datei im Kontext der angegebenen Anmeldeinformationen (Benutzer, Domäne und Kennwort).  
  
> [!NOTE]
>  Wenn die ausführbare Datei auf einem remote-Laufwerk befindet, müssen Sie die Netzwerkfreigabe ein uniform Resource Identifier (URI), nicht auf einen verknüpften Laufwerkbuchstaben mit identifizieren.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei zu einer URL ist, wird der Prozess nicht gestartet und `null` zurückgegeben wird.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne vorherige Erstellung eines neuen <xref:System.Diagnostics.Process> Instanz. Die Überladung ist eine Alternative zu den einzelnen Schritten beim Erstellen eines neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, und <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> Eigenschaften der <xref:System.Diagnostics.Process.StartInfo%2A> aufrufen und -Eigenschaft <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Auf ähnliche Weise, in der gleichen Weise wie die **ausführen** im Dialogfeld den Namen einer ausführbaren Datei mit oder ohne die ".exe"-Erweiterung akzeptiert, die ".exe"-Erweiterung ist optional, der `fileName` Parameter. Sie können z. B. Festlegen der `fileName` Parameter auf "Notepad.exe" oder "Notepad". Wenn die `fileName` Parameter darstellt, eine ausführbare Datei, die `arguments` Darstellung Parameters kann eine Datei zu reagieren, wie z. B. die Textdatei in `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Der Dateiname muss eine ausführbare Datei in darstellen der <xref:System.Diagnostics.Process.Start%2A> Überladungen mit `userName`, `password`, und `domain` Parameter.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen Sie möglicherweise schließen, oder Sie riskieren den Verlust von Systemressourcen. Schließen Prozesse, die mithilfe von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde kein Dateiname angegeben.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.  
  
 - oder -  
  
 Die Summe aus der Länge der Argumente und der Länge des vollständigen Pfads zur zugehörigen Datei überschreitet 2080. Die Fehlermeldung dieser Ausnahme kann eine der folgenden sein: „Der an einen Systemaufruf weitergegebene Datenbereich ist zu klein.“ oder "Zugriff verweigert".</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Methode, die unter Linux oder macOS nicht unterstützt wird (nur .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Eigenschaften ab, die an die <see cref="M:System.Diagnostics.Process.Start" />-Methode von <see cref="T:System.Diagnostics.Process" /> übergeben werden sollen, oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Diagnostics.ProcessStartInfo" />, die die Daten darstellt, mit denen der Prozess gestartet werden soll. Diese Argumente beinhalten den Namen der ausführbaren Datei oder des Dokuments, das zum Starten des Prozesses verwendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> Stellt den Satz von Parametern zu verwenden, um einen Prozess zu starten. Wenn <xref:System.Diagnostics.Process.Start%2A> aufgerufen wird, die <xref:System.Diagnostics.Process.StartInfo%2A> wird verwendet, um den zu startenden Prozess angeben. Nur erforderliche <xref:System.Diagnostics.Process.StartInfo%2A> Member, der festgelegt wird. die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft. Starten eines Prozesses durch Angabe der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft ähnelt dem Eingeben der Informationen in den **ausführen** im Dialogfeld die Windows **starten** Menü. Aus diesem Grund die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft muss nicht auf die ausführbare Datei darstellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung mit einer Anwendung, die auf dem System installierten zugeordnet wurde. Zum Beispiel die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Erweiterung .txt haben können, wenn Sie zugeordnet haben Textdateien in einem Editor wie Editor, oder es .doc aufweisen kann, wenn Sie einem Textverarbeitungsprogramm wie Microsoft Word DOC-Dateien verfügen. Auf ähnliche Weise, in der gleichen Weise wie die **ausführen** im Dialogfeld den Namen einer ausführbaren Datei mit oder ohne die ".exe"-Erweiterung akzeptiert, die ".exe"-Erweiterung ist optional, der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Member. Sie können z. B. Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft auf "Notepad.exe" oder "Notepad".  
  
 Sie können eine ClickOnce-Anwendung starten, indem die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft, um den Speicherort (z. B. eine Webadresse), von dem Sie die Anwendung ursprünglich installiert haben. Starten Sie eine ClickOnce-Anwendung nicht durch Angabe der entsprechenden Speicherort auf Ihrer Festplatte.  
  
 Wenn der Dateiname eine nicht ausführbare Datei, z. B. eine DOC-Datei umfasst, können Sie ein Verb an, welche Aktion für die Datei angeben einschließen. Sie können z. B. Festlegen der <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> "Print" für eine Datei mit der Erweiterung .doc. Die Datei im angegebenen Namen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft muss nicht Erweiterung erforderlich, wenn Sie manuell einen Wert für die <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Eigenschaft. Allerdings bei Verwendung der <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> Eigenschaft, um zu bestimmen, welche Verben zur Verfügung stehen, müssen Sie die Erweiterung einschließen.  
  
 Sie können ändern, dass die angegebenen Parameter die <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft bis zu dem Zeitpunkt, die Sie Aufrufen der <xref:System.Diagnostics.Process.Start%2A> Methode für den Prozess. Nachdem der Prozess gestartet wurde, Ändern der <xref:System.Diagnostics.Process.StartInfo%2A> Werte nicht beeinträchtigen oder starten Sie den zugeordneten Prozess. Aufrufen der <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> -Methode mit der <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> und <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> festgelegten Eigenschaften, die nicht verwaltete `CreateProcessWithLogonW` Funktion wird aufgerufen, die den Prozess in einem neuen Fenster, selbst wenn startet die <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> Eigenschaftswert ist `true` oder die <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> Eigenschaftswert ist <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Sie sollten nur Zugriff auf die <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft für eine <xref:System.Diagnostics.Process> zurückgegebenes Objekt der <xref:System.Diagnostics.Process.Start%2A> Methode. Beispielsweise sollten Sie nicht zugreifen der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft für eine <xref:System.Diagnostics.Process> zurückgegebenes Objekt <xref:System.Diagnostics.Process.GetProcesses%2A>. In .NET Core, andernfalls die <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft löst eine <xref:System.InvalidOperationException> und auf .NET Framework gibt es ein Dummy <xref:System.Diagnostics.ProcessStartInfo> Objekt.
  
 Wenn der Prozess gestartet wird, wird der Dateiname ist die Datei, die die (schreibgeschützte) füllt <xref:System.Diagnostics.Process.MainModule%2A> Eigenschaft. Wenn Sie verwenden möchten, rufen Sie die ausführbare Datei, die dem Prozess zugeordnet ist, nachdem der Prozess gestartet wurde, verwenden Sie die <xref:System.Diagnostics.Process.MainModule%2A> Eigenschaft. Wenn Sie die ausführbare Datei der festlegen möchten eine <xref:System.Diagnostics.Process> Instanz, für die ein zugeordnete Prozess nicht gestartet wurde, verwenden Sie die <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Member. Da die Elemente der der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft sind Argumente, die übergeben werden, die <xref:System.Diagnostics.Process.Start%2A> Methode eines Prozesses ändern der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> -Eigenschaft nach Beginn der zugeordnete Prozess gestartet wurde, werden nicht zurückgesetzt. die <xref:System.Diagnostics.Process.MainModule%2A> Eigenschaft. Diese Eigenschaften werden nur zum Initialisieren von des zugeordneten Prozess verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel füllt ein <xref:System.Diagnostics.Process.StartInfo%2A> mit der Datei zum Ausführen die Aktion ausgeführt wird, und gibt an, ob er es sollte eine Benutzeroberfläche angezeigt. Weitere Beispiele finden Sie auf den Referenzseiten für Eigenschaften der <xref:System.Diagnostics.ProcessStartInfo> Klasse.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert, der die <see cref="P:System.Diagnostics.Process.StartInfo" /> angibt, ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Diagnostics.Process.Start" />-Methode wurde nicht verwendet, um den Prozess zu starten.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeit ab, zu der der zugeordnete Prozess gestartet wurde.</summary>
        <value>Ein Objekt, das angibt, wann der zugeordnete Prozess gestartet wurde. Eine Ausnahme wird ausgelöst, wenn der Prozess nicht ausgeführt wird.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.StartTime" /> -Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde beendet.  
  
 - oder -  
  
 Der Prozess wurde nicht gestartet.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Aufruf der Windows-Funktion ist ein Fehler aufgetreten.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das zum Marshallen der Ereignishandleraufrufe verwendet wird, die als Ergebnis eines Prozessbeendigungsereignisses ausgegeben werden, oder legt dieses fest.</summary>
        <value>Das <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, das zum Marshallen von Ereignishandleraufrufen verwendet wird, die als Ergebnis eines <see cref="E:System.Diagnostics.Process.Exited" />-Ereignisses des Prozesses ausgegeben werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> ist `null`, Methoden, verarbeiten die <xref:System.Diagnostics.Process.Exited> Ereignis auf einem Thread vom Threadpool Systems aufgerufen werden. Weitere Informationen zu System Threadpools, finden Sie unter <xref:System.Threading.ThreadPool>.  
  
 Wenn die <xref:System.Diagnostics.Process.Exited> Ereignis erfolgt durch einen visuellen Windows Forms-Komponente, z. B. eine <xref:System.Windows.Forms.Button>, Zugriff auf die Komponente über den systemthreadpool funktionieren möglicherweise nicht oder möglicherweise wird eine Ausnahme ausgelöst. Vermeiden Sie dies durch Festlegen von <xref:System.Diagnostics.Process.SynchronizingObject%2A> an eine Windows Forms-Komponente, wodurch die Methoden zur Behandlung der <xref:System.Diagnostics.Process.Exited> Ereignis, um auf dem gleichen Thread aufgerufen werden, auf dem die Komponente erstellt wurde.  
  
 Wenn die <xref:System.Diagnostics.Process> dient in [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in einem Windows Forms-Designer <xref:System.Diagnostics.Process.SynchronizingObject%2A> wird automatisch festgelegt, um das Steuerelement, enthält die <xref:System.Diagnostics.Process>. Wenn Sie platzieren z. B. eine <xref:System.Diagnostics.Process> in einem Designer für `Form1` (erbt von <xref:System.Windows.Forms.Form>) die <xref:System.Diagnostics.Process.SynchronizingObject%2A> Eigenschaft <xref:System.Diagnostics.Process> festgelegt ist, mit der Instanz von `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 In der Regel wird diese Eigenschaft festgelegt, wenn die Komponente in ein Steuerelement oder Formular platziert wird, da diese Komponenten für einen bestimmten Thread gebunden sind.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gruppe von Threads ab, die im zugeordneten Prozess ausgeführt werden.</summary>
        <value>Ein Array vom Typ <see cref="T:System.Diagnostics.ProcessThread" />, das die Threads des Betriebssystems darstellt, die gegenwärtig im zugeordneten Prozess ausgeführt werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread führt Code in einem Prozess aus. Jeder Prozess wird mit einem einzelnen Thread, der primäre Thread gestartet. Jeder Thread kann zusätzliche Threads generieren. Threads innerhalb eines Prozesses freigeben den Adressraum des Prozesses.  
  
 Verwendung <xref:System.Diagnostics.ProcessThread> zum Abrufen aller Threads, die den aktuellen Prozess zugeordnet. Der primäre Thread ist nicht unbedingt am Index 0 (null) im Array.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Für den Prozess ist kein <see cref="P:System.Diagnostics.Process.Id" /> vorhanden, oder der <see cref="T:System.Diagnostics.Process" />-Instanz ist kein Prozess zugeordnet.  
  
- oder - 
Der zugeordnete Prozess wurde beendet.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me). Legen Sie <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> fest, um unter Windows 98 und Windows Me auf diese Eigenschaft zuzugreifen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Formatiert den Prozessnamen als Zeichenfolge, ggf. kombiniert mit dem Typ der übergeordneten Komponente.</summary>
        <returns>Der <see cref="P:System.Diagnostics.Process.ProcessName" /> kombiniert mit dem <see cref="M:System.Object.ToString" />-Rückgabewert der Basiskomponente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="M:System.Diagnostics.Process.ToString" /> wird unter Windows 98 nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamte Prozessorzeit für diesen Prozess ab.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, während der der zugeordnete Prozess die CPU verwendet hat. Dieser Wert ist die Summe von <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> und <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> -Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Benutzerprozessorzeit für diesen Prozess ab.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, während der der zugeordnete Prozess Code innerhalb der Anwendung des Prozesses (nicht im Betriebssystemkern) ausgeführt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> -Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des virtuellen Speichers für diesen Prozess in Bytes ab.</summary>
        <value>Die virtuelle Speicher in Bytes, der vom zugehörigen Prozess angefordert wurde.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des virtuellen Speichers, der für den zugeordneten Prozess belegt wird, in Bytes ab.</summary>
        <value>Die Größe des virtuellen Speichers in Bytes, der für den zugeordneten Prozess belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des virtuellen Speichers ein, die den Prozess in Bytes dar. Das Betriebssystem ordnet den virtuellen Adressraum für jeden Prozess, der entweder Seiten im physischen Speicher zu Seiten, die in der Auslagerungsdatei des virtuellen Speichers auf dem Datenträger gespeichert oder geladen.  
  
 Diese Eigenschaft kann zur Überwachung der speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Den Wert der Eigenschaft entspricht der **virtuelle Bytes** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und zeigt die beenden-Code und Spitzenwerte Arbeitsspeicherstatistik.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt die Zeitspanne für das Warten auf die Beendigung des zugeordneten Prozesses fest und blockiert den aktuellen Ausführungsthread, bis die Zeit verstrichen oder der Prozess beendet ist. Verwenden Sie das Ereignis <see cref="E:System.Diagnostics.Process.Exited" />, um ein Blockieren des aktuellen Threads zu verhindern.  
  
Codebeispiele finden Sie auf den Referenzseiten zu den Eigenschaften <see cref="P:System.Diagnostics.Process.StandardError" /> und <see cref="P:System.Diagnostics.Process.ExitCode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Weist die <see cref="T:System.Diagnostics.Process" />-Komponente an, unbestimmte Zeit zu warten, bis der zugeordnete Prozess beendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> wird den aktuellen Thread wartet, bis der zugeordnete Prozess beendet wird.  Es sollte aufgerufen werden, nachdem alle anderen Methoden für den Prozess aufgerufen werden. Verwenden Sie das Ereignis <xref:System.Diagnostics.Process.Exited>, um ein Blockieren des aktuellen Threads zu verhindern.  
  
 Diese Methode weist die <xref:System.Diagnostics.Process> -Komponente wartet, bis eine unbegrenzte Zeitspanne für die Prozess- und Ereignis-Handler zu beenden. Dadurch kann eine Anwendung nicht mehr reagiert. Wenn Sie aufrufen, z. B. <xref:System.Diagnostics.Process.CloseMainWindow%2A> für einen Prozess, der über eine Benutzeroberfläche verfügt, die Anforderung an das Betriebssystem zum Beenden des zugeordneten Prozesses kann nicht behandelt werden, wenn der Prozess geschrieben wird, nie eine Meldungsschleife eingeben.  
  
> [!NOTE]
>  In der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] und früheren Versionen der <xref:System.Diagnostics.Process.WaitForExit> Überladung gewartet <xref:System.Int32.MaxValue> Millisekunden (ca. 24 Tage) nicht unbegrenzt. Frühere Versionen darüber hinaus nicht warten, für die Ereignishandler, wenn der Agent beendet die vollständige <xref:System.Int32.MaxValue> Uhrzeit wurde erreicht.  
  
 Diese Überladung wird sichergestellt, dass die gesamte Verarbeitung abgeschlossen wurde, einschließlich der Verarbeitung von asynchronen Ereignissen für die umgeleiteten Standardausgabe. Sie sollten diese Überladung verwenden, nach einem Aufruf der <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> Überladung, wenn die standard-Ausgabedatenstrom an asynchrone Ereignishandler umgeleitet wurde.  
  
 Wenn ein zugeordnete Prozess beendet wird (d. h., wenn er durch das Betriebssystem über eine ungewöhnliche oder nicht ordnungsgemäß beendet heruntergefahren ist), speichert das System administrative Informationen über den Prozess und gibt Sie zurück an die Komponente, die aufgerufen hat <xref:System.Diagnostics.Process.WaitForExit>. Die <xref:System.Diagnostics.Process> Komponente stehen dann die Informationen, einschließlich der <xref:System.Diagnostics.Process.ExitTime%2A>, mithilfe der <xref:System.Diagnostics.Process.Handle%2A> für den beendeten Prozess.  
  
 Da der zugeordnete Prozess beendet wurde, die <xref:System.Diagnostics.Process.Handle%2A> -Eigenschaft der Komponente wird nicht mehr auf eine vorhandene Prozessressource verweist. Das Handle kann stattdessen verwendet werden, nur des Betriebssystems Zugriff auf Informationen über die Prozessressource. Das System ist das Vorhandensein von Handles für beendete Prozesse, die nicht, indem freigegeben wurden <xref:System.Diagnostics.Process> Komponenten, sodass er hält die <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.Handle%2A> Informationen im Arbeitsspeicher, bis die <xref:System.Diagnostics.Process> Komponente insbesondere Gibt Ressourcen frei. Aus diesem Grund bei jedem Aufrufen <xref:System.Diagnostics.Process.Start%2A> für eine <xref:System.Diagnostics.Process> Instanz ist, rufen Sie <xref:System.Diagnostics.Process.Close%2A> wann der zugeordnete Prozess beendet wurde und Sie die entsprechenden administrativen Informationen nicht mehr benötigen. <xref:System.Diagnostics.Process.Close%2A> Gibt den für den beendeten Prozess belegten Arbeitsspeicher frei.  
  
   
  
## Examples  
 Finden Sie im Abschnitt "Hinweise" der <xref:System.Diagnostics.Process.StandardError%2A> Eigenschaft-Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Auf die Wait-Einstellung konnte nicht zugegriffen werden.</exception>
        <exception cref="T:System.SystemException">Es wurde kein Prozess <see cref="P:System.Diagnostics.Process.Id" /> festgelegt, und ein <see cref="P:System.Diagnostics.Process.Handle" />, aus dem die <see cref="P:System.Diagnostics.Process.Id" />-Eigenschaft bestimmt werden kann, ist nicht vorhanden.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" /> -Objekt ist kein Prozess zugeordnet.  
  
- oder - 
Sie versuchen, <see cref="M:System.Diagnostics.Process.WaitForExit" /> für einen Prozess aufzurufen, der auf einem Remotecomputer ausgeführt wird. Diese Methode ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Die Zeitspanne in Millisekunden, die auf die Beendigung des zugeordneten Prozesses gewartet werden soll. Der Höchstwert ist der größtmögliche Wert einer 32-Bit-Ganzzahl, der für das Betriebssystem unendlich bedeutet.</param>
        <summary>Weist die <see cref="T:System.Diagnostics.Process" />-Komponente an, für die Dauer von angegebenen Millisekunden zu warten, bis der zugeordnete Prozess beendet wird.</summary>
        <returns><see langword="true" />, wenn der zugeordnete Prozess beendet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> wird den aktuellen Thread wartet, bis der zugeordnete Prozess beendet wird. Es sollte aufgerufen werden, nachdem alle anderen Methoden für den Prozess aufgerufen werden. Verwenden Sie das Ereignis <xref:System.Diagnostics.Process.Exited>, um ein Blockieren des aktuellen Threads zu verhindern.  
  
 Diese Methode weist die <xref:System.Diagnostics.Process> -Komponente wartet, bis eine gewisse Zeit für den Prozess zu beenden. Wenn der zugeordnete Prozess nicht am Ende des Intervalls beendet wird, da die Anforderung zum Beenden verweigert wird, `false` an die aufrufende Prozedur zurückgegeben wird. Sie können angeben, <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für `milliseconds`, und <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> Verhalten sich identisch zu den <xref:System.Diagnostics.Process.WaitForExit> überladen. Wenn Sie 0 (null) an die Methode übergeben, gibt es `true` nur dann, wenn der Prozess bereits beendet wurde; andernfalls wird sofort zurückgegeben `false`.  
  
> [!NOTE]
>  In der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] und frühere Versionen, wenn `milliseconds` -1 ist, wurde die <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> Überladung gewartet <xref:System.Int32.MaxValue> Millisekunden (ca. 24 Tage) nicht unbegrenzt.  
  
 Standardausgabe an asynchrone Ereignishandler umgeleitet wurde, ist es möglich, dass die Verarbeitung der Ausgabe wird nicht abgeschlossen haben, wenn diese Methode zurückgegeben. Um sicherzustellen, dass die asynchrone Ereignisverarbeitung abgeschlossen wurde, rufen die <xref:System.Diagnostics.Process.WaitForExit> Überladung, die keine Parameter, nachdem annimmt eine `true` von dieser Überladung. Um sicherzustellen, dass die <xref:System.Diagnostics.Process.Exited> Ereignis wird in Windows Forms-Anwendungen ordnungsgemäß verarbeitet, legen Sie die <xref:System.Diagnostics.Process.SynchronizingObject%2A> Eigenschaft.  
  
 Wenn ein zugeordnete Prozess beendet wird (heruntergefahren durch das Betriebssystem über eine ungewöhnliche oder nicht ordnungsgemäß beendet), das System speichert administrative Informationen über den Prozess und gibt Sie zurück an die Komponente, die aufgerufen hat <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. Die <xref:System.Diagnostics.Process> Komponente stehen dann die Informationen, einschließlich der <xref:System.Diagnostics.Process.ExitTime%2A>, mithilfe der <xref:System.Diagnostics.Process.Handle%2A> für den beendeten Prozess.  
  
 Da der zugeordnete Prozess beendet wurde, die <xref:System.Diagnostics.Process.Handle%2A> -Eigenschaft der Komponente wird nicht mehr auf eine vorhandene Prozessressource verweist. Das Handle kann stattdessen verwendet werden, nur des Betriebssystems Zugriff auf Informationen über die Prozessressource. Das System ist das Vorhandensein von Handles für beendete Prozesse, die nicht, indem freigegeben wurden <xref:System.Diagnostics.Process> Komponenten, sodass er hält die <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.Handle%2A> Informationen im Arbeitsspeicher, bis die <xref:System.Diagnostics.Process> Komponente insbesondere Gibt Ressourcen frei. Aus diesem Grund bei jedem Aufrufen <xref:System.Diagnostics.Process.Start%2A> für eine <xref:System.Diagnostics.Process> Instanz ist, rufen Sie <xref:System.Diagnostics.Process.Close%2A> wann der zugeordnete Prozess beendet wurde und Sie die entsprechenden administrativen Informationen nicht mehr benötigen. <xref:System.Diagnostics.Process.Close%2A> Gibt den für den beendeten Prozess belegten Arbeitsspeicher frei.  
  
   
  
## Examples  
 Finden Sie im Codebeispiel für die <xref:System.Diagnostics.Process.ExitCode%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Auf die Wait-Einstellung konnte nicht zugegriffen werden.</exception>
        <exception cref="T:System.SystemException">Es wurde kein Prozess <see cref="P:System.Diagnostics.Process.Id" /> festgelegt, und ein <see cref="P:System.Diagnostics.Process.Handle" />, aus dem die <see cref="P:System.Diagnostics.Process.Id" />-Eigenschaft bestimmt werden kann, ist nicht vorhanden.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" /> -Objekt ist kein Prozess zugeordnet.  
  
- oder - 
Sie versuchen, <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> für einen Prozess aufzurufen, der auf einem Remotecomputer ausgeführt wird. Diese Methode ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="milliseconds" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bewirkt, dass die <see cref="T:System.Diagnostics.Process" />-Komponente wartet, bis der zugeordnete Prozess in den Leerlauf wechselt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass die <see cref="T:System.Diagnostics.Process" />-Komponente unbegrenzt wartet, bis der zugeordnete Prozess in den Leerlauf wechselt. Diese Überladung ist nur für Prozesse mit einer Benutzeroberfläche und einer Nachrichtenschleife gültig.</summary>
        <returns><see langword="true" />, wenn der zugehörige Prozess in den Leerlauf wechselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Diagnostics.Process.WaitForInputIdle> zu erzwingen, dass die Verarbeitung Ihrer Anwendung warten, bis die Nachrichtenschleife in den Leerlauf zurückgegeben hat. Wenn ein Prozess mit einer Benutzeroberfläche ausgeführt wird, führt eine Meldungsschleife jedes Mal, wenn eine Windows-Nachricht an den Prozess durch das Betriebssystem gesendet wird. Gibt zurück, klicken Sie dann der Prozess in der Nachrichtenschleife. Ein Prozess wird als im Leerlauf sein, wenn sie Nachrichten innerhalb einer Nachrichtenschleife wartet bezeichnet. Dieser Status ist beispielsweise nützlich, wenn Ihre Anwendung für einen Prozess ab, um den Vorgang abzuschließen, erstellen das Hauptfenster aus, bevor die Anwendung mit diesem Fenster kommuniziert warten muss.  
  
 Wenn ein Prozess nicht über eine Nachrichtenschleife verfügt <xref:System.Diagnostics.Process.WaitForInputIdle> löst eine <xref:System.InvalidOperationException>.  
  
 Die <xref:System.Diagnostics.Process.WaitForInputIdle> Überladung weist das <xref:System.Diagnostics.Process> Komponente, um unbegrenzt zu warten, bis der Prozess in die Meldungsschleife im Leerlauf. Diese Anweisung kann dazu führen, dass eine Anwendung nicht mehr reagiert. Z. B. wenn der Prozess immer geschrieben wird die Meldungsschleife unmittelbar beendet, wie das Codefragment `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Prozess verfügt nicht über eine grafische Benutzeroberfläche.  
  
- oder - 
Es ist ein unbekannter Fehler aufgetreten. Der Prozess konnte nicht in den Leerlauf wechseln.  
  
- oder - 
Der Prozess wurde bereits beendet.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Der Wert 1 für <see cref="F:System.Int32.MaxValue" />, der die Zeitspanne in Millisekunden angibt, die gewartet werden soll, bis sich der zugehörige Prozess im Leerlauf befindet. Der Wert 0 gibt eine sofortige Rückgabe an, der Wert -1 gibt eine unendliche Wartezeit an.</param>
        <summary>Bewirkt, dass die <see cref="T:System.Diagnostics.Process" />-Komponente die Dauer von angegebenen Millisekunden wartet, bis der zugeordnete Prozess in den Leerlauf wechselt. Diese Überladung ist nur für Prozesse mit einer Benutzeroberfläche und einer Nachrichtenschleife gültig.</summary>
        <returns><see langword="true" />, wenn der zugeordnete Prozess in den Leerlauf wechselt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> zu erzwingen, dass die Verarbeitung Ihrer Anwendung warten, bis die Nachrichtenschleife in den Leerlauf zurückgegeben hat. Wenn ein Prozess mit einer Benutzeroberfläche ausgeführt wird, führt eine Meldungsschleife jedes Mal, wenn eine Windows-Nachricht an den Prozess durch das Betriebssystem gesendet wird. Gibt zurück, klicken Sie dann der Prozess in der Nachrichtenschleife. Ein Prozess wird als im Leerlauf sein, wenn sie Nachrichten innerhalb einer Nachrichtenschleife wartet bezeichnet. Dieser Status ist beispielsweise nützlich, wenn Ihre Anwendung für einen Prozess ab, um den Vorgang abzuschließen, erstellen das Hauptfenster aus, bevor die Anwendung mit diesem Fenster kommuniziert warten muss.  
  
 Wenn ein Prozess nicht über eine Nachrichtenschleife verfügt <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> löst eine <xref:System.InvalidOperationException>.  
  
 Die <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> Überladung weist das <xref:System.Diagnostics.Process> -Komponente wartet, bis eine gewisse Zeit für den Prozess, in die Meldungsschleife im Leerlauf. Wenn der zugeordnete Prozess nicht am Ende des Intervalls im Leerlauf befindet, da die Schleife, Verarbeitung von Nachrichten ist `false` an die aufrufende Prozedur zurückgegeben wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Prozess verfügt nicht über eine grafische Benutzeroberfläche.  
  
- oder - 
Es ist ein unbekannter Fehler aufgetreten. Der Prozess konnte nicht in den Leerlauf wechseln.  
  
- oder - 
Der Prozess wurde bereits beendet.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Belegung des physischen Speichers durch den zugeordneten Prozess in Bytes ab.</summary>
        <value>Der Gesamtgröße des vom zugeordneten Prozess verwendeten physischen Speichers in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe der Menge Arbeitsspeicher verwendet, durch den Prozess in Bytes dar. Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die derzeit sichtbar ist, an den Prozess physischen RAM-Speicher. Diese Seiten sind resident und verfügbar für eine Anwendung verwenden, ohne einen Seitenfehler auslösen.  
  
 Der Arbeitssatz enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die allen Anweisungen, die der Prozess ausgeführt wird enthalten, einschließlich der Prozess-Module und der Systembibliotheken.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des physischen Speichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Die Größe des physischen Speichers in Bytes, der für den zugeordneten Prozess belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe der Menge Arbeitsspeicher verwendet, durch den Prozess in Bytes dar. Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die derzeit sichtbar ist, an den Prozess physischen RAM-Speicher. Diese Seiten sind resident und verfügbar für eine Anwendung verwenden, ohne einen Seitenfehler auslösen.  
  
 Der Arbeitssatz enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die allen Anweisungen, die der Prozess ausgeführt wird enthalten, einschließlich der Anweisungen in die Prozess-Module und der Systembibliotheken.  
  
 Diese Eigenschaft kann zur Überwachung der speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Den Wert der Eigenschaft entspricht der **Arbeitsseite** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird dann abgerufen, und zeigt die verschiedenen Eigenschaften des zugeordneten Prozesses. Im Beispiel erkennt, wenn der Prozess beendet wird, und zeigt die beenden-Code und Spitzenwerte Arbeitsspeicherstatistik.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Plattform ist Windows 98 oder Windows Millennium Edition (Windows Me), die diese Eigenschaft nicht unterstützt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>