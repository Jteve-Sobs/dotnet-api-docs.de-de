<Type Name="Debugger" FullName="System.Diagnostics.Debugger">
  <TypeSignature Language="C#" Value="public sealed class Debugger" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Debugger extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Debugger" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Debugger" />
  <TypeSignature Language="C++ CLI" Value="public ref class Debugger sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Debug</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="b6034-101">Ermöglicht die Kommunikation mit einem Debugger.</span><span class="sxs-lookup"><span data-stu-id="b6034-101">Enables communication with a debugger.</span></span> <span data-ttu-id="b6034-102">Diese Klasse kann nicht vererbt werden.</span><span class="sxs-lookup"><span data-stu-id="b6034-102">This class cannot be inherited.</span></span></summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Debugger ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debugger.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Debugger();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Call the static methods directly on this type", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b6034-103">Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.Debugger" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="b6034-103">Initializes a new instance of the <see cref="T:System.Diagnostics.Debugger" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static void Break ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Break() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debugger.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Break ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Break();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b6034-104">Signalisiert einem angefügten Debugger einen Haltepunkt.</span><span class="sxs-lookup"><span data-stu-id="b6034-104">Signals a breakpoint to an attached debugger.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6034-105">Wenn kein Debugger angefügt ist, werden Benutzer gefragt, ob sie einen Debugger anfügen möchten.</span><span class="sxs-lookup"><span data-stu-id="b6034-105">If no debugger is attached, users are asked if they want to attach a debugger.</span></span> <span data-ttu-id="b6034-106">Wenn Benutzer mit Ja antworten, wird der Debugger gestartet.</span><span class="sxs-lookup"><span data-stu-id="b6034-106">If users say yes, the debugger is started.</span></span> <span data-ttu-id="b6034-107">Wenn ein Debugger angefügt ist, der Debugger mit einem Haltepunkt Benutzerereignis signalisiert wird, und der Debugger unterbricht die Ausführung des Prozesses, als ob ein debuggerhaltepunkt erreicht wurde, hatte.</span><span class="sxs-lookup"><span data-stu-id="b6034-107">If a debugger is attached, the debugger is signaled with a user breakpoint event, and the debugger suspends execution of the process just as if a debugger breakpoint had been hit.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="b6034-108">Beginnend mit [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], die Common Language Runtime führt nicht mehr strikte Kontrolle des Debuggers für die <xref:System.Diagnostics.Debugger.Break%2A> -Methode, aber stattdessen meldet einen Fehler im Windows Error Reporting (WER)-Subsystem.</span><span class="sxs-lookup"><span data-stu-id="b6034-108">Starting with [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the runtime no longer exercises tight control of launching the debugger for the <xref:System.Diagnostics.Debugger.Break%2A> method, but instead reports an error to the Windows Error Reporting (WER) subsystem.</span></span> <span data-ttu-id="b6034-109">WER bietet viele Einstellungen zum Anpassen des Problems reporting zu nutzen, damit die Art der viele Faktoren beeinflussen kann, WER auf einen Fehler wie z. B. die Version des Betriebssystems, Prozess, Session, Benutzer, Computer und Domäne reagiert.</span><span class="sxs-lookup"><span data-stu-id="b6034-109">WER provides many settings to customize the problem reporting experience, so a lot of factors will influence  the way WER responds to an error such as operating system version, process, session, user, machine and domain.</span></span> <span data-ttu-id="b6034-110">Wenn Sie Problembehandlungstool unerwartete Ergebnisse, die beim Aufrufen der <xref:System.Diagnostics.Debugger.Break%2A> -Methode, überprüfen Sie die WER-Einstellungen auf Ihrem Computer.</span><span class="sxs-lookup"><span data-stu-id="b6034-110">If you're having unexpected results when calling  the <xref:System.Diagnostics.Debugger.Break%2A> method,  check the  WER settings on your machine.</span></span> <span data-ttu-id="b6034-111">Weitere Informationen zum Anpassen von WER finden Sie unter [WER Settings](https://msdn.microsoft.com/library/windows/desktop/bb513638.aspx).</span><span class="sxs-lookup"><span data-stu-id="b6034-111">For more information on how to customize WER, see [WER Settings](https://msdn.microsoft.com/library/windows/desktop/bb513638.aspx).</span></span> <span data-ttu-id="b6034-112">Wenn Sie möchten, um sicherzustellen, dass der Debugger wird gestartet, unabhängig von den WER-Einstellungen, achten Sie darauf, rufen Sie die <xref:System.Diagnostics.Debugger.Launch%2A> Methode stattdessen.</span><span class="sxs-lookup"><span data-stu-id="b6034-112">If you want to ensure the debugger is launched regardless of the WER settings, be sure to call the <xref:System.Diagnostics.Debugger.Launch%2A> method instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b6034-113">Im folgenden Codebeispiel wird veranschaulicht, wie den Debugger beim Aufruf beendet <xref:System.Console.WriteLine%2A>.</span><span class="sxs-lookup"><span data-stu-id="b6034-113">The following code example demonstrates how to stop the debugger at the call to <xref:System.Console.WriteLine%2A>.</span></span>  
  
```vb  
Debugger.Break()  
Console.WriteLine("Hello, world.")  
```  
  
```csharp  
Debugger.Break();  
Console.WriteLine("Hello, world.");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b6034-114">Die <see cref="T:System.Security.Permissions.UIPermission" /> ist nicht so festgelegt, dass der Debugger unterbrochen wird.</span><span class="sxs-lookup"><span data-stu-id="b6034-114">The <see cref="T:System.Security.Permissions.UIPermission" /> is not set to break into the debugger.</span></span></exception>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="b6034-115">für die Berechtigung zum Starten von eines Debuggers.</span><span class="sxs-lookup"><span data-stu-id="b6034-115">for permission to start a debugger.</span></span> <span data-ttu-id="b6034-116">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="b6034-116">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="b6034-117">für den Betrieb mit nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="b6034-117">for operating with unmanaged code.</span></span> <span data-ttu-id="b6034-118">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="b6034-118">Associated enumeration:  <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefaultCategory">
      <MemberSignature Language="C#" Value="public static readonly string DefaultCategory;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string DefaultCategory" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.Debugger.DefaultCategory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultCategory As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ DefaultCategory;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b6034-119">Stellt die Standardkategorie einer Nachricht mit einer Konstanten dar.</span><span class="sxs-lookup"><span data-stu-id="b6034-119">Represents the default category of message with a constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6034-120">Der Wert dieser Standard-Konstante ist `null`.</span><span class="sxs-lookup"><span data-stu-id="b6034-120">The value of this default constant is `null`.</span></span> <span data-ttu-id="b6034-121"><xref:System.Diagnostics.Debugger.DefaultCategory> wird von <xref:System.Diagnostics.Debugger.Log%2A> verwendet.</span><span class="sxs-lookup"><span data-stu-id="b6034-121"><xref:System.Diagnostics.Debugger.DefaultCategory> is used by <xref:System.Diagnostics.Debugger.Log%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAttached">
      <MemberSignature Language="C#" Value="public static bool IsAttached { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsAttached" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debugger.IsAttached" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsAttached As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsAttached { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b6034-122">Ruft einen Wert ab, der angibt, ob ein Debugger an den Prozess angefügt ist.</span><span class="sxs-lookup"><span data-stu-id="b6034-122">Gets a value that indicates whether a debugger is attached to the process.</span></span></summary>
        <value>
          <span data-ttu-id="b6034-123"><see langword="true" />, wenn ein Debugger angefügt ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b6034-123"><see langword="true" /> if a debugger is attached; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLogging">
      <MemberSignature Language="C#" Value="public static bool IsLogging ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLogging() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debugger.IsLogging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLogging () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLogging();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b6034-124">Überprüft, ob die Protokollierung durch einen angefügten Debugger aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="b6034-124">Checks to see if logging is enabled by an attached debugger.</span></span></summary>
        <returns>
          <span data-ttu-id="b6034-125"><see langword="true" />, wenn ein Debugger angefügt und die Protokollierung aktiviert ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b6034-125"><see langword="true" /> if a debugger is attached and logging is enabled; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="b6034-126">Der angefügte Debugger ist der verwaltete Debugger, der im <see langword="DbgManagedDebugger" />-Registrierungsschlüssel registriert ist.</span><span class="sxs-lookup"><span data-stu-id="b6034-126">The attached debugger is the registered managed debugger in the <see langword="DbgManagedDebugger" /> registry key.</span></span> <span data-ttu-id="b6034-127">Weitere Informationen über diesen Schlüssel finden Sie unter [Enabling JIT-Attach Debugging](~/docs/framework/debug-trace-profile/enabling-jit-attach-debugging.md).</span><span class="sxs-lookup"><span data-stu-id="b6034-127">For more information on this key, see [Enabling JIT-Attach Debugging](~/docs/framework/debug-trace-profile/enabling-jit-attach-debugging.md).</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Launch">
      <MemberSignature Language="C#" Value="public static bool Launch ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Launch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debugger.Launch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Launch () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Launch();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b6034-128">Startet einen Debugger und fügt diesen an den Prozess an.</span><span class="sxs-lookup"><span data-stu-id="b6034-128">Launches and attaches a debugger to the process.</span></span></summary>
        <returns>
          <span data-ttu-id="b6034-129"><see langword="true" />, wenn der Debugger erfolgreich gestartet wurde oder der Debugger bereits angefügt ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b6034-129"><see langword="true" /> if the startup is successful or if the debugger is already attached; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6034-130">Wenn bereits ein Debugger angefügt ist, passiert nichts.</span><span class="sxs-lookup"><span data-stu-id="b6034-130">If a debugger is already attached, nothing happens.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b6034-131"><see cref="T:System.Security.Permissions.UIPermission" /> ist für das Starten des Debuggers nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="b6034-131">The <see cref="T:System.Security.Permissions.UIPermission" /> is not set to start the debugger.</span></span></exception>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="b6034-132">für die Berechtigung zum Starten von eines Debuggers.</span><span class="sxs-lookup"><span data-stu-id="b6034-132">for permission to start a debugger.</span></span> <span data-ttu-id="b6034-133">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="b6034-133">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="b6034-134">für den Betrieb mit nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="b6034-134">for operating with unmanaged code.</span></span> <span data-ttu-id="b6034-135">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /></span><span class="sxs-lookup"><span data-stu-id="b6034-135">Associated enumeration:  <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /></span></span></permission>
        <altmember cref="T:System.Security.Permissions.UIPermission" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static void Log (int level, string category, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log(int32 level, string category, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debugger.Log(System.Int32,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log (level As Integer, category As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Log(int level, System::String ^ category, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Int32" />
        <Parameter Name="category" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="level"><span data-ttu-id="b6034-136">Eine Beschreibung der Wichtigkeit der Nachricht.</span><span class="sxs-lookup"><span data-stu-id="b6034-136">A description of the importance of the message.</span></span></param>
        <param name="category"><span data-ttu-id="b6034-137">Die Kategorie der Nachricht.</span><span class="sxs-lookup"><span data-stu-id="b6034-137">The category of the message.</span></span></param>
        <param name="message"><span data-ttu-id="b6034-138">Die anzuzeigende Nachricht.</span><span class="sxs-lookup"><span data-stu-id="b6034-138">The message to show.</span></span></param>
        <summary><span data-ttu-id="b6034-139">Stellt eine Nachricht für den angefügten Debugger bereit.</span><span class="sxs-lookup"><span data-stu-id="b6034-139">Posts a message for the attached debugger.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6034-140">Ist kein Debugger angefügt, hat diese Methode keine Auswirkung.</span><span class="sxs-lookup"><span data-stu-id="b6034-140">If there is no debugger attached, this method has no effect.</span></span> <span data-ttu-id="b6034-141">Der Debugger kann oder möglicherweise nicht gemeldet, die Nachricht, abhängig von dessen Einstellungen.</span><span class="sxs-lookup"><span data-stu-id="b6034-141">The debugger might or might not report the message, depending upon its settings.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b6034-142">Der Category-Parameter ist auf 256 Zeichen beschränkt.</span><span class="sxs-lookup"><span data-stu-id="b6034-142">The category parameter is limited to 256 characters.</span></span> <span data-ttu-id="b6034-143">Zeichenfolgen, die länger als 256 Zeichen werden abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="b6034-143">Strings longer than 256 characters are truncated.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOfCrossThreadDependency">
      <MemberSignature Language="C#" Value="public static void NotifyOfCrossThreadDependency ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void NotifyOfCrossThreadDependency() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debugger.NotifyOfCrossThreadDependency" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub NotifyOfCrossThreadDependency ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void NotifyOfCrossThreadDependency();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b6034-144">Benachrichtigt einen Debugger, dass die Ausführung in einem Pfad fortgesetzt werden soll, der eine threadübergreifende Abhängigkeit beinhaltet.</span><span class="sxs-lookup"><span data-stu-id="b6034-144">Notifies a debugger that execution is about to enter a path that involves a cross-thread dependency.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b6034-145">Debugger müssen ausdrücklich Rückrufe aktivieren, die sie empfangen möchten.</span><span class="sxs-lookup"><span data-stu-id="b6034-145">Debuggers must specifically enable callbacks that they wish to receive.</span></span> <span data-ttu-id="b6034-146">Ein Debugger, der threadübergreifenden Abhängigkeitsrückrufe empfangen möchte, muss die Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="b6034-146">A debugger that wants to receive cross-thread dependency callbacks must call the  method.</span></span>  
  
 <span data-ttu-id="b6034-147">Ein Debugger an die ausgewählte <xref:System.Diagnostics.Debugger.NotifyOfCrossThreadDependency%2A> können ergreifen Sie entsprechende Maßnahmen auf Benachrichtigung.</span><span class="sxs-lookup"><span data-stu-id="b6034-147">A debugger that has selected <xref:System.Diagnostics.Debugger.NotifyOfCrossThreadDependency%2A> can take appropriate action upon notification.</span></span> <span data-ttu-id="b6034-148">Beispielsweise erfordert eine funktionsauswertung in der Regel ausführen Einfrieren alle Threads mit Ausnahme des Threads, die die Auswertung ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="b6034-148">For example, performing a function evaluation typically requires freezing all threads except for the thread that is performing the evaluation.</span></span> <span data-ttu-id="b6034-149">Wenn die funktionsauswertung in mehr als einem Thread die Ausführung erforderlich ist, wie in Remoting-Szenarien auftreten können, wird die Auswertung blockiert.</span><span class="sxs-lookup"><span data-stu-id="b6034-149">If the function evaluation requires execution on more than one thread, as might occur in remoting scenarios, the evaluation will block.</span></span> <span data-ttu-id="b6034-150">Die <xref:System.Diagnostics.Debugger.NotifyOfCrossThreadDependency%2A> informiert dem Debugger, dass sie einen Thread freigeben oder Abbrechen, die funktionsauswertung hat.</span><span class="sxs-lookup"><span data-stu-id="b6034-150">The <xref:System.Diagnostics.Debugger.NotifyOfCrossThreadDependency%2A> notification informs the debugger that it has to release a thread or abort the function evaluation.</span></span> <span data-ttu-id="b6034-151">Die Benachrichtigung unterliegt Sammlung aus, nach der Methodenrückgabe.</span><span class="sxs-lookup"><span data-stu-id="b6034-151">The notification is subject to collection after this method returns.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>