<Type Name="DiagnosticListener" FullName="System.Diagnostics.DiagnosticListener">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bdcc8090f3f750834e869c1a46bd4c6dcfa9ec5d" /><Meta Name="ms.sourcegitcommit" Value="6c0b6310824199ff476e4a9eec6e9ed0bd1a51c9" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/05/2019" /><Meta Name="ms.locfileid" Value="74874858" /></Metadata><TypeSignature Language="C#" Value="public class DiagnosticListener : System.Diagnostics.DiagnosticSource, IDisposable, IObservable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DiagnosticListener extends System.Diagnostics.DiagnosticSource implements class System.IDisposable, class System.IObservable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.DiagnosticListener" />
  <TypeSignature Language="VB.NET" Value="Public Class DiagnosticListener&#xA;Inherits DiagnosticSource&#xA;Implements IDisposable, IObservable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class DiagnosticListener : System::Diagnostics::DiagnosticSource, IDisposable, IObservable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type DiagnosticListener = class&#xA;    inherit DiagnosticSource&#xA;    interface IDisposable&#xA;    interface IObservable&lt;KeyValuePair&lt;string, obj&gt;&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.1</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Diagnostics.DiagnosticSource</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IObservable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Implementierung der abstrakten <see cref="T:System.Diagnostics.DiagnosticSource" />-Klasse bereit, die einen benannten Ort darstellt, an eine Quelle ihre Informationen (Ereignisse) sendet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

`DiagnosticListener` ist eine notificationsource. Dies bedeutet, dass das zurückgegebene Ergebnis zum Protokollieren von Benachrichtigungen verwendet werden kann. es verfügt jedoch auch über eine <xref:System.Diagnostics.DiagnosticListener.Subscribe%2A>-Methode, sodass Benachrichtigungen beliebig weitergeleitet werden können. Daher besteht seine Aufgabe darin, die Dinge vom Producer an alle Listener (Multicasting) weiterzuleiten. Im Allgemeinen sollten Sie keine eigenen <xref:System.Diagnostics.DiagnosticListener> erstellen, aber die Standardeinstellung verwenden, damit Benachrichtigungen so öffentlich wie möglich sind.

Weitere Informationen zu den Klassen <xref:System.Diagnostics.DiagnosticSource> und <xref:System.Diagnostics.DiagnosticListener> finden Sie im [Benutzerhandbuch für diagnosticsource](https://github.com/dotnet/corefx/blob/d3942d4671919edb0cca6ddc1840190f524a809d/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md).

        ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DiagnosticListener (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DiagnosticListener(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.DiagnosticListener : string -&gt; System.Diagnostics.DiagnosticListener" Usage="new System.Diagnostics.DiagnosticListener name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name dieses <see cref="T:System.Diagnostics.DiagnosticListener" />.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Diagnostics.DiagnosticListener" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllListeners">
      <MemberSignature Language="C#" Value="public static IObservable&lt;System.Diagnostics.DiagnosticListener&gt; AllListeners { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IObservable`1&lt;class System.Diagnostics.DiagnosticListener&gt; AllListeners" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.DiagnosticListener.AllListeners" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllListeners As IObservable(Of DiagnosticListener)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IObservable&lt;System::Diagnostics::DiagnosticListener ^&gt; ^ AllListeners { IObservable&lt;System::Diagnostics::DiagnosticListener ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllListeners : IObservable&lt;System.Diagnostics.DiagnosticListener&gt;" Usage="System.Diagnostics.DiagnosticListener.AllListeners" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IObservable&lt;System.Diagnostics.DiagnosticListener&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der Listener für diesen <see cref="T:System.Diagnostics.DiagnosticListener" /> ab.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

Wenn Sie dies abonnieren, erhalten Sie Rückrufe für alle notificationlistener in der AppDomain sowie die in der Vergangenheit aufgetretenen Listener und alle zukünftigen Listener, die in der Zukunft erstellt wurden.

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="diagnosticListener.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die NotificationListeners frei.</summary>
        <remarks>Benachrichtigungslistener sind nicht eigenständig, da Sie sich in einer globalen Liste befinden (zur Auffindbarkeit). Sie müssen Sie explizit verwerfen. Beachten Sie, dass das Verwerfen <c>(bool)</c> -Muster nicht durchgeführt wird, da keine Unterklassen unterstützt werden sollen, die nicht den Status "nicht verwaltet" aufweisen.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled();" />
      <MemberSignature Language="F#" Value="override this.IsEnabled : unit -&gt; bool" Usage="diagnosticListener.IsEnabled " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, ob registrierte Abonnenten vorhanden sind.</summary>
        <returns><see langword="true" />, wenn registrierte Abonnenten vorhanden sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

Wenn das Setup für die Benachrichtigung teuer ist, können Sie `IsEnabled()` vor dem Ausführen dieses Setups anrufen. Producer können `IsEnabled()` optional aufrufen, bevor Sie <xref:System.Diagnostics.DiagnosticListener.IsEnabled(System.String)> in Leistungs kritischen Teilen der Anwendung aufrufen, um zu bestimmen, ob Listener zum <xref:System.Diagnostics.DiagnosticListener>vorhanden sind.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public override bool IsEnabled (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsEnabled(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.IsEnabled(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsEnabled (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsEnabled(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.IsEnabled : string -&gt; bool" Usage="diagnosticListener.IsEnabled name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>Überprüft, ob der <see cref="T:System.Diagnostics.DiagnosticListener" /> aktiviert ist.</summary>
        <returns><see langword="true" />, wenn Benachrichtigungen aktiviert sind, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public override bool IsEnabled (string name, object arg1, object arg2 = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsEnabled(string name, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.IsEnabled(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsEnabled (name As String, arg1 As Object, Optional arg2 As Object = null) As Boolean" />
      <MemberSignature Language="F#" Value="override this.IsEnabled : string * obj * obj -&gt; bool" Usage="diagnosticListener.IsEnabled (name, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu überprüfenden Ereignisses.</param>
        <param name="arg1">Das Objekt, das einen Kontext darstellt.</param>
        <param name="arg2">Das Objekt, das einen Kontext darstellt.</param>
        <summary>Überprüft, ob ein Abonnent der Diagnoseereignisse am Empfang von Ereignissen mit diesem Namen interessiert ist. Abonnenten geben Ihr Interesse mithilfe eines in <see cref="Overload:System.Diagnostics.DiagnosticListener.Subscribe" /> bereitgestellten Delegaten an.</summary>
        <returns><see langword="true" />, wenn er aktiviert ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.DiagnosticListener.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Diagnostics.DiagnosticListener.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen dieses <see cref="T:System.Diagnostics.DiagnosticListener" /> ab.</summary>
        <value>Der Name des <see cref="T:System.Diagnostics.DiagnosticListener" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivityExport">
      <MemberSignature Language="C#" Value="public override void OnActivityExport (System.Diagnostics.Activity activity, object payload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnActivityExport(class System.Diagnostics.Activity activity, object payload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.OnActivityExport(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnActivityExport(System::Diagnostics::Activity ^ activity, System::Object ^ payload);" />
      <MemberSignature Language="F#" Value="override this.OnActivityExport : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticListener.OnActivityExport (activity, payload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="payload" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity">Die Aktivität, die von einem externen Ereignis betroffen ist.</param>
        <param name="payload">Ein Objekt, das die ausgehende Anforderung darstellt</param>
        <summary>Ruft die OnActivityExport-Methode aller Abonnenten auf</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivityImport">
      <MemberSignature Language="C#" Value="public override void OnActivityImport (System.Diagnostics.Activity activity, object payload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnActivityImport(class System.Diagnostics.Activity activity, object payload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.OnActivityImport(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnActivityImport(System::Diagnostics::Activity ^ activity, System::Object ^ payload);" />
      <MemberSignature Language="F#" Value="override this.OnActivityImport : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticListener.OnActivityImport (activity, payload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="payload" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity">Die Aktivität, die von einem externen Ereignis betroffen ist.</param>
        <param name="payload">Ein Objekt, das die eingehende Anforderung darstellt</param>
        <summary>Ruft die OnActivityImport-Methode aller Abonnenten auf</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subscribe">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Diese Methoden ermöglichen das Hinzufügen eines Abonnenten, und einige von Ihnen stellen optionale Ereignisfiltermethoden bereit.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subscribe">
      <MemberSignature Language="C#" Value="public IDisposable Subscribe (IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; observer);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable Subscribe(class System.IObserver`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; observer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.Subscribe(System.IObserver{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Subscribe (observer As IObserver(Of KeyValuePair(Of String, Object))) As IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ Subscribe(IObserver&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ observer);" />
      <MemberSignature Language="F#" Value="abstract member Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; IDisposable&#xA;override this.Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; IDisposable" Usage="diagnosticListener.Subscribe observer" />
      <MemberSignature Language="C#" Value="public virtual IDisposable Subscribe (IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; observer);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Subscribe (observer As IObserver(Of KeyValuePair(Of String, Object))) As IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IObservable`1.Subscribe(System.IObserver{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="System.IObserver&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="observer">Ein Abonnent.</param>
        <summary>Fügt einen Abonnenten hinzu.</summary>
        <returns>Ein Verweis auf eine Schnittstelle, mit der der Listener den Empfang von Benachrichtigungen beenden kann, bevor die <see cref="T:System.Diagnostics.DiagnosticSource" /> das Absenden der Benachrichtigungen abgeschlossen hat.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subscribe">
      <MemberSignature Language="C#" Value="public virtual IDisposable Subscribe (IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; observer, Func&lt;string,object,object,bool&gt; isEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable Subscribe(class System.IObserver`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; observer, class System.Func`4&lt;string, object, object, bool&gt; isEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.Subscribe(System.IObserver{System.Collections.Generic.KeyValuePair{System.String,System.Object}},System.Func{System.String,System.Object,System.Object,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Subscribe (observer As IObserver(Of KeyValuePair(Of String, Object)), isEnabled As Func(Of String, Object, Object, Boolean)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ Subscribe(IObserver&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ observer, Func&lt;System::String ^, System::Object ^, System::Object ^, bool&gt; ^ isEnabled);" />
      <MemberSignature Language="F#" Value="abstract member Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; * Func&lt;string, obj, obj, bool&gt; -&gt; IDisposable&#xA;override this.Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; * Func&lt;string, obj, obj, bool&gt; -&gt; IDisposable" Usage="diagnosticListener.Subscribe (observer, isEnabled)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="System.IObserver&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="isEnabled" Type="System.Func&lt;System.String,System.Object,System.Object,System.Boolean&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="observer">Ein Abonnent.</param>
        <param name="isEnabled">Ein Delegat, der Ereignisse auf der Grundlage ihres Namens und von bis zu zwei Kontextobjekten filtert (die <see langword="null" /> sein können), oder <see langword="null" />, wenn ein Ereignisfilter nicht erwünscht ist.</param>
        <summary>Fügt einen Abonnenten hinzu und filtert optional Ereignisse auf der Grundlage ihres Namens und von bis zu zwei Kontextobjekten.</summary>
        <returns>Ein Verweis auf eine Schnittstelle, mit der der Listener den Empfang von Benachrichtigungen beenden kann, bevor die <see cref="T:System.Diagnostics.DiagnosticSource" /> das Absenden der Benachrichtigungen abgeschlossen hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

Wenn `isEnabled` nicht `null`ist, weist dies darauf hin, dass einige Ereignisse nicht interessant sind und für Effizienz übersprungen werden können.

Eine bestimmte Instrumentations Site hat die Möglichkeit, eine oder mehrere <xref:System.Diagnostics.DiagnosticListener.IsEnabled%2A> Überladungen aufzurufenden, in denen Sie den Namen des Ereignisses und bis zu zwei andere Objekte (Instrumentierungs Site spezifisch) als Argumente übergibt. Wenn einer dieser <xref:System.Diagnostics.DiagnosticListener.IsEnabled%2A> Aufrufe erfolgt, wird dieses `isEnabled` Prädikat mit übergebenen Werten aufgerufen (Wenn kürzere über Ladungen verwendet werden, `null` für fehlende Kontext Objekte weitergegeben).

Dadurch erhält eine bestimmte Instrumentations Site die Möglichkeit, bis zu zwei Informationen an den Abonnenten zu übergeben, um eine ausgereifte, effiziente Filterung durchzuführen. Dies erfordert eine bessere Kopplung zwischen der Instrumentations Site und dem Abonnenten Code.

Es wird erwartet, dass eine bestimmte Instrumentations Site verschiedene über Ladungen von `IsEnabled` für dasselbe Ereignis aufruft und zuerst <xref:System.Diagnostics.DiagnosticListener.IsEnabled(System.String)>aufruft, der den Filter mit zwei `null` Kontext Objekten aufruft. Wenn `isEnabled` `true`zurückgibt, wird erneut mit Kontext Objekten aufgerufen. Der `isEnabled` Filter sollte in diesem Sinne entworfen werden.

Beachten Sie, dass das `isEnabled`-Prädikat eine optionale Optimierung ist, damit die Instrumentations Site das Einrichten der Nutzlast und das Aufrufen von <xref:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)> vermeiden kann, wenn kein Abonnent Sie interessiert. Insbesondere die Instrumentations Site hat die Möglichkeit, das <xref:System.Diagnostics.DiagnosticListener.IsEnabled%2A> Prädikat (ohne Aufruf) zu ignorieren und einfach <xref:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)>abzurufen. Wenn der Abonnent also das Filtern erfordert, muss er sich selbst durchführen.

Wenn dieser Parameter `null`ist, erfolgt keine Filterung (alle über Ladungen von <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> Rückgabe `true`).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subscribe">
      <MemberSignature Language="C#" Value="public virtual IDisposable Subscribe (IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; observer, Predicate&lt;string&gt; isEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable Subscribe(class System.IObserver`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; observer, class System.Predicate`1&lt;string&gt; isEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.Subscribe(System.IObserver{System.Collections.Generic.KeyValuePair{System.String,System.Object}},System.Predicate{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Subscribe (observer As IObserver(Of KeyValuePair(Of String, Object)), isEnabled As Predicate(Of String)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ Subscribe(IObserver&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ observer, Predicate&lt;System::String ^&gt; ^ isEnabled);" />
      <MemberSignature Language="F#" Value="abstract member Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; * Predicate&lt;string&gt; -&gt; IDisposable&#xA;override this.Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; * Predicate&lt;string&gt; -&gt; IDisposable" Usage="diagnosticListener.Subscribe (observer, isEnabled)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="System.IObserver&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" />
        <Parameter Name="isEnabled" Type="System.Predicate&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="observer">Ein Abonnent.</param>
        <param name="isEnabled">Ein Delegat, der Ereignisse auf der Grundlage ihres Namens filtert (<see cref="T:System.String" />). Der Delegat sollte <see langword="true" /> zurückgeben, wenn das Ereignis aktiviert ist.</param>
        <summary>Fügt einen Abonnenten hinzu und filtert optional Ereignisse auf der Grundlage ihres Namens.</summary>
        <returns>Ein Verweis auf eine Schnittstelle, mit der der Listener den Empfang von Benachrichtigungen beenden kann, bevor die <see cref="T:System.Diagnostics.DiagnosticSource" /> das Absenden der Benachrichtigungen abgeschlossen hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

Wenn `isEnabled` nicht `null`ist, sind einige Ereignisse nicht interessant und können aus Effizienzgründen übersprungen werden. Das `isEnabled`-Prädikat ist eine optionale Optimierung, damit die Instrumentations Site das Einrichten der Nutzlast und das Aufrufen von <xref:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)> vermeiden kann, wenn kein Abonnent Sie interessiert. Insbesondere die Instrumentations Site hat die Möglichkeit, das <xref:System.Diagnostics.DiagnosticListener.IsEnabled> Prädikat (nicht aufrufen) zu ignorieren und einfach <xref:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)>abzurufen. Wenn der Abonnent also das Filtern erfordert, muss er sich selbst durchführen.

Wenn `isEnabled` `null`ist, erfolgt keine Filterung (alle über Ladungen von <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> geben `true`zurück).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subscribe">
      <MemberSignature Language="C#" Value="public virtual IDisposable Subscribe (IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; observer, Func&lt;string,object,object,bool&gt; isEnabled, Action&lt;System.Diagnostics.Activity,object&gt; onActivityImport = null, Action&lt;System.Diagnostics.Activity,object&gt; onActivityExport = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable Subscribe(class System.IObserver`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; observer, class System.Func`4&lt;string, object, object, bool&gt; isEnabled, class System.Action`2&lt;class System.Diagnostics.Activity, object&gt; onActivityImport, class System.Action`2&lt;class System.Diagnostics.Activity, object&gt; onActivityExport) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.Subscribe(System.IObserver{System.Collections.Generic.KeyValuePair{System.String,System.Object}},System.Func{System.String,System.Object,System.Object,System.Boolean},System.Action{System.Diagnostics.Activity,System.Object},System.Action{System.Diagnostics.Activity,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Subscribe (observer As IObserver(Of KeyValuePair(Of String, Object)), isEnabled As Func(Of String, Object, Object, Boolean), Optional onActivityImport As Action(Of Activity, Object) = null, Optional onActivityExport As Action(Of Activity, Object) = null) As IDisposable" />
      <MemberSignature Language="F#" Value="abstract member Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; * Func&lt;string, obj, obj, bool&gt; * Action&lt;System.Diagnostics.Activity, obj&gt; * Action&lt;System.Diagnostics.Activity, obj&gt; -&gt; IDisposable&#xA;override this.Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; * Func&lt;string, obj, obj, bool&gt; * Action&lt;System.Diagnostics.Activity, obj&gt; * Action&lt;System.Diagnostics.Activity, obj&gt; -&gt; IDisposable" Usage="diagnosticListener.Subscribe (observer, isEnabled, onActivityImport, onActivityExport)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="System.IObserver&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="isEnabled" Type="System.Func&lt;System.String,System.Object,System.Object,System.Boolean&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="onActivityImport" Type="System.Action&lt;System.Diagnostics.Activity,System.Object&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="onActivityExport" Type="System.Action&lt;System.Diagnostics.Activity,System.Object&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="observer">Ein Abonnent.</param>
        <param name="isEnabled">Ein Delegat, der Ereignisse auf der Grundlage ihres Namens und von bis zu zwei Kontextobjekten filtert (die <see langword="null" /> sein können), oder <see langword="null" />, wenn ein Ereignisfilter nicht erwünscht ist</param>
        <param name="onActivityImport">Ein Action-Delegat, der die betroffene Aktivität von einem externen Ereignis sowie von einem Objekt, das die eingehende Anforderung darstellt, empfängt.</param>
        <param name="onActivityExport">Ein Action-Delegat, der die betroffene Aktivität von einem externen Ereignis sowie von einem Objekt, das die ausgehende Anforderung darstellt, empfängt.</param>
        <summary>Fügt einen Abonnenten hinzu, filtert optional Ereignisse auf der Grundlage ihres Namens und von bis zu zwei Kontextobjekten, und gibt Methoden an, die aufgerufen werden sollen, wenn Anbieter Aktivitäten von außerhalb des Prozesses importieren oder exportieren.</summary>
        <returns>Ein Verweis auf eine Schnittstelle, mit der der Listener den Empfang von Benachrichtigungen beenden kann, bevor die <see cref="T:System.Diagnostics.DiagnosticSource" /> das Absenden der Benachrichtigungen abgeschlossen hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Wenn `isEnabled` ungleich NULL ist, können einige Ereignisse für Effizienz übersprungen werden.  

Sie können auch die Methoden ' onactivityimport ' und ' onactivityexport ' angeben, die aufgerufen werden, wenn Anbieter Aktivitäten von außerhalb des Prozesses importieren oder exportieren (z. b. aus HTTP-Anforderungen). Diese Methoden werden nach dem Importieren oder Exportieren der Aktivität aufgerufen und können verwendet werden, um die Aktivität oder die ausgehende Anforderung zum Hinzufügen von Richtlinien zu ändern.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="diagnosticListener.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge mit dem Namen dieses DiagnosticListener zurück.</summary>
        <returns>Der Name dieses DiagnosticListener.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (string name, object value);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(string name, object value) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (name As String, value As Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(System::String ^ name, System::Object ^ value);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-3.0" />
      <MemberSignature Language="F#" Value="override this.Write : string * obj -&gt; unit" Usage="diagnosticListener.Write (name, value)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-3.0" />
      <MemberSignature Language="C#" Value="public override void Write (string name, object parameters);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(string name, object parameters) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (name As String, parameters As Object)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(System::String ^ name, System::Object ^ parameters);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
      <MemberSignature Language="F#" Value="override this.Write : string * obj -&gt; unit" Usage="diagnosticListener.Write (name, parameters)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-3.0" />
        <Parameter Name="parameters" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu protokollierenden Ereignisses.</param>
        <param name="value">Ein Objekt, das die Nutzlast für das Ereignis darstellt.</param>
        <param name="parameters">Ein Objekt, das die Nutzlast für das Ereignis darstellt.</param>
        <summary>Protokolliert eine Benachrichtigung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Weitere Informationen finden Sie unter der Methode <xref:System.Diagnostics.DiagnosticSource.Write%2A?displayProperty=nameWithType>.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
