<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a3829ede129d3e7d57ac5de6d01f254065d682a7" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75027027" /></Metadata><TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht die Interaktion mit Windows-Ereignisprotokollen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 mit <xref:System.Diagnostics.EventLog> können Sie auf Windows-Ereignisprotokolle zugreifen oder diese anpassen, die Informationen zu wichtigen Software-oder Hardware Ereignissen aufzeichnen. Mithilfe <xref:System.Diagnostics.EventLog>können Sie aus vorhandenen Protokollen lesen, Einträge in Protokolle schreiben, Ereignis Quellen erstellen oder löschen, Protokolle löschen und auf Protokolleinträge reagieren. Sie können auch neue Protokolle erstellen, wenn Sie eine Ereignis Quelle erstellen.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle. Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen. Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf. Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.  
  
 Zusätzlich zur Bereitstellung des Zugriffs auf einzelne Ereignisprotokolle und deren Einträge ermöglicht Ihnen die <xref:System.Diagnostics.EventLog>-Klasse den Zugriff auf die Auflistung aller Ereignisprotokolle. Mit den `static` Mitgliedern von <xref:System.Diagnostics.EventLog> können Sie Protokolle löschen, Protokoll Listen erhalten, eine Quelle erstellen oder löschen oder feststellen, ob ein Computer bereits eine bestimmte Quelle enthält.  
  
 Es gibt drei Standard Ereignisprotokolle: Anwendung, System und Sicherheit. Ein Sicherheitsprotokoll ist schreibgeschützt. Andere Anwendungen und Dienste, die Sie installieren, z. b. Active Directory, verfügen möglicherweise über zusätzliche Ereignisprotokolle.  
  
 Bei der Verwendung der <xref:System.Diagnostics.EventLog>-Klasse müssen Sicherheitsaspekte berücksichtigt werden. <xref:System.Diagnostics.EventLog> erfordert <xref:System.Diagnostics.EventLogPermission> Berechtigungen für bestimmte Aktionen in der .NET Framework 2,0 und höheren Versionen oder volle Vertrauenswürdigkeit in .NET Framework 1,0 und 1,1. Es wird empfohlen, dass <xref:System.Diagnostics.EventLogPermission> nicht teilweise vertrauenswürdigem Code erteilt werden.  Sie sollten niemals ein Ereignisprotokoll Objekt, einschließlich <xref:System.Diagnostics.EventLogEntryCollection> und <xref:System.Diagnostics.EventLogEntry> Objekten, an weniger vertrauenswürdigen Code übergeben. Wenn Sie z. b. ein <xref:System.Diagnostics.EventLog> Objekt erstellen, einen Eintrag schreiben und dann das <xref:System.Diagnostics.EventLog> Objekt an teilweise vertrauenswürdigen Code übergeben, kann dies zu einem Sicherheitsproblem führen, da durch die Möglichkeit zum Lesen und Schreiben in das Ereignisprotokoll Aktionen wie das Ausgeben von Ereignisprotokoll Meldungen im Namen einer anderen Anwendung ermöglicht wird.  
  
 Ab Windows Vista werden die Anmelde Informationen eines Benutzers von der Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Um den Code auszuführen, der auf das Sicherheitsprotokoll zugreift, müssen Sie Ihre Anmelde Informationen zuerst von Standardbenutzer auf Administrator herauf Stufen. Sie können dies tun, wenn Sie eine Anwendung starten, indem Sie das Kontextmenü für die Anwendung öffnen (wenn Sie eine Maus verwenden, mit der rechten Maustaste auf das Anwendungssymbol klicken) und angeben, dass Sie als Administrator ausführen möchten.  
  
 Mit <xref:System.Diagnostics.EventLog> können Sie benutzerdefinierte Ereignisprotokolle erstellen, die Sie über die Ereignisanzeige des Servers anzeigen können. Verwenden Sie die <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>-Methode, um einen lokalisierten Namen für das Ereignisprotokoll im Ereignisanzeige anzuzeigen. Verwenden Sie die <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>-Methode, um das Verhalten des Ereignis Protokolls zu konfigurieren, wenn es die maximale Protokoll Größe erreicht.  
  
 Um aus einem Ereignisprotokoll zu lesen, geben Sie den Protokollnamen (<xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft) und den Server Computernamen (<xref:System.Diagnostics.EventLog.MachineName%2A>-Eigenschaft für das Ereignisprotokoll an. Wenn Sie den Server Computernamen nicht angeben, wird davon ausgegangen, dass der lokale Computer "." lautet. Es ist nicht erforderlich, die Ereignis Quelle (<xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft) anzugeben, da eine Quelle nur zum Schreiben in Protokolle erforderlich ist. Die <xref:System.Diagnostics.EventLog.Entries%2A>-Eigenschaft wird automatisch mit der Liste der Einträge des Ereignis Protokolls aufgefüllt.  
  
 Um in ein Ereignisprotokoll zu schreiben, geben Sie eine Ereignis Quelle an, oder erstellen Sie eine (<xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft). Sie müssen über Administrator Anmelde Informationen auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen. Die Ereignis Quelle registriert die Anwendung im Ereignisprotokoll als gültige Quelle für Einträge. Sie können die Ereignis Quelle verwenden, um jeweils nur in ein Protokoll zu schreiben. Bei der <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft kann es sich um eine beliebige zufällige Zeichenfolge handeln, aber der Name muss sich von anderen Quellen auf dem Computer unterscheiden. Die Ereignis Quelle ist in der Regel der Name der Anwendung oder eine andere identifizierende Zeichenfolge. Wenn Sie versuchen, einen doppelten <xref:System.Diagnostics.EventLog.Source%2A> Wert zu erstellen, wird eine Ausnahme ausgelöst. Allerdings kann einem einzelnen Ereignisprotokoll mehrere Quellen zugeordnet werden.  
  
 Wenn die Ereignis Quelle für das Ereignisprotokoll, das der <xref:System.Diagnostics.EventLog> Instanz zugeordnet ist, nicht vorhanden ist, wird eine neue Ereignis Quelle erstellt. Zum Erstellen einer Ereignis Quelle unter Windows Vista und höher oder Windows Server 2003 müssen Sie über Administrator Berechtigungen verfügen.  
  
 Diese Anforderung ist darauf zu achten, dass alle Ereignisprotokolle, einschließlich der Sicherheitsprotokolle, durchsucht werden müssen, um zu bestimmen, ob die Ereignis Quelle eindeutig ist. Ab Windows Vista verfügen Benutzer nicht über die Berechtigung zum Zugriff auf das Sicherheitsprotokoll. Daher wird eine <xref:System.Security.SecurityException> ausgelöst.  
  
> [!IMPORTANT]
>  Zum Erstellen oder Löschen einer Ereignis Quelle muss der zugrunde liegende Code mithilfe eines benannten Mutex synchronisiert werden. Wenn eine Anwendung mit hohen Berechtigungen das benannte Mutex sperrt, wird beim Versuch, eine Ereignis Quelle zu erstellen oder zu löschen, die Anwendung nicht mehr reagiert, bis die Sperre aufgehoben wurde. Um dieses Problem zu vermeiden, erteilen Sie <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> Berechtigung niemals für nicht vertrauenswürdigen Code. Außerdem ermöglicht <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> Berechtigung möglicherweise, dass andere Berechtigungen umgangen werden und nur hochgradig vertrauenswürdigem Code gewährt werden.  
  
 Anwendungen und Dienste sollten in das Anwendungsprotokoll oder in ein benutzerdefiniertes Protokoll schreiben. Gerätetreiber sollten in das System Protokoll schreiben. Wenn Sie die <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft nicht explizit festlegen, wird im Ereignisprotokoll standardmäßig das Anwendungsprotokoll verwendet.  
  
> [!NOTE]
>  Es ist nicht zu schützen, dass eine Anwendung als registrierte Quelle geschrieben wird.  Wenn einer Anwendung <xref:System.Diagnostics.EventLogPermissionAccess.Write> Berechtigung erteilt wird, können Ereignisse für jede gültige Quelle geschrieben werden, die auf dem Computer registriert ist.  
  
 Verwenden Sie die Methoden <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A>, um Ereignisse in ein Ereignisprotokoll zu schreiben. Sie müssen eine Ereignis Quelle angeben, um Ereignisse zu schreiben. vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren.  
  
 Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle konfigurieren, indem Sie ein <xref:System.Diagnostics.EventLogInstaller> Objekt oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode verwenden. Sie müssen über Administrator Anmelde Informationen auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Jede Quelle kann gleichzeitig in nur ein Ereignisprotokoll schreiben. die Anwendung kann jedoch mehrere Quellen zum Schreiben in mehrere Ereignisprotokolle verwenden. Beispielsweise kann Ihre Anwendung mehrere Quellen erfordern, die für verschiedene Ereignisprotokolle oder andere Ressourcen Dateien konfiguriert sind. Wenn Sie die Konfigurationsdetails einer vorhandenen Quelle ändern möchten, müssen Sie die Quelle löschen und Sie dann mit der neuen Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Quelle mit der aktualisierten Konfiguration, anstatt die vorhandene Quelle zu löschen.  
  
 Sie können die Ereignis Quelle mit lokalisierten Ressourcen für die Ereignis Kategorie und die Meldungs Zeichenfolgen registrieren. Die Anwendung kann Ereignisprotokoll Einträge mithilfe von Ressourcen bezeichgern schreiben, anstatt die eigentlichen Zeichen folgen Werte anzugeben. Weitere Informationen zum Konfigurieren ihrer Quelle mit Ressourcen Dateien finden Sie in den Klassen <xref:System.Diagnostics.EventLogInstaller> und <xref:System.Diagnostics.EventSourceCreationData>.  
  
 Wenn Ihre Anwendung Zeichen folgen Werte direkt in das Ereignisprotokoll schreibt, müssen Sie die Ressourcen Dateieigenschaften für die Quelle nicht festlegen. Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
 Beim Schreiben von Ereignissen müssen Sie mindestens eine Meldungs Zeichenfolge oder den Ressourcen Bezeichner für eine Meldungs Zeichenfolge angeben. Andere Ereignis Eigenschaften sind optional. Zu den optionalen Ereignis Einstellungen zählen beispielsweise folgende:  
  
-   Sie können den <xref:System.Diagnostics.EventLogEntryType> festlegen, um das Symbol anzugeben, das der Ereignisanzeige für den Eintrag anzeigt.  
  
-   Sie können einen Kategoriebezeichner für das-Ereignis angeben, wenn Ihre Anwendung Kategorien zum Filtern der Ereignisse verwendet.  
  
-   Sie können dem Ereignis Eintrag binäre Daten anfügen, wenn Sie einem bestimmten Ereignis Weitere Informationen zuordnen möchten.  
  
> [!IMPORTANT]
>  Die Ereignisprotokollierung beansprucht Speicherplatz, Prozessorzeit und andere Systemressourcen. Es ist wichtig, nur wichtige Informationen zu protokollieren. Es wird empfohlen, dass Sie Ereignisprotokoll Aufrufe in einem Fehler Pfad statt im Hauptcodepfad platzieren, damit Sie sich nicht negativ auf die Leistung auswirken.  
  
 Eine Liste der anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.Diagnostics.EventLog>finden Sie im <xref:System.Diagnostics.EventLog.%23ctor%2A>-Konstruktor.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Ereignis Quelle `MySource` erstellt, wenn Sie nicht bereits vorhanden ist, und ein Eintrag in das Ereignisprotokoll `MyNewLog`geschrieben.  
  
> [!NOTE]
>  Ab Windows Vista müssen Sie diese Anwendung als Administrator ausführen.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventLog" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventLog" />-Klasse. Die Instanz wird keinem Protokoll zugeordnet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bevor Sie <xref:System.Diagnostics.EventLog.WriteEntry%2A>aufrufen, geben Sie die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft der <xref:System.Diagnostics.EventLog>-Instanz an. Wenn Sie nur <xref:System.Diagnostics.EventLog.Entries%2A> aus dem Protokoll lesen, können Sie alternativ nur die Eigenschaften <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> angeben.  
  
> [!NOTE]
>  Wenn Sie keine <xref:System.Diagnostics.EventLog.MachineName%2A>angeben, wird der lokale Computer (".") angenommen.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.Diagnostics.EventLog>angezeigt.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Eine leere Zeichenfolge ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Eine leere Zeichenfolge ("").|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Der lokale Computer (".").|  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Quell `MySource` erstellt, wenn Sie noch nicht vorhanden ist, und ein Eintrag in das Ereignisprotokoll `MyNewLog`geschrieben.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des Protokolls auf dem lokalen Computer.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventLog" />-Klasse. Ordnet die Instanz einem Protokoll auf dem lokalen Computer zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung legt die <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft auf den `logName`-Parameter fest. Bevor Sie <xref:System.Diagnostics.EventLog.WriteEntry%2A>aufrufen, geben Sie die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft der <xref:System.Diagnostics.EventLog>-Instanz an. Wenn Sie nur <xref:System.Diagnostics.EventLog.Entries%2A> aus dem Protokoll lesen, können Sie alternativ nur die Eigenschaften <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> angeben.  
  
> [!NOTE]
>  Wenn Sie keine <xref:System.Diagnostics.EventLog.MachineName%2A>angeben, wird der lokale Computer (".") angenommen. Diese Überladung des Konstruktors gibt die <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft an, Sie können diese jedoch ändern, bevor Sie die <xref:System.Diagnostics.EventLog.Entries%2A>-Eigenschaft lesen.  
  
 Wenn die Quelle, die Sie in der <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft angeben, von anderen Quellen auf dem Computer eindeutig ist, erstellt ein nachfolgende <xref:System.Diagnostics.EventLog.WriteEntry%2A> ein Protokoll mit dem angegebenen Namen, sofern es nicht bereits vorhanden ist.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.Diagnostics.EventLog>angezeigt.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Eine leere Zeichenfolge ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Der `logName`-Parameter.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Der lokale Computer (".").|  
  
   
  
## Examples  
 Im folgenden Beispiel werden Einträge im Ereignisprotokoll "MyNewLog" auf dem lokalen Computer gelesen.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Protokollname ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Protokollname ist ungültig.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des Protokolls auf dem angegebenen Computer.</param>
        <param name="machineName">Der Computer, auf dem das Protokoll vorhanden ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventLog" />-Klasse. Ordnet die Instanz einem Protokoll auf dem angegebenen Computer zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung legt die <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft auf den `logName`-Parameter und die <xref:System.Diagnostics.EventLog.MachineName%2A>-Eigenschaft auf den `machineName`-Parameter fest. Bevor Sie <xref:System.Diagnostics.EventLog.WriteEntry%2A>aufrufen, geben Sie die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft der <xref:System.Diagnostics.EventLog>an. Wenn Sie nur <xref:System.Diagnostics.EventLog.Entries%2A> aus dem Protokoll lesen, können Sie alternativ nur die Eigenschaften <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> angeben.  
  
> [!NOTE]
>  Diese Überladung des Konstruktors gibt die Eigenschaften <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> an, aber Sie können sich vor dem Lesen der <xref:System.Diagnostics.EventLog.Entries%2A> Eigenschaft ändern.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.Diagnostics.EventLog>angezeigt.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Eine leere Zeichenfolge ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Der `logName`-Parameter.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Der `machineName`-Parameter.|  
  
   
  
## Examples  
 Im folgenden Beispiel werden Einträge im Ereignisprotokoll "MyNewLog" auf dem Computer "MyServer" gelesen.  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Protokollname ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Protokollname ist ungültig.  
  
 - oder -  
  
 Der Computername ist ungültig.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des Protokolls auf dem angegebenen Computer.</param>
        <param name="machineName">Der Computer, auf dem das Protokoll vorhanden ist.</param>
        <param name="source">Die Quelle für Ereignisprotokolleinträge.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventLog" />-Klasse. Ordnet die Instanz einem Protokoll auf dem angegebenen Computer zu und erstellt die angegebene Quelle bzw. weist diese dem <see cref="T:System.Diagnostics.EventLog" /> zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor legt die <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft auf den `logName`-Parameter, die <xref:System.Diagnostics.EventLog.MachineName%2A>-Eigenschaft auf den `machineName`-Parameter und die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft auf den `source`-Parameter fest. Die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft ist erforderlich, wenn in ein Ereignisprotokoll geschrieben wird. Wenn Sie jedoch nur aus einem Ereignisprotokoll lesen, sind nur die Eigenschaften <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> erforderlich (sofern dem Ereignisprotokoll auf dem Server bereits eine Quelle zugeordnet ist). Wenn Sie nur aus dem Ereignisprotokoll lesen, genügt möglicherweise eine weitere Überladung des Konstruktors.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.Diagnostics.EventLog>angezeigt.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Der `source`-Parameter.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Der `logName`-Parameter.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Der `machineName`-Parameter.|  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Eintrag auf dem lokalen Computer mithilfe der Quelle "MySource" in das Ereignisprotokoll "MyNewLog" geschrieben.  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Protokollname ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Protokollname ist ungültig.  
  
 - oder -  
  
 Der Computername ist ungültig.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Initialisierung von <see cref="T:System.Diagnostics.EventLog" /> für die Verwendung in einem Formular oder durch eine andere Komponente. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurfs Umgebung verwendet diese Methode, um die Initialisierung einer Komponente zu starten, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.Diagnostics.EventLog.EndInit%2A>-Methode beendet die Initialisierung. Wenn Sie die Methoden <xref:System.Diagnostics.EventLog.BeginInit%2A> und <xref:System.Diagnostics.EventLog.EndInit%2A> verwenden, wird verhindert, dass das Steuerelement verwendet wird, bevor es vollständig initialisiert wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.EventLog" /> wurde bereits initialisiert.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Einträge aus dem Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ereignisprotokolle werden mit einer maximalen Größe festgelegt, die bestimmt, wie viele Einträge Sie enthalten können. Wenn ein Ereignisprotokoll voll ist, wird die Aufzeichnung neuer Ereignis Informationen beendet, oder es wird begonnen, frühere Einträge zu überschreiben. Wenn die Ereignisaufzeichnung angehalten wird, können Sie mit dieser Methode das Protokoll vorhandener Einträge löschen und zulassen, dass Ereignisse erneut aufgezeichnet werden. Sie müssen über Administrator Berechtigungen für den Computer verfügen, auf dem sich das Protokoll befindet, um Ereignisprotokoll Einträge zu löschen.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> das Ereignisprotokoll schließt, gibt die Ereignis Handles frei, ruft neue Lese-und Schreib Handles ab und öffnet das Ereignisprotokoll erneut. Ereignisse, die nach dem Abrufen der-Methode empfangen werden, werden nicht zusammen mit den vorhandenen Ereignissen gelöscht.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Ereignisprotokoll gelöscht.  
  
> [!CAUTION]
>  Da Anwendungs-, System-, Sicherheits-und andere Nichtbenutzer definierte Protokolle wichtige Informationen enthalten können. Stellen Sie sicher, dass Sie vor der Ausführung dieses Beispielcodes ein benutzerdefiniertes Protokoll angeben. In diesem Beispiel werden die benutzerdefinierten Protokoll `myNewLog`gelöscht.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Ereignisprotokoll wurde nicht erfolgreich gelöscht.  
  
 - oder -  
  
 Das Protokoll kann nicht geöffnet werden. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <exception cref="T:System.ArgumentException">Für die <see cref="P:System.Diagnostics.EventLog.Log" />-Eigenschaft wurde kein Wert angegeben. Stellen Sie sicher, dass der Protokollname keine leere Zeichenfolge ist.</exception>
        <exception cref="T:System.InvalidOperationException">Das Protokoll ist nicht vorhanden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt das Ereignisprotokoll und gibt Lese- und Schreibhandles frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.EventLog.Close%2A>-Methode wird von der geschützten <xref:System.ComponentModel.Component.Dispose%2A>-Methode aufgerufen. Sie müssen <xref:System.Diagnostics.EventLog.Close%2A> vor dem Aufrufen von <xref:System.ComponentModel.Component.Dispose%2A>nicht aufrufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Lese- oder Schreibhandle des Ereignisprotokolls wurde nicht freigegeben.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Richtet eine Anwendung so ein, dass diese Ereignisinformationen in ein bestimmtes Protokoll im System schreiben kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceData">Die Konfigurationseigenschaften für die Ereignisquelle und ihr Zielereignisprotokoll.</param>
        <summary>Richtet mit den angegebenen Konfigurationseigenschaften für die Ereignisquelle und dem entsprechenden Ereignisprotokoll als gültige Ereignisquelle zum Schreiben lokalisierter Ereignismeldungen ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine neue Quelle zum Schreiben von Einträgen in ein Ereignisprotokoll auf dem lokalen Computer oder einem Remote Computer zu konfigurieren. Es ist nicht erforderlich, diese Methode zum Lesen aus einem Ereignisprotokoll zu verwenden.  
  
 Die <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode verwendet die Eingabe `sourceData`<xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> und <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>-Eigenschaften, um Registrierungs Werte auf dem Zielcomputer für die neue Quelle und das zugehörige Ereignisprotokoll zu erstellen. Ein neuer Quellen Name darf nicht mit einem vorhandenen Quellnamen oder einem vorhandenen Ereignisprotokoll Namen auf dem Zielcomputer identisch sein. Wenn die <xref:System.Diagnostics.EventSourceCreationData.LogName%2A>-Eigenschaft nicht festgelegt ist, wird die Quelle für das Anwendungs Ereignisprotokoll registriert. Wenn die <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> nicht festgelegt ist, wird die Quelle auf dem lokalen Computer registriert.  
  
> [!NOTE]
>  Zum Erstellen einer Ereignis Quelle in Windows Vista und höher oder Windows Server 2003 müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich der Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignis Quelle eindeutig ist. Ab Windows Vista verfügen Benutzer nicht über die Berechtigung zum Zugriff auf das Sicherheitsprotokoll. Daher wird eine <xref:System.Security.SecurityException> ausgelöst.  
>   
>  Ab Windows Vista werden die Berechtigungen eines Benutzers von der Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Um den Code auszuführen, der auf das Sicherheitsprotokoll zugreift, müssen Sie zunächst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.  
  
 Verwenden Sie <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A>, um Ereignisse in ein Ereignisprotokoll zu schreiben. Sie müssen eine Ereignis Quelle angeben, um Ereignisse zu schreiben. vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren.  
  
 Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Sie können eine Ereignis Quelle für ein vorhandenes Ereignisprotokoll oder ein neues Ereignisprotokoll erstellen. Wenn Sie eine neue Quelle für ein neues Ereignisprotokoll erstellen, registriert das System die Quelle für dieses Protokoll, das Protokoll wird jedoch erst erstellt, wenn der erste Eintrag darin geschrieben wird.  
  
 Das Betriebssystem speichert Ereignisprotokolle als Dateien. Wenn Sie mit <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ein neues Ereignisprotokoll erstellen, wird die zugehörige Datei im Verzeichnis%SystemRoot%\System32\Config auf dem angegebenen Computer gespeichert. Der Dateiname wird festgelegt, indem die ersten 8 Zeichen der <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft mit der Dateinamenerweiterung ". evt" angehängt werden.  
  
 Jede Quelle kann nur jeweils nur in ein Ereignisprotokoll schreiben. die Anwendung kann jedoch mehrere Quellen zum Schreiben in mehrere Ereignisprotokolle verwenden. Beispielsweise kann Ihre Anwendung mehrere Quellen erfordern, die für verschiedene Ereignisprotokolle oder andere Ressourcen Dateien konfiguriert sind.  
  
 Sie können die Ereignis Quelle mit lokalisierten Ressourcen Dateien für die Ereignis Kategorie und die Meldungs Zeichenfolgen registrieren. Die Anwendung kann Ereignisprotokoll Einträge mithilfe von Ressourcen bezeichgern schreiben, anstatt die tatsächliche Zeichenfolge anzugeben. Der Ereignisanzeige verwendet den Ressourcen Bezeichner, um die entsprechende Zeichenfolge anhand der aktuellen Spracheinstellungen in der lokalisierten Ressourcen Datei zu suchen und anzuzeigen. Sie können eine separate Datei für Ereignis Kategorien, Meldungen und Parameter Einfügungs Zeichenfolgen registrieren, oder Sie können dieselbe Ressourcen Datei für alle drei Zeichen folgen Typen registrieren. Verwenden Sie die Eigenschaften <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>und <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A>, um die Quelle so zu konfigurieren, dass lokalisierte Einträge in das Ereignisprotokoll geschrieben werden. Wenn die Zeichen folgen Werte von der Anwendung direkt in das Ereignisprotokoll geschrieben werden, müssen Sie diese Eigenschaften nicht festlegen.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
 Wenn Sie die Konfigurationsdetails einer vorhandenen Quelle ändern möchten, müssen Sie die Quelle löschen und Sie dann mit der neuen Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Quelle mit der aktualisierten Konfiguration, anstatt die vorhandene Quelle zu löschen.  
  
> [!NOTE]
>  Wenn eine Quelle für ein Ereignisprotokoll konfiguriert ist und Sie Sie für ein anderes Ereignisprotokoll neu konfigurieren, müssen Sie den Computer neu starten, damit die Änderungen wirksam werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ermittelt, ob die Ereignis Quelle mit dem Namen `SampleApplicationSource` auf dem lokalen Computer registriert ist. Wenn die Ereignis Quelle nicht vorhanden ist, wird im Beispiel die Nachrichten Ressourcen Datei für die Quelle festgelegt und die neue Ereignis Quelle erstellt. Schließlich wird im Beispiel der lokalisierte Anzeige Name für das Ereignisprotokoll mithilfe des Ressourcen-ID-Werts in `DisplayNameMsgId` und des Ressourcen Dateipfads in `messageFile`festgelegt.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 Im Beispiel wird die folgende Meldungs Textdatei verwendet, die in die Ressourcen Bibliothek EventLogMsgs. dll integriert ist. Eine Meldungs Textdatei ist die Quelle, aus der die Nachrichten Ressourcen Datei erstellt wird. Die Meldungs Textdatei definiert die Ressourcen Bezeichner und den Text für die Kategorie, die Ereignismeldung und die Parameter Einfügezeichenfolgen. Der Ressourcen Bezeichner 5001 wird speziell für den lokalisierten Namen des Ereignis Protokolls definiert.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der in <paramref name="sourceData" /> angegebene Computername ist nicht gültig.  
  
- oder - 
Der in <paramref name="sourceData" /> angegebene Dateiname ist <see langword="null" />.  
  
- oder - 
Der in <paramref name="sourceData" /> angegebene Protokollname ist nicht gültig. Ereignisprotokollnamen müssen aus druckbaren Zeichen bestehen und dürfen nicht die Zeichen "*", "?" oder "\\" enthalten.  
  
- oder - 
Der in <paramref name="sourceData" /> angegebene Protokollname ist für die Benutzerprotokollerstellung nicht gültig. Die Ereignisprotokollnamen AppEvent, SysEvent und SecEvent sind für die Verwendung durch das System reserviert.  
  
- oder - 
Der Protokollname stimmt mit einem vorhandenen Ereignisquellennamen überein.  
  
- oder - 
Der in <paramref name="sourceData" /> angegebene Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.  
  
- oder - 
Die ersten acht Zeichen des in <paramref name="sourceData" /> angegebenen Protokollnamens sind nicht eindeutig.  
  
- oder - 
Der in <paramref name="sourceData" /> angegebene Quellenname ist bereits registriert.  
  
- oder - 
Der in <paramref name="sourceData" /> angegebene Quellenname stimmt mit einem vorhandenen Ereignisprotokollnamen überein.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceData" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Quellenname, unter dem die Anwendung auf dem lokalen Computer registriert ist.</param>
        <param name="logName">Der Name des Protokolls, in das die Einträge der Quelle geschrieben werden. Zu den möglichen Werten gehören das Anwendungs- bzw. Systemprotokoll oder ein benutzerdefiniertes Ereignisprotokoll.</param>
        <summary>Richtet den angegebenen Quellennamen als gültige Ereignisquelle für das Schreiben von Einträgen in ein Protokoll auf dem lokalen Computer ein. Diese Methode kann auch ein neues benutzerdefiniertes Protokoll auf dem lokalen Computer erstellen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um ein benutzerdefiniertes Protokoll zu erstellen oder um eine <xref:System.Diagnostics.EventLog.Source%2A> für ein vorhandenes Protokoll auf dem lokalen Computer zu erstellen und zu registrieren.  
  
 Wenn `logName` `null` oder eine leere Zeichenfolge ("") ist, wenn Sie <xref:System.Diagnostics.EventLog.CreateEventSource%2A>aufruft, wird das Protokollstandard mäßig auf das Anwendungsprotokoll angewendet. Wenn das Protokoll auf dem lokalen Computer nicht vorhanden ist, erstellt das System ein benutzerdefiniertes Protokoll und registriert die Anwendung als <xref:System.Diagnostics.EventLog.Source%2A> für dieses Protokoll.  
  
> [!NOTE]
>  Zum Erstellen einer Ereignis Quelle in Windows Vista und höher oder Windows Server 2003 müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich der Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignis Quelle eindeutig ist. Ab Windows Vista verfügen Benutzer nicht über die Berechtigung zum Zugriff auf das Sicherheitsprotokoll. Daher wird eine <xref:System.Security.SecurityException> ausgelöst.  
>   
>  Unter Windows Vista (und höher) werden die Berechtigungen eines Benutzers von der Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Um den Code auszuführen, der auf das Sicherheitsprotokoll zugreift, müssen Sie zunächst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.  
  
 Sie müssen nur dann eine Ereignis Quelle erstellen, wenn Sie in das Ereignisprotokoll schreiben. Bevor Sie einen Eintrag in ein Ereignisprotokoll schreiben, müssen Sie die Ereignis Quelle im Ereignisprotokoll als gültige Quelle für Ereignisse registrieren. Wenn Sie einen Protokolleintrag schreiben, verwendet das System die <xref:System.Diagnostics.EventLog.Source%2A>, um das entsprechende Protokoll zu finden, in dem Sie den Eintrag platzieren können. Wenn Sie das Ereignisprotokoll lesen, können Sie entweder den <xref:System.Diagnostics.EventLog.Source%2A>oder einen <xref:System.Diagnostics.EventLog.Log%2A> angeben und <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Sie müssen die <xref:System.Diagnostics.EventLog.MachineName%2A> nicht angeben, wenn Sie eine Verbindung mit einem Protokoll auf dem lokalen Computer herstellen. Wenn Sie die <xref:System.Diagnostics.EventLog.MachineName%2A> beim Lesen aus einem Protokoll nicht angeben, wird der lokale Computer (".") angenommen.  
  
 Verwenden Sie <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A>, um Ereignisse in ein Ereignisprotokoll zu schreiben. Sie müssen eine Ereignis Quelle angeben, um Ereignisse zu schreiben. vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren.  
  
 Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Sie können eine Ereignis Quelle für ein vorhandenes Ereignisprotokoll oder ein neues Ereignisprotokoll erstellen. Wenn Sie eine neue Quelle für ein neues Ereignisprotokoll erstellen, registriert das System die Quelle für dieses Protokoll, das Protokoll wird jedoch erst erstellt, wenn der erste Eintrag darin geschrieben wird.  
  
 Das Betriebssystem speichert Ereignisprotokolle als Dateien. Wenn Sie mit <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ein neues Ereignisprotokoll erstellen, wird die zugehörige Datei im Verzeichnis%SystemRoot%\System32\Config auf dem angegebenen Computer gespeichert. Der Dateiname wird festgelegt, indem die ersten 8 Zeichen der <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft mit der Dateinamenerweiterung ". evt" angehängt werden.  
  
 Die Quelle muss auf dem lokalen Computer eindeutig sein. ein neuer Quellen Name darf nicht mit einem vorhandenen Quellnamen oder einem vorhandenen Ereignisprotokoll Namen identisch sein. Jede Quelle kann gleichzeitig in nur ein Ereignisprotokoll schreiben. die Anwendung kann jedoch mehrere Quellen zum Schreiben in mehrere Ereignisprotokolle verwenden. Beispielsweise kann Ihre Anwendung mehrere Quellen erfordern, die für verschiedene Ereignisprotokolle oder andere Ressourcen Dateien konfiguriert sind.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
 Wenn Sie die Konfigurationsdetails einer vorhandenen Quelle ändern möchten, müssen Sie die Quelle löschen und Sie dann mit der neuen Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Quelle mit der aktualisierten Konfiguration, anstatt die vorhandene Quelle zu löschen.  
  
> [!NOTE]
>  Wenn eine Quelle bereits einem Protokoll zugeordnet wurde und Sie Sie einem neuen Protokoll zuordnen, müssen Sie den Computer neu starten, damit die Änderungen wirksam werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Quell `MySource` erstellt, wenn Sie noch nicht vorhanden ist, und ein Eintrag in das Ereignisprotokoll `MyNewLog`geschrieben.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> ist eine leere Zeichenfolge ("") oder <see langword="null" />  
  
- oder - 
 <paramref name="logName" /> ist kein gültiger Ereignisprotokollname. Ereignisprotokollnamen müssen aus druckbaren Zeichen bestehen und dürfen nicht die Zeichen "*", "?" oder "\\" enthalten.  
  
- oder - 
 <paramref name="logName" /> ist nicht gültig für Benutzerprotokollerstellung. Die Ereignisprotokollnamen AppEvent, SysEvent und SecEvent sind für die Verwendung durch das System reserviert.  
  
- oder - 
Der Protokollname stimmt mit einem vorhandenen Ereignisquellennamen überein.  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.  
  
- oder - 
Die ersten acht Zeichen von <paramref name="logName" /> stimmen mit den ersten acht Zeichen eines vorhandenen Ereignisprotokollnamens überein.  
  
- oder - 
Die Quelle kann nicht registriert werden, da diese bereits auf dem lokalen Computer vorhanden ist.  
  
- oder - 
Der Quellenname stimmt mit einem vorhandenen Ereignisprotokollnamen überein.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte auf dem lokalen Computer nicht geöffnet werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;dotnet-plat-ext-3.0;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-3.0;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="logName">Der Name des Protokolls, in das die Einträge der Quelle geschrieben werden. Zu den möglichen Werten gehören das Anwendungs- bzw. Systemprotokoll oder ein benutzerdefiniertes Ereignisprotokoll. Wenn Sie keinen Wert angeben, wird standardmäßig für <paramref name="logName" /> das Anwendungsprotokoll verwendet.</param>
        <param name="machineName">Der Name des Computers, auf dem diese Ereignisquelle registriert wird, oder "." für den lokalen Computer.</param>
        <summary>Richtet den angegebenen Quellennamen als gültige Ereignisquelle für das Schreiben von Einträgen in ein Protokoll auf dem angegebenen Computer ein. Mit dieser Methode kann auch ein neues benutzerdefiniertes Protokoll auf dem angegebenen Computer erstellt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um ein benutzerdefiniertes Protokoll zu erstellen oder eine <xref:System.Diagnostics.EventLog.Source%2A> für ein vorhandenes Protokoll auf dem angegebenen Computer zu erstellen und zu registrieren.  
  
 Wenn `logName` `null` oder eine leere Zeichenfolge ("") ist, wenn Sie <xref:System.Diagnostics.EventLog.CreateEventSource%2A>aufruft, wird das Protokollstandard mäßig auf das Anwendungsprotokoll angewendet. Wenn das Protokoll auf dem angegebenen Computer nicht vorhanden ist, erstellt das System ein benutzerdefiniertes Protokoll und registriert die Anwendung als <xref:System.Diagnostics.EventLog.Source%2A> für dieses Protokoll.  
  
 Sie müssen nur dann eine Ereignis Quelle erstellen, wenn Sie in das Ereignisprotokoll schreiben. Bevor Sie einen Eintrag in ein Ereignisprotokoll schreiben, müssen Sie die Ereignis Quelle im Ereignisprotokoll als gültige Quelle für Ereignisse registrieren. Wenn Sie einen Protokolleintrag schreiben, verwendet das System die <xref:System.Diagnostics.EventLog.Source%2A>, um das entsprechende Protokoll zu finden, in dem Sie den Eintrag platzieren können. Wenn Sie das Ereignisprotokoll lesen, können Sie entweder den <xref:System.Diagnostics.EventLog.Source%2A>oder einen <xref:System.Diagnostics.EventLog.Log%2A> angeben und <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Zum Erstellen einer Ereignis Quelle in Windows Vista und höher oder Windows Server 2003 müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich der Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignis Quelle eindeutig ist. In Windows Vista und höher verfügen Benutzer nicht über die Berechtigung zum Zugriff auf das Sicherheitsprotokoll. Daher wird eine <xref:System.Security.SecurityException> ausgelöst.  
>   
>  Unter Windows Vista (und höher) werden die Berechtigungen eines Benutzers von der Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Um den Code auszuführen, der auf das Sicherheitsprotokoll zugreift, müssen Sie zunächst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.  
  
 Verwenden Sie <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A>, um Ereignisse in ein Ereignisprotokoll zu schreiben. Sie müssen eine Ereignis Quelle angeben, um Ereignisse zu schreiben. vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren.  
  
 Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Sie können eine Ereignis Quelle für ein vorhandenes Ereignisprotokoll oder ein neues Ereignisprotokoll erstellen. Wenn Sie eine neue Quelle für ein neues Ereignisprotokoll erstellen, registriert das System die Quelle für dieses Protokoll, das Protokoll wird jedoch erst erstellt, wenn der erste Eintrag darin geschrieben wird.  
  
 Das Betriebssystem speichert Ereignisprotokolle als Dateien. Wenn Sie mit <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ein neues Ereignisprotokoll erstellen, wird die zugehörige Datei im Verzeichnis%SystemRoot%\System32\Config auf dem angegebenen Computer gespeichert. Der Dateiname wird festgelegt, indem die ersten 8 Zeichen der <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft mit der Dateinamenerweiterung ". evt" angehängt werden.  
  
 Die Quelle muss auf dem lokalen Computer eindeutig sein. ein neuer Quellen Name darf nicht mit einem vorhandenen Quellnamen oder einem vorhandenen Ereignisprotokoll Namen identisch sein. Jede Quelle kann gleichzeitig in nur ein Ereignisprotokoll schreiben. die Anwendung kann jedoch mehrere Quellen zum Schreiben in mehrere Ereignisprotokolle verwenden. Beispielsweise kann Ihre Anwendung mehrere Quellen erfordern, die für verschiedene Ereignisprotokolle oder andere Ressourcen Dateien konfiguriert sind.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
 Wenn Sie die Konfigurationsdetails einer vorhandenen Quelle ändern möchten, müssen Sie die Quelle löschen und Sie dann mit der neuen Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Quelle mit der aktualisierten Konfiguration, anstatt die vorhandene Quelle zu löschen.  
  
> [!NOTE]
>  Wenn eine Quelle bereits einem Protokoll zugeordnet wurde und Sie Sie einem neuen Protokoll zuordnen, müssen Sie den Computer neu starten, damit die Änderungen wirksam werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Quell `MySource` auf dem Computer `MyServer`erstellt und ein Eintrag in das Ereignisprotokoll `MyNewLog`geschrieben.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="machineName" /> ist kein gültiger Computername.  
  
- oder - 
 <paramref name="source" /> ist eine leere Zeichenfolge ("") oder <see langword="null" />  
  
- oder - 
 <paramref name="logName" /> ist kein gültiger Ereignisprotokollname. Ereignisprotokollnamen müssen aus druckbaren Zeichen bestehen und dürfen nicht die Zeichen "*", "?" oder "\\" enthalten.  
  
- oder - 
 <paramref name="logName" /> ist nicht gültig für Benutzerprotokollerstellung. Die Ereignisprotokollnamen AppEvent, SysEvent und SecEvent sind für die Verwendung durch das System reserviert.  
  
- oder - 
Der Protokollname stimmt mit einem vorhandenen Ereignisquellennamen überein.  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.  
  
- oder - 
Die ersten acht Zeichen von <paramref name="logName" /> stimmen mit den ersten acht Zeichen eines vorhandenen Ereignisprotokollnamens auf dem angegebenen Computer überein.  
  
- oder - 
Die Quelle kann nicht registriert werden, da diese bereits auf dem angegebenen Computer vorhanden ist.  
  
- oder - 
Der Quellenname stimmt mit einem vorhandenen Ereignisquellennamen überein.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte auf dem angegebenen Computer nicht geöffnet werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt eine Protokollressource.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des zu löschenden Protokolls. Mögliche Werte: Anwendungs-, Sicherheits- und Systemprotokoll sowie alle benutzerdefinierten Ereignisprotokolle auf dem Computer.</param>
        <summary>Entfernt ein Ereignisprotokoll vom lokalen Computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, wenn sich das Protokoll, das Sie löschen möchten, auf dem lokalen Computer befindet. Sie können alle Protokolle auf dem Computer löschen, sofern Sie über die entsprechenden Registrierungs Berechtigungen verfügen.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> entfernt das von `logName` angegebene Protokoll vom lokalen Computer. Wenn Sie nur die in einem Protokoll registrierte Quelle löschen möchten, wenden Sie sich an <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Wenn Sie nur die Protokolleinträge löschen möchten, wenden Sie <xref:System.Diagnostics.EventLog.Clear%2A>an. <xref:System.Diagnostics.EventLog.Delete%2A> und <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sind `static` Methoden, sodass Sie für die Klasse selbst aufgerufen werden können. Es ist nicht erforderlich, eine neue Instanz von <xref:System.Diagnostics.EventLog> zu erstellen, um eine der beiden Methoden aufzurufen.  
  
 Die <xref:System.Diagnostics.EventLog.Delete%2A>-Methode löscht zunächst die Datei, die den Inhalt des Protokolls enthält. Anschließend greift er auf die Registrierung zu und entfernt alle für dieses Protokoll registrierten Ereignis Quellen. Wenn Sie das Protokoll zu einem späteren Zeitpunkt neu erstellen, sollten Sie die Ereignis Quellen erneut registrieren, wenn Sie wieder verwendet werden sollen. Wenn Sie die Ereignis Quellen nicht registrieren und andere Benutzer ohne Angabe eines Protokoll namens in eine Ereignis Quelle schreiben, wird die Ereignis Quelle im Anwendungs Ereignisprotokoll erstellt. Daher schreiben Anwendungen, die zuvor Einträge in das gelöschte und neu erstellte Protokoll schreiben konnten, stattdessen in das Anwendungsprotokoll, da es jetzt die Ereignis Quelle enthält.  
  
> [!NOTE]
>  Die Neuerstellung eines Ereignis Protokolls kann ein schwieriger Prozess sein. Vermeiden Sie das Löschen der vom System erstellten Ereignisprotokolle, z. b. des Anwendungs Protokolls.  
  
 Wenn Sie ein Protokoll durch einen <xref:System.Diagnostics.EventLog.Delete%2A> Löschvorgang löschen, werden automatisch die in diesem Protokoll registrierten Quellen gelöscht. Dies kann dazu führen, dass andere Anwendungen dieses Protokoll verwenden können.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Protokoll vom lokalen Computer gelöscht. Im Beispiel wird das Protokoll aus seiner Quelle bestimmt.  
  
> [!NOTE]
>  Mehr als eine Quelle kann in ein Ereignisprotokoll schreiben. Bevor Sie ein benutzerdefiniertes Protokoll löschen, stellen Sie sicher, dass keine anderen Quellen in dieses Protokoll schreiben.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> ist eine leere Zeichenfolge ("") oder <see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte auf dem lokalen Computer nicht geöffnet werden.  
  
- oder -
  
 Das Protokoll ist auf dem lokalen Computer nicht vorhanden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Ereignisprotokoll wurde nicht erfolgreich gelöscht.  
  
 - oder -  
  
 Das Protokoll kann nicht geöffnet werden. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des zu löschenden Protokolls. Mögliche Werte: Anwendungs-, Sicherheits- und Systemprotokoll sowie alle benutzerdefinierten Ereignisprotokolle auf dem angegebenen Computer.</param>
        <param name="machineName">Der Name des Computers, auf dem das Protokoll gelöscht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Entfernt ein Ereignisprotokoll vom angegebenen Computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, wenn sich das Protokoll, das Sie löschen möchten, auf einem Remote Computer befindet. Sie können alle Protokolle auf dem Computer löschen, sofern Sie über die entsprechenden Registrierungs Berechtigungen verfügen.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> entfernt das von `logName` angegebene Protokoll vom Computer, der durch `machineName`angegeben wird. Wenn Sie nur die in einem Protokoll registrierte Quelle löschen möchten, wenden Sie sich an <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Wenn Sie nur die Protokolleinträge löschen möchten, wenden Sie <xref:System.Diagnostics.EventLog.Clear%2A>an. <xref:System.Diagnostics.EventLog.Delete%2A> und <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sind `static` Methoden, sodass Sie für die Klasse selbst aufgerufen werden können. Es ist nicht erforderlich, eine Instanz von <xref:System.Diagnostics.EventLog> zu erstellen, um eine der beiden Methoden aufzurufen.  
  
 Diese Methode löscht zunächst die Datei, die den Inhalt des Protokolls enthält. Anschließend greift er auf die Registrierung zu und entfernt alle für dieses Protokoll registrierten Ereignis Quellen. Wenn Sie das Protokoll zu einem späteren Zeitpunkt neu erstellen, sollten Sie die Ereignis Quellen erneut registrieren, wenn Sie wieder verwendet werden sollen. Wenn Sie die Ereignis Quellen nicht registrieren und andere Benutzer ohne Angabe eines Protokoll namens in eine Ereignis Quelle schreiben, wird die Ereignis Quelle im Anwendungs Ereignisprotokoll erstellt. Daher schreiben Anwendungen, die zuvor Einträge in das gelöschte und neu erstellte Protokoll schreiben konnten, stattdessen in das Anwendungsprotokoll, da es jetzt die Ereignis Quelle enthält.  
  
> [!NOTE]
>  Die Neuerstellung eines Ereignis Protokolls kann ein schwieriger Prozess sein. Vermeiden Sie das Löschen der vom System erstellten Ereignisprotokolle, z. b. des Anwendungs Protokolls.  
  
 Wenn Sie ein Protokoll durch einen <xref:System.Diagnostics.EventLog.Delete%2A> Löschvorgang löschen, werden automatisch die in diesem Protokoll registrierten Quellen gelöscht. Dies kann dazu führen, dass andere Anwendungen dieses Protokoll verwenden können.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Protokoll auf dem angegebenen Computer gelöscht. Im Beispiel wird das Protokoll aus seiner Quelle bestimmt.  
  
> [!NOTE]
>  Mehr als eine Quelle kann in ein Ereignisprotokoll schreiben. Bevor Sie ein benutzerdefiniertes Protokoll löschen, stellen Sie sicher, dass keine anderen Quellen in dieses Protokoll schreiben.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> ist eine leere Zeichenfolge ("") oder <see langword="null" />  
  
- oder - 
 <paramref name="machineName" /> ist kein gültiger Computername.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte auf dem angegebenen Computer nicht geöffnet werden.  
  
- oder -
  
 Das Protokoll ist auf dem angegebenen Computer nicht vorhanden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Ereignisprotokoll wurde nicht erfolgreich gelöscht.  
  
 - oder -  
  
 Das Protokoll kann nicht geöffnet werden. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt die Registrierung der Ereignisquellen einer Anwendung aus dem Ereignisprotokoll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name, unter dem die Anwendung im Ereignisprotokollsystem registriert ist.</param>
        <summary>Entfernt die Registrierung der Ereignisquelle aus dem Ereignisprotokoll auf dem lokalen Computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die Registrierung einer <xref:System.Diagnostics.EventLog.Source%2A> auf dem lokalen Computer zu entfernen. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> auf die Registrierung auf dem lokalen Computer zugreift und die Registrierung Ihrer Anwendung als gültige Quelle für Ereignisse entfernt.  
  
 Sie können die Komponente als gültige Quelle für Ereignisse entfernen, wenn Sie Sie nicht mehr benötigen, um Einträge in dieses Protokoll zu schreiben. Dies kann z. b. der Fall sein, wenn Sie die Komponente von einem Protokoll in ein anderes ändern müssen. Da eine Quelle nur in jeweils einem Protokoll registriert werden kann, müssen Sie beim Ändern des Protokolls die aktuelle Registrierung entfernen.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> entfernt nur die Quelle, die für ein Protokoll registriert ist. Wenn Sie das Protokoll selbst entfernen möchten, wenden Sie <xref:System.Diagnostics.EventLog.Delete%2A>an. Wenn Sie nur die Protokolleinträge löschen möchten, wenden Sie <xref:System.Diagnostics.EventLog.Clear%2A>an. <xref:System.Diagnostics.EventLog.Delete%2A> und <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sind `static` Methoden, sodass Sie für die Klasse selbst aufgerufen werden können. Es ist nicht erforderlich, eine Instanz von <xref:System.Diagnostics.EventLog> zu erstellen, um eine der beiden Methoden aufzurufen.  
  
 Wenn Sie ein Protokoll durch einen <xref:System.Diagnostics.EventLog.Delete%2A> Löschvorgang löschen, werden automatisch die in diesem Protokoll registrierten Quellen gelöscht. Dies kann dazu führen, dass andere Anwendungen dieses Protokoll verwenden können.  
  
> [!NOTE]
>  Wenn eine Quelle bereits einem Protokoll zugeordnet wurde und Sie Sie einem neuen Protokoll zuordnen, müssen Sie den Computer neu starten, damit die Änderungen wirksam werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Quelle vom lokalen Computer gelöscht. Im Beispiel wird das Protokoll aus seiner Quelle ermittelt, und anschließend wird das Protokoll gelöscht.  
  
> [!NOTE]
>  Mehr als eine Quelle kann in ein Ereignisprotokoll schreiben. Bevor Sie ein benutzerdefiniertes Protokoll löschen, stellen Sie sicher, dass keine anderen Quellen in dieses Protokoll schreiben.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Parameter ist in der Registrierung des lokalen Computers nicht vorhanden.  
  
- oder - 
Sie verfügen nicht über Schreibzugriff auf den Registrierungsschlüssel für das Ereignisprotokoll.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name, unter dem die Anwendung im Ereignisprotokollsystem registriert ist.</param>
        <param name="machineName">Der Name des Computers, auf dem der Registrierungseintrag gelöscht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Entfernt die Registrierung der Ereignisquellen einer Anwendung auf dem angegebenen Computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um die Registrierung einer <xref:System.Diagnostics.EventLog.Source%2A> von einem Remote Computer zu entfernen. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> auf die Registrierung auf dem durch `machineName` angegebenen Computer zugreift und die Registrierung Ihrer Anwendung als gültige Quelle für Ereignisse entfernt.  
  
 Sie können die Komponente als gültige Quelle für Ereignisse entfernen, wenn Sie Sie nicht mehr benötigen, um Einträge in dieses Protokoll zu schreiben. Dies kann z. b. der Fall sein, wenn Sie die Komponente von einem Protokoll in ein anderes ändern müssen. Da eine Quelle nur in jeweils einem Protokoll registriert werden kann, müssen Sie beim Ändern des Protokolls die aktuelle Registrierung entfernen.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> entfernt nur die Quelle, die für ein Protokoll registriert ist. Wenn Sie das Protokoll selbst entfernen möchten, wenden Sie <xref:System.Diagnostics.EventLog.Delete%2A>an. Wenn Sie nur die Protokolleinträge löschen möchten, wenden Sie <xref:System.Diagnostics.EventLog.Clear%2A>an. <xref:System.Diagnostics.EventLog.Delete%2A> und <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sind `static` Methoden, sodass Sie für die Klasse selbst aufgerufen werden können. Es ist nicht erforderlich, eine Instanz von <xref:System.Diagnostics.EventLog> zu erstellen, um eine der beiden Methoden aufzurufen.  
  
 Wenn Sie ein Protokoll durch einen <xref:System.Diagnostics.EventLog.Delete%2A> Löschvorgang löschen, werden automatisch die in diesem Protokoll registrierten Quellen gelöscht. Dies kann dazu führen, dass andere Anwendungen dieses Protokoll verwenden können.  
  
> [!NOTE]
>  Wenn eine Quelle bereits einem Protokoll zugeordnet wurde und Sie Sie einem neuen Protokoll zuordnen, müssen Sie den Computer neu starten, damit die Änderungen wirksam werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Quelle von dem angegebenen Computer gelöscht. Im Beispiel wird das Protokoll aus seiner Quelle ermittelt, und anschließend wird das Protokoll gelöscht.  
  
> [!NOTE]
>  Mehr als eine Quelle kann in ein Ereignisprotokoll schreiben. Bevor Sie ein benutzerdefiniertes Protokoll löschen, stellen Sie sicher, dass keine anderen Quellen in dieses Protokoll schreiben.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="machineName" />-Parameter ist ungültig.  
  
- oder - 
Der <paramref name="source" />-Parameter ist in der Registrierung des angegebenen Computers nicht vorhanden.  
  
- oder - 
Sie verfügen nicht über Schreibzugriff auf den Registrierungsschlüssel für das Ereignisprotokoll.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> kann nicht gelöscht werden, da in der Registrierung der übergeordnete Schlüssel für <paramref name="source" /> keinen Unterschlüssel mit demselben Namen enthält.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Diagnostics.EventLog" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der öffentlichen `Dispose()`-Methode und der <xref:System.Object.Finalize%2A>-Methode aufgerufen. `Dispose()` Ruft die geschützte `Dispose(Boolean)` Methode auf, wobei der `disposing`-Parameter auf `true`festgelegt ist. <xref:System.Object.Finalize%2A> ruft `Dispose` auf, bei dem `disposing` auf `false`festgelegt ist.  
  
 Wenn der `disposing`-Parameter den Wert true hat, gibt diese Methode alle Ressourcen frei, die von allen verwalteten Objekten aufbewahrt werden, auf die diese <xref:System.Diagnostics.EventLog> verweist Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben <see langword="Dispose(Boolean)" /> Sie darauf achten, nicht auf Objekte zu verweisen, die zuvor in einem früheren <see langword="Dispose" />von freigegeben wurden. Weitere Informationen zum Implementieren von <see langword="Dispose(Boolean)" />finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.  
  
Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Diagnostics.EventLog" /> Benachrichtigungen über <see cref="E:System.Diagnostics.EventLog.EntryWritten" />-Ereignisse erhält, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Diagnostics.EventLog" /> beim Schreiben eines Eintrags in das Protokoll benachrichtigt wird; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>-Eigenschaft bestimmt, ob die <xref:System.Diagnostics.EventLog> Ereignisse auslöst, wenn Einträge in das Protokoll geschrieben werden. Wenn die Eigenschaft `true`ist, erhalten Komponenten, die das <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis empfangen, immer dann eine Benachrichtigung, wenn ein Eintrag in das Protokoll geschrieben wird, das in der <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft angegeben ist. Wenn <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> `false`ist, werden keine Ereignisse ausgelöst.  
  
> [!NOTE]
>  Ereignis Benachrichtigungen können nur empfangen werden, wenn Einträge auf dem lokalen Computer geschrieben werden. Benachrichtigungen für auf Remote Computern geschriebene Einträge können nicht empfangen werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis behandelt.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das Ereignisprotokoll wird auf einem Remotecomputer gespeichert.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Initialisierung eines <see cref="T:System.Diagnostics.EventLog" />, das in einem Formular oder von einer anderen Komponente verwendet wird. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurfs Umgebung verwendet diese Methode, um die Initialisierung einer Komponente zu beenden, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.Diagnostics.EventLog.BeginInit%2A>-Methode startet die Initialisierung. Die Verwendung der Methoden <xref:System.Diagnostics.EventLog.BeginInit%2A> und <xref:System.Diagnostics.EventLog.EndInit%2A> verhindert, dass das-Steuerelement verwendet wird, bevor es vollständig initialisiert wird.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Inhalt des Ereignisprotokolls ab.</summary>
        <value>Eine <see cref="T:System.Diagnostics.EventLogEntryCollection" /> mit den Einträgen im Ereignisprotokoll. Jeder Eintrag ist einer Instanz der <see cref="T:System.Diagnostics.EventLogEntry" />-Klasse zugeordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie das <xref:System.Diagnostics.EventLog.Entries%2A>-Element beim Lesen aus dem Ereignisprotokoll.  
  
 Da die Eigenschaft schreibgeschützt ist, können Sie mit <xref:System.Diagnostics.EventLog.Entries%2A>keinen Eintrag ändern oder in das Protokoll schreiben. Geben Sie stattdessen eine <xref:System.Diagnostics.EventLog.Source%2A> an, und geben Sie <xref:System.Diagnostics.EventLog.WriteEntry%2A> ein, um einen neuen Protokolleintrag zu schreiben. Sie können <xref:System.Diagnostics.EventLog.Entries%2A> verwenden, um die Anzahl der Einträge im Ereignisprotokoll zu zählen und jede <xref:System.Diagnostics.EventLogEntry> in der Sammlung anzuzeigen. Verwenden Sie das Element für indizierte <xref:System.Diagnostics.EventLogEntryCollection.Item%2A>, um Informationen zu einem bestimmten Eintrag abzurufen, z. b. <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>oder <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.  
  
 Es ist nicht erforderlich, eine <xref:System.Diagnostics.EventLog.Source%2A> anzugeben, wenn nur aus einem Protokoll gelesen wird. Sie können nur die Eigenschaften <xref:System.Diagnostics.EventLog.Log%2A> Name und <xref:System.Diagnostics.EventLog.MachineName%2A> (Server Computername) für die <xref:System.Diagnostics.EventLog> Instanz angeben. In beiden Fällen wird der <xref:System.Diagnostics.EventLog.Entries%2A> Member automatisch mit der Liste der Einträge des Ereignis Protokolls aufgefüllt. Sie können den entsprechenden Index für ein Element in dieser Liste auswählen, um einzelne Einträge zu lesen.  
  
 Ein wichtiger Unterschied zwischen dem Lesen und Schreiben von Protokoll Einträgen besteht darin, dass es nicht erforderlich ist, explizit eine Read-Methode aufzurufen. Nachdem die <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> angegeben wurden, wird die Eigenschaft <xref:System.Diagnostics.EventLog.Entries%2A> automatisch aufgefüllt. Wenn Sie den Wert der Eigenschaft <xref:System.Diagnostics.EventLog.Log%2A> oder <xref:System.Diagnostics.EventLog.MachineName%2A> ändern, wird die Eigenschaft <xref:System.Diagnostics.EventLog.Entries%2A> erneut aufgefüllt, wenn Sie Sie das nächste Mal lesen.  
  
> [!NOTE]
>  Sie müssen die <xref:System.Diagnostics.EventLog.MachineName%2A> nicht angeben, wenn Sie eine Verbindung mit einem Protokoll herstellen. Wenn Sie die <xref:System.Diagnostics.EventLog.MachineName%2A>nicht angeben, wird der lokale Computer (".") angenommen.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Einträge im Ereignisprotokoll "MyNewLog" auf dem lokalen Computer gelesen.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Schreiben eines Eintrags in das Ereignisprotokoll auf dem lokalen Computer ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um Ereignis Benachrichtigungen zu erhalten, müssen Sie <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> auf `true`festlegen. Ereignis Benachrichtigungen können nur empfangen werden, wenn Einträge auf dem lokalen Computer geschrieben werden. Benachrichtigungen für auf Remote Computern geschriebene Einträge können nicht empfangen werden.  
  
 Beim Erstellen eines <xref:System.Diagnostics.EventLog.EntryWritten>-Delegaten geben Sie die Methode für die Ereignisbehandlung an. Um dem Ereignishandler das Ereignis zuzuordnen, fügen Sie dem Ereignis eine Instanz des Delegaten hinzu. Der-Ereignishandler wird immer dann aufgerufen, wenn das-Ereignis auftritt, bis Sie den Delegaten entfernen. Weitere Informationen zur Behandlung von Ereignissen mit Delegaten finden Sie unter [behandeln und Auswerfen von Ereignissen](~/docs/standard/events/index.md).  
  
 Das System antwortet nur dann auf <xref:System.Diagnostics.EventLog.WriteEntry%2A>, wenn das letzte Schreib Ereignis mindestens sechs Sekunden lang aufgetreten ist. Dies bedeutet, dass Sie nur eine <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis Benachrichtigung innerhalb eines Zeitraums von sechs Sekunden empfangen, auch wenn mehr als eine Änderung des Ereignis Protokolls auftritt. Wenn Sie ein ausreichend langes Ruheintervall (ca. 10 Sekunden) zwischen den Aufrufen von <xref:System.Diagnostics.EventLog.WriteEntry%2A>einfügen, ist es weniger wahrscheinlich, dass Sie ein Ereignis übersehen. Wenn Schreib Ereignisse jedoch häufiger auftreten, erhalten Sie die Ereignis Benachrichtigung möglicherweise erst im nächsten Intervall. In der Regel werden Benachrichtigungen über verpasste Ereignisse nicht verloren gehen, sondern verzögert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Eintrags geschriebenes Ereignis behandelt.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob das angegebene Protokoll vorhanden ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des zu suchenden Protokolls. Mögliche Werte: Anwendungs-, Sicherheits-, System- und andere anwendungsspezifische Protokolle (z.B. im Zusammenhang mit Active Directory) oder ein beliebiges benutzerdefiniertes Protokoll auf dem Computer.</param>
        <summary>Bestimmt, ob das Protokoll auf dem lokalen Computer vorhanden ist.</summary>
        <returns><see langword="true" />, wenn das Protokoll auf dem lokalen Computer vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um zu bestimmen, ob ein Protokoll auf dem lokalen Computer vorhanden ist. Wenn Sie bestimmen möchten, ob eine Quelle auf dem lokalen Computer vorhanden ist, verwenden Sie <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Da diese Methode auf die Registrierung zugreift, müssen Sie über die entsprechenden Registrierungs Berechtigungen auf dem lokalen Computer verfügen. Andernfalls gibt die Abfrage `false`zurück.  
  
 Da Sie einem neuen Protokoll den Namen eines vorhandenen Protokolls auf demselben Computer nicht mitteilen können, verwenden Sie diese Methode vor dem Erstellen eines neuen Protokolls, um zu ermitteln, ob die angegebene `logName` bereits auf dem lokalen Computer vorhanden ist. Der `logName` Parameter unterscheidet nicht zwischen Groß-und Kleinschreibung  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> ist eine `static` Methode, sodass Sie für die Klasse selbst aufgerufen werden kann. Es ist nicht erforderlich, eine Instanz von <xref:System.Diagnostics.EventLog> zu erstellen, um <xref:System.Diagnostics.EventLog.Exists%2A>aufzurufen.  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">logName ist <see langword="null" /> oder eine leere Zeichenfolge.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Das zu suchende Protokoll. Mögliche Werte: Anwendungs-, Sicherheits-, System- und andere anwendungsspezifische Protokolle (z.B. im Zusammenhang mit Active Directory) oder ein beliebiges benutzerdefiniertes Protokoll auf dem Computer.</param>
        <param name="machineName">Der Name des Computers, auf dem das Protokoll gesucht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Bestimmt, ob das Protokoll auf dem angegebenen Computer vorhanden ist.</summary>
        <returns><see langword="true" />, wenn das Protokoll auf dem angegebenen Computer vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um zu bestimmen, ob ein Protokoll auf einem Remote Computer vorhanden ist. Wenn Sie bestimmen möchten, ob eine Quelle auf einem Remote Computer vorhanden ist, verwenden Sie <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Da diese Methode auf die Registrierung zugreift, müssen Sie über die entsprechenden Registrierungs Berechtigungen auf dem angegebenen Computer verfügen. Andernfalls gibt die Abfrage `false`zurück.  
  
 Da Sie dem Namen eines vorhandenen Protokolls auf dem gleichen Computer keinen neuen protokollieren können, verwenden Sie diese Methode vor dem Erstellen eines neuen Protokolls, um zu bestimmen, ob ein mit dem angegebenen `logName` bereits auf dem Server vorhanden ist, der durch den `machineName`-Parameter angegeben wird. Bei den Parametern `logName` und `machineName` wird Groß-/Kleinschreibung nicht beachtet  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> ist eine `static` Methode, sodass Sie für die Klasse selbst aufgerufen werden kann. Es ist nicht erforderlich, eine neue Instanz von <xref:System.Diagnostics.EventLog> zu erstellen, um <xref:System.Diagnostics.EventLog.Exists%2A>aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="machineName" />-Parameter hat ein ungültiges Format. Stellen Sie sicher, dass Sie für den Computer, auf dem Sie die Suche durchführen, die richtige Syntax verwenden.  
  
- oder - 
<paramref name="logName" /> ist <see langword="null" /> oder eine leere Zeichenfolge.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Array der Ereignisprotokolle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sucht nach allen Ereignisprotokollen auf dem lokalen Computer und erstellt ein Array von <see cref="T:System.Diagnostics.EventLog" />-Objekten, das die Liste enthält.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.EventLog" />, das die auf dem lokalen Computer vorhandenen Protokolle darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array von <xref:System.Diagnostics.EventLog> Objekten ist eine Momentaufnahme aller Ereignisprotokolle auf dem lokalen Computer, wenn der <xref:System.Diagnostics.EventLog.GetEventLogs%2A> aufgerufen wird. Dabei handelt es sich nicht um eine dynamische Auflistung, sodass das Löschen oder Erstellen von Protokollen in Echtzeit nicht widerspiegelt wird. Vergewissern Sie sich, dass ein Protokoll im Array vorhanden ist, bevor Sie es lesen oder schreiben. Das Array umfasst in der Regel mindestens drei Protokolle: Anwendung, System und Sicherheit. Wenn Sie benutzerdefinierte Protokolle auf dem lokalen Computer erstellt haben, werden diese ebenfalls im Array angezeigt.  
  
 Zum Abrufen der Liste der Ereignisprotokolle müssen Sie über die entsprechenden Registrierungs Berechtigungen verfügen. Diese Berechtigungen sind identisch mit den Berechtigungen, die erforderlich sind, um <xref:System.Diagnostics.EventLog.Exists%2A> und <xref:System.Diagnostics.EventLog.SourceExists%2A>aufzurufen.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Ereignisprotokolle auf, die auf dem lokalen Computer definiert sind, und zeigt Konfigurationsdetails für jedes Ereignisprotokoll an.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Sie verfügen nicht über Lesezugriff auf die Registrierung.  
  
 - oder -  
  
 Auf dem Computer ist kein Ereignisprotokolldienst vorhanden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Computer, auf dem nach Ereignisprotokollen gesucht werden soll.</param>
        <summary>Sucht nach allen Ereignisprotokollen auf dem angegebenen Computer und erstellt ein Array von <see cref="T:System.Diagnostics.EventLog" />-Objekten, das die Liste enthält.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.EventLog" />, das die auf dem angegebenen Computer vorhandenen Protokolle darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array von <xref:System.Diagnostics.EventLog>-Objekten ist eine Momentaufnahme aller Ereignisprotokolle auf dem Computer, der durch den `machineName`-Parameter angegeben wird, wenn der <xref:System.Diagnostics.EventLog.GetEventLogs%2A> aufgerufen wird. Dabei handelt es sich nicht um eine dynamische Auflistung, sodass das Löschen oder Erstellen von Protokollen in Echtzeit nicht widerspiegelt wird. Vergewissern Sie sich, dass ein Protokoll im Array vorhanden ist, bevor Sie es lesen oder schreiben. Das Array umfasst in der Regel mindestens drei Protokolle: Anwendung, System und Sicherheit. Wenn Sie benutzerdefinierte Protokolle auf dem angegebenen Computer erstellt haben, werden diese ebenfalls im Array angezeigt.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> ist eine `static` Methode, sodass Sie für die <xref:System.Diagnostics.EventLog> Klasse selbst aufgerufen werden kann. Es ist nicht erforderlich, eine Instanz eines <xref:System.Diagnostics.EventLog> Objekts zu erstellen, um die-Methode aufzurufen.  
  
 Zum Abrufen der Liste der Ereignisprotokolle müssen Sie über die entsprechenden Registrierungs Berechtigungen verfügen. Diese Berechtigungen sind identisch mit den Berechtigungen, die erforderlich sind, um <xref:System.Diagnostics.EventLog.Exists%2A> und <xref:System.Diagnostics.EventLog.SourceExists%2A>aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Liste der Protokolle auf dem Computer "MyServer" abgerufen. Anschließend wird der Name jedes Protokolls ausgegeben.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="machineName" />-Parameter ist ein ungültiger Computername.</exception>
        <exception cref="T:System.InvalidOperationException">Sie verfügen nicht über Lesezugriff auf die Registrierung.  
  
 - oder -  
  
 Auf dem Computer ist kein Ereignisprotokolldienst vorhanden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Protokolls ab, aus dem gelesen bzw. in das geschrieben werden soll, oder legt diesen fest.</summary>
        <value>Der Name des Protokolls. Dies kann das Anwendungs-, das System- bzw. das Sicherheitsprotokoll oder ein benutzerdefinierter Protokollname sein. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf dem Server sind standardmäßig drei Protokolldateien vorhanden: Anwendung, System und Sicherheit. Anwendungen und Dienste verwenden die Protokolldatei der Anwendung. Gerätetreiber verwenden die System Protokolldatei. Das System generiert Erfolgs-und Fehler Überwachungs Ereignisse im Sicherheitsprotokoll, wenn die Überwachung aktiviert ist. Wenn Sie andere Anwendungen installiert haben, wie z. b. Active Directory auf Windows-Servern, gibt es möglicherweise andere Standardprotokoll Dateien. Außerdem können Sie benutzerdefinierte Protokolldateien auf einem lokalen Computer oder einem Remote Computer erstellen. Benutzerdefinierte Protokolle helfen Ihnen, die Einträge ausführlicher zu organisieren als zulässig, wenn die Komponenten Ereignisse in das Standard Anwendungsprotokoll schreiben.  
  
> [!NOTE]
>  Protokollnamen sind auf acht Zeichen beschränkt. Gemäß dem System sind MyLogSample1 und MyLogSample2 dasselbe Protokoll.  
  
 Wenn Sie in ein Ereignisprotokoll schreiben, genügt es nicht, die <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft anzugeben. Sie müssen ihrer Ereignisprotokoll Ressource eine <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft zuordnen, um Sie mit einem bestimmten Protokoll zu verbinden. Es ist nicht erforderlich, eine <xref:System.Diagnostics.EventLog.Source%2A> anzugeben, wenn nur aus einem Protokoll gelesen wird, aber eine Ereignis Quelle muss mit der Ereignisprotokoll Ressource in der Registrierung des Servers verknüpft werden. Sie können nur den Namen des <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> (Server Computername) angeben, aus dem Sie lesen möchten.  
  
> [!NOTE]
>  Sie müssen die <xref:System.Diagnostics.EventLog.MachineName%2A> nicht angeben, wenn Sie eine Verbindung mit einem Protokoll herstellen. Wenn Sie die <xref:System.Diagnostics.EventLog.MachineName%2A>nicht angeben, wird der lokale Computer (".") angenommen.  
  
 Wenn die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft nicht angegeben wurde, gibt ein-Aufruf<xref:System.Diagnostics.EventLog.Log%2A> eine leere Zeichenfolge zurück, wenn <xref:System.Diagnostics.EventLog.Log%2A> nicht explizit festgelegt wurde (durch Festlegen der <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft oder durch den-Konstruktor). Wenn die <xref:System.Diagnostics.EventLog.Source%2A> angegeben wurde, gibt <xref:System.Diagnostics.EventLog.Log%2A> den Namen des Protokolls zurück, in dem diese Quelle registriert wurde.  
  
 Eine Quelle kann nur jeweils in jeweils einem Protokoll registriert werden. Wenn die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft für eine Instanz von <xref:System.Diagnostics.EventLog>festgelegt wurde, können Sie die <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft für diese <xref:System.Diagnostics.EventLog> nicht ändern, ohne den Wert <xref:System.Diagnostics.EventLog.Source%2A> zu ändern oder zuerst <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> zu ändern. Wenn Sie die <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft ändern, nachdem die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft festgelegt wurde, wird beim Schreiben eines Protokoll Eintrags eine Ausnahme ausgelöst.  
  
 Das Betriebssystem speichert Ereignisprotokolle als Dateien. Wenn Sie mit <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ein neues Ereignisprotokoll erstellen, wird die zugehörige Datei im Verzeichnis%SystemRoot%\System32\Config auf dem angegebenen Computer gespeichert. Der Dateiname wird festgelegt, indem die ersten 8 Zeichen der <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft mit der Dateinamenerweiterung ". evt" angehängt werden.  
  
 Es ist nicht möglich, ein neues Protokoll allein mit der <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft zu erstellen (ohne eine Quelle für das Protokoll anzugeben). Sie können <xref:System.Diagnostics.EventLog.CreateEventSource%2A>aufrufen, einen neuen Protokollnamen als Parameter übergeben und dann <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>aufrufen. Die Absicht besteht jedoch in der Regel darin, neue anwendungsspezifische Protokolle zu erstellen (und Einträge in diese zu schreiben) oder aus vorhandenen Protokollen zu lesen.  
  
 Wenn sich der <xref:System.Diagnostics.EventLog.Log%2A> Wert ändert, wird das Ereignisprotokoll geschlossen, und alle Ereignis Handles werden freigegeben.  
  
> [!CAUTION]
>  Wenn Sie die <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft auf den Namen eines Protokolls festlegen, das nicht vorhanden ist, fügt das System den <xref:System.Diagnostics.EventLog> dem Anwendungsprotokoll hinzu, warnt Sie jedoch nicht darauf, dass ein anderes Protokoll als das von Ihnen angegebene Protokoll verwendet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Einträge im Ereignisprotokoll "netweventlog" auf dem lokalen Computer gelesen.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den angezeigten Namen des Ereignisprotokolls ab.</summary>
        <value>Ein Name, der das Ereignisprotokoll in der Ereignisanzeige des Systems darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  In Windows Vista und höher verfügen Benutzer nicht über die Berechtigung zum Zugriff auf das Sicherheitsprotokoll. Wenn Sie Windows Vista oder höher als Benutzer ausführen, erhalten Sie eine <xref:System.Security.SecurityException>, wenn Sie versuchen, auf den anzeigen Amen für ein Ereignis im Sicherheitsprotokoll zuzugreifen.  
>   
>  Unter Windows Vista (und höher) werden die Berechtigungen eines Benutzers von der Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Um den Code auszuführen, der auf das Sicherheitsprotokoll zugreift, müssen Sie zunächst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Ereignisprotokolle aufgelistet, die auf dem lokalen Computer definiert sind, und die <xref:System.Diagnostics.EventLog.LogDisplayName%2A> für jedes Ereignisprotokoll angezeigt.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das angegebene <see cref="P:System.Diagnostics.EventLog.Log" /> ist in der Registrierung für diesen Computer nicht vorhanden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">, um den angegebenen Registrierungsschlüssel lesen zu können. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name der Ereignisquelle.</param>
        <param name="machineName">Der Name des Computers, auf dem gesucht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Ruft den Namen des Protokolls ab, in der die angegebene Quelle registriert ist.</summary>
        <returns>Der Name des Protokolls, das der angegebenen Quelle in der Registrierung zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Ereignis Quelle gibt an, was das Ereignis protokolliert. Dies ist häufig der Name der Anwendung oder der Name einer Unterkomponente der Anwendung, wenn die Anwendung groß ist. Anwendungen und Dienste sollten in das Anwendungsprotokoll oder in ein benutzerdefiniertes Protokoll schreiben. Gerätetreiber sollten in das System Protokoll schreiben.  
  
 Wenn Sie eine neue Quelle erstellen, die jeweils nur in ein Protokoll schreiben kann, registriert das System die Anwendung im Ereignisprotokoll als gültige Quelle für Einträge. Die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft kann eine beliebige Zeichenfolge sein, aber der Name kann nicht von anderen Quellen auf dem Computer verwendet werden. Beim Versuch, einen duplizierten <xref:System.Diagnostics.EventLog.Source%2A> Wert zu erstellen, wird eine Ausnahme ausgelöst. Ein einzelnes Ereignisprotokoll kann jedoch viele verschiedene Quellen enthalten, die in das Protokoll schreiben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Quelle vom lokalen Computer gelöscht. Im Beispiel wird das Protokoll aus seiner Quelle ermittelt, und anschließend wird das Protokoll gelöscht.  
  
> [!NOTE]
>  Mehr als eine Quelle kann in ein Ereignisprotokoll schreiben. Bevor Sie ein benutzerdefiniertes Protokoll löschen, stellen Sie sicher, dass keine anderen Quellen in dieses Protokoll schreiben.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Computers ab, auf dem Ereignisse gelesen oder geschrieben werden sollen, oder legt diesen fest.</summary>
        <value>Der Name des Servers, auf dem das Ereignisprotokoll gespeichert ist. Der Standardwert ist der lokale Computer („.“).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie in ein Ereignisprotokoll schreiben, müssen Sie dem Ereignisprotokoll Objekt eine <xref:System.Diagnostics.EventLog.Source%2A> zuordnen, um es mit einem bestimmten Protokoll zu verbinden. Es ist nicht erforderlich, die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft anzugeben, wenn nur aus einem Protokoll gelesen wird. Sie können nur den Namen des <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> (Server Computername) angeben.  
  
> [!NOTE]
>  Sie müssen die <xref:System.Diagnostics.EventLog.MachineName%2A> nicht angeben, wenn Sie eine Verbindung mit einem Protokoll herstellen. Wenn Sie die <xref:System.Diagnostics.EventLog.MachineName%2A>nicht angeben, wird der lokale Computer (".") angenommen.  
  
 Eine Quelle kann nur jeweils in jeweils einem Protokoll registriert werden. Wenn die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft für eine Instanz von <xref:System.Diagnostics.EventLog>festgelegt wurde, können Sie die <xref:System.Diagnostics.EventLog.MachineName%2A>-Eigenschaft für diese <xref:System.Diagnostics.EventLog> nicht ändern, ohne den Wert <xref:System.Diagnostics.EventLog.Source%2A> zu ändern oder zuerst <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> zu ändern. Wenn Sie die <xref:System.Diagnostics.EventLog.MachineName%2A>-Eigenschaft ändern, werden die <xref:System.Diagnostics.EventLog> alle Handles geschlossen und wieder an das Protokoll und die Quelle auf dem neuen Computer angefügt.  
  
 Der <xref:System.Diagnostics.EventLog.MachineName%2A>-Wert darf keine leere Zeichenfolge sein. Wenn Sie nicht explizit festgelegt ist, wird standardmäßig der lokale Computer (".") verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Einträge im Ereignisprotokoll "netweventlog" auf einem angegebenen Computer gelesen.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Computername ist ungültig.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Ereignisprotokollgröße in Kilobyte ab oder legt diese fest.</summary>
        <value>Die maximale Ereignisprotokollgröße in Kilobyte. Der Standardwert lautet 512 und gibt eine maximale Dateigröße von 512 Kilobyte an.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>-Eigenschaft stellt die Größenbeschränkung der Ereignisprotokoll Datei dar. Wenn das Ereignisprotokoll die Größenbeschränkung erreicht, bestimmt der konfigurierte <xref:System.Diagnostics.EventLog.OverflowAction%2A> Wert, ob neue Einträge verworfen werden oder ob neue Einträge Ältere Einträge überschreiben.  
  
> [!NOTE]
>  Diese Eigenschaft stellt eine Konfigurationseinstellung für das Ereignisprotokoll dar, das durch diese Instanz dargestellt wird. Wenn das Ereignisprotokoll die maximale Größe erreicht, gibt diese Eigenschaft an, wie das Betriebssystem neue Einträge verarbeitet, die von allen Ereignis Quellen geschrieben wurden, die für das Ereignisprotokoll registriert sind.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Ereignisprotokolle auf, die auf dem lokalen Computer definiert sind, und zeigt Konfigurationsdetails für jedes Ereignisprotokoll an.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der angegebene Wert ist kleiner als 64, größer als 4194240 oder kein ganzes Vielfaches von 64.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.EventLog.Log" />-Wert ist kein gültiger Protokollname.  
  
- oder - 
Der Registrierungsschlüssel für das Ereignisprotokoll konnte auf dem Zielcomputer nicht geöffnet werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Tagen ab, für die Einträge im Ereignisprotokoll beibehalten werden sollen.</summary>
        <value>Die Anzahl von Tagen, für die Einträge im Ereignisprotokoll beibehalten werden. Der Standardwert ist 7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>-Eigenschaft, um die aktuelle Einstellung für ein Ereignisprotokoll zu überprüfen. Verwenden Sie <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>, um die Mindestanzahl von Tagen zu ändern, die jeder Eintrag im Ereignisprotokoll beibehalten werden muss.  
  
 Der <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wert hängt von dem konfigurierten Überlauf Verhalten des Ereignis Protokolls ab. Wenn die <xref:System.Diagnostics.OverflowAction>-Eigenschaft für ein Ereignisprotokoll auf <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>festgelegt ist, ist der <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wert 0 (null). Wenn die <xref:System.Diagnostics.OverflowAction>-Eigenschaft für ein Ereignisprotokoll auf <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>festgelegt ist, ist der <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wert-1. Wenn die <xref:System.Diagnostics.OverflowAction>-Eigenschaft für ein Ereignisprotokoll auf <xref:System.Diagnostics.OverflowAction.OverwriteOlder>festgelegt ist, ist der <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wert größer als 0 (null), und gibt die Anzahl der Tage an, für die Ereignisprotokoll Einträge beibehalten werden sollen, wenn das Ereignisprotokoll voll ist.  
  
 Das Überlauf Verhalten tritt nur auf, wenn das Größenlimit eines Ereignis Protokolls erreicht wird. Wenn die <xref:System.Diagnostics.EventLog.OverflowAction%2A> eines <xref:System.Diagnostics.EventLog> auf <xref:System.Diagnostics.OverflowAction.OverwriteOlder>festgelegt ist und das Ereignisprotokoll seine maximale Größe erreicht, werden neue Einträge nur dann geschrieben, wenn Sie Einträge ersetzen können, deren Alter den <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Zeitraum überschreitet. Die Beibehaltung von Ereignis Einträgen für einen minimalen Zeitraum ist sinnvoll, wenn das Ereignisprotokoll regelmäßig archiviert wird. Andernfalls riskieren Sie, neue Einträge zu verlieren, wenn das Ereignisprotokoll das Limit erreicht. Um den Verlust neuer Ereignis Informationen zu vermeiden, legen Sie die minimale Beibehaltungs Dauer für Ereignisse auf Grundlage ihres Archiv Zeitplans für ein bestimmtes Ereignisprotokoll fest.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Ereignisprotokolle auf, die auf dem lokalen Computer definiert sind, und zeigt Konfigurationsdetails für jedes Ereignisprotokoll an.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="retentionDays" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">Das Überlaufverhalten für das Schreiben neuer Einträge in das Ereignisprotokoll.</param>
        <param name="retentionDays">Die Mindestanzahl von Tagen, für die jeder Ereignisprotokolleintrag beibehalten wird. Dieser Parameter wird nur verwendet, wenn <paramref name="action" /> auf <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" /> festgelegt ist.</param>
        <summary>Ändert das konfigurierte Verhalten zum Schreiben neuer Einträge, wenn die maximale Dateigröße des Ereignisprotokolls erreicht wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Überlauf Verhalten für ein Ereignisprotokoll gibt an, was geschieht, wenn neue Einträge in ein Protokoll geschrieben werden, das die maximale Dateigröße erreicht hat.  
  
> [!NOTE]
>  Das Überlauf Verhalten tritt nur in Kraft, wenn die maximale Dateigröße eines Ereignis Protokolls erreicht wird. Das Überlauf Verhalten wirkt sich nicht auf das Schreiben eines neuen Eintrags in ein Protokoll aus, das weitere Ereignisprotokoll Einträge aufnehmen kann.  
  
 Die <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>-Methode konfiguriert das Überlauf Verhalten eines Ereignis Protokolls. <xref:System.Diagnostics.EventLog>-Instanz. Nach dem Aufrufen dieser Methode für das Ereignisprotokoll, das durch die <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft angegeben wurde, spiegeln die Werte für die <xref:System.Diagnostics.EventLog.OverflowAction%2A>-und <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Eigenschaft das neu konfigurierte Überlauf Verhalten wider  
  
> [!NOTE]
>  Diese Eigenschaft stellt eine Konfigurationseinstellung für das Ereignisprotokoll dar, das durch diese Instanz dargestellt wird. Wenn das Ereignisprotokoll die maximale Größe erreicht, gibt diese Eigenschaft an, wie das Betriebssystem neue Einträge verarbeitet, die von allen Ereignis Quellen geschrieben wurden, die für das Ereignisprotokoll registriert sind.  
  
 Legen Sie den `action`-Parameter auf <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> fest, um anzugeben, dass ein neuer Eintrag den ältesten Eintrag überschreibt, wenn der <xref:System.Diagnostics.EventLog> seine maximale Größe erreicht. Wenn der `action`-Parameter auf <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>festgelegt ist, wird der Wert des `retentionDays`-Parameters ignoriert.  
  
 Legen Sie den `action`-Parameter auf <xref:System.Diagnostics.OverflowAction.OverwriteOlder> fest, um anzugeben, dass jeder neue Eintrag ältere Einträge überschreibt, wenn der <xref:System.Diagnostics.EventLog> seine maximale Größe erreicht. Geben Sie die Anzahl von Tagen an, die Ereignisse im Protokoll beibehalten werden müssen, indem Sie den `retentionDays`-Parameter verwenden. Ereignisse, die innerhalb der Beibehaltungs Dauer geschrieben wurden, werden nicht von neuen Einträgen überschrieben.  
  
 Legen Sie den `action`-Parameter auf <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> fest, um neue Ereignisse zu verwerfen, wenn die maximale Protokoll Größe erreicht ist. Wenn der `action`-Parameter auf <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>festgelegt ist, wird der Wert des `retentionDays`-Parameters ignoriert.  
  
> [!CAUTION]
>  Das Festlegen der Überlauf Richtlinie auf <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> gibt an, dass neue Einträge verworfen werden, wenn das Ereignisprotokoll voll ist. Wenn Sie diese Einstellung verwenden, stellen Sie sicher, dass das Ereignisprotokoll regelmäßig archiviert und gelöscht wird, um das Erreichen der maximalen Größenbeschränkung zu vermeiden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die konfigurierte Überlauf Richtlinie für ein angegebenes Ereignisprotokoll an und ermöglicht dem Benutzer die Auswahl einer neuen Überlauf Richtlinien Einstellung für das Ereignisprotokoll.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> ist kein gültiger <see cref="P:System.Diagnostics.EventLog.OverflowAction" />-Wert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="retentionDays" /> ist kleiner als 1 oder größer als 365.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.EventLog.Log" />-Wert ist kein gültiger Protokollname.  
  
- oder - 
Der Registrierungsschlüssel für das Ereignisprotokoll konnte auf dem Zielcomputer nicht geöffnet werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das zum Speichern neuer Einträge bei Erreichen der maximalen Dateigröße des Ereignisprotokolls konfigurierte Verhalten ab.</summary>
        <value>Der <see cref="T:System.Diagnostics.OverflowAction" />-Wert, der das zum Speichern neuer Einträge beim Erreichen der maximalen Dateigröße des Ereignisprotokolls konfigurierte Verhalten angibt. Die Standardeinstellung ist <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Größe von Ereignisprotokollen vergrößert sich, wenn neue Ereignisse in Sie geschrieben werden. Jedes Ereignisprotokoll hat eine konfigurierte maximale Größenbeschränkung. die <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>-Eigenschaft definiert die maximale Anzahl von Kilobyte, die für die Größe der Ereignisprotokoll Datei zulässig sind.  
  
 Verwenden Sie den <xref:System.Diagnostics.EventLog.OverflowAction%2A>-Eigenschafts Wert, um das konfigurierte Überlauf Verhalten für ein Ereignisprotokoll mit der maximalen Größe zu untersuchen. Verwenden Sie die <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>-Methode, um das Überlauf Verhalten für ein Ereignisprotokoll zu ändern.  
  
> [!NOTE]
>  Das Überlauf Verhalten tritt nur in Kraft, wenn die maximale Dateigröße eines Ereignis Protokolls erreicht wird. Das Überlauf Verhalten wirkt sich nicht auf das Schreiben eines neuen Eintrags in ein Protokoll aus, das weitere Ereignisprotokoll Einträge aufnehmen kann.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Ereignisprotokolle auf, die auf dem lokalen Computer definiert sind, und zeigt Konfigurationsdetails für jedes Ereignisprotokoll an.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="resourceId" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="resourceFile">Der vollständig angegebene Pfad einer lokalisierten Ressourcendatei.</param>
        <param name="resourceId">Der Ressourcenbezeichner, der eine lokalisierte Zeichenfolge in der Ressourcendatei indiziert.</param>
        <summary>Gibt den lokalisierten Namen des Ereignisprotokolls an, der in der Ereignisanzeige des Servers angezeigt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>, um einen lokalisierten Namen in der Ereignisanzeige für benutzerdefinierte Ereignisprotokolle zu registrieren und anzuzeigen.  
  
 Der angegebene Ressourcen Bezeichner muss einer lokalisierten Zeichenfolge entsprechen, die in der Ressourcen Datei definiert ist. Der Ereignisanzeige zeigt den Namen des benutzerdefinierten Ereignis Protokolls mithilfe der lokalisierten Zeichenfolge und der aktuellen Kultur Einstellungen an. Beispielsweise können Sie mehrere Ereignisprotokoll Namen definieren, die für unterschiedliche Kulturen in der Ressourcen Datei lokalisiert werden. Die Ereignisanzeige zeigt die lokalisierte Zeichenfolge an, die den Kultur Einstellungen des aktuellen Benutzers entspricht.  
  
 Wenn das Ereignisanzeige die lokalisierte Zeichenfolge nicht aus der Ressourcen Datei laden kann, oder wenn kein Anzeige Name für das Ereignisprotokoll registriert wurde, zeigt der Ereignisanzeige den Namen des Ereignis Protokolls an, der in <xref:System.Diagnostics.EventLog.Log%2A>definiert ist.  
  
> [!NOTE]
>  Sie müssen einen anzeigen Amen für die vordefinierten Ereignisprotokolle nicht registrieren. Das Betriebssystem registriert die lokalisierten anzeigen Amen für die Anwendungs-, System-und Sicherheits Ereignisprotokolle.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ermittelt, ob die Ereignis Quelle mit dem Namen `SampleApplicationSource` auf dem lokalen Computer registriert ist. Wenn die Ereignis Quelle nicht vorhanden ist, wird im Beispiel die Nachrichten Ressourcen Datei für die Quelle festgelegt und die neue Ereignis Quelle erstellt. Schließlich wird im Beispiel der lokalisierte Anzeige Name für das Ereignisprotokoll mithilfe des Ressourcen-ID-Werts in `DisplayNameMsgId` und des Ressourcen Dateipfads in `messageFile`festgelegt.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 Im Beispiel wird die folgende Meldungs Textdatei verwendet, die in die Ressourcen Bibliothek EventLogMsgs. dll integriert ist. Eine Meldungs Textdatei ist die Quelle, aus der die Nachrichten Ressourcen Datei erstellt wird. Die Meldungs Textdatei definiert die Ressourcen Bezeichner und den Text für die Kategorie, die Ereignismeldung und die Parameter Einfügezeichenfolgen. Der Ressourcen Bezeichner 5001 wird speziell für den lokalisierten Namen des Ereignis Protokolls definiert.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.EventLog.Log" />-Wert ist kein gültiger Protokollname.  
  
- oder - 
Der Registrierungsschlüssel für das Ereignisprotokoll konnte auf dem Zielcomputer nicht geöffnet werden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceFile" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Verwalten von Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zu registrierenden Namen der Quelle ab, die zum Schreiben in das Ereignisprotokoll verwendet werden soll, oder legt diesen fest.</summary>
        <value>Der Name, der im Ereignisprotokoll als Quelle für Einträge registriert ist. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Ereignis Quelle gibt an, was das Ereignis protokolliert. Dies ist häufig der Name der Anwendung oder der Name einer Unterkomponente der Anwendung, wenn die Anwendung groß ist. Anwendungen und Dienste sollten in das Anwendungsprotokoll oder in ein benutzerdefiniertes Protokoll schreiben. Gerätetreiber sollten in das System Protokoll schreiben.  
  
 Wenn Sie in ein Ereignisprotokoll schreiben, müssen Sie nur eine Ereignis Quelle angeben. Bevor Sie einen Eintrag in ein Ereignisprotokoll schreiben, müssen Sie die Ereignis Quelle im Ereignisprotokoll als gültige Quelle für Ereignisse registrieren. Wenn Sie einen Protokolleintrag schreiben, verwendet das System die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft, um das entsprechende Protokoll zu finden, in dem Sie den Eintrag platzieren können. Wenn Sie das Ereignisprotokoll lesen, können Sie entweder den <xref:System.Diagnostics.EventLog.Source%2A>oder einen <xref:System.Diagnostics.EventLog.Log%2A> angeben und <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Sie müssen die <xref:System.Diagnostics.EventLog.MachineName%2A> nicht angeben, wenn Sie eine Verbindung mit einem Protokoll auf dem lokalen Computer herstellen. Wenn Sie die <xref:System.Diagnostics.EventLog.MachineName%2A>nicht angeben, wird der lokale Computer (".") angenommen.  
  
 Verwenden Sie <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A>, um Ereignisse in ein Ereignisprotokoll zu schreiben. Sie müssen eine Ereignis Quelle angeben, um Ereignisse zu schreiben. vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren.  
  
 Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Sie können eine Ereignis Quelle für ein vorhandenes Ereignisprotokoll oder ein neues Ereignisprotokoll erstellen. Wenn Sie eine neue Quelle für ein neues Ereignisprotokoll erstellen, registriert das System die Quelle für dieses Protokoll, das Protokoll wird jedoch erst erstellt, wenn der erste Eintrag darin geschrieben wird.  
  
 Die Quelle muss auf dem lokalen Computer eindeutig sein. ein neuer Quellen Name darf nicht mit einem vorhandenen Quellnamen oder einem vorhandenen Ereignisprotokoll Namen identisch sein. Jede Quelle kann gleichzeitig in nur ein Ereignisprotokoll schreiben. die Anwendung kann jedoch mehrere Quellen zum Schreiben in mehrere Ereignisprotokolle verwenden. Beispielsweise kann Ihre Anwendung mehrere Quellen erfordern, die für verschiedene Ereignisprotokolle oder andere Ressourcen Dateien konfiguriert sind.  
  
 Wenn Sie den <xref:System.Diagnostics.EventLog.Source%2A> Wert ändern, wird der <xref:System.Diagnostics.EventLog>, in dem er registriert ist, geschlossen, und alle Ereignis Handles werden freigegeben.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
 Wenn Sie die Konfigurationsdetails einer vorhandenen Quelle ändern möchten, müssen Sie die Quelle löschen und Sie dann mit der neuen Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Quelle mit der aktualisierten Konfiguration, anstatt die vorhandene Quelle zu löschen.  
  
> [!NOTE]
>  Wenn eine Quelle bereits einem Protokoll zugeordnet wurde und Sie Sie einem neuen Protokoll zuordnen, müssen Sie den Computer neu starten, damit die Änderungen wirksam werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Quell `MySource` erstellt, wenn Sie noch nicht vorhanden ist, und ein Eintrag in das Ereignisprotokoll `MyNewLog`geschrieben.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht die Registrierung eines Computers nach einer bestimmten Ereignisquelle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name der Ereignisquelle.</param>
        <summary>Bestimmt, ob eine Ereignisquelle auf dem lokalen Computer registriert ist.</summary>
        <returns><see langword="true" />, wenn die Ereignisquelle auf dem lokalen Computer registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um zu bestimmen, ob eine Ereignis Quelle auf dem lokalen Computer vorhanden ist. Wenn Sie bestimmen möchten, ob ein Protokoll auf dem lokalen Computer vorhanden ist, verwenden Sie <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Da diese Methode auf die Registrierung zugreift, müssen Sie über die entsprechenden Registrierungs Berechtigungen auf dem lokalen Computer verfügen. Andernfalls wird eine <xref:System.Security.SecurityException> ausgelöst.  
  
> [!NOTE]
>  Um nach einer Ereignis Quelle in Windows Vista und höher oder Windows Server 2003 zu suchen, müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich der Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignis Quelle eindeutig ist. Ab Windows Vista verfügen Benutzer nicht über die Berechtigung zum Zugriff auf das Sicherheitsprotokoll. Daher wird eine <xref:System.Security.SecurityException> ausgelöst.  
>   
>  Ab Windows Vista werden die Berechtigungen eines Benutzers von der Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Um den Code auszuführen, der auf Leistungsindikatoren zugreift, müssen Sie zunächst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.  
  
> [!NOTE]
>  Ein Dienst, der unter dem <xref:System.ServiceProcess.ServiceAccount.LocalSystem> Konto ausgeführt wird, verfügt nicht über die erforderlichen Berechtigungen, um diese Methode auszuführen. Die Lösung besteht darin, zu überprüfen, ob die Ereignis Quelle im <xref:System.ServiceProcess.ServiceInstaller>vorhanden ist, und wenn Sie nicht vorhanden ist, um die Quelle im Installationsprogramm zu erstellen.  
  
 Da Sie dem Namen einer vorhandenen Quelle auf demselben Computer keine neue Quelle geben können, verwenden Sie diese Methode, bevor Sie versuchen, <xref:System.Diagnostics.EventLog.CreateEventSource%2A> aufzurufen, um sicherzustellen, dass eine Quelle mit dem von `source` angegebenen Namen nicht bereits auf dem lokalen Computer vorhanden ist. Beim `source`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Quell `MySource` erstellt, wenn Sie noch nicht vorhanden ist, und ein Eintrag in das Ereignisprotokoll `MyNewLog`geschrieben.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><paramref name="source" /> wurde nicht gefunden, aber einige oder alle Ereignisprotokolle konnten nicht durchsucht werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name der Ereignisquelle.</param>
        <param name="machineName">Der Name des Computers, auf dem gesucht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Bestimmt, ob eine Ereignisquelle auf einem angegebenen Computer registriert ist.</summary>
        <returns><see langword="true" />, wenn die Ereignisquelle auf dem angegebenen Computer registriert ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um zu bestimmen, ob eine Ereignis Quelle auf dem durch den `machineName`-Parameter angegebenen Computer vorhanden ist. Wenn Sie bestimmen möchten, ob ein Protokoll auf dem angegebenen Computer vorhanden ist, verwenden Sie <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Da diese Methode auf die Registrierung zugreift, müssen Sie über die entsprechenden Registrierungs Berechtigungen für den angegebenen Server verfügen. Andernfalls wird eine <xref:System.Security.SecurityException> ausgelöst.  
  
> [!NOTE]
>  Um nach einer Ereignis Quelle in Windows Vista und höher oder Windows Server 2003 zu suchen, müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich der Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignis Quelle eindeutig ist. Ab Windows Vista verfügen Benutzer nicht über die Berechtigung zum Zugriff auf das Sicherheitsprotokoll. Daher wird eine <xref:System.Security.SecurityException> ausgelöst.  
>   
>  Ab Windows Vista werden die Berechtigungen eines Benutzers von der Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Um den Code auszuführen, der auf Leistungsindikatoren zugreift, müssen Sie zunächst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.  
  
> [!NOTE]
>  Ein Dienst, der unter dem <xref:System.ServiceProcess.ServiceAccount.LocalSystem> Konto ausgeführt wird, verfügt nicht über die erforderlichen Berechtigungen, um diese Methode auszuführen. Die Lösung besteht darin, zu überprüfen, ob die Ereignis Quelle im <xref:System.ServiceProcess.ServiceInstaller>vorhanden ist, und wenn Sie nicht vorhanden ist, um die Quelle im Installationsprogramm zu erstellen.  
  
 Da Sie eine neue Quelle nicht als Namen für eine vorhandene Quelle auf demselben Computer angeben können, verwenden Sie diese Methode, bevor Sie versuchen, <xref:System.Diagnostics.EventLog.CreateEventSource%2A> aufzurufen, um sicherzustellen, dass eine Quelle mit dem von `source` angegebenen Namen nicht bereits auf dem Computer vorhanden ist. Bei den Parametern `source` und `machineName` wird Groß-/Kleinschreibung nicht beachtet  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> ist eine `static` Methode, sodass Sie für die Klasse selbst aufgerufen werden kann. Es ist nicht erforderlich, eine Instanz von <xref:System.Diagnostics.EventLog> zu erstellen, um <xref:System.Diagnostics.EventLog.SourceExists%2A>aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Quell `MySource` auf dem Computer `MyServer`erstellt und ein Eintrag in das Ereignisprotokoll `MyNewLog`geschrieben.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> ist ein ungültiger Computername.</exception>
        <exception cref="T:System.Security.SecurityException"><paramref name="source" /> wurde nicht gefunden, aber einige oder alle Ereignisprotokolle konnten nicht durchsucht werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt für das Marshallen der Ereignishandleraufrufe ab, die aufgrund eines Ereignisses für das Schreiben eines <see cref="T:System.Diagnostics.EventLog" />-Eintrags ausgegeben werden, oder legt dieses fest.</summary>
        <value>Das <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> für das Marshallen von Ereignishandleraufrufen, die aufgrund eines <see cref="E:System.Diagnostics.EventLog.EntryWritten" />-Ereignisses im Ereignisprotokoll ausgegeben werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> `null`ist, werden Methoden, die das <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis verarbeiten, in einem Thread aus dem Thread Pool des Systems aufgerufen. Weitere Informationen zu System Thread Pools finden Sie unter <xref:System.Threading.ThreadPool>.  
  
 Wenn das <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis von einer Visual Windows Forms-Komponente behandelt wird, z. b. eine Schaltfläche, funktioniert der Zugriff auf die Komponente über den System Thread Pool möglicherweise nicht, oder es kann zu einer Ausnahme kommen. Vermeiden Sie dies, indem Sie <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> auf eine Windows Forms Komponente festlegen, die bewirkt, dass die Methoden, die das <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis verarbeiten, in demselben Thread aufgerufen werden, auf dem die Komponente erstellt wurde.  
  
 Wenn die <xref:System.Diagnostics.EventLog> innerhalb [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in einem Windows Forms-Designer verwendet wird, wird <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> automatisch auf das Steuerelement festgelegt, das die <xref:System.Diagnostics.EventLog>enthält. Wenn Sie z. b. eine <xref:System.Diagnostics.EventLog> in einem Designer für Form1 platzieren (der von <xref:System.Windows.Forms.Form>erbt), wird die Eigenschaft <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> von <xref:System.Diagnostics.EventLog> auf die Instanz von Form1 festgelegt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt einen Eintrag in das Ereignisprotokoll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <summary>Schreibt einen Eintrag vom Typ Information mit dem angegebenen Meldungstext in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen Informations Eintrag in das Ereignisprotokoll zu schreiben, das dieser <xref:System.Diagnostics.EventLog> Instanz zugeordnet ist. Wenn Sie andere <xref:System.Diagnostics.EventLogEntryType>angeben möchten, verwenden Sie eine andere Überladung <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf nicht%*n*enthalten, wobei *n* ein ganzzahliger Wert (z. b. %1) ist, da Sie in der Ereignisanzeige als Einfügezeichenfolge behandelt wird. Da eine IPv6-Adresse (Internet Protocol, Version 6) diese Zeichenfolge enthalten kann, können Sie keine Ereignismeldung protokollieren, die eine IPv6-Adresse enthält.  
  
 Sie müssen die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft für die <xref:System.Diagnostics.EventLog> Komponente festlegen, bevor Sie Einträge in das Protokoll schreiben können. Vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren.  
  
 Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Wenn die Quelle, die in der <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft dieser <xref:System.Diagnostics.EventLog> Instanz angegeben ist, nicht auf dem Computer registriert ist, auf den die Komponente schreibt, ruft <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.CreateEventSource%2A> auf und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie keine <xref:System.Diagnostics.EventLog.MachineName%2A> für die <xref:System.Diagnostics.EventLog>-Instanz angeben, bevor Sie <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>aufgerufen haben, wird der lokale Computer (".") angenommen.  
  
 Wenn das System die <xref:System.Diagnostics.EventLog.Source%2A> über einen <xref:System.Diagnostics.EventLog.WriteEntry%2A> registrieren muss und die <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft für Ihre <xref:System.Diagnostics.EventLog> Instanz nicht festgelegt wurde, wird das Protokollstandard mäßig auf das Anwendungsprotokoll festgelegt.  
  
> [!NOTE]
>  Viele der oben aufgeführten Ausnahmen werden durch Fehler generiert, die während der Registrierung der <xref:System.Diagnostics.EventLog.Source%2A>ausgelöst werden.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll. Es wird keine lokalisierbare Nachrichten Ressourcen Datei verwendet. Verwenden Sie die <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Ereignisse mithilfe einer lokalisierten Nachrichten Ressourcen Datei zu schreiben.  
  
 Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag auf einen Remote Computer schreiben, entspricht der Wert der Meldung (die Text Zeichenfolge) möglicherweise nicht Ihren Erwartungen, wenn der Remote Computer die .NET Framework nicht ausgeführt hat.  
  
> [!NOTE]
>  Wenn der `message`-Parameter ein NUL-Zeichen enthält, wird die Nachricht im Ereignisprotokoll mit dem NUL-Zeichen beendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Quell `MySource` erstellt, wenn Sie noch nicht vorhanden ist, und ein Eintrag in das Ereignisprotokoll `MyNewLog`geschrieben.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" />-Eigenschaft von <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
- oder - 
Die Methode hat versucht, eine neue Ereignisquelle zu registrieren, der Computername in <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist jedoch ungültig.  
  
- oder - 
Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
- oder - 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <summary>Schreibt einen Eintrag für einen Fehler, eine Warnung, eine Information, eine Erfolgs- oder Fehlerüberwachung mit dem angegebenen Meldungstext in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen Eintrag eines angegebenen <xref:System.Diagnostics.EventLogEntryType> in das Ereignisprotokoll zu schreiben. Der `type` wird durch ein Symbol und einen Text in der Type-Spalte in der Ereignisanzeige für ein Protokoll angegeben.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf nicht%*n*enthalten, wobei *n* ein ganzzahliger Wert (z. b. %1) ist, da Sie in der Ereignisanzeige als Einfügezeichenfolge behandelt wird. Da eine IPv6-Adresse (Internet Protocol, Version 6) diese Zeichenfolge enthalten kann, können Sie keine Ereignismeldung protokollieren, die eine IPv6-Adresse enthält.  
  
 Sie müssen die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft für die <xref:System.Diagnostics.EventLog> Komponente festlegen, bevor Sie Einträge in das Protokoll schreiben können. Vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren.  
  
 Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Wenn die Quelle, die in der <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft dieser <xref:System.Diagnostics.EventLog> Instanz angegeben ist, nicht auf dem Computer registriert ist, auf den die Komponente schreibt, ruft <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.CreateEventSource%2A> auf und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie keine <xref:System.Diagnostics.EventLog.MachineName%2A> für die <xref:System.Diagnostics.EventLog>-Instanz angeben, bevor Sie <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>aufgerufen haben, wird der lokale Computer (".") angenommen.  
  
 Wenn das System die <xref:System.Diagnostics.EventLog.Source%2A> über einen <xref:System.Diagnostics.EventLog.WriteEntry%2A> registrieren muss und die <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft für Ihre <xref:System.Diagnostics.EventLog> Instanz nicht festgelegt wurde, wird das Protokollstandard mäßig auf das Anwendungsprotokoll festgelegt.  
  
> [!NOTE]
>  Viele oben aufgeführte Ausnahmen werden durch Fehler generiert, die während der Registrierung der <xref:System.Diagnostics.EventLog.Source%2A>ausgelöst wurden.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll. Es wird keine lokalisierbare Nachrichten Ressourcen Datei verwendet. Verwenden Sie die <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Ereignisse mithilfe einer lokalisierten Nachrichten Ressourcen Datei zu schreiben.  
  
 Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag auf einen Remote Computer schreiben, entspricht der Wert der Meldung (die Text Zeichenfolge) möglicherweise nicht Ihren Erwartungen, wenn der Remote Computer die .NET Framework nicht ausgeführt hat.  
  
> [!NOTE]
>  Wenn der `message`-Parameter ein NUL-Zeichen enthält, wird die Nachricht im Ereignisprotokoll mit dem NUL-Zeichen beendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Warn Eintrag auf dem lokalen Computer in das Ereignisprotokoll "MyNewLog" geschrieben.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" />-Eigenschaft von <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
- oder - 
Die Methode hat versucht, eine neue Ereignisquelle zu registrieren, der Computername in <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist jedoch ungültig.  
  
- oder - 
Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
- oder - 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <summary>Schreibt einen Eintrag vom Typ Information mit dem angegebenen Meldungstext in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Schreiben eines Informations Eintrags in das Ereignisprotokoll, wobei eine Quelle verwendet wird, die bereits als Ereignis Quelle für das entsprechende Protokoll registriert ist. Wenn Sie andere <xref:System.Diagnostics.EventLogEntryType>angeben möchten, verwenden Sie eine andere Überladung <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
 Vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren. Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll. Es wird keine lokalisierbare Nachrichten Ressourcen Datei verwendet. Verwenden Sie die <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Ereignisse mithilfe einer lokalisierten Nachrichten Ressourcen Datei zu schreiben.  
  
 Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
> [!NOTE]
>  Wenn der `message`-Parameter ein NUL-Zeichen enthält, wird die Nachricht im Ereignisprotokoll mit dem NUL-Zeichen beendet.  
>   
>  Die `message` Zeichenfolge darf nicht%*n*enthalten, wobei *n* ein ganzzahliger Wert (z. b. %1) ist, da Sie in der Ereignisanzeige als Einfügezeichenfolge behandelt wird. Da eine IPv6-Adresse (Internet Protocol, Version 6) diese Zeichenfolge enthalten kann, können Sie keine Ereignismeldung protokollieren, die eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Quell `MySource` erstellt, wenn Sie noch nicht vorhanden ist, und ein Eintrag in das Ereignisprotokoll `MyNewLog`geschrieben.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Wert ist eine leere Zeichenfolge ("").  
  
- oder - 
Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
- oder - 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext und dem von der Anwendung definierten Ereignisbezeichner in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen Eintrag mit einem Anwendungs definierten `eventID` in das Ereignisprotokoll zu schreiben. Der `eventID` in Verbindung mit der Quelle ein Ereignis eindeutig identifiziert. Jede Anwendung kann Ihre eigenen nummerierten Ereignisse und die Beschreibungs Zeichenfolgen definieren, denen Sie zugeordnet sind. Ereignis Betrachter zeigen diese Zeichen folgen Werte an, um dem Benutzer zu helfen, herauszufinden, was schief gelaufen ist, und die auszuführenden Aktionen vorzuschlagen.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf nicht%*n*enthalten, wobei *n* ein ganzzahliger Wert (z. b. %1) ist, da Sie in der Ereignisanzeige als Einfügezeichenfolge behandelt wird. Da eine IPv6-Adresse (Internet Protocol, Version 6) diese Zeichenfolge enthalten kann, können Sie keine Ereignismeldung protokollieren, die eine IPv6-Adresse enthält.  
  
 Zusätzlich zum Ereignis Bezeichner können Sie eine <xref:System.Diagnostics.EventLogEntryType> für das Ereignis angeben, das in das Ereignisprotokoll geschrieben wird. Der `type` wird durch ein Symbol und einen Text in der Type-Spalte in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp Fehler, Warnung, Information, Erfolgs Überwachung oder Fehlerüberwachung ist.  
  
 Sie müssen die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft für die <xref:System.Diagnostics.EventLog> Komponente festlegen, bevor Sie Einträge in das Protokoll schreiben können. Vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren.  
  
 Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Wenn die Quelle, die in der <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft dieser <xref:System.Diagnostics.EventLog> Instanz angegeben ist, nicht auf dem Computer registriert ist, auf den die Komponente schreibt, ruft <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.CreateEventSource%2A> auf und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie keine <xref:System.Diagnostics.EventLog.MachineName%2A> für die <xref:System.Diagnostics.EventLog>-Instanz angeben, bevor Sie <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>aufgerufen haben, wird der lokale Computer (".") angenommen.  
  
 Wenn das System die <xref:System.Diagnostics.EventLog.Source%2A> über einen <xref:System.Diagnostics.EventLog.WriteEntry%2A> registrieren muss und die <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft für Ihre <xref:System.Diagnostics.EventLog> Instanz nicht festgelegt wurde, wird das Protokollstandard mäßig auf das Anwendungsprotokoll festgelegt.  
  
> [!NOTE]
>  Viele oben aufgeführte Ausnahmen werden durch Fehler generiert, die während der Registrierung der <xref:System.Diagnostics.EventLog.Source%2A>ausgelöst wurden.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll. Es wird keine lokalisierbare Nachrichten Ressourcen Datei verwendet. Verwenden Sie die <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Ereignisse mithilfe einer lokalisierten Nachrichten Ressourcen Datei zu schreiben.  
  
 Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag auf einen Remote Computer schreiben, entspricht der Wert der Meldung (die Text Zeichenfolge) möglicherweise nicht Ihren Erwartungen, wenn der Remote Computer die .NET Framework nicht ausgeführt hat.  
  
> [!NOTE]
>  Wenn der `message`-Parameter ein NUL-Zeichen enthält, wird die Nachricht im Ereignisprotokoll mit dem NUL-Zeichen beendet.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" />-Eigenschaft von <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
- oder - 
Die Methode hat versucht, eine neue Ereignisquelle zu registrieren, der Computername in <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist jedoch ungültig.  
  
- oder - 
Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
- oder - 
 <paramref name="eventID" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
- oder - 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <summary>Schreibt einen Eintrag für einen Fehler, eine Warnung, eine Information oder eine Erfolgs- oder Fehlerüberwachung mit dem angegebenen Meldungstext in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen Eintrag eines angegebenen <xref:System.Diagnostics.EventLogEntryType> in das Ereignisprotokoll zu schreiben, wobei eine Quelle verwendet wird, die bereits als Ereignis Quelle für das entsprechende Protokoll registriert ist. Der `type` wird durch ein Symbol und einen Text in der Type-Spalte in der Ereignisanzeige für ein Protokoll angegeben.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf nicht%*n*enthalten, wobei *n* ein ganzzahliger Wert (z. b. %1) ist, da Sie in der Ereignisanzeige als Einfügezeichenfolge behandelt wird. Da eine IPv6-Adresse (Internet Protocol, Version 6) diese Zeichenfolge enthalten kann, können Sie keine Ereignismeldung protokollieren, die eine IPv6-Adresse enthält.  
  
 Vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren. Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll. Es wird keine lokalisierbare Nachrichten Ressourcen Datei verwendet. Verwenden Sie die <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Ereignisse mithilfe einer lokalisierten Nachrichten Ressourcen Datei zu schreiben.  
  
 Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
> [!NOTE]
>  Wenn der `message`-Parameter ein NUL-Zeichen enthält, wird die Nachricht im Ereignisprotokoll mit dem NUL-Zeichen beendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Warn Eintrag auf dem lokalen Computer in das Ereignisprotokoll "MyNewLog" geschrieben.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Wert ist eine leere Zeichenfolge ("").  
  
- oder - 
Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
- oder - 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <param name="category">Die der Meldung zugeordnete anwendungsspezifische Unterkategorie.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext, dem von der Anwendung definierten Ereignisbezeichner und der Kategorie in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen Eintrag mit einem Anwendungs definierten `category` in das Ereignisprotokoll zu schreiben. Der Ereignisanzeige verwendet die Kategorie zum Filtern von Ereignissen, die von einer Ereignis Quelle geschrieben wurden. Der Ereignisanzeige kann die Kategorie als numerischen Wert anzeigen, oder die Kategorie kann als Ressourcen Bezeichner verwendet werden, um eine lokalisierte Kategoriezeichenfolge anzuzeigen.  
  
> [!NOTE]
>  Der `category`-Parameter muss ein positiver Wert sein. Negative Kategoriewerte werden als ergänzende positive Zahl in der Ereignisanzeige angezeigt. Beispielsweise wird a-10 als 65.526, a-1 als 65.535 angezeigt.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf nicht%*n*enthalten, wobei *n* ein ganzzahliger Wert (z. b. %1) ist, da Sie in der Ereignisanzeige als Einfügezeichenfolge behandelt wird. Da eine IPv6-Adresse (Internet Protocol, Version 6) diese Zeichenfolge enthalten kann, können Sie keine Ereignismeldung protokollieren, die eine IPv6-Adresse enthält.  
  
 Wenn Sie im Ereignisanzeige lokalisierte Kategoriezeichenfolgen anzeigen möchten, müssen Sie eine mit einer Kategorieressourcendatei konfigurierte Ereignis Quelle verwenden und die `category` auf einen Ressourcen Bezeichner in der Ressourcen Datei der Kategorie festlegen. Wenn die Ereignis Quelle nicht über eine konfigurierte Kategorieressourcendatei verfügt oder wenn die angegebene `category` keine Zeichenfolge in der Ressourcen Datei der Kategorie indiziert, zeigt der Ereignisanzeige den Wert der numerischen Kategorie für diesen Eintrag an. Konfigurieren Sie die Kategorieressourcendatei und die Anzahl der Kategoriezeichenfolgen in der Ressourcen Datei mithilfe der <xref:System.Diagnostics.EventLogInstaller> oder der <xref:System.Diagnostics.EventSourceCreationData>-Klasse.  
  
 Zusätzlich zur Kategorie können Sie einen Ereignis Bezeichner für das Ereignis angeben, das in das Ereignisprotokoll geschrieben wird. Ereignis Bezeichner identifizieren zusammen mit der Ereignis Quelle ein Ereignis eindeutig. Jede Anwendung kann Ihre eigenen nummerierten Ereignisse und die Beschreibungs Zeichenfolgen definieren, denen Sie zugeordnet sind. Ereignis Betrachter zeigen diese Zeichen folgen Werte an, um dem Benutzer zu helfen, herauszufinden, was schief gelaufen ist, und die auszuführenden Aktionen vorzuschlagen.  
  
 Schließlich können Sie eine <xref:System.Diagnostics.EventLogEntryType> für das Ereignis angeben, das in das Ereignisprotokoll geschrieben wird. Der `type` wird durch ein Symbol und einen Text in der Type-Spalte in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp Fehler, Warnung, Information, Erfolgs Überwachung oder Fehlerüberwachung ist.  
  
 Sie müssen die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft für die <xref:System.Diagnostics.EventLog> Komponente festlegen, bevor Sie Einträge in das Protokoll schreiben können. Vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren.  
  
 Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Wenn die Quelle, die in der <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft dieser <xref:System.Diagnostics.EventLog> Instanz angegeben ist, nicht auf dem Computer registriert ist, auf den die Komponente schreibt, ruft <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.CreateEventSource%2A> auf und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie keine <xref:System.Diagnostics.EventLog.MachineName%2A> für die <xref:System.Diagnostics.EventLog>-Instanz angeben, bevor Sie <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>aufgerufen haben, wird der lokale Computer (".") angenommen.  
  
 Wenn das System die <xref:System.Diagnostics.EventLog.Source%2A> über einen <xref:System.Diagnostics.EventLog.WriteEntry%2A> registrieren muss und die <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft für Ihre <xref:System.Diagnostics.EventLog> Instanz nicht festgelegt wurde, wird das Protokollstandard mäßig auf das Anwendungsprotokoll festgelegt.  
  
> [!NOTE]
>  Viele oben aufgeführte Ausnahmen werden durch Fehler generiert, die während der Registrierung der <xref:System.Diagnostics.EventLog.Source%2A>ausgelöst wurden.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll. Es wird keine lokalisierbare Nachrichten Ressourcen Datei verwendet. Verwenden Sie die <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Ereignisse mithilfe einer lokalisierten Nachrichten Ressourcen Datei zu schreiben.  
  
 Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag auf einen Remote Computer schreiben, entspricht der Wert der Meldung (die Text Zeichenfolge) möglicherweise nicht Ihren Erwartungen, wenn der Remote Computer die .NET Framework nicht ausgeführt hat.  
  
> [!NOTE]
>  Wenn der `message`-Parameter ein NUL-Zeichen enthält, wird die Nachricht im Ereignisprotokoll mit dem NUL-Zeichen beendet.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" />-Eigenschaft von <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
- oder - 
Die Methode hat versucht, eine neue Ereignisquelle zu registrieren, der Computername in <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist jedoch ungültig.  
  
- oder - 
Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
- oder - 
 <paramref name="eventID" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
- oder - 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext und dem von der Anwendung definierten Ereignisbezeichner in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen Eintrag mit einem Anwendungs definierten `eventID` in das Ereignisprotokoll zu schreiben, wobei eine Quelle verwendet wird, die bereits als Ereignis Quelle für das entsprechende Protokoll registriert ist. Mit dem `eventID`wird zusammen mit der Quelle ein Ereignis eindeutig identifiziert. Jede Anwendung kann Ihre eigenen nummerierten Ereignisse und die Beschreibungs Zeichenfolgen definieren, denen Sie zugeordnet sind. Ereignis-Viewer zeigen diese Zeichen folgen dem Benutzer an, um dem Benutzer zu helfen, herauszufinden, was schief gelaufen ist, und die zu übergreifenden Maßnahmen vorzuschlagen.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf nicht%*n*enthalten, wobei *n* ein ganzzahliger Wert (z. b. %1) ist, da Sie in der Ereignisanzeige als Einfügezeichenfolge behandelt wird. Da eine IPv6-Adresse (Internet Protocol, Version 6) diese Zeichenfolge enthalten kann, können Sie keine Ereignismeldung protokollieren, die eine IPv6-Adresse enthält.  
  
 Zusätzlich zum Ereignis Bezeichner können Sie mit dieser Überladung von <xref:System.Diagnostics.EventLog.WriteEntry%2A> eine <xref:System.Diagnostics.EventLogEntryType> für das Ereignis angeben, das in das Ereignisprotokoll geschrieben wird. Der `type` wird durch ein Symbol und einen Text in der Type-Spalte in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp Fehler, Warnung, Information, Erfolgs Überwachung oder Fehlerüberwachung ist.  
  
 Vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren. Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll. Es wird keine lokalisierbare Nachrichten Ressourcen Datei verwendet. Verwenden Sie die <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Ereignisse mithilfe einer lokalisierten Nachrichten Ressourcen Datei zu schreiben.  
  
 Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
> [!NOTE]
>  Wenn der `message`-Parameter ein NUL-Zeichen enthält, wird die Nachricht im Ereignisprotokoll mit dem NUL-Zeichen beendet.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Wert ist eine leere Zeichenfolge ("").  
  
- oder - 
Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
- oder - 
 <paramref name="eventID" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
- oder - 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <param name="category">Die der Meldung zugeordnete anwendungsspezifische Unterkategorie.</param>
        <param name="rawData">Ein Bytearray mit den dem Eintrag zugeordneten Binärdaten.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext, dem von der Anwendung definierten Ereignisbezeichner und der Kategorie in das Ereignisprotokoll und fügt Binärdaten an die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um Anwendungs definierte ereignisspezifische Daten in das Ereignisprotokoll zu schreiben. Die Ereignisanzeige interpretiert diese Daten nicht. Rohdaten werden nur in einem kombinierten Hexadezimal-und Textformat angezeigt. Verwenden Sie ereignisspezifische Daten sparsam, darunter auch, wenn Sie sicher sind, dass es für jemanden nützlich sein wird, das das Problem zu debuggen. Sie können auch ereignisspezifische Daten verwenden, um Informationen zu speichern, die von der Anwendung unabhängig vom Ereignisanzeige verarbeitet werden können. Beispielsweise können Sie einen Viewer speziell für Ihre Ereignisse schreiben oder ein Programm schreiben, das die Protokolldatei scannt und Berichte erstellt, die Informationen aus den ereignisspezifischen Daten enthalten.  
  
 Zusätzlich zu den Binärdaten können Sie eine Anwendungs definierte Kategorie und einen Anwendungs definierten Ereignis Bezeichner angeben. Der Ereignisanzeige verwendet die Kategorie zum Filtern von Ereignissen, die von einer Ereignis Quelle geschrieben wurden. Der Ereignisanzeige kann die Kategorie als numerischen Wert anzeigen, oder die Kategorie kann als Ressourcen Bezeichner verwendet werden, um eine lokalisierte Kategoriezeichenfolge anzuzeigen.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf nicht%*n*enthalten, wobei *n* ein ganzzahliger Wert (z. b. %1) ist, da Sie in der Ereignisanzeige als Einfügezeichenfolge behandelt wird. Da eine IPv6-Adresse (Internet Protocol, Version 6) diese Zeichenfolge enthalten kann, können Sie keine Ereignismeldung protokollieren, die eine IPv6-Adresse enthält.  
  
> [!NOTE]
>  Der `category`-Parameter muss ein positiver Wert sein. Negative Kategoriewerte werden als ergänzende positive Zahl in der Ereignisanzeige angezeigt. Beispielsweise wird a-10 als 65.526, a-1 als 65.535 angezeigt.  
  
 Wenn Sie im Ereignisanzeige lokalisierte Kategoriezeichenfolgen anzeigen möchten, müssen Sie eine mit einer Kategorieressourcendatei konfigurierte Ereignis Quelle verwenden und die `category` auf einen Ressourcen Bezeichner in der Ressourcen Datei der Kategorie festlegen. Wenn die Ereignis Quelle nicht über eine konfigurierte Kategorieressourcendatei verfügt oder wenn die angegebene `category` keine Zeichenfolge in der Ressourcen Datei der Kategorie indiziert, zeigt der Ereignisanzeige den Wert der numerischen Kategorie für diesen Eintrag an. Konfigurieren Sie die Kategorieressourcendatei und die Anzahl der Kategoriezeichenfolgen in der Ressourcen Datei mithilfe der <xref:System.Diagnostics.EventLogInstaller> oder der <xref:System.Diagnostics.EventSourceCreationData>-Klasse.  
  
 Ereignis Bezeichner identifizieren zusammen mit der Ereignis Quelle ein Ereignis eindeutig. Jede Anwendung kann Ihre eigenen nummerierten Ereignisse und die Beschreibungs Zeichenfolgen definieren, denen Sie zugeordnet sind. Ereignis Betrachter zeigen diese Zeichen folgen Werte an, um dem Benutzer zu helfen, herauszufinden, was schief gelaufen ist, und die auszuführenden Aktionen vorzuschlagen.  
  
 Schließlich können Sie eine <xref:System.Diagnostics.EventLogEntryType> für das Ereignis angeben, das in das Ereignisprotokoll geschrieben wird. Der `type` wird durch ein Symbol und einen Text in der Type-Spalte in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp Fehler, Warnung, Information, Erfolgs Überwachung oder Fehlerüberwachung ist.  
  
 Sie müssen die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft für die <xref:System.Diagnostics.EventLog> Komponente festlegen, bevor Sie Einträge in das Protokoll schreiben können. Vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren.  
  
 Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Wenn die Quelle, die in der <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft dieser <xref:System.Diagnostics.EventLog> Instanz angegeben ist, nicht auf dem Computer registriert ist, auf den die Komponente schreibt, ruft <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.CreateEventSource%2A> auf und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie keine <xref:System.Diagnostics.EventLog.MachineName%2A> für die <xref:System.Diagnostics.EventLog>-Instanz angeben, bevor Sie <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>aufgerufen haben, wird der lokale Computer (".") angenommen.  
  
 Wenn das System die <xref:System.Diagnostics.EventLog.Source%2A> über einen <xref:System.Diagnostics.EventLog.WriteEntry%2A> registrieren muss und die <xref:System.Diagnostics.EventLog.Log%2A>-Eigenschaft für Ihre <xref:System.Diagnostics.EventLog> Instanz nicht festgelegt wurde, wird das Protokollstandard mäßig auf das Anwendungsprotokoll festgelegt.  
  
> [!NOTE]
>  Viele oben aufgeführte Ausnahmen werden durch Fehler generiert, die während der Registrierung der <xref:System.Diagnostics.EventLog.Source%2A>ausgelöst wurden.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll. Es wird keine lokalisierbare Nachrichten Ressourcen Datei verwendet. Verwenden Sie die <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Ereignisse mithilfe einer lokalisierten Nachrichten Ressourcen Datei zu schreiben.  
  
 Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag auf einen Remote Computer schreiben, entspricht der Wert der Meldung (die Text Zeichenfolge) möglicherweise nicht Ihren Erwartungen, wenn der Remote Computer die .NET Framework nicht ausgeführt hat.  
  
> [!NOTE]
>  Wenn der `message`-Parameter ein NUL-Zeichen enthält, wird die Nachricht im Ereignisprotokoll mit dem NUL-Zeichen beendet.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" />-Eigenschaft von <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
- oder - 
Die Methode hat versucht, eine neue Ereignisquelle zu registrieren, der Computername in <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist jedoch ungültig.  
  
- oder - 
Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
- oder - 
 <paramref name="eventID" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
- oder - 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <param name="category">Die der Meldung zugeordnete anwendungsspezifische Unterkategorie.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext, dem von der Anwendung definierten Ereignisbezeichner und der Kategorie in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird. Anhand der <paramref name="category" /> kann die Ereignisanzeige Ereignisse im Protokoll filtern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen Eintrag mit einem Anwendungs definierten `category` in das Ereignisprotokoll zu schreiben, wobei eine Quelle verwendet wird, die bereits als Ereignis Quelle für das entsprechende Protokoll registriert ist. Der Ereignisanzeige verwendet die Kategorie zum Filtern von Ereignissen, die von einer Ereignis Quelle geschrieben wurden. Der Ereignisanzeige kann die Kategorie als numerischen Wert anzeigen, oder die Kategorie kann als Ressourcen Bezeichner verwendet werden, um eine lokalisierte Kategoriezeichenfolge anzuzeigen.  
  
> [!NOTE]
>  Der `category`-Parameter muss ein positiver Wert sein. Negative Kategoriewerte werden als ergänzende positive Zahl in der Ereignisanzeige angezeigt. Beispielsweise wird a-10 als 65.526, a-1 als 65.535 angezeigt.  
  
 Wenn Sie im Ereignisanzeige lokalisierte Kategoriezeichenfolgen anzeigen möchten, müssen Sie eine mit einer Kategorieressourcendatei konfigurierte Ereignis Quelle verwenden und die `category` auf einen Ressourcen Bezeichner in der Ressourcen Datei der Kategorie festlegen. Wenn die Ereignis Quelle nicht über eine konfigurierte Kategorieressourcendatei verfügt oder wenn die angegebene `category` keine Zeichenfolge in der Ressourcen Datei der Kategorie indiziert, zeigt der Ereignisanzeige den Wert der numerischen Kategorie für diesen Eintrag an. Konfigurieren Sie die Kategorieressourcendatei und die Anzahl der Kategoriezeichenfolgen in der Ressourcen Datei mithilfe der <xref:System.Diagnostics.EventLogInstaller> oder der <xref:System.Diagnostics.EventSourceCreationData>-Klasse.  
  
 Zusätzlich zur Kategorie können Sie einen Ereignis Bezeichner für das Ereignis angeben, das in das Ereignisprotokoll geschrieben wird. Ereignis Bezeichner identifizieren zusammen mit der Ereignis Quelle ein Ereignis eindeutig. Jede Anwendung kann Ihre eigenen nummerierten Ereignisse und die Beschreibungs Zeichenfolgen definieren, denen Sie zugeordnet sind. Ereignis Betrachter zeigen diese Zeichen folgen Werte an, um dem Benutzer zu helfen, herauszufinden, was schief gelaufen ist, und die auszuführenden Aktionen vorzuschlagen.  
  
 Schließlich können Sie eine <xref:System.Diagnostics.EventLogEntryType> für das Ereignis angeben, das in das Ereignisprotokoll geschrieben wird. Der `type` wird durch ein Symbol und einen Text in der Type-Spalte in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp Fehler, Warnung, Information, Erfolgs Überwachung oder Fehlerüberwachung ist.  
  
 Vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren. Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll. Es wird keine lokalisierbare Nachrichten Ressourcen Datei verwendet. Verwenden Sie die <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Ereignisse mithilfe einer lokalisierten Nachrichten Ressourcen Datei zu schreiben.  
  
 Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
> [!NOTE]
>  Wenn der `message`-Parameter ein NUL-Zeichen enthält, wird die Nachricht im Ereignisprotokoll mit dem NUL-Zeichen beendet.  
>   
>  Die `message` Zeichenfolge darf nicht%*n*enthalten, wobei *n* ein ganzzahliger Wert (z. b. %1) ist, da Sie in der Ereignisanzeige als Einfügezeichenfolge behandelt wird. Da eine IPv6-Adresse (Internet Protocol, Version 6) diese Zeichenfolge enthalten kann, können Sie keine Ereignismeldung protokollieren, die eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Wert ist eine leere Zeichenfolge ("").  
  
- oder - 
Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
- oder - 
 <paramref name="eventID" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
- oder - 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <param name="category">Die der Meldung zugeordnete anwendungsspezifische Unterkategorie.</param>
        <param name="rawData">Ein Bytearray mit den dem Eintrag zugeordneten Binärdaten.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext, dem von der Anwendung definierten Ereignisbezeichner und der Kategorie in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird, und fügt Binärdaten an die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um Anwendungs definierte ereignisspezifische Daten in das Ereignisprotokoll zu schreiben, wobei eine Quelle verwendet wird, die bereits als Ereignis Quelle für das entsprechende Protokoll registriert ist. Die Ereignisanzeige interpretiert diese Daten nicht. Rohdaten werden nur in einem kombinierten Hexadezimal-und Textformat angezeigt. Verwenden Sie ereignisspezifische Daten sparsam. Fügen Sie Sie nur ein, wenn Sie sicher sind, dass Sie nützlich sein wird. Sie können auch ereignisspezifische Daten verwenden, um Informationen zu speichern, die von der Anwendung unabhängig vom Ereignisanzeige verarbeitet werden können. Beispielsweise können Sie einen Viewer speziell für Ihre Ereignisse schreiben oder ein Programm schreiben, das die Protokolldatei scannt und Berichte erstellt, die Informationen aus den ereignisspezifischen Daten enthalten.  
  
 Zusätzlich zu den Binärdaten können Sie eine Anwendungs definierte Kategorie und einen Anwendungs definierten Ereignis Bezeichner angeben. Der Ereignisanzeige verwendet die Kategorie zum Filtern von Ereignissen, die von einer Ereignis Quelle geschrieben wurden. Der Ereignisanzeige kann die Kategorie als numerischen Wert anzeigen, oder die Kategorie kann als Ressourcen Bezeichner verwendet werden, um eine lokalisierte Kategoriezeichenfolge anzuzeigen.  
  
> [!NOTE]
>  Der `category`-Parameter muss ein positiver Wert sein. Negative Kategoriewerte werden als ergänzende positive Zahl in der Ereignisanzeige angezeigt. Beispielsweise wird a-10 als 65.526, a-1 als 65.535 angezeigt.  
  
 Wenn Sie im Ereignisanzeige lokalisierte Kategoriezeichenfolgen anzeigen möchten, müssen Sie eine mit einer Kategorieressourcendatei konfigurierte Ereignis Quelle verwenden und die `category` auf einen Ressourcen Bezeichner in der Ressourcen Datei der Kategorie festlegen. Wenn die Ereignis Quelle nicht über eine konfigurierte Kategorieressourcendatei verfügt oder wenn die angegebene `category` keine Zeichenfolge in der Ressourcen Datei der Kategorie indiziert, zeigt der Ereignisanzeige den Wert der numerischen Kategorie für diesen Eintrag an. Konfigurieren Sie die Kategorieressourcendatei und die Anzahl der Kategoriezeichenfolgen in der Ressourcen Datei mithilfe der <xref:System.Diagnostics.EventLogInstaller> oder der <xref:System.Diagnostics.EventSourceCreationData>-Klasse.  
  
 Ereignis Bezeichner identifizieren in Verbindung mit der Ereignis Quelle ein Ereignis eindeutig. Jede Anwendung kann Ihre eigenen nummerierten Ereignisse und die Beschreibungs Zeichenfolgen definieren, denen Sie zugeordnet sind. Ereignis Betrachter zeigen diese Zeichen folgen Werte an, um dem Benutzer zu helfen, herauszufinden, was schief gelaufen ist, und die auszuführenden Aktionen vorzuschlagen.  
  
 Schließlich können Sie eine <xref:System.Diagnostics.EventLogEntryType> für das Ereignis angeben, das in das Ereignisprotokoll geschrieben wird. Der `type` wird durch ein Symbol und einen Text in der Type-Spalte in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp Fehler, Warnung, Information, Erfolgs Überwachung oder Fehlerüberwachung ist.  
  
 Vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren. Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll. Es wird keine lokalisierbare Nachrichten Ressourcen Datei verwendet. Verwenden Sie die <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Ereignisse mithilfe einer lokalisierten Nachrichten Ressourcen Datei zu schreiben.  
  
 Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
> [!NOTE]
>  Wenn der `message`-Parameter ein NUL-Zeichen enthält, wird die Nachricht im Ereignisprotokoll mit dem NUL-Zeichen beendet.  
>   
>  Die `message` Zeichenfolge darf nicht%*n*enthalten, wobei *n* ein ganzzahliger Wert (z. b. %1) ist, da Sie in der Ereignisanzeige als Einfügezeichenfolge behandelt wird. Da eine IPv6-Adresse (Internet Protocol, Version 6) diese Zeichenfolge enthalten kann, können Sie keine Ereignismeldung protokollieren, die eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Wert ist eine leere Zeichenfolge ("").  
  
- oder - 
Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
- oder - 
 <paramref name="eventID" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
- oder - 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt einen lokalisierten Ereigniseintrag in das Ereignisprotokoll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Eine <see cref="T:System.Diagnostics.EventInstance" />-Instanz, die einen lokalisierten Ereignisprotokolleintrag darstellt.</param>
        <param name="values">Ein Array von Zeichenfolgen, die mit dem Meldungstext des Ereignisprotokolleintrags zusammengeführt werden sollen.</param>
        <summary>Schreibt einen lokalisierten Eintrag in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen lokalisierten Eintrag in das Ereignisprotokoll zu schreiben. Sie geben die Ereignis Eigenschaften mit Ressourcen bezeichmern anstelle von Zeichen folgen Werten an. Der Ereignisanzeige verwendet die Ressourcen Bezeichner, um die entsprechenden Zeichen folgen aus der lokalisierten Ressourcen Datei für die <xref:System.Diagnostics.EventLog.Source%2A>anzuzeigen. Sie müssen die Quelle mit der entsprechenden Ressourcen Datei registrieren, bevor Sie Ereignisse mithilfe von Ressourcen bezeichgern schreiben.  
  
 Die Eingabe `instance` Instanz gibt die Ereignismeldung und die Eigenschaften an. Legen Sie den <xref:System.Diagnostics.EventInstance.InstanceId%2A> der `instance` Eingabe für die definierte Nachricht in der Ressourcen Datei der Quell Nachricht fest. Sie können optional die <xref:System.Diagnostics.EventInstance.CategoryId%2A> und <xref:System.Diagnostics.EventInstance.EntryType%2A> der `instance` Eingabe festlegen, um die Kategorie und den Ereignistyp des Ereignis Eintrags zu definieren. Sie können auch ein Array von sprachunabhängigen Zeichen folgen angeben, das in den lokalisierten Nachrichtentext eingefügt werden soll. Legen Sie `values` auf `null` fest, wenn die Ereignismeldung keine Formatierungs Platzhalter für Ersatz Zeichenfolgen enthält.  
  
 Vor der Verwendung von <xref:System.Diagnostics.EventLog.WriteEvent%2A>müssen Sie die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft für die <xref:System.Diagnostics.EventLog> Komponente festlegen. Die angegebene Quelle muss konfiguriert werden, damit lokalisierte Einträge in das Protokoll geschrieben werden. die Quelle muss mindestens über eine definierte Nachrichten Ressourcen Datei verfügen.  
  
 Vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren. Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Verwenden Sie die <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, wenn die Anwendung Zeichen folgen Werte direkt in das Ereignisprotokoll schreibt.  
  
 Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag auf einen Remote Computer schreiben, entspricht der Wert der `message` Zeichenfolge möglicherweise nicht Ihren Erwartungen, wenn auf dem Remote Computer die .NET Framework nicht ausgeführt wird. Außerdem darf die `message` Zeichenfolge%*n*nicht enthalten, wobei *n* ein ganzzahliger Wert (z. b. %1) ist, weil die Ereignisanzeige ihn als Einfügezeichenfolge behandelt. Da eine IPv6-Adresse (Internet Protocol, Version 6) diese Zeichenfolge enthalten kann, können Sie keine Ereignismeldung protokollieren, die eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei Überwachungs Einträge in das Ereignisprotokoll `myNewLog`geschrieben. Im Beispiel werden eine neue Ereignis Quelle und ein neues Ereignisprotokoll erstellt, wenn Sie auf dem lokalen Computer nicht vorhanden sind. Der Text der Ereignismeldung wird mithilfe eines Ressourcen Bezeichners in einer Ressourcen Datei angegeben.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 Im Beispiel wird die folgende Meldungs Textdatei verwendet, die in die Ressourcen Bibliothek EventLogMsgs. dll integriert ist. Eine Meldungs Textdatei ist die Quelle, aus der die Nachrichten Ressourcen Datei erstellt wird. Die Meldungs Textdatei definiert die Ressourcen Bezeichner und den Text für die Kategorie, die Ereignismeldung und die Parameter Einfügezeichenfolgen.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" />-Eigenschaft von <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
- oder - 
Die Methode hat versucht, eine neue Ereignisquelle zu registrieren, der Computername in <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist jedoch ungültig.  
  
- oder - 
Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
- oder - 
 <paramref name="instance.InstanceId" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
- oder - 
 <paramref name="values" /> enthält mehr als 256 Elemente.  
  
- oder - 
Eines der <paramref name="values" />-Elemente ist länger als 32.766 Bytes.  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Eine <see cref="T:System.Diagnostics.EventInstance" />-Instanz, die einen lokalisierten Ereignisprotokolleintrag darstellt.</param>
        <param name="data">Ein Bytearray mit den dem Eintrag zugeordneten Binärdaten.</param>
        <param name="values">Ein Array von Zeichenfolgen, die mit dem Meldungstext des Ereignisprotokolleintrags zusammengeführt werden sollen.</param>
        <summary>Schreibt einen Ereignisprotokolleintrag mit den angegebenen Ereignisdaten, Meldungsersetzungszeichenfolgen und zugeordneten Binärdaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen lokalisierten Eintrag mit zusätzlichen ereignisspezifischen Daten in das Ereignisprotokoll zu schreiben. Sie geben die Ereignis Eigenschaften mit Ressourcen bezeichmern anstelle von Zeichen folgen Werten an. Der Ereignisanzeige verwendet die Ressourcen Bezeichner, um die entsprechenden Zeichen folgen aus der lokalisierten Ressourcen Datei für die <xref:System.Diagnostics.EventLog.Source%2A>anzuzeigen. Sie müssen die Quelle mit der entsprechenden Ressourcen Datei registrieren, bevor Sie Ereignisse mithilfe von Ressourcen bezeichgern schreiben.  
  
 Die Eingabe `instance` Instanz gibt die Ereignismeldung und die Eigenschaften an. Legen Sie den <xref:System.Diagnostics.EventInstance.InstanceId%2A> der `instance` Eingabe für die definierte Nachricht in der Ressourcen Datei der Quell Nachricht fest. Sie können optional die <xref:System.Diagnostics.EventInstance.CategoryId%2A> und <xref:System.Diagnostics.EventInstance.EntryType%2A> der `instance` Eingabe festlegen, um die Kategorie und den Ereignistyp des Ereignis Eintrags zu definieren. Sie können auch ein Array von sprachunabhängigen Zeichen folgen angeben, das in den lokalisierten Nachrichtentext eingefügt werden soll. Legen Sie `values` auf `null` fest, wenn die Ereignismeldung keine Formatierungs Platzhalter für Ersatz Zeichenfolgen enthält.  
  
 Geben Sie Binärdaten mit einem Ereignis an, wenn es erforderlich ist, zusätzliche Details für das Ereignis bereitzustellen. Verwenden Sie z. b. den `data`-Parameter, um Informationen zu einem bestimmten Fehler einzuschließen. Der Ereignisanzeige interpretiert die zugeordneten Ereignisdaten nicht. die Daten werden in einem kombinierten Hexadezimal-und Textformat angezeigt. Verwenden Sie ereignisspezifische Daten sparsam. Fügen Sie Sie nur ein, wenn Sie sicher sind, dass Sie nützlich sein wird. Sie können auch ereignisspezifische Daten verwenden, um Informationen zu speichern, die von der Anwendung unabhängig vom Ereignisanzeige verarbeitet werden können. Beispielsweise können Sie einen Viewer speziell für Ihre Ereignisse schreiben oder ein Programm schreiben, das das Ereignisprotokoll scannt und Berichte erstellt, die Informationen aus den ereignisspezifischen Daten enthalten.  
  
 Vor der Verwendung von <xref:System.Diagnostics.EventLog.WriteEvent%2A>müssen Sie die <xref:System.Diagnostics.EventLog.Source%2A>-Eigenschaft für die <xref:System.Diagnostics.EventLog> Komponente vor der Komponente festlegen. Die angegebene Quelle muss konfiguriert werden, damit lokalisierte Einträge in das Protokoll geschrieben werden. die Quelle muss mindestens über eine definierte Nachrichten Ressourcen Datei verfügen.  
  
 Vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren. Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
> [!NOTE]
>  Wenn Sie keine <xref:System.Diagnostics.EventLog.MachineName%2A> für die <xref:System.Diagnostics.EventLog>-Instanz angeben, bevor Sie <xref:System.Diagnostics.EventLog.WriteEvent%2A>aufgerufen haben, wird der lokale Computer (".") angenommen.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Verwenden Sie die <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, wenn die Anwendung Zeichen folgen Werte direkt in das Ereignisprotokoll schreibt.  
  
 Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag auf einen Remote Computer schreiben, entspricht der Wert der `message` Zeichenfolge möglicherweise nicht Ihren Erwartungen, wenn auf dem Remote Computer die .NET Framework nicht ausgeführt wird. Außerdem darf die `message` Zeichenfolge%*n*nicht enthalten, wobei *n* ein ganzzahliger Wert (z. b. %1) ist, weil die Ereignisanzeige ihn als Einfügezeichenfolge behandelt. Da eine IPv6-Adresse (Internet Protocol, Version 6) diese Zeichenfolge enthalten kann, können Sie keine Ereignismeldung protokollieren, die eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei Überwachungs Einträge in das Ereignisprotokoll `myNewLog`geschrieben. Im Beispiel werden eine neue Ereignis Quelle und ein neues Ereignisprotokoll erstellt, wenn Sie auf dem lokalen Computer nicht vorhanden sind. Der Text der Ereignismeldung wird mithilfe eines Ressourcen Bezeichners in einer Ressourcen Datei angegeben.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 Im Beispiel wird die folgende Meldungs Textdatei verwendet, die in die Ressourcen Bibliothek EventLogMsgs. dll integriert ist. Eine Meldungs Textdatei ist die Quelle, aus der die Nachrichten Ressourcen Datei erstellt wird. Die Meldungs Textdatei definiert die Ressourcen Bezeichner und den Text für die Kategorie, die Ereignismeldung und die Parameter Einfügezeichenfolgen.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" />-Eigenschaft von <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
- oder - 
Die Methode hat versucht, eine neue Ereignisquelle zu registrieren, der Computername in <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist jedoch ungültig.  
  
- oder - 
Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
- oder - 
 <paramref name="instance.InstanceId" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
- oder - 
 <paramref name="values" /> enthält mehr als 256 Elemente.  
  
- oder - 
Eines der <paramref name="values" />-Elemente ist länger als 32.766 Bytes.  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Der Name der für die Anwendung auf dem angegebenen Computer registrierten Ereignisquelle.</param>
        <param name="instance">Eine <see cref="T:System.Diagnostics.EventInstance" />-Instanz, die einen lokalisierten Ereignisprotokolleintrag darstellt.</param>
        <param name="values">Ein Array von Zeichenfolgen, die mit dem Meldungstext des Ereignisprotokolleintrags zusammengeführt werden sollen.</param>
        <summary>Schreibt unter Verwendung der angegebenen registrierten Ereignisquelle einen Ereignisprotokolleintrag mit den angegebenen Ereignisdaten und Meldungsersetzungszeichenfolgen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen lokalisierten Eintrag in das Ereignisprotokoll zu schreiben, wobei eine Quelle verwendet wird, die bereits als Ereignis Quelle für das entsprechende Protokoll registriert ist. Sie geben die Ereignis Eigenschaften mit Ressourcen bezeichmern anstelle von Zeichen folgen Werten an. Der Ereignisanzeige verwendet die Ressourcen Bezeichner, um die entsprechenden Zeichen folgen aus der lokalisierten Ressourcen Datei für die Quelle anzuzeigen. Sie müssen die Quelle mit der entsprechenden Ressourcen Datei registrieren, bevor Sie Ereignisse mithilfe von Ressourcen bezeichgern schreiben.  
  
 Die Eingabe `instance` Instanz gibt die Ereignismeldung und die Eigenschaften an. Legen Sie den <xref:System.Diagnostics.EventInstance.InstanceId%2A> der `instance` Eingabe für die definierte Nachricht in der Ressourcen Datei der Quell Nachricht fest. Sie können optional die <xref:System.Diagnostics.EventInstance.CategoryId%2A> und <xref:System.Diagnostics.EventInstance.EntryType%2A> der `instance` Eingabe festlegen, um die Kategorie und den Ereignistyp des Ereignis Eintrags zu definieren. Sie können auch ein Array von sprachunabhängigen Zeichen folgen angeben, das in den lokalisierten Nachrichtentext eingefügt werden soll. Legen Sie `values` auf `null` fest, wenn die Ereignismeldung keine Formatierungs Platzhalter für Ersatz Zeichenfolgen enthält.  
  
 Die angegebene Quelle muss vor der Verwendung von <xref:System.Diagnostics.EventLog.WriteEvent%2A>für ein Ereignisprotokoll registriert werden. Die angegebene Quelle muss konfiguriert werden, damit lokalisierte Einträge in das Protokoll geschrieben werden. die Quelle muss mindestens über eine definierte Nachrichten Ressourcen Datei verfügen.  
  
 Vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren. Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Verwenden Sie die <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, wenn die Anwendung Zeichen folgen Werte direkt in das Ereignisprotokoll schreibt.  
  
 Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
   
  
## Examples  
 Im folgenden Beispiel werden ein Informations Ereignis Eintrag und ein Warnungs Ereignis Eintrag in ein vorhandenes Ereignisprotokoll geschrieben. Der Text der Ereignismeldung wird mithilfe eines Ressourcen Bezeichners in einer Ressourcen Datei angegeben. Im Beispiel wird davon ausgegangen, dass die zugehörige Ressourcen Datei für die Quelle registriert wurde.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 Im Beispiel wird die folgende Meldungs Textdatei verwendet, die in die Ressourcen Bibliothek EventLogMsgs. dll integriert ist. Eine Meldungs Textdatei ist die Quelle, aus der die Nachrichten Ressourcen Datei erstellt wird. Die Meldungs Textdatei definiert die Ressourcen Bezeichner und den Text für die Kategorie, die Ereignismeldung und die Parameter Einfügezeichenfolgen.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Wert ist eine leere Zeichenfolge ("").  
  
- oder - 
Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
- oder - 
 <paramref name="instance.InstanceId" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
- oder - 
 <paramref name="values" /> enthält mehr als 256 Elemente.  
  
- oder - 
Eines der <paramref name="values" />-Elemente ist länger als 32.766 Bytes.  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Der Name der für die Anwendung auf dem angegebenen Computer registrierten Ereignisquelle.</param>
        <param name="instance">Eine <see cref="T:System.Diagnostics.EventInstance" />-Instanz, die einen lokalisierten Ereignisprotokolleintrag darstellt.</param>
        <param name="data">Ein Bytearray mit den dem Eintrag zugeordneten Binärdaten.</param>
        <param name="values">Ein Array von Zeichenfolgen, die mit dem Meldungstext des Ereignisprotokolleintrags zusammengeführt werden sollen.</param>
        <summary>Schreibt einen Ereignisprotokolleintrag mit den angegebenen Ereignisdaten, Meldungsersetzungszeichenfolgen und zugeordneten Binärdaten und unter Verwendung der angegebenen registrierten Ereignisquelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen lokalisierten Eintrag mit zusätzlichen ereignisspezifischen Daten in das Ereignisprotokoll zu schreiben, wobei eine Quelle verwendet wird, die bereits als Ereignis Quelle für das entsprechende Protokoll registriert ist. Sie geben die Ereignis Eigenschaften mit Ressourcen bezeichmern anstelle von Zeichen folgen Werten an. Der Ereignisanzeige verwendet die Ressourcen Bezeichner, um die entsprechenden Zeichen folgen aus der lokalisierten Ressourcen Datei für die Quelle anzuzeigen. Sie müssen die Quelle mit der entsprechenden Ressourcen Datei registrieren, bevor Sie Ereignisse mithilfe von Ressourcen bezeichgern schreiben.  
  
 Die Eingabe `instance` Instanz gibt die Ereignismeldung und die Eigenschaften an. Legen Sie den <xref:System.Diagnostics.EventInstance.InstanceId%2A> der `instance` Eingabe für die definierte Nachricht in der Ressourcen Datei der Quell Nachricht fest. Sie können optional die <xref:System.Diagnostics.EventInstance.CategoryId%2A> und <xref:System.Diagnostics.EventInstance.EntryType%2A> der `instance` Eingabe festlegen, um die Kategorie und den Ereignistyp des Ereignis Eintrags zu definieren. Sie können auch ein Array von sprachunabhängigen Zeichen folgen angeben, das in den lokalisierten Nachrichtentext eingefügt werden soll. Legen Sie `values` auf `null` fest, wenn die Ereignismeldung keine Formatierungs Platzhalter für Ersatz Zeichenfolgen enthält.  
  
 Geben Sie Binärdaten mit einem Ereignis an, wenn es erforderlich ist, zusätzliche Details für das Ereignis bereitzustellen. Verwenden Sie z. b. den `data`-Parameter, um Informationen zu einem bestimmten Fehler einzuschließen. Der Ereignisanzeige interpretiert die zugeordneten Ereignisdaten nicht. die Daten werden in einem kombinierten Hexadezimal-und Textformat angezeigt. Verwenden Sie ereignisspezifische Daten sparsam. Fügen Sie Sie nur ein, wenn Sie sicher sind, dass Sie nützlich sein wird. Sie können auch ereignisspezifische Daten verwenden, um Informationen zu speichern, die von der Anwendung unabhängig vom Ereignisanzeige verarbeitet werden können. Beispielsweise können Sie einen Viewer speziell für Ihre Ereignisse schreiben oder ein Programm schreiben, das das Ereignisprotokoll scannt und Berichte erstellt, die Informationen aus den ereignisspezifischen Daten enthalten.  
  
 Die angegebene Quelle muss vor der Verwendung von <xref:System.Diagnostics.EventLog.WriteEvent%2A>für ein Ereignisprotokoll registriert werden. Die angegebene Quelle muss konfiguriert werden, damit lokalisierte Einträge in das Protokoll geschrieben werden. die Quelle muss mindestens über eine definierte Nachrichten Ressourcen Datei verfügen.  
  
 Vor dem Schreiben des ersten Eintrags mit der Quelle müssen Sie die Ereignis Quelle erstellen und konfigurieren. Erstellen Sie die neue Ereignis Quelle während der Installation der Anwendung. Dies ermöglicht es dem Betriebssystem, die Liste der registrierten Ereignis Quellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem die Liste der Ereignis Quellen nicht aktualisiert hat und Sie versuchen, ein Ereignis mit der neuen Quelle zu schreiben, tritt beim Schreibvorgang ein Fehler auf. Sie können eine neue Quelle mithilfe eines <xref:System.Diagnostics.EventLogInstaller>oder mithilfe der <xref:System.Diagnostics.EventLog.CreateEventSource%2A>-Methode konfigurieren. Sie müssen über Administratorrechte auf dem Computer verfügen, um eine neue Ereignis Quelle zu erstellen.  
  
 Die Quelle muss entweder zum Schreiben lokalisierter Einträge oder zum Schreiben direkter Zeichen folgen konfiguriert werden. Verwenden Sie die <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, wenn die Anwendung Zeichen folgen Werte direkt in das Ereignisprotokoll schreibt.  
  
 Wenn Ihre Anwendung Einträge mithilfe von Ressourcen bezeichgern und Zeichen folgen Werten schreibt, müssen Sie zwei separate Quellen registrieren. Konfigurieren Sie z. b. eine Quelle mit Ressourcen Dateien, und verwenden Sie dann diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEvent%2A>-Methode, um Einträge mithilfe von Ressourcen bezeichlern in das Ereignisprotokoll zu schreiben. Erstellen Sie dann eine andere Quelle ohne Ressourcen Dateien, und verwenden Sie diese Quelle in der <xref:System.Diagnostics.EventLog.WriteEntry%2A>-Methode, um Zeichen folgen mithilfe dieser Quelle direkt in das Ereignisprotokoll zu schreiben.  
  
   
  
## Examples  
 Im folgenden Beispiel werden ein Informations Ereignis Eintrag und ein Warnungs Ereignis Eintrag in ein vorhandenes Ereignisprotokoll geschrieben. Der Text der Ereignismeldung wird mithilfe eines Ressourcen Bezeichners in einer Ressourcen Datei angegeben. Im Beispiel wird davon ausgegangen, dass die zugehörige Ressourcen Datei für die Quelle registriert wurde.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 Im Beispiel wird die folgende Meldungs Textdatei verwendet, die in die Ressourcen Bibliothek EventLogMsgs. dll integriert ist. Eine Meldungs Textdatei ist die Quelle, aus der die Nachrichten Ressourcen Datei erstellt wird. Die Meldungs Textdatei definiert die Ressourcen Bezeichner und den Text für die Kategorie, die Ereignismeldung und die Parameter Einfügezeichenfolgen.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Wert ist eine leere Zeichenfolge ("").  
  
- oder - 
Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
- oder - 
 <paramref name="instance.InstanceId" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
- oder - 
 <paramref name="values" /> enthält mehr als 256 Elemente.  
  
- oder - 
Eines der <paramref name="values" />-Elemente ist länger als 32.766 Bytes.  
  
- oder - 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokoll Informationen auf dem Computer. Zugehörige Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>
