<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c7b0720d24124f7818c7801c79354a1bfa733467" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39888445" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht die Interaktion mit Windows-Ereignisprotokollen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> Sie können zugreifen und diese anpassen Windows-Ereignisprotokolle, mit denen Informationen über wichtige Software oder Hardware-Ereignisse. Mithilfe von <xref:System.Diagnostics.EventLog>, Sie können in vorhandene Protokolle lesen, Einträge in Protokolle schreiben, erstellen oder Löschen von Ereignisquellen, Protokolle löschen und Protokollereignisse reagieren. Sie können auch neue Protokolle erstellen, wenn Sie eine Ereignisquelle zu erstellen.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mit dem Typ haben, sollten Sie es entweder direkt oder indirekt freigeben. Damit des Typs direkt freigegeben werden, rufen Sie die <xref:System.IDisposable.Dispose%2A> -Methode in einer `try` / `catch` Block. Um sie indirekt löschen, verwenden Sie ein Sprachkonstrukt wie `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "mithilfe von ein-Objekt, das implementiert" IDisposable "" in der <xref:System.IDisposable> schnittstellenthema.  
  
 Zusätzlich zur Bereitstellung von Zugriff auf einzelne Ereignisprotokolle und deren Einträge dem <xref:System.Diagnostics.EventLog> Klasse können Sie die Auflistung sämtlicher Ereignisprotokolle zugreifen. Sie können die `static` Mitglied <xref:System.Diagnostics.EventLog> um Protokolle zu löschen, Log-Listen abrufen, erstellen oder löschen eine Datenquelle oder zu bestimmen, ob ein Computer bereits mit eine bestimmte Quelle enthält.  
  
 Es gibt drei Standard-Ereignisprotokolle: Anwendung, System und Sicherheit. Ein Sicherheitsprotokoll ist schreibgeschützt. Andere Anwendungen und Dienste, die Sie installieren, die können Sie z. B. Active Directory, möglicherweise zusätzliche Ereignisprotokolle.  
  
 Es sind Sicherheitsaspekte zu, bei Verwendung der <xref:System.Diagnostics.EventLog> Klasse. <xref:System.Diagnostics.EventLog> erfordert <xref:System.Diagnostics.EventLogPermission> Berechtigungen für bestimmte Aktionen in der .NET Framework 2.0 und höheren Versionen oder voll vertrauenswürdig in .NET Framework 1.0 und 1.1. Es wird empfohlen, <xref:System.Diagnostics.EventLogPermission> nicht für teilweise vertrauenswürdigen Code erteilt werden.  Sollten Sie niemals ein Ereignisprotokoll-Objekt übergeben einschließlich <xref:System.Diagnostics.EventLogEntryCollection> und <xref:System.Diagnostics.EventLogEntry> Objekte an weniger vertrauenswürdigen Code. Erstellen Sie z. B. eine <xref:System.Diagnostics.EventLog> -Objekt, das Schreiben eines Eintrags und deren Übergabe der <xref:System.Diagnostics.EventLog> teilweise vertrauenswürdiger Code kann zu verwendendes Objekt ein Sicherheitsproblem, da die Möglichkeit zum Lesen und Schreiben in das Ereignisprotokoll schreiben Code zum Ausführen von Aktionen, z. B. die Ausgabe kann die ereignisprotokollmeldungen den Namen einer anderen Anwendung.  
  
 Ab Windows Vista-Benutzerkontensteuerung (UAC) bestimmt die Anmeldeinformationen eines Benutzers. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Zum Ausführen des Codes, der auf das Sicherheitsprotokoll zugreift, müssen Sie zunächst Ihre Anmeldeinformationen von Standardbenutzer auf Administrator erhöhen. Sie erreichen dies, wenn Sie eine Anwendung starten, indem Sie das Kontextmenü für die Anwendung öffnen (Wenn Sie eine Maus verwenden, mit der rechten Maustaste das Symbol der Anwendung) und angeben, die Sie als Administrator ausführen möchten.  
  
 Sie können <xref:System.Diagnostics.EventLog> an, um benutzerdefinierte Ereignisprotokolle zu erstellen, die Sie über den Server anzeigen können die Ereignisanzeige. Verwenden der <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> Methode, um einen lokalisierten Namen für das Ereignisprotokoll in der Ereignisanzeige anzuzeigen. Verwenden der <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Methode, um das Verhalten des Ereignisprotokolls zu konfigurieren, wenn die maximale Protokollgröße erreicht.  
  
 Geben Sie zum Lesen aus einem Ereignisprotokoll der Protokollname (<xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft) und den Namen des Servers (<xref:System.Diagnostics.EventLog.MachineName%2A> -Eigenschaft für das Ereignisprotokoll geschrieben. Wenn Sie nicht den Namen des Servers, des lokalen Computers angeben ".", wird angenommen. Es ist nicht erforderlich, an die Ereignisquelle (<xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft), da eine Quelle nur für das Schreiben in Protokolle erforderlich ist. Die <xref:System.Diagnostics.EventLog.Entries%2A> Eigenschaft wird automatisch mit das Ereignisprotokoll Liste mit Einträgen gefüllt.  
  
 Klicken Sie zum Schreiben in ein Ereignisprotokoll angeben, oder erstellen Sie eine Quelle (<xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft). Sie benötigen Administratoranmeldeinformationen auf dem Computer, um eine neue Ereignisquelle zu erstellen. Die Ereignisquelle registriert die Anwendung mit dem Ereignisprotokoll als gültige Quelle für Einträge. Die Ereignisquelle können jeweils nur ein Protokoll schreiben. Die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft kann eine beliebige Zeichenfolge sein, aber der Name muss sich von anderen Quellen auf dem Computer sein. Die Ereignisquelle ist in der Regel der Name der Anwendung oder eine andere identifizierende Zeichenfolge. Erstellen eines Duplikats möchten <xref:System.Diagnostics.EventLog.Source%2A> Wert löst eine Ausnahme aus. Allerdings kann ein Ereignisprotokoll mehrere Quellen zugeordnet sein.  
  
 Wenn die Ereignisquelle für das Ereignisprotokoll zugeordnet. die <xref:System.Diagnostics.EventLog> Instanz ist nicht vorhanden, wird eine neue Ereignisquelle erstellt. Um eine Ereignisquelle in Windows Vista und höher oder Windows Server 2003 zu erstellen, müssen Sie die administrative Anmeldeinformationen verfügen.  
  
 Diese Anforderung ist, da alle Ereignisprotokolle, einschließlich von Sicherheitsprotokollen, durchsucht werden muss, um zu bestimmen, ob die Ereignisquelle eindeutig ist. Ab Windows Vista sind Benutzer nicht berechtigt, auf das Sicherheitsprotokoll zugreifen.; aus diesem Grund eine <xref:System.Security.SecurityException> ausgelöst.  
  
> [!IMPORTANT]
>  Erstellen oder Löschen einer Ereignisquelle erfordert die Synchronisierung des zugrunde liegenden Code mithilfe ein benanntes Mutex. Wenn eine Anwendung mit weit reichenden Berechtigungen den benannten Mutex gesperrt wurde, wird das Erstellen oder eine Ereignisquelle löschen möchten die Anwendung reagiert, bis die Sperre aufgehoben wird. Um dieses Problem zu vermeiden, erteilen Sie niemals <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> Berechtigung für nicht vertrauenswürdigen Code. Darüber hinaus <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> Berechtigung möglicherweise andere Berechtigungen umgangen werden kann und sollte nur sehr vertrauenswürdigen Code erteilt werden.  
  
 Anwendungen und Dienste sollten in das Anwendungsprotokoll oder in ein benutzerdefiniertes Protokoll schreiben. Gerätetreiber müssen in das Systemprotokoll schreiben. Wenn Sie nicht explizit festlegen der <xref:System.Diagnostics.EventLog.Log%2A> -Eigenschaft, das Ereignisprotokoll ist standardmäßig in das Anwendungsprotokoll.  
  
> [!NOTE]
>  Es gibt nichts zu verhindern, dass eine Anwendung schreiben, als alle registrierten Quellen.  Wenn eine Anwendung gewährt wird <xref:System.Diagnostics.EventLogPermissionAccess.Write> -Berechtigung, Schreiben sie Ereignisse für jede gültige Quelle auf dem Computer registriert.  
  
 Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methoden zum Schreiben von Ereignissen in ein Ereignisprotokoll. Sie müssen eine Ereignisquelle zum Schreiben von Ereignissen angeben. Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem noch nicht die Liste der Ereignisquellen aktualisiert, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können eine neue Datenquelle konfigurieren, mit einem <xref:System.Diagnostics.EventLogInstaller> Objekt oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie benötigen Administratoranmeldeinformationen auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Jede Quelle kann jeweils nur ein Ereignisprotokoll schreiben. Allerdings kann die Anwendung auf mehreren Quellen verwenden, zum Schreiben in verschiedenen Ereignisprotokollen. Z. B. möglicherweise die Anwendung mehrere Quellen für unterschiedliche Ereignisprotokolle oder andere Ressourcendateien konfiguriert. Um die Konfigurationsdetails der einer vorhandenen Datenquelle ändern zu können, müssen Sie der Quelle löschen und dann mit der neuen Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Datenquelle, mit der aktualisierten Konfiguration anstelle die vorhandene Quelle löschen.  
  
 Sie können die Ereignisquelle mit lokalisierten Ressourcen für die Kategorie und Meldungszeichenfolgen registrieren. Die Anwendung kann die Einträge im Ereignisprotokoll schreiben, anstatt die tatsächlichen Zeichenfolgenwerte mithilfe von Ressourcen-IDs. Finden Sie in der <xref:System.Diagnostics.EventLogInstaller> und <xref:System.Diagnostics.EventSourceCreationData> Klassen für Weitere Informationen zum Konfigurieren der Quelle mit Ressourcendateien.  
  
 Wenn die Anwendung die Werte direkt in das Ereignisprotokoll schreibt, müssen Sie nicht den Dateieigenschaften für die Quelle der Ressourcensatz. Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
 Beim Schreiben von Ereignissen, müssen Sie mindestens eine Nachrichtenzeichenfolge oder der Ressourcenbezeichner für eine Meldungszeichenfolge angeben. Andere Eigenschaften sind optional. Die folgenden: Beispiele für optionale ereigniseinstellungen  
  
-   Sie können festlegen, die <xref:System.Diagnostics.EventLogEntryType> auf das Symbol anzugeben, in dem die Ereignisanzeige für den Eintrag angezeigt.  
  
-   Sie können ein Kategorie-ID für das Ereignis angeben, wenn Ihre Anwendung mithilfe von Kategorien Filtern der Ereignisse.  
  
-   Sie können die Binärdaten an den Ereigniseintrag anfügen, wenn Sie ein bestimmtes Ereignis zusätzliche Informationen zuordnen möchten.  
  
> [!IMPORTANT]
>  Event-Protokollierung belegt Speicherplatz auf dem Datenträger, Prozessor-Zeit und andere Systemressourcen. Es ist wichtig, um nur wichtige Informationen zu protokollieren. Es wird empfohlen, dass Sie Aufrufe des Ereignisprotokolls platzieren, in einem Pfad für Fehler, anstatt im Pfad Hauptcode, sodass sie nicht Leistung beeinträchtigen.  
  
 Eine Liste der anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.Diagnostics.EventLog>, finden Sie unter den <xref:System.Diagnostics.EventLog.%23ctor%2A> Konstruktor.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Ereignisquelle `MySource` wenn er noch nicht vorhanden ist, und einen Eintrag im Ereignisprotokoll schreibt `MyNewLog`.  
  
> [!NOTE]
>  Ab Windows Vista müssen Sie diese Anwendung als Administrator ausführen.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventLog" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventLog" />-Klasse. Die Instanz wird keinem Protokoll zugeordnet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vor dem Aufruf <xref:System.Diagnostics.EventLog.WriteEntry%2A>, geben Sie die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft der <xref:System.Diagnostics.EventLog> Instanz. Wenn Sie nur lesen <xref:System.Diagnostics.EventLog.Entries%2A> aus dem Protokoll, können Sie alternativ angeben nur der <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> Eigenschaften.  
  
> [!NOTE]
>  Wenn Sie keinen angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A>, dem lokalen Computer (".") wird angenommen.  
  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Diagnostics.EventLog>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Eine leere Zeichenfolge ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Eine leere Zeichenfolge ("").|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Dem lokalen Computer (".").|  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` wenn er noch nicht vorhanden, und einen Eintrag im Ereignisprotokoll schreibt `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des Protokolls auf dem lokalen Computer.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventLog" />-Klasse. Ordnet die Instanz einem Protokoll auf dem lokalen Computer zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird der <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft, um die `logName` Parameter. Vor dem Aufruf <xref:System.Diagnostics.EventLog.WriteEntry%2A>, geben Sie die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft der <xref:System.Diagnostics.EventLog> Instanz. Wenn Sie nur lesen <xref:System.Diagnostics.EventLog.Entries%2A> aus dem Protokoll, können Sie alternativ angeben nur der <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> Eigenschaften.  
  
> [!NOTE]
>  Wenn Sie keinen angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A>, dem lokalen Computer (".") wird angenommen. Gibt an, diese Überladung des Konstruktors der <xref:System.Diagnostics.EventLog.Log%2A> -Eigenschaft, aber Sie können ändern, dies vor dem Lesen der <xref:System.Diagnostics.EventLog.Entries%2A> Eigenschaft.  
  
 Wenn Sie die Quelle im Angeben der <xref:System.Diagnostics.EventLog.Source%2A> -Eigenschaft ist eindeutig von anderen Quellen auf dem Computer, ein nachfolgender Aufruf von <xref:System.Diagnostics.EventLog.WriteEntry%2A> erstellt ein Protokoll mit dem angegebenen Namen, wenn es nicht bereits vorhanden ist.  
  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Diagnostics.EventLog>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Eine leere Zeichenfolge ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Der `logName`-Parameter.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Dem lokalen Computer (".").|  
  
   
  
## Examples  
 Das folgende Beispiel liest die Einträge in das Ereignisprotokoll "MyNewLog" auf dem lokalen Computer.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Protokollname ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Protokollname ist ungültig.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des Protokolls auf dem angegebenen Computer.</param>
        <param name="machineName">Der Computer, auf dem das Protokoll vorhanden ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventLog" />-Klasse. Ordnet die Instanz einem Protokoll auf dem angegebenen Computer zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird der <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft, um die `logName` Parameter und die <xref:System.Diagnostics.EventLog.MachineName%2A> Eigenschaft, um die `machineName` Parameter. Vor dem Aufruf <xref:System.Diagnostics.EventLog.WriteEntry%2A>, geben Sie die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft der <xref:System.Diagnostics.EventLog>. Wenn Sie nur lesen <xref:System.Diagnostics.EventLog.Entries%2A> aus dem Protokoll, können Sie alternativ angeben nur der <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> Eigenschaften.  
  
> [!NOTE]
>  Gibt an, diese Überladung des Konstruktors der <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> Eigenschaften, aber Sie können ändern, entweder vor dem Lesen der <xref:System.Diagnostics.EventLog.Entries%2A> Eigenschaft.  
  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Diagnostics.EventLog>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Eine leere Zeichenfolge ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Der `logName`-Parameter.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Der `machineName`-Parameter.|  
  
   
  
## Examples  
 Das folgende Beispiel liest die Einträge in das Ereignisprotokoll "MyNewLog", auf dem Computer "MyServer".  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Protokollname ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Protokollname ist ungültig.  
  
- oder - 
Der Computername ist ungültig.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des Protokolls auf dem angegebenen Computer.</param>
        <param name="machineName">Der Computer, auf dem das Protokoll vorhanden ist.</param>
        <param name="source">Die Quelle für Ereignisprotokolleinträge.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventLog" />-Klasse. Ordnet die Instanz einem Protokoll auf dem angegebenen Computer zu und erstellt die angegebene Quelle bzw. weist diese dem <see cref="T:System.Diagnostics.EventLog" /> zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor legt die <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft, um die `logName` -Parameter der <xref:System.Diagnostics.EventLog.MachineName%2A> Eigenschaft, um die `machineName` Parameter, und die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft, um die `source` Parameter. Die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft ist erforderlich, wenn Sie in ein Ereignisprotokoll schreiben. Aber wenn Sie nur das Lesen aus einem Ereignisprotokoll, nur sind die <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> Eigenschaften müssen angegeben werden (solange das Ereignisprotokoll auf dem Server eine Quelle, die bereits zugeordnet ist). Wenn Sie nur das Lesen aus dem Ereignisprotokoll sind, kann eine andere Überladung des Konstruktors ausreichend sein.  
  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Diagnostics.EventLog>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Der `source`-Parameter.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Der `logName`-Parameter.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Der `machineName`-Parameter.|  
  
   
  
## Examples  
 Im folgende Beispiel schreibt einen Eintrag in ein Ereignisprotokoll, "MyNewLog", auf dem lokalen Computer, die mit der Quelle "MySource".  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Protokollname ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Protokollname ist ungültig.  
  
- oder - 
Der Computername ist ungültig.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Initialisierung von <see cref="T:System.Diagnostics.EventLog" /> für die Verwendung in einem Formular oder durch eine andere Komponente. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurf, die Umgebung verwendet diese Methode, um die Initialisierung einer Komponente, die in einem Formular oder von einer anderen Komponente verwendet zu starten. Die <xref:System.Diagnostics.EventLog.EndInit%2A> -Methode beendet die Initialisierung. Mithilfe der <xref:System.Diagnostics.EventLog.BeginInit%2A> und <xref:System.Diagnostics.EventLog.EndInit%2A> Methoden verhindern, dass das Steuerelement verwendet wird, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.EventLog" /> wurde bereits initialisiert.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Einträge aus dem Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ereignisprotokolle werden mit einer maximalen Größe festgelegt, die bestimmt, wie viele Einträge sie enthalten können. Wenn ein Ereignisprotokoll voll ist, wird es beendet die Aufzeichnung von Informationen zu neuen oder beginnt, die auf frühere Einträge werden überschrieben. Ereignisaufzeichnung beenden möchten, können Sie diese Methode, deaktivieren das Protokoll des vorhandenen Einträge, und erlauben, dass Sie die Aufzeichnung von Ereignissen erneut zu starten. Sie benötigen Administratorberechtigungen auf dem Computer, auf denen sich das Protokoll zum Löschen der Einträge im Ereignisprotokoll befindet.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> Schließt das Ereignisprotokoll, gibt die Ereignishandles, ruft neue Lese- und Schreibhandles frei, und erneut öffnet das Ereignisprotokoll geschrieben. Ereignisse, die nach dem Aufruf der Methode empfangen werden nicht zusammen mit der vorhandenen Ereignisse gelöscht.  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Ereignisprotokoll gelöscht.  
  
> [!CAUTION]
>  Da die Anwendung, System-, Sicherheits- und andere nicht benutzerdefinierte Protokolle wichtige Informationen, und enthalten können Achten Sie darauf, dass Sie ein benutzerdefiniertes Protokoll angeben, vor der Ausführung dieses Beispielcodes. Dieses Beispiel löscht das benutzerdefinierte Protokoll `myNewLog`.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Ereignisprotokoll wurde nicht erfolgreich gelöscht.  
  
- oder - 
Das Protokoll kann nicht geöffnet werden. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <exception cref="T:System.ArgumentException">Für die <see cref="P:System.Diagnostics.EventLog.Log" />-Eigenschaft wurde kein Wert angegeben. Stellen Sie sicher, dass der Protokollname keine leere Zeichenfolge ist.</exception>
        <exception cref="T:System.InvalidOperationException">Das Protokoll ist nicht vorhanden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt das Ereignisprotokoll und gibt Lese- und Schreibhandles frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.EventLog.Close%2A> Methode wird aufgerufen, indem Sie die geschützte <xref:System.ComponentModel.Component.Dispose%2A> Methode. Sie müssen nicht aufzurufende <xref:System.Diagnostics.EventLog.Close%2A> vor dem Aufruf <xref:System.ComponentModel.Component.Dispose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Lese- oder Schreibhandle des Ereignisprotokolls wurde nicht freigegeben.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Richtet eine Anwendung so ein, dass diese Ereignisinformationen in ein bestimmtes Protokoll im System schreiben kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">Die Konfigurationseigenschaften für die Ereignisquelle und ihr Zielereignisprotokoll.</param>
        <summary>Richtet mit den angegebenen Konfigurationseigenschaften für die Ereignisquelle und dem entsprechenden Ereignisprotokoll als gültige Ereignisquelle zum Schreiben lokalisierter Ereignismeldungen ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine neue Quelle für das Schreiben von Einträgen in ein Ereignisprotokoll auf dem lokalen Computer oder einem Remotecomputer zu konfigurieren. Es ist nicht notwendig, diese Methode zum Lesen aus einem Ereignisprotokoll verwenden.  
  
 Die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> -Methode verwendet die Eingabe `sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> und <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> Eigenschaften, die Registrierungswerte auf dem Zielcomputer für die neue Quelle und das zugeordnete Ereignisprotokoll erstellt. Ein neuen Namen für die Datenquelle darf nicht den Datenquellennamen einer vorhandenen oder einem vorhandenen Ereignisprotokollnamen auf dem bereitstellungszielcomputer übereinstimmen. Wenn die <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> Eigenschaft nicht festgelegt ist, wird die Quelle für das Ereignisprotokoll der Anwendung registriert. Wenn die <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> ist nicht festgelegt ist, wird die Quelle auf dem lokalen Computer registriert ist.  
  
> [!NOTE]
>  Um eine Ereignisquelle in Windows Vista und höher oder Windows Server 2003 zu erstellen, müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignisquelle eindeutig ist. Ab Windows Vista sind Benutzer nicht berechtigt, auf das Sicherheitsprotokoll zugreifen.; aus diesem Grund eine <xref:System.Security.SecurityException> ausgelöst.  
>   
>  Ab Windows Vista-Benutzerkontensteuerung (UAC) bestimmt die Berechtigungen eines Benutzers. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Zum Ausführen des Codes, der auf das Sicherheitsprotokoll zugreift, müssen Sie zuerst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.   
  
 Verwendung <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A> werden Ereignisse in ein Ereignisprotokoll geschrieben. Sie müssen eine Ereignisquelle zum Schreiben von Ereignissen angeben. Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Sie können eine Ereignisquelle für ein vorhandenes oder ein neues Ereignisprotokoll erstellen. Wenn Sie eine neue Quelle für ein neues Ereignisprotokoll erstellen, registriert das System die Quelle für das Protokoll geschrieben, aber das Protokoll wird nicht erstellt werden, bis der erste Eintrag darin geschrieben wird.  
  
 Das Betriebssystem speichert Ereignisprotokolle als Dateien. Bei Verwendung von <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventLog.CreateEventSource%2A> um ein neues Ereignisprotokoll erstellen, wird die zugehörige Datei im Verzeichnis %SystemRoot%\System32\Config auf dem angegebenen Computer gespeichert. Der Dateiname wird festgelegt, durch die ersten 8 Zeichen Anhängen der <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft mit der Erweiterung "EVT".  
  
 Jede Quelle kann nur zu einem Zeitpunkt nur ein Ereignisprotokoll schreiben. Allerdings kann die Anwendung auf mehreren Quellen verwenden, zum Schreiben in verschiedenen Ereignisprotokollen. Z. B. möglicherweise die Anwendung mehrere Quellen für unterschiedliche Ereignisprotokolle oder andere Ressourcendateien konfiguriert.  
  
 Sie können die Ereignisquelle mit lokalisierten Ressourcen-Dateien für die Kategorie und Meldungszeichenfolgen registrieren. Ihre Anwendung kann Einträge im Ereignisprotokoll mithilfe der Ressourcen-IDs, statt die tatsächliche Zeichenfolge zu schreiben. Die Ereignisanzeige verwendet die Ressourcen-ID zum Suchen und Anzeigen der entsprechenden Zeichenfolge aus der lokalisierten Ressourcendatei, die basierend auf aktuellen spracheinstellungen. Sie können eine separate Datei für Ereigniskategorien, Meldungen und Parameter einfügen-Zeichenfolgen registrieren, oder Sie können die Ressourcendatei für alle drei Typen von Zeichenfolgen. Verwenden der <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, und <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> Eigenschaften zum Konfigurieren von der Quelle zum Schreiben lokalisierter Einträge in das Ereignisprotokoll geschrieben. Wenn die Anwendung die Zeichenfolgenwerte direkt in das Ereignisprotokoll schreibt, müssen Sie nicht zum Festlegen dieser Eigenschaften.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
 Um die Konfigurationsdetails der einer vorhandenen Datenquelle ändern zu können, müssen Sie der Quelle löschen und dann mit der neuen Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Datenquelle mit der aktualisierten Konfiguration löschen, statt die vorhandene Datenquelle aus.  
  
> [!NOTE]
>  Wenn eine Quelle für ein Ereignisprotokoll konfiguriert ist, und Sie neu für ein anderes Ereignisprotokoll konfigurieren, müssen Sie den Computer für die Änderungen wirksam werden neu starten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob die Ereignisquelle, mit dem Namen `SampleApplicationSource` auf dem lokalen Computer registriert ist. Wenn die Ereignisquelle nicht vorhanden ist, wird im Beispiel wird von der Meldungsressourcendatei für die Quelle, und erstellt die neue Ereignisquelle. Im Beispiel wird schließlich den lokalisierten Anzeigenamen für das Ereignisprotokoll, die mit dem Ressourcen-ID-Wert in `DisplayNameMsgId` und den Ressourcenpfad für die Datei im `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 Im Beispiel wird die folgende Meldung-Textdatei, die Ressourcenbibliothek EventLogMsgs.dll integriert. Eine Nachricht Text-Datei ist die Quelle, aus der Meldungsressourcendatei erstellt wird. Die Nachricht-Text-Datei definiert die Ressourcen-IDs und der Text für die Kategorie, ereignismeldung und Parameter einfügen-Zeichenfolgen. Für den lokalisierten Namen des Ereignisprotokolls ist insbesondere Ressourcenbezeichner 5001 definiert.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der in <paramref name="sourceData" /> angegebene Computername ist nicht gültig.  
  
\- oder – 
Der in <paramref name="sourceData" /> angegebene Dateiname ist <see langword="null" />.  
  
\- oder – 
Der in <paramref name="sourceData" /> angegebene Protokollname ist nicht gültig. Ereignisprotokollnamen müssen aus druckbaren Zeichen bestehen und dürfen nicht die Zeichen "*", "?" oder "\\" enthalten.  
  
\- oder – 
Der in <paramref name="sourceData" /> angegebene Protokollname ist für die Benutzerprotokollerstellung nicht gültig. Die Ereignisprotokollnamen AppEvent, SysEvent und SecEvent sind für die Verwendung durch das System reserviert.  
  
\- oder – 
Der Protokollname stimmt mit einem vorhandenen Ereignisquellennamen überein.  
  
\- oder – 
Der in <paramref name="sourceData" /> angegebene Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.  
  
\- oder – 
Die ersten acht Zeichen des in <paramref name="sourceData" /> angegebenen Protokollnamens sind nicht eindeutig.  
  
\- oder – 
Der in <paramref name="sourceData" /> angegebene Quellenname ist bereits registriert.  
  
\- oder – 
Der in <paramref name="sourceData" /> angegebene Quellenname stimmt mit einem vorhandenen Ereignisprotokollnamen überein.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceData" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Quellenname, unter dem die Anwendung auf dem lokalen Computer registriert ist.</param>
        <param name="logName">Der Name des Protokolls, in das die Einträge der Quelle geschrieben werden. Zu den möglichen Werten gehören das Anwendungs- bzw. Systemprotokoll oder ein benutzerdefiniertes Ereignisprotokoll.</param>
        <summary>Richtet den angegebenen Quellennamen als gültige Ereignisquelle für das Schreiben von Einträgen in ein Protokoll auf dem lokalen Computer ein. Diese Methode kann auch ein neues benutzerdefiniertes Protokoll auf dem lokalen Computer erstellen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um ein benutzerdefiniertes Protokoll zu erstellen oder zu erstellen und registrieren Sie eine <xref:System.Diagnostics.EventLog.Source%2A> in ein vorhandenes Protokoll auf dem lokalen Computer.  
  
 Wenn `logName` ist `null` oder eine leere Zeichenfolge ("") beim Aufruf <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, das Protokoll wird standardmäßig in das Anwendungsprotokoll. Wenn das Protokoll auf dem lokalen Computer nicht vorhanden ist, wird das System ein benutzerdefiniertes Protokoll erstellt und registriert die Anwendung als eine <xref:System.Diagnostics.EventLog.Source%2A> für das Protokoll geschrieben.  
  
> [!NOTE]
>  Um eine Ereignisquelle in Windows Vista und höher oder Windows Server 2003 zu erstellen, müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignisquelle eindeutig ist. Ab Windows Vista sind Benutzer nicht berechtigt, auf das Sicherheitsprotokoll zugreifen.; aus diesem Grund eine <xref:System.Security.SecurityException> ausgelöst.  
>   
>  Unter Windows Vista (und höher) werden die Berechtigungen eines Benutzers von der Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Zum Ausführen des Codes, der auf das Sicherheitsprotokoll zugreift, müssen Sie zuerst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.   
  
 Sie müssen nur eine Ereignisquelle zu erstellen, wenn Sie in das Ereignisprotokoll schreiben. Bevor Sie einen Eintrag in ein Ereignisprotokoll schreiben, müssen Sie die Ereignisquelle mit dem Ereignisprotokoll als gültige Quelle von Ereignissen registrieren. Wenn Sie einen Protokolleintrag schreiben, das System verwendet die <xref:System.Diagnostics.EventLog.Source%2A> finden Sie das entsprechende Protokoll, in dem der Eintrag geschrieben. Wenn Sie das Ereignisprotokoll lesen, können Sie entweder eine angeben der <xref:System.Diagnostics.EventLog.Source%2A>, oder ein <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Sie sind nicht erforderlich, an die <xref:System.Diagnostics.EventLog.MachineName%2A> , wenn Sie die Verbindung mit einem Protokoll auf dem lokalen Computer herstellen. Wenn Sie keinen angeben der <xref:System.Diagnostics.EventLog.MachineName%2A> beim Lesen aus einem Protokoll, des lokalen Computers (".") wird angenommen.  
  
 Verwendung <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A> werden Ereignisse in ein Ereignisprotokoll geschrieben. Sie müssen eine Ereignisquelle zum Schreiben von Ereignissen angeben. Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Sie können eine Ereignisquelle für ein vorhandenes oder ein neues Ereignisprotokoll erstellen. Wenn Sie eine neue Quelle für ein neues Ereignisprotokoll erstellen, registriert das System die Quelle für das Protokoll geschrieben, aber das Protokoll wird nicht erstellt werden, bis der erste Eintrag darin geschrieben wird.  
  
 Das Betriebssystem speichert Ereignisprotokolle als Dateien. Bei Verwendung von <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventLog.CreateEventSource%2A> um ein neues Ereignisprotokoll erstellen, wird die zugehörige Datei im Verzeichnis %SystemRoot%\System32\Config auf dem angegebenen Computer gespeichert. Der Dateiname wird festgelegt, durch die ersten 8 Zeichen Anhängen der <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft mit der Erweiterung "EVT".  
  
 Die Quelle muss auf dem lokalen Computer eindeutig sein. ein neuen Quellennamen kann nicht den Datenquellennamen einer vorhandenen oder einem vorhandenen Ereignisprotokollnamen überein. Jede Quelle kann jeweils nur ein Ereignisprotokoll schreiben. Allerdings kann die Anwendung auf mehreren Quellen verwenden, zum Schreiben in verschiedenen Ereignisprotokollen. Z. B. möglicherweise die Anwendung mehrere Quellen für unterschiedliche Ereignisprotokolle oder andere Ressourcendateien konfiguriert.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
 Um die Konfigurationsdetails der einer vorhandenen Datenquelle ändern zu können, müssen Sie der Quelle löschen und dann mit der neuen Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Datenquelle mit der aktualisierten Konfiguration löschen, statt die vorhandene Datenquelle aus.  
  
> [!NOTE]
>  Wenn eine Quelle in ein Protokoll wurde bereits zugeordnet, und Sie es in ein neues Protokoll ordnen, müssen Sie den Computer für die Änderungen wirksam werden neu starten.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` wenn er noch nicht vorhanden, und einen Eintrag im Ereignisprotokoll schreibt `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> ist eine leere Zeichenfolge ("") oder <see langword="null" />  
  
\- oder – 
 <paramref name="logName" /> ist kein gültiger Ereignisprotokollname. Ereignisprotokollnamen müssen aus druckbaren Zeichen bestehen und dürfen nicht die Zeichen "*", "?" oder "\\" enthalten.  
  
\- oder – 
 <paramref name="logName" /> ist nicht gültig für Benutzerprotokollerstellung. Die Ereignisprotokollnamen AppEvent, SysEvent und SecEvent sind für die Verwendung durch das System reserviert.  
  
\- oder – 
Der Protokollname stimmt mit einem vorhandenen Ereignisquellennamen überein.  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.  
  
\- oder – 
Die ersten acht Zeichen von <paramref name="logName" /> stimmen mit den ersten acht Zeichen eines vorhandenen Ereignisprotokollnamens überein.  
  
\- oder – 
Die Quelle kann nicht registriert werden, da diese bereits auf dem lokalen Computer vorhanden ist.  
  
\- oder – 
Der Quellenname stimmt mit einem vorhandenen Ereignisprotokollnamen überein.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte auf dem lokalen Computer nicht geöffnet werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="logName">Der Name des Protokolls, in das die Einträge der Quelle geschrieben werden. Zu den möglichen Werten gehören das Anwendungs- bzw. Systemprotokoll oder ein benutzerdefiniertes Ereignisprotokoll. Wenn Sie keinen Wert angeben, wird standardmäßig für <c>logName</c> das Anwendungsprotokoll verwendet.</param>
        <param name="machineName">Der Name des Computers, auf dem diese Ereignisquelle registriert wird, oder "." für den lokalen Computer.</param>
        <summary>Richtet den angegebenen Quellennamen als gültige Ereignisquelle für das Schreiben von Einträgen in ein Protokoll auf dem angegebenen Computer ein. Mit dieser Methode kann auch ein neues benutzerdefiniertes Protokoll auf dem angegebenen Computer erstellt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um ein benutzerdefiniertes Protokoll zu erstellen oder zu erstellen und registrieren Sie eine <xref:System.Diagnostics.EventLog.Source%2A> in ein vorhandenes Protokoll auf dem angegebenen Computer.  
  
 Wenn `logName` ist `null` oder eine leere Zeichenfolge ("") beim Aufruf <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, das Protokoll wird standardmäßig in das Anwendungsprotokoll. Wenn das Protokoll auf dem angegebenen Computer nicht vorhanden ist, wird das System ein benutzerdefiniertes Protokoll erstellt und registriert die Anwendung als eine <xref:System.Diagnostics.EventLog.Source%2A> für das Protokoll geschrieben.  
  
 Sie müssen nur eine Ereignisquelle zu erstellen, wenn Sie in das Ereignisprotokoll schreiben. Bevor Sie einen Eintrag in ein Ereignisprotokoll schreiben, müssen Sie die Ereignisquelle mit dem Ereignisprotokoll als gültige Quelle von Ereignissen registrieren. Wenn Sie einen Protokolleintrag schreiben, das System verwendet die <xref:System.Diagnostics.EventLog.Source%2A> finden Sie das entsprechende Protokoll, in dem der Eintrag geschrieben. Wenn Sie das Ereignisprotokoll lesen, können Sie entweder eine angeben der <xref:System.Diagnostics.EventLog.Source%2A>, oder ein <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Um eine Ereignisquelle in Windows Vista und höher oder Windows Server 2003 zu erstellen, müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignisquelle eindeutig ist. In Windows Vista und höher, verfügen Benutzer über die Berechtigung zum Zugriff auf das Sicherheitsprotokoll nicht; aus diesem Grund eine <xref:System.Security.SecurityException> ausgelöst.  
>   
>  Unter Windows Vista (und höher) werden die Berechtigungen eines Benutzers von der Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Zum Ausführen des Codes, der auf das Sicherheitsprotokoll zugreift, müssen Sie zuerst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.   
  
 Verwendung <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A> werden Ereignisse in ein Ereignisprotokoll geschrieben. Sie müssen eine Ereignisquelle zum Schreiben von Ereignissen angeben. Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Sie können eine Ereignisquelle für ein vorhandenes oder ein neues Ereignisprotokoll erstellen. Wenn Sie eine neue Quelle für ein neues Ereignisprotokoll erstellen, registriert das System die Quelle für das Protokoll geschrieben, aber das Protokoll wird nicht erstellt werden, bis der erste Eintrag darin geschrieben wird.  
  
 Das Betriebssystem speichert Ereignisprotokolle als Dateien. Bei Verwendung von <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventLog.CreateEventSource%2A> um ein neues Ereignisprotokoll erstellen, wird die zugehörige Datei im Verzeichnis %SystemRoot%\System32\Config auf dem angegebenen Computer gespeichert. Der Dateiname wird festgelegt, durch die ersten 8 Zeichen Anhängen der <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft mit der Erweiterung "EVT".  
  
 Die Quelle muss auf dem lokalen Computer eindeutig sein. ein neuen Quellennamen kann nicht den Datenquellennamen einer vorhandenen oder einem vorhandenen Ereignisprotokollnamen überein. Jede Quelle kann jeweils nur ein Ereignisprotokoll schreiben. Allerdings kann die Anwendung auf mehreren Quellen verwenden, zum Schreiben in verschiedenen Ereignisprotokollen. Z. B. möglicherweise die Anwendung mehrere Quellen für unterschiedliche Ereignisprotokolle oder andere Ressourcendateien konfiguriert.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
 Um die Konfigurationsdetails der einer vorhandenen Datenquelle ändern zu können, müssen Sie der Quelle löschen und dann mit der neuen Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Datenquelle mit der aktualisierten Konfiguration löschen, statt die vorhandene Datenquelle aus.  
  
> [!NOTE]
>  Wenn eine Quelle in ein Protokoll wurde bereits zugeordnet, und Sie es in ein neues Protokoll ordnen, müssen Sie den Computer für die Änderungen wirksam werden neu starten.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` auf dem Computer `MyServer`, und schreibt einen Eintrag im Ereignisprotokoll `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="machineName" /> ist kein gültiger Computername.  
  
\- oder – 
 <paramref name="source" /> ist eine leere Zeichenfolge ("") oder <see langword="null" />  
  
\- oder – 
 <paramref name="logName" /> ist kein gültiger Ereignisprotokollname. Ereignisprotokollnamen müssen aus druckbaren Zeichen bestehen und dürfen nicht die Zeichen "*", "?" oder "\\" enthalten.  
  
\- oder – 
 <paramref name="logName" /> ist nicht gültig für Benutzerprotokollerstellung. Die Ereignisprotokollnamen AppEvent, SysEvent und SecEvent sind für die Verwendung durch das System reserviert.  
  
\- oder – 
Der Protokollname stimmt mit einem vorhandenen Ereignisquellennamen überein.  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.  
  
\- oder – 
Die ersten acht Zeichen von <paramref name="logName" /> stimmen mit den ersten acht Zeichen eines vorhandenen Ereignisprotokollnamens auf dem angegebenen Computer überein.  
  
\- oder – 
Die Quelle kann nicht registriert werden, da diese bereits auf dem angegebenen Computer vorhanden ist.  
  
\- oder – 
Der Quellenname stimmt mit einem vorhandenen Ereignisquellennamen überein.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte auf dem angegebenen Computer nicht geöffnet werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt eine Protokollressource.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des zu löschenden Protokolls. Zu den möglichen Werten gehören das Anwendungs-, Sicherheits- bzw. Systemprotokoll und alle benutzerdefinierten Ereignisprotokolle auf dem Computer.</param>
        <summary>Entfernt ein Ereignisprotokoll vom lokalen Computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, wenn das Protokoll, die, das Sie löschen möchten, auf dem lokalen Computer ist. Sie können beliebiges Protokoll auf dem Computer, löschen, sofern Sie über Registrierungsberechtigungen verfügen.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Entfernt das angegebene vom `logName` auf dem lokalen Computer. Wenn Sie löschen möchten, nur die Quelle in ein Protokoll registriert, rufen Sie <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Wenn Sie nur die Protokolleinträge löschen möchten, rufen Sie <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> und <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sind `static` Methoden, damit sie in der Klasse selbst aufgerufen werden können. Es ist nicht erforderlich, erstellen eine neue Instanz der <xref:System.Diagnostics.EventLog> entweder-Methode aufrufen.  
  
 Die <xref:System.Diagnostics.EventLog.Delete%2A> Methode löscht zuerst die Datei, die den Inhalt des Protokolls enthält. Anschließend greift auf die Registrierung und entfernt alle Ereignisquellen, die für das Protokoll registriert. Wenn Sie das Protokoll zu einem späteren Zeitpunkt neu erstellen, sollten Sie die Ereignisquellen aus, wenn sie wiederverwendet werden, werden in diesem Fall registrieren. Wenn Sie nicht die Ereignisquellen registrieren und andere Benutzer, die mit einer Ereignisquelle ohne Angabe eines Namens für die Protokolldatei schreiben, wird die Ereignisquelle in das Anwendungsereignisprotokoll erstellt werden. Aus diesem Grund werden Anwendungen, die zuvor Einträge in das Protokoll zu schreiben waren, Sie gelöscht und neu erstellt, in das Anwendungsprotokoll stattdessen geschrieben werden, da sie jetzt die Ereignisquelle enthält.  
  
> [!NOTE]
>  Neuerstellen eines Ereignisprotokolls, kann ein schwieriger Prozess sein. Löschen eine der vom System erstellten Ereignisprotokolle, z. B. das Anwendungsprotokoll zu vermeiden.  
  
 Löschen eines Protokolls durch einen Aufruf von <xref:System.Diagnostics.EventLog.Delete%2A> löscht automatisch die Quellen, die in diesem Protokoll registriert. Dadurch können andere Anwendungen verwenden das Protokoll nicht verwendbare geschrieben werden.  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Protokoll auf dem lokalen Computer gelöscht. Im Beispiel wird das Protokoll und der zugehörigen Quelle bestimmt.  
  
> [!NOTE]
>  Mehr als einer Datenquelle kann in ein Ereignisprotokoll schreiben. Stellen Sie vor dem Löschen eines benutzerdefinierten Protokolls können Sie sicher, dass keine anderen Quellen, die beim Schreiben in das Protokoll geschrieben.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> ist eine leere Zeichenfolge ("") oder <see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte auf dem lokalen Computer nicht geöffnet werden.  
  
\- oder – 
Das Protokoll ist auf dem lokalen Computer nicht vorhanden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Ereignisprotokoll wurde nicht erfolgreich gelöscht.  
  
- oder - 
Das Protokoll kann nicht geöffnet werden. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des zu löschenden Protokolls. Zu den möglichen Werten gehören das Anwendungs-, Sicherheits- bzw. Systemprotokoll und alle benutzerdefinierten Ereignisprotokolle auf dem angegebenen Computer.</param>
        <param name="machineName">Der Name des Computers, auf dem das Protokoll gelöscht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Entfernt ein Ereignisprotokoll vom angegebenen Computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, wenn das Protokoll, die, das Sie löschen möchten, auf einem Remotecomputer ist. Sie können beliebiges Protokoll auf dem Computer, löschen, sofern Sie über Registrierungsberechtigungen verfügen.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Entfernt das angegebene vom `logName` aus dem angegebenen Computer `machineName`. Wenn Sie löschen möchten, nur die Quelle in ein Protokoll registriert, rufen Sie <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Wenn Sie nur die Protokolleinträge löschen möchten, rufen Sie <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> und <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sind `static` Methoden, damit sie in der Klasse selbst aufgerufen werden können. Es ist nicht erforderlich, zum Erstellen einer Instanz von <xref:System.Diagnostics.EventLog> entweder-Methode aufrufen.  
  
 Diese Methode löscht zuerst die Datei, die den Inhalt des Protokolls enthält. Anschließend greift auf die Registrierung und entfernt alle Ereignisquellen, die für das Protokoll registriert. Wenn Sie das Protokoll zu einem späteren Zeitpunkt neu erstellen, sollten Sie die Ereignisquellen aus, wenn sie wiederverwendet werden, werden in diesem Fall registrieren. Wenn Sie nicht die Ereignisquellen registrieren und andere Benutzer, die mit einer Ereignisquelle ohne Angabe eines Namens für die Protokolldatei schreiben, wird die Ereignisquelle in das Anwendungsereignisprotokoll erstellt werden. Aus diesem Grund werden Anwendungen, die zuvor Einträge in das Protokoll zu schreiben waren, Sie gelöscht und neu erstellt, in das Anwendungsprotokoll stattdessen geschrieben werden, da sie jetzt die Ereignisquelle enthält.  
  
> [!NOTE]
>  Neuerstellen eines Ereignisprotokolls, kann ein schwieriger Prozess sein. Löschen eine der vom System erstellten Ereignisprotokolle, z. B. das Anwendungsprotokoll zu vermeiden.  
  
 Löschen eines Protokolls durch einen Aufruf von <xref:System.Diagnostics.EventLog.Delete%2A> löscht automatisch die Quellen, die in diesem Protokoll registriert. Dadurch können andere Anwendungen verwenden das Protokoll nicht verwendbare geschrieben werden.  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Protokoll aus dem angegebenen Computer gelöscht. Im Beispiel wird das Protokoll und der zugehörigen Quelle bestimmt.  
  
> [!NOTE]
>  Mehr als einer Datenquelle kann in ein Ereignisprotokoll schreiben. Stellen Sie vor dem Löschen eines benutzerdefinierten Protokolls können Sie sicher, dass keine anderen Quellen, die beim Schreiben in das Protokoll geschrieben.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> ist eine leere Zeichenfolge ("") oder <see langword="null" />  
  
\- oder – 
 <paramref name="machineName" /> ist kein gültiger Computername.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte auf dem angegebenen Computer nicht geöffnet werden.  
  
\- oder – 
Das Protokoll ist auf dem angegebenen Computer nicht vorhanden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Ereignisprotokoll wurde nicht erfolgreich gelöscht.  
  
- oder - 
Das Protokoll kann nicht geöffnet werden. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt die Registrierung der Ereignisquellen einer Anwendung aus dem Ereignisprotokoll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name, unter dem die Anwendung im Ereignisprotokollsystem registriert ist.</param>
        <summary>Entfernt die Registrierung der Ereignisquelle aus dem Ereignisprotokoll auf dem lokalen Computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können Sie die Registrierung entfernen einer <xref:System.Diagnostics.EventLog.Source%2A> auf dem lokalen Computer. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> greift auf die Registrierung auf dem lokalen Computer aus, und entfernt die Registrierung Ihrer Anwendung als gültige Quelle von Ereignissen.  
  
 Sie können Ihre Komponente als gültige Quelle von Ereignissen entfernen, wenn Sie nicht mehr benötigen, damit Einträge in das Protokoll zu schreiben. Dies wäre z. B. möglich, wenn Sie die Komponente aus einem Protokoll auf einen anderen ändern müssen. Da eine Quelle nur in ein Protokoll zu einem Zeitpunkt registriert werden kann, erfordert das Ändern des Protokolls, die aktuelle Registrierung zu entfernen.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> entfernt nur die Quelle in ein Protokoll registriert. Wenn Sie das Protokoll selbst entfernen möchten, rufen Sie <xref:System.Diagnostics.EventLog.Delete%2A>. Wenn Sie nur die Protokolleinträge löschen möchten, rufen Sie <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> und <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sind `static` Methoden, damit sie in der Klasse selbst aufgerufen werden können. Es ist nicht erforderlich, zum Erstellen einer Instanz von <xref:System.Diagnostics.EventLog> entweder-Methode aufrufen.  
  
 Löschen eines Protokolls durch einen Aufruf von <xref:System.Diagnostics.EventLog.Delete%2A> löscht automatisch die Quellen, die in diesem Protokoll registriert. Dadurch können andere Anwendungen verwenden das Protokoll nicht verwendbare geschrieben werden.  
  
> [!NOTE]
>  Wenn eine Quelle in ein Protokoll wurde bereits zugeordnet, und Sie es in ein neues Protokoll ordnen, müssen Sie den Computer für die Änderungen wirksam werden neu starten.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Quelle vom lokalen Computer gelöscht. Im Beispiel wird das Protokoll und der zugehörigen Quelle bestimmt, und klicken Sie dann das Protokoll gelöscht.  
  
> [!NOTE]
>  Mehr als einer Datenquelle kann in ein Ereignisprotokoll schreiben. Stellen Sie vor dem Löschen eines benutzerdefinierten Protokolls können Sie sicher, dass keine anderen Quellen, die beim Schreiben in das Protokoll geschrieben.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Parameter ist in der Registrierung des lokalen Computers nicht vorhanden.  
  
\- oder – 
Sie verfügen nicht über Schreibzugriff auf den Registrierungsschlüssel für das Ereignisprotokoll.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name, unter dem die Anwendung im Ereignisprotokollsystem registriert ist.</param>
        <param name="machineName">Der Name des Computers, auf dem der Registrierungseintrag gelöscht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Entfernt die Registrierung der Ereignisquellen einer Anwendung auf dem angegebenen Computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Überladung können Sie die Registrierung entfernen einer <xref:System.Diagnostics.EventLog.Source%2A> von einem Remotecomputer aus. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> greift auf die Registrierung auf dem Computer, die anhand des `machineName` und entfernt die Registrierung Ihrer Anwendung als gültige Quelle von Ereignissen.  
  
 Sie können Ihre Komponente als gültige Quelle von Ereignissen entfernen, wenn Sie nicht mehr benötigen, damit Einträge in das Protokoll zu schreiben. Dies wäre z. B. möglich, wenn Sie die Komponente aus einem Protokoll auf einen anderen ändern müssen. Da eine Quelle nur in ein Protokoll zu einem Zeitpunkt registriert werden kann, erfordert das Ändern des Protokolls, die aktuelle Registrierung zu entfernen.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> entfernt nur die Quelle in ein Protokoll registriert. Wenn Sie das Protokoll selbst entfernen möchten, rufen Sie <xref:System.Diagnostics.EventLog.Delete%2A>. Wenn Sie nur die Protokolleinträge löschen möchten, rufen Sie <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> und <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sind `static` Methoden, damit sie in der Klasse selbst aufgerufen werden können. Es ist nicht erforderlich, zum Erstellen einer Instanz von <xref:System.Diagnostics.EventLog> entweder-Methode aufrufen.  
  
 Löschen eines Protokolls durch einen Aufruf von <xref:System.Diagnostics.EventLog.Delete%2A> löscht automatisch die Quellen, die in diesem Protokoll registriert. Dadurch können andere Anwendungen verwenden das Protokoll nicht verwendbare geschrieben werden.  
  
> [!NOTE]
>  Wenn eine Quelle in ein Protokoll wurde bereits zugeordnet, und Sie es in ein neues Protokoll ordnen, müssen Sie den Computer für die Änderungen wirksam werden neu starten.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Quelle aus dem angegebenen Computer gelöscht. Im Beispiel wird das Protokoll und der zugehörigen Quelle bestimmt, und klicken Sie dann das Protokoll gelöscht.  
  
> [!NOTE]
>  Mehr als einer Datenquelle kann in ein Ereignisprotokoll schreiben. Stellen Sie vor dem Löschen eines benutzerdefinierten Protokolls können Sie sicher, dass keine anderen Quellen, die beim Schreiben in das Protokoll geschrieben.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="machineName" />-Parameter ist ungültig.  
  
\- oder – 
Der <paramref name="source" />-Parameter ist in der Registrierung des angegebenen Computers nicht vorhanden.  
  
\- oder – 
Sie verfügen nicht über Schreibzugriff auf den Registrierungsschlüssel für das Ereignisprotokoll.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> kann nicht gelöscht werden, da in der Registrierung der übergeordnete Schlüssel für <paramref name="source" /> keinen Unterschlüssel mit demselben Namen enthält.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die vom <see cref="T:System.Diagnostics.EventLog" /> verwendeten nicht verwalteten Ressourcen und optional auch die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der öffentlichen `Dispose()` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose()` Ruft die geschützte `Dispose(Boolean)` -Methode mit dem `disposing` Parametersatz zu `true`. <xref:System.Object.Finalize%2A> Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn die `disposing` Parameter true ist, gibt diese Methode alle Ressourcen frei, die für verwaltete Objekte, die dieses <xref:System.Diagnostics.EventLog> Verweise. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose(Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die zuvor von einem früheren Aufruf freigegeben wurden <see langword="Dispose" />. Weitere Informationen zur Implementierung <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Diagnostics.EventLog" /> Benachrichtigungen über <see cref="E:System.Diagnostics.EventLog.EntryWritten" />-Ereignisse erhält, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Diagnostics.EventLog" /> beim Schreiben eines Eintrags in das Protokoll benachrichtigt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> Eigenschaft bestimmt, ob die <xref:System.Diagnostics.EventLog> Ereignisse auslöst, wenn Einträge in das Protokoll geschrieben werden. Wenn die Eigenschaft den Wert `true`, Komponenten, die die <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis benachrichtigt, sobald ein Eintrag in das Protokoll, das im angegebenen geschrieben erhalten die <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft. Wenn <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> ist `false`, werden keine Ereignisse ausgelöst.  
  
> [!NOTE]
>  Sie können ereignisbenachrichtigungen empfangen, nur, wenn Einträge auf dem lokalen Computer geschrieben werden. Sie können keine Benachrichtigungen für Einträge, die auf Remotecomputern geschrieben.  
  
   
  
## Examples  
 Das folgende Beispiel verarbeitet ein <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das Ereignisprotokoll wird auf einem Remotecomputer gespeichert.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Initialisierung eines <see cref="T:System.Diagnostics.EventLog" />, das in einem Formular oder von einer anderen Komponente verwendet wird. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurf, die Umgebung verwendet diese Methode beendet die Initialisierung einer Komponente, die in einem Formular oder von einer anderen Komponente verwendet. Die <xref:System.Diagnostics.EventLog.BeginInit%2A> -Methode startet die Initialisierung. Mithilfe der <xref:System.Diagnostics.EventLog.BeginInit%2A> und <xref:System.Diagnostics.EventLog.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Inhalt des Ereignisprotokolls ab.</summary>
        <value>Eine <see cref="T:System.Diagnostics.EventLogEntryCollection" /> mit den Einträgen im Ereignisprotokoll. Jeder Eintrag ist einer Instanz der <see cref="T:System.Diagnostics.EventLogEntry" />-Klasse zugeordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Diagnostics.EventLog.Entries%2A> Member beim Lesen aus dem Ereignisprotokoll.  
  
 Da die Eigenschaft schreibgeschützt ist, keinen Eintrag zu ändern oder Schreiben in die Protokolldatei mit <xref:System.Diagnostics.EventLog.Entries%2A>. Geben Sie stattdessen eine <xref:System.Diagnostics.EventLog.Source%2A> , und rufen Sie <xref:System.Diagnostics.EventLog.WriteEntry%2A> einen neuen Protokolleintrag geschrieben. Sie können <xref:System.Diagnostics.EventLog.Entries%2A> zum zählen der Anzahl der Einträge im Ereignisprotokoll und Anzeigen von einzelnen <xref:System.Diagnostics.EventLogEntry> in der Auflistung. Verwenden Sie die indizierte <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> Member zum Abrufen von Informationen über einen bestimmten Eintrag, wie <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, oder <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.  
  
 Es ist nicht erforderlich, geben Sie einen <xref:System.Diagnostics.EventLog.Source%2A> beim nur aus einem Protokoll lesen. Kann nur angegeben, die <xref:System.Diagnostics.EventLog.Log%2A> Name und <xref:System.Diagnostics.EventLog.MachineName%2A> (Name des Computers)-Eigenschaften für die <xref:System.Diagnostics.EventLog> Instanz. In beiden Fällen die <xref:System.Diagnostics.EventLog.Entries%2A> Member wird mit dem Ereignisprotokoll Liste der Einträge automatisch aufgefüllt. Sie können den entsprechenden Index für ein Element in dieser Liste zum Lesen der einzelnen Einträge auswählen.  
  
 Ein wichtiger Unterschied zwischen dem Lesen und Schreiben von Protokolleinträgen ist, dass es nicht notwendig, explizit eine read-Methode aufrufen. Nach der <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A> angegeben sind, die <xref:System.Diagnostics.EventLog.Entries%2A> Eigenschaft wird automatisch aufgefüllt. Wenn Sie den Wert des Ändern der <xref:System.Diagnostics.EventLog.Log%2A> oder <xref:System.Diagnostics.EventLog.MachineName%2A> -Eigenschaft, die <xref:System.Diagnostics.EventLog.Entries%2A> Eigenschaft neu einlesen der nächsten aufgefüllt.  
  
> [!NOTE]
>  Sie sind nicht erforderlich, an die <xref:System.Diagnostics.EventLog.MachineName%2A> Wenn Sie die in ein Protokoll herstellen. Wenn Sie keinen angeben der <xref:System.Diagnostics.EventLog.MachineName%2A>, dem lokalen Computer ".", wird davon ausgegangen.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Einträge im Ereignisprotokoll, "MyNewLog", auf dem lokalen Computer gelesen.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Schreiben eines Eintrags in das Ereignisprotokoll auf dem lokalen Computer ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um ereignisbenachrichtigungen zu erhalten, müssen Sie festlegen, <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> zu `true`. Ereignisbenachrichtigungen können nur empfangen werden, wenn Einträge auf dem lokalen Computer geschrieben werden. Sie können keine Benachrichtigungen für Einträge, die auf Remotecomputern geschrieben.  
  
 Beim Erstellen eines <xref:System.Diagnostics.EventLog.EntryWritten>-Delegaten geben Sie die Methode für die Ereignisbehandlung an. Um dem Ereignishandler das Ereignis zuzuordnen, fügen Sie dem Ereignis eine Instanz des Delegaten hinzu. Der Ereignishandler wird aufgerufen, wenn das Ereignis tritt auf, bis Sie den Delegaten entfernen. Weitere Informationen zur Ereignisbehandlung mit Delegaten finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Das System reagiert auf <xref:System.Diagnostics.EventLog.WriteEntry%2A> nur dann, wenn die letzte mindestens sechs Sekunden Schreibereignis. Dies bedeutet Folgendes: Sie erhalten nur <xref:System.Diagnostics.EventLog.EntryWritten> ereignisbenachrichtigung innerhalb einer Laufzeit von sechs-Sekunden-Intervall, auch wenn mehr als ein Ereignis protokolländerung tritt auf. Wenn Sie eine ausreichend lange (etwa 10 Sekunden) zwischen den Aufrufen einfügen <xref:System.Diagnostics.EventLog.WriteEntry%2A>, Sie sind weniger wahrscheinlich, dass Sie ein Ereignis verpasst haben. Wenn jedoch Schreibereignisse häufig auftreten, können Sie nicht die ereignisbenachrichtigung bis zum nächsten Intervall erhalten. In der Regel übersehenen Ereignisses Benachrichtigungen sind nicht verloren gehen, aber verzögert.  
  
   
  
## Examples  
 Im folgende Beispiel verarbeitet einen Eintrag mit dem Ereignis geschrieben.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob das angegebene Protokoll vorhanden ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Der Name des zu suchenden Protokolls. Folgende Werte sind möglich: Anwendungs-, Sicherheits-, System- oder andere anwendungsspezifische Protokolle, z. B. im Zusammenhang mit Active Directory, oder ein beliebiges benutzerdefiniertes Protokoll auf dem Computer.</param>
        <summary>Bestimmt, ob das Protokoll auf dem lokalen Computer vorhanden ist.</summary>
        <returns>
          <see langword="true" />, wenn das Protokoll auf dem lokalen Computer vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um zu bestimmen, ob ein Protokoll auf dem lokalen Computer vorhanden ist. Wenn Sie bestimmen, ob eine Quelle vorhanden, auf dem lokalen Computer verwenden ist möchten <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Da diese Methode die Registrierung zugreift, müssen Sie die entsprechenden Registrierungswerte-Berechtigungen auf dem lokalen Computer verfügen; die Abfrage andernfalls `false`.  
  
 Da Sie einem neuen Protokoll nicht den Namen des vorhandenen Protokolls auf dem gleichen Computer geben können, können Sie diese Methode vor dem Erstellen eines neuen Protokolls verwenden, um zu bestimmen, ob das angegebene `logName` bereits auf dem lokalen Computer vorhanden ist. Die `logName` Parameter ist nicht in der Groß-/Kleinschreibung beachtet.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> ist eine `static` Methode, sodass sie in der Klasse selbst aufgerufen werden kann. Es ist nicht erforderlich, zum Erstellen einer Instanz von <xref:System.Diagnostics.EventLog> aufzurufende <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">logName ist <see langword="null" /> oder eine leere Zeichenfolge.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Das zu suchende Protokoll. Folgende Werte sind möglich: Anwendungs-, Sicherheits-, System- oder andere anwendungsspezifische Protokolle, z. B. im Zusammenhang mit Active Directory, oder ein beliebiges benutzerdefiniertes Protokoll auf dem Computer.</param>
        <param name="machineName">Der Name des Computers, auf dem das Protokoll gesucht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Bestimmt, ob das Protokoll auf dem angegebenen Computer vorhanden ist.</summary>
        <returns>
          <see langword="true" />, wenn das Protokoll auf dem angegebenen Computer vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um zu bestimmen, ob ein Protokoll auf einem Remotecomputer vorhanden ist. Wenn Sie bestimmen, ob eine Quelle vorhanden, auf einem Remotecomputer verwenden ist möchten <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Da diese Methode die Registrierung zugreift, müssen Sie die entsprechenden Registrierungswerte-Berechtigungen verfügen, auf dem angegebenen Computer; die Abfrage andernfalls `false`.  
  
 Da Sie einem neuen Protokoll nicht den Namen des vorhandenen Protokolls auf dem gleichen Computer geben können, können Sie diese Methode vor dem Erstellen eines neuen Protokolls verwenden, um zu bestimmen, ob mit dem angegebenen `logName` bereits vorhanden ist, auf dem Server, die gemäß der `machineName` Parameter. Die `logName` und `machineName` Parameter sind nicht in der Groß-/Kleinschreibung beachtet.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> ist eine `static` Methode, sodass sie in der Klasse selbst aufgerufen werden kann. Es ist nicht erforderlich, erstellen eine neue Instanz der <xref:System.Diagnostics.EventLog> aufzurufende <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="machineName" />-Parameter hat ein ungültiges Format. Stellen Sie sicher, dass Sie für den Computer, auf dem Sie die Suche durchführen, die richtige Syntax verwenden.  
  
- oder - 
<paramref name="logName" /> ist <see langword="null" /> oder eine leere Zeichenfolge.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Array der Ereignisprotokolle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sucht nach allen Ereignisprotokollen auf dem lokalen Computer und erstellt ein Array von <see cref="T:System.Diagnostics.EventLog" />-Objekten, das die Liste enthält.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.EventLog" />, das die auf dem lokalen Computer vorhandenen Protokolle darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array von <xref:System.Diagnostics.EventLog> Objekten ist eine Momentaufnahme aller Ereignisprotokolle auf dem lokalen Computer bei dem Aufruf von <xref:System.Diagnostics.EventLog.GetEventLogs%2A> erfolgt. Dies ist keiner dynamischen Sammlung, damit es nicht das Löschen oder Erstellen von Protokollen in Echtzeit zu entsprechen. Überprüfen Sie, dass ein Protokoll im Array vorhanden ist, bevor Sie lesen oder schreiben. Das Array enthält in der Regel mindestens drei Protokolle: Anwendung, System und Sicherheit. Wenn Sie benutzerdefinierte Protokolle auf dem lokalen Computer erstellt haben, werden sie in das Array wird ebenfalls angezeigt.  
  
 Abrufen einer Liste der Ereignisprotokolle, müssen Sie die entsprechenden Registrierungswerte-Berechtigungen verfügen. Diese Berechtigungen sind identisch mit denen zum Aufrufen erforderlichen <xref:System.Diagnostics.EventLog.Exists%2A> und <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Ereignisprotokolle auf dem lokalen Computer definierten aufgelistet, und zeigt Konfigurationsdetails für jedes Ereignisprotokoll.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Sie verfügen nicht über Lesezugriff auf die Registrierung.  
  
- oder - 
Auf dem Computer ist kein Ereignisprotokolldienst vorhanden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Computer, auf dem nach Ereignisprotokollen gesucht werden soll.</param>
        <summary>Sucht nach allen Ereignisprotokollen auf dem angegebenen Computer und erstellt ein Array von <see cref="T:System.Diagnostics.EventLog" />-Objekten, das die Liste enthält.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.EventLog" />, das die auf dem angegebenen Computer vorhandenen Protokolle darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array von <xref:System.Diagnostics.EventLog> Objekten ist eine Momentaufnahme aller Ereignisprotokolle auf dem Computer, die gemäß der `machineName` Parameter bei der der Aufruf von <xref:System.Diagnostics.EventLog.GetEventLogs%2A> erfolgt. Dies ist keiner dynamischen Sammlung, damit es nicht das Löschen oder Erstellen von Protokollen in Echtzeit zu entsprechen. Überprüfen Sie, dass ein Protokoll im Array vorhanden ist, bevor Sie lesen oder schreiben. Das Array enthält in der Regel mindestens drei Protokolle: Anwendung, System und Sicherheit. Wenn Sie benutzerdefinierte Protokolle auf dem angegebenen Computer erstellt haben, werden sie in das Array wird ebenfalls angezeigt.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> ist eine `static` Methode, sodass es für aufgerufen werden, kann die <xref:System.Diagnostics.EventLog> selbst. Es ist nicht erforderlich, zum Erstellen einer Instanz von einem <xref:System.Diagnostics.EventLog> Objekt, um einen Aufruf der Methode.  
  
 Abrufen einer Liste der Ereignisprotokolle, müssen Sie die entsprechenden Registrierungswerte-Berechtigungen verfügen. Diese Berechtigungen sind identisch mit denen zum Aufrufen erforderlichen <xref:System.Diagnostics.EventLog.Exists%2A> und <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel ruft eine Liste der Protokolle auf dem Computer "MyServer". Es gibt dann den Namen des jeweiligen Protokolls.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="machineName" />-Parameter ist ein ungültiger Computername.</exception>
        <exception cref="T:System.InvalidOperationException">Sie verfügen nicht über Lesezugriff auf die Registrierung.  
  
- oder - 
Auf dem Computer ist kein Ereignisprotokolldienst vorhanden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Protokolls ab, aus dem gelesen bzw. in das geschrieben werden soll, oder legt diesen fest.</summary>
        <value>Der Name des Protokolls. Dies kann das Anwendungs-, das System- bzw. das Sicherheitsprotokoll oder ein benutzerdefinierter Protokollname sein. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Drei Protokolldateien vorhanden sind, wird standardmäßig auf dem Server: Anwendung, System und Sicherheit. Verwenden die Protokolldatei der Anwendung, Anwendungen und Dienste. Gerätetreiber mithilfe der System-Log-Datei. Das System Überwachungsereignisse für Erfolg und Fehler in das Sicherheitsprotokoll generiert, wenn die Überwachung aktiviert ist. Wenn Sie andere Anwendungen, die installiert werden, wie Active Directory auf Windows-Servern haben möglicherweise andere Standard-Protokolldateien. Darüber hinaus können Sie benutzerdefinierte Protokolldateien auf einem lokalen oder remote-Computer erstellen. Benutzerdefinierte Protokolle unterstützen, können Sie die Einträge in einer ausführlicheren Weise als zulässig ist, wenn Ihre Komponenten Ereignisse in das Standardanwendungsprotokoll schreiben.  
  
> [!NOTE]
>  Log-Namen sind auf acht Zeichen begrenzt. Gemäß dem System sind bezeichnen MyLogSample1 und MyLogSample2 dasselbe Protokoll.  
  
 Wenn Sie in ein Ereignisprotokoll schreiben, es ist nicht ausreichend, geben Sie die <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft. Sie müssen das Zuordnen einer <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft mit dem die Ereignisprotokoll-Ressource für die Verbindung mit einem bestimmten Protokoll. Es ist nicht erforderlich, geben Sie einen <xref:System.Diagnostics.EventLog.Source%2A> Wenn nur das Lesen aus einem Protokoll, aber eine Ereignisquelle muss die Ereignisprotokoll-Ressource in der Registrierung des Servers zugeordnet. Kann nur angegeben, die <xref:System.Diagnostics.EventLog.Log%2A> Name und <xref:System.Diagnostics.EventLog.MachineName%2A> (Name des Servercomputers) lesen.  
  
> [!NOTE]
>  Sie sind nicht erforderlich, an die <xref:System.Diagnostics.EventLog.MachineName%2A> Wenn Sie die in ein Protokoll herstellen. Wenn Sie keinen angeben der <xref:System.Diagnostics.EventLog.MachineName%2A>, dem lokalen Computer (".") wird angenommen.  
  
 Wenn die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft nicht angegeben wurde, einen Aufruf von <xref:System.Diagnostics.EventLog.Log%2A> gibt eine leere Zeichenfolge zurück, wenn <xref:System.Diagnostics.EventLog.Log%2A> nicht explizit festgelegt wurde (durch Festlegen der <xref:System.Diagnostics.EventLog.Log%2A> -Eigenschaft oder durch den Konstruktor). Wenn die <xref:System.Diagnostics.EventLog.Source%2A> angegeben wurde, <xref:System.Diagnostics.EventLog.Log%2A> gibt den Namen des Protokolls für die diese Quelle registriert wurde.  
  
 Eine Quelle kann nur ein Protokoll zu einem Zeitpunkt registriert werden. Wenn die <xref:System.Diagnostics.EventLog.Source%2A> -Eigenschaft wurde festgelegt, für eine Instanz von <xref:System.Diagnostics.EventLog>, kann nicht geändert werden die <xref:System.Diagnostics.EventLog.Log%2A> -Eigenschaft für diesen <xref:System.Diagnostics.EventLog> ohne Änderung des Werts der <xref:System.Diagnostics.EventLog.Source%2A> oder Aufrufen <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> erste. Wenn Sie ändern die <xref:System.Diagnostics.EventLog.Log%2A> -Eigenschaft nach der <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft festgelegt wurde, wird das Schreiben ein Protokolleintrags löst eine Ausnahme aus.  
  
 Das Betriebssystem speichert Ereignisprotokolle als Dateien. Bei Verwendung von <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventLog.CreateEventSource%2A> um ein neues Ereignisprotokoll erstellen, wird die zugehörige Datei im Verzeichnis %SystemRoot%\System32\Config auf dem angegebenen Computer gespeichert. Der Dateiname wird festgelegt, durch die ersten 8 Zeichen Anhängen der <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft mit der Erweiterung "EVT".  
  
 Sie können nicht erstellt, ein neues Protokoll mit der <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft allein (ohne Angabe einer Quelle für das Protokoll an). Rufen Sie <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, einen neuen Protokollnamen als Parameter übergeben, und rufen dann <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Der Zweck ist jedoch in der Regel entweder erstellen (und schreiben Einträge) neue anwendungsspezifische Protokolle, oder in vorhandene Protokolle lesen.  
  
 Wenn die <xref:System.Diagnostics.EventLog.Log%2A> geändert wird, im Ereignisprotokoll wird geschlossen, und alle Ereignishandles freigegeben werden.  
  
> [!CAUTION]
>  Setzen Sie die <xref:System.Diagnostics.EventLog.Log%2A> -Eigenschaft auf den Namen der ein Protokoll, das nicht vorhanden ist, fügt das System die <xref:System.Diagnostics.EventLog> in das Anwendungsprotokoll, aber warnt Sie nicht, dass sie ein Protokoll als die verwendet wird, die Sie angegeben haben.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Einträge im Ereignisprotokoll, "NewEventLog", auf dem lokalen Computer gelesen.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den angezeigten Namen des Ereignisprotokolls ab.</summary>
        <value>Ein Name, der das Ereignisprotokoll in der Ereignisanzeige des Systems darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  In Windows Vista und höher, verfügen Benutzer über die Berechtigung zum Zugriff auf das Sicherheitsprotokoll nicht. Wenn Sie Windows Vista ausgeführt werden, oder später als Benutzer Sie erhalten eine <xref:System.Security.SecurityException> beim Versuch, den Anzeigenamen für ein Ereignis in das Sicherheitsprotokoll zugreifen.  
>   
>  Unter Windows Vista (und höher) werden die Berechtigungen eines Benutzers von der Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Zum Ausführen des Codes, der auf das Sicherheitsprotokoll zugreift, müssen Sie zuerst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.   
  
   
  
## Examples  
 Im folgenden Beispiel werden die Ereignisprotokolle auf dem lokalen Computer definierten aufgelistet, und zeigt die <xref:System.Diagnostics.EventLog.LogDisplayName%2A> für jedes Ereignisprotokoll.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das angegebene <see cref="P:System.Diagnostics.EventLog.Log" /> ist in der Registrierung für diesen Computer nicht vorhanden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name der Ereignisquelle.</param>
        <param name="machineName">Der Name des Computers, auf dem gesucht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Ruft den Namen des Protokolls ab, in der die angegebene Quelle registriert ist.</summary>
        <returns>Der Name des Protokolls, das der angegebenen Quelle in der Registrierung zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Ereignisquelle gibt an, wodurch das Ereignis protokolliert. Es ist oft den Namen der Anwendung oder den Namen der Unterkomponente der Anwendung, wenn die Anwendung groß ist. Anwendungen und Dienste müssen in das Anwendungsprotokoll oder ein benutzerdefiniertes Protokoll schreiben. Gerätetreiber müssen in das Systemprotokoll schreiben.  
  
 Bei der Erstellung einer neuen Quelle, die nur in ein Protokoll zu einem Zeitpunkt schreiben können, registriert das System die Anwendung mit dem Ereignisprotokoll als gültige Quelle für Einträge an. Die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft kann eine beliebige Zeichenfolge sein, aber der Name kann nicht von anderen Quellen auf dem Computer verwendet werden. Der Versuch, eine doppelte erstellen <xref:System.Diagnostics.EventLog.Source%2A> Wert löst eine Ausnahme aus. Allerdings kann ein Ereignisprotokoll vielen verschiedene Quellen, die in den sie schreiben müssen.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Quelle vom lokalen Computer gelöscht. Im Beispiel wird das Protokoll und der zugehörigen Quelle bestimmt, und klicken Sie dann das Protokoll gelöscht.  
  
> [!NOTE]
>  Mehr als einer Datenquelle kann in ein Ereignisprotokoll schreiben. Stellen Sie vor dem Löschen eines benutzerdefinierten Protokolls können Sie sicher, dass keine anderen Quellen, die beim Schreiben in das Protokoll geschrieben.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Computers ab, auf dem Ereignisse gelesen oder geschrieben werden sollen, oder legt diesen fest.</summary>
        <value>Der Name des Servers, auf dem das Ereignisprotokoll gespeichert ist. Der Standardwert ist der lokale Computer (".").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie in ein Ereignisprotokoll schreiben, müssen Sie Zuordnen einer <xref:System.Diagnostics.EventLog.Source%2A> mit dem Ereignisprotokoll-Objekt, für die Verbindung mit einem bestimmten Protokoll. Es ist nicht erforderlich, an die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft, wenn Sie nur aus einem Protokoll gelesen. Sie können angeben, nur die <xref:System.Diagnostics.EventLog.Log%2A> Name und <xref:System.Diagnostics.EventLog.MachineName%2A> (Name des Computers).  
  
> [!NOTE]
>  Sie müssen nicht angeben. die <xref:System.Diagnostics.EventLog.MachineName%2A> Wenn Sie die in ein Protokoll herstellen. Wenn Sie keinen angeben der <xref:System.Diagnostics.EventLog.MachineName%2A>, dem lokalen Computer (".") wird angenommen.  
  
 Eine Quelle kann nur ein Protokoll zu einem Zeitpunkt registriert werden. Wenn die <xref:System.Diagnostics.EventLog.Source%2A> -Eigenschaft wurde festgelegt, für eine Instanz von <xref:System.Diagnostics.EventLog>, kann nicht geändert werden die <xref:System.Diagnostics.EventLog.MachineName%2A> -Eigenschaft für diesen <xref:System.Diagnostics.EventLog> ohne Änderung des Werts der <xref:System.Diagnostics.EventLog.Source%2A> oder Aufrufen <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> erste. Wenn Sie ändern die <xref:System.Diagnostics.EventLog.MachineName%2A> -Eigenschaft, die <xref:System.Diagnostics.EventLog> alle Handles schließen und erneut angefügt wird, um das Protokoll und der Quelle auf dem neuen Computer.  
  
 Die <xref:System.Diagnostics.EventLog.MachineName%2A> Wert darf keine leere Zeichenfolge sein. Wenn sie nicht explizit festgelegt ist, wird standardmäßig auf dem lokalen Computer (".").  
  
   
  
## Examples  
 Das folgende Beispiel liest die Einträge in das Ereignisprotokoll "NewEventLog", auf einem angegebenen Computer.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Computername ist ungültig.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Ereignisprotokollgröße in Kilobyte ab oder legt diese fest.</summary>
        <value>Die maximale Ereignisprotokollgröße in Kilobyte. Der Standardwert lautet 512 und gibt eine maximale Dateigröße von 512 Kilobyte an.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> Eigenschaft darstellt, das Größenlimit von der Ereignisprotokolldatei. Wenn das Ereignisprotokoll erreicht die maximale Größe, die den konfigurierten <xref:System.Diagnostics.EventLog.OverflowAction%2A> Wert bestimmt, ob neue Einträge verworfen werden, oder, ob das neue Einträge ältere Einträge überschreiben.  
  
> [!NOTE]
>  Diese Eigenschaft stellt eine Konfigurationseinstellung für das Ereignisprotokoll, die von dieser Instanz dargestellten dar. Wenn das Ereignisprotokoll die maximale Größe erreicht, gibt diese Eigenschaft an, wie das Betriebssystem neue Einträge, die durch alle Ereignisquellen, die registriert wird, für das Ereignisprotokoll geschrieben behandelt.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Ereignisprotokolle auf dem lokalen Computer definierten aufgelistet, und zeigt Konfigurationsdetails für jedes Ereignisprotokoll.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der angegebene Wert ist kleiner als 64, größer als 4194240 oder kein ganzes Vielfaches von 64.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.EventLog.Log" />-Wert ist kein gültiger Protokollname.  
  
\- oder – 
Der Registrierungsschlüssel für das Ereignisprotokoll konnte auf dem Zielcomputer nicht geöffnet werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Tagen ab, für die Einträge im Ereignisprotokoll beibehalten werden sollen.</summary>
        <value>Die Anzahl von Tagen, für die Einträge im Ereignisprotokoll beibehalten werden. Der Standardwert ist 7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Eigenschaft, um die aktuelle Einstellung für ein Ereignisprotokoll überprüfen. Verwendung <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> so ändern Sie die minimale Anzahl von Tagen, die jeder Eintrag im Ereignisprotokoll beibehalten werden müssen.  
  
 Die <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wert hängt vom konfigurierten Überlaufverhalten des Ereignisprotokolls an. Wenn die <xref:System.Diagnostics.OverflowAction> für ein Ereignisprotokoll-Eigenschaftensatz auf <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, und klicken Sie dann die <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wert ist 0. Wenn die <xref:System.Diagnostics.OverflowAction> für ein Ereignisprotokoll-Eigenschaftensatz auf <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, und klicken Sie dann die <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wert ist 1. Wenn die <xref:System.Diagnostics.OverflowAction> für ein Ereignisprotokoll-Eigenschaftensatz auf <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, und klicken Sie dann die <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wert ist größer als 0 (null), und gibt die Anzahl von Tagen, Einträge im Ereignisprotokoll beibehalten werden sollen, wenn das Ereignisprotokoll voll ist.  
  
 Das Überlaufverhalten tritt nur auf, wenn ein Ereignisprotokoll die maximale Dateigröße erreicht. Wenn ein <xref:System.Diagnostics.EventLog> hat seine <xref:System.Diagnostics.EventLog.OverflowAction%2A> legen Sie auf <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, im Ereignisprotokoll die maximale Größe erreicht, und neue Einträge werden nur geschrieben, wenn sie Einträge ersetzen können, deren Alter überschreitet, die <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Zeitraum. Ereigniseinträge für einen Zeitraum mindestens ist geeignet, wenn das Ereignisprotokoll regelmäßig archiviert wird. Andernfalls riskieren Sie neue Einträge verlieren, wenn das Ereignisprotokoll auf den Grenzwert erreicht wird. Um zu vermeiden, neue Ereignisinformationen verloren gehen, legen Sie die Mindestbeibehaltungsdauer Tage für die Ereignisse basierend auf den Zeitplan "Archiv" für ein bestimmtes Ereignisprotokoll.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Ereignisprotokolle auf dem lokalen Computer definierten aufgelistet, und zeigt Konfigurationsdetails für jedes Ereignisprotokoll.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">Das Überlaufverhalten für das Schreiben neuer Einträge in das Ereignisprotokoll.</param>
        <param name="retentionDays">Die Mindestanzahl von Tagen, für die jeder Ereignisprotokolleintrag beibehalten wird. Dieser Parameter wird nur verwendet, wenn <c>action</c> auf <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" /> festgelegt ist.</param>
        <summary>Ändert das konfigurierte Verhalten zum Schreiben neuer Einträge, wenn die maximale Dateigröße des Ereignisprotokolls erreicht wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Überlaufverhalten für ein Ereignisprotokoll gibt an, was geschieht, wenn neue Einträge werden in ein Protokoll geschrieben werden, die die maximale Dateigröße erreicht hat.  
  
> [!NOTE]
>  Das Überlaufverhalten wird wirksam, nur, wenn ein Ereignisprotokoll die maximale Dateigröße erreicht wird. Das Überlaufverhalten wirkt sich nicht auf einen neuen Eintrag in ein Protokoll schreiben, die zusätzliche Ereignisprotokolleinträge aufnehmen kann.  
  
 Die <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> -Methode konfiguriert das Überlaufverhalten von einem Ereignisprotokoll. <xref:System.Diagnostics.EventLog> -Instanz. Nach dem Aufrufen dieser Methode für das Ereignisprotokoll, die gemäß der <xref:System.Diagnostics.EventLog.Log%2A> -Eigenschaft, die <xref:System.Diagnostics.EventLog.OverflowAction%2A> und <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Eigenschaftswerte Geben Sie die neu konfigurierte Überlaufverhalten.  
  
> [!NOTE]
>  Diese Eigenschaft stellt eine Konfigurationseinstellung für das Ereignisprotokoll, die von dieser Instanz dargestellten dar. Wenn das Ereignisprotokoll die maximale Größe erreicht, gibt diese Eigenschaft an, wie das Betriebssystem neue Einträge, die durch alle Ereignisquellen, die registriert wird, für das Ereignisprotokoll geschrieben behandelt.  
  
 Legen Sie die `action` Parameter, um <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> um anzugeben, dass ein neuer Eintrag der älteste Eintrag überschrieben wird bei der <xref:System.Diagnostics.EventLog> die maximale Größe erreicht. Wenn die `action` Parametersatz zu <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, `retentionDays` Parameterwert wird ignoriert.  
  
 Legen Sie die `action` Parameter, um <xref:System.Diagnostics.OverflowAction.OverwriteOlder> , um anzugeben, dass jeder neuer Eintrag, ältere Einträge überschreibt bei der <xref:System.Diagnostics.EventLog> die maximale Größe erreicht. Geben Sie die Anzahl der Tage, die Ereignisse beibehalten werden müssen, in der Protokolldatei mit dem `retentionDays` Parameter. Ereignisse, die innerhalb der Beibehaltungsdauer geschrieben werden nicht von neuen Einträgen überschrieben.  
  
 Legen Sie die `action` Parameter <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> verwerfen neue Ereignisse, wenn die maximale Protokollgröße erreicht ist. Wenn die `action` Parametersatz zu <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, `retentionDays` Parameterwert wird ignoriert.  
  
> [!CAUTION]
>  Festlegen der Überlaufrichtlinie auf <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> gibt an, dass neue Einträge verworfen werden, wenn das Ereignisprotokoll voll ist. Wenn Sie diese Einstellung verwenden, stellen Sie sicher, das Ereignisprotokoll regelmäßig archiviert und gelöscht werden, um zu vermeiden, die maximale größenbeschränkung erreicht ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die konfigurierten Überlaufrichtlinie für ein bestimmtes Ereignisprotokoll, und ermöglicht dem Benutzer, wählen Sie eine neue Einstellung für das Ereignisprotokoll Überlauf.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> ist kein gültiger <see cref="P:System.Diagnostics.EventLog.OverflowAction" />-Wert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" /> ist kleiner als 1 oder größer als 365.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.EventLog.Log" />-Wert ist kein gültiger Protokollname.  
  
\- oder – 
Der Registrierungsschlüssel für das Ereignisprotokoll konnte auf dem Zielcomputer nicht geöffnet werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das zum Speichern neuer Einträge bei Erreichen der maximalen Dateigröße des Ereignisprotokolls konfigurierte Verhalten ab.</summary>
        <value>Der <see cref="T:System.Diagnostics.OverflowAction" />-Wert, der das zum Speichern neuer Einträge beim Erreichen der maximalen Dateigröße des Ereignisprotokolls konfigurierte Verhalten angibt. Der Standardwert ist <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ereignisprotokolle größer als neue Termine in sie geschrieben werden. Jedes Ereignisprotokoll verfügt über eine konfigurierte maximale Größenlimit; die <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> Eigenschaft definiert die maximale Anzahl der Kilobytes, die für die Dateigröße des Ereignisprotokolls zulässig.  
  
 Verwenden der <xref:System.Diagnostics.EventLog.OverflowAction%2A> Eigenschaftswert angibt, überprüfen Sie die konfigurierten Überlaufverhalten für ein Ereignisprotokoll die maximale Größe erreicht. Verwenden der <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Methode, um das Überlaufverhalten für ein Ereignisprotokoll zu ändern.  
  
> [!NOTE]
>  Das Überlaufverhalten wird wirksam, nur, wenn ein Ereignisprotokoll die maximale Dateigröße erreicht wird. Das Überlaufverhalten wirkt sich nicht auf einen neuen Eintrag in ein Protokoll schreiben, die zusätzliche Ereignisprotokolleinträge aufnehmen kann.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Ereignisprotokolle auf dem lokalen Computer definierten aufgelistet, und zeigt Konfigurationsdetails für jedes Ereignisprotokoll.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">Der vollständig angegebene Pfad einer lokalisierten Ressourcendatei.</param>
        <param name="resourceId">Der Ressourcenbezeichner, der eine lokalisierte Zeichenfolge in der Ressourcendatei indiziert.</param>
        <summary>Gibt den lokalisierten Namen des Ereignisprotokolls an, der in der Ereignisanzeige des Servers angezeigt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> zu registrieren und einen lokalisierten Namen in der Ereignisanzeige für benutzerdefinierte Ereignisprotokolle anzeigen.  
  
 Die angegebenen Ressourcenbezeichner muss eine lokalisierte Zeichenfolge, die in der Ressourcendatei definierten entsprechen. Die Ereignisanzeige werden die benutzerdefinierten Ereignisprotokollname die lokalisierte Zeichenfolge mit der aktuellen kultureinstellungen angezeigt. Beispielsweise können Sie mehrere Ereignisprotokollnamen für unterschiedliche Kulturen in Ihrer Ressourcendatei lokalisierte definieren. Die Ereignisanzeige werden die lokalisierte Zeichenfolge für die Einstellungen der Kultur des aktuellen Benutzers angezeigt.  
  
 Wenn der Ereignisanzeige die lokalisierte Zeichenfolge aus der Ressourcendatei kann nicht geladen werden, oder wenn kein Anzeigename für das Ereignisprotokoll registriert wurde, klicken Sie dann der Ereignisanzeige der Name des Ereignisprotokolls wird in definierten <xref:System.Diagnostics.EventLog.Log%2A>.  
  
> [!NOTE]
>  Sie müssen sich nicht um einen Anzeigenamen für die vordefinierten-Ereignisprotokolle zu registrieren. Das Betriebssystem registriert die lokalisierten Anzeigenamen für die Ereignisprotokolle Anwendung, System und Sicherheit.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob die Ereignisquelle, mit dem Namen `SampleApplicationSource` auf dem lokalen Computer registriert ist. Wenn die Ereignisquelle nicht vorhanden ist, wird im Beispiel wird von der Meldungsressourcendatei für die Quelle, und erstellt die neue Ereignisquelle. Im Beispiel wird schließlich den lokalisierten Anzeigenamen für das Ereignisprotokoll, die mit dem Ressourcen-ID-Wert in `DisplayNameMsgId` und den Ressourcenpfad für die Datei im `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 Im Beispiel wird die folgende Meldung-Textdatei, die Ressourcenbibliothek EventLogMsgs.dll integriert. Eine Nachricht Text-Datei ist die Quelle, aus der Meldungsressourcendatei erstellt wird. Die Nachricht-Text-Datei definiert die Ressourcen-IDs und der Text für die Kategorie, ereignismeldung und Parameter einfügen-Zeichenfolgen. Für den lokalisierten Namen des Ereignisprotokolls ist insbesondere Ressourcenbezeichner 5001 definiert.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.EventLog.Log" />-Wert ist kein gültiger Protokollname.  
  
\- oder – 
Der Registrierungsschlüssel für das Ereignisprotokoll konnte auf dem Zielcomputer nicht geöffnet werden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFile" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">für die Verwaltung von Ereignisprotokollinformationen auf dem Computer aus. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zu registrierenden Namen der Quelle ab, die zum Schreiben in das Ereignisprotokoll verwendet werden soll, oder legt diesen fest.</summary>
        <value>Der Name, der im Ereignisprotokoll als Quelle für Einträge registriert ist. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Ereignisquelle gibt an, wodurch das Ereignis protokolliert. Es ist oft den Namen der Anwendung oder den Namen der Unterkomponente der Anwendung, wenn die Anwendung groß ist. Anwendungen und Dienste müssen in das Anwendungsprotokoll oder ein benutzerdefiniertes Protokoll schreiben. Gerätetreiber müssen in das Systemprotokoll schreiben.  
  
 Sie müssen nur eine Ereignisquelle angeben, wenn Sie in ein Ereignisprotokoll schreiben. Bevor Sie einen Eintrag in ein Ereignisprotokoll schreiben, müssen Sie die Ereignisquelle mit dem Ereignisprotokoll als gültige Quelle von Ereignissen registrieren. Wenn Sie einen Protokolleintrag schreiben, das System verwendet die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft, um das entsprechende Protokoll, in dem den Eintrag zu finden. Wenn Sie das Ereignisprotokoll lesen, können Sie entweder eine angeben der <xref:System.Diagnostics.EventLog.Source%2A>, oder ein <xref:System.Diagnostics.EventLog.Log%2A> und <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Sie sind nicht erforderlich, an die <xref:System.Diagnostics.EventLog.MachineName%2A> , wenn Sie die Verbindung mit einem Protokoll auf dem lokalen Computer herstellen. Wenn Sie keinen angeben der <xref:System.Diagnostics.EventLog.MachineName%2A>, dem lokalen Computer (".") wird angenommen.  
  
 Verwendung <xref:System.Diagnostics.EventLog.WriteEvent%2A> und <xref:System.Diagnostics.EventLog.WriteEntry%2A> werden Ereignisse in ein Ereignisprotokoll geschrieben. Sie müssen eine Ereignisquelle zum Schreiben von Ereignissen angeben. Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Sie können eine Ereignisquelle für ein vorhandenes oder ein neues Ereignisprotokoll erstellen. Wenn Sie eine neue Quelle für ein neues Ereignisprotokoll erstellen, registriert das System die Quelle für das Protokoll geschrieben, aber das Protokoll wird nicht erstellt werden, bis der erste Eintrag darin geschrieben wird.  
  
 Die Quelle muss auf dem lokalen Computer eindeutig sein. ein neuen Quellennamen kann nicht den Datenquellennamen einer vorhandenen oder einem vorhandenen Ereignisprotokollnamen überein. Jede Quelle kann jeweils nur ein Ereignisprotokoll schreiben. Allerdings kann die Anwendung auf mehreren Quellen verwenden, zum Schreiben in verschiedenen Ereignisprotokollen. Z. B. möglicherweise die Anwendung mehrere Quellen für unterschiedliche Ereignisprotokolle oder andere Ressourcendateien konfiguriert.  
  
 Wenn Sie ändern die <xref:System.Diagnostics.EventLog.Source%2A> Wert, der <xref:System.Diagnostics.EventLog> , die es registriert wurde geschlossen, und alle Ereignishandles freigegeben werden.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
 Um die Konfigurationsdetails der einer vorhandenen Datenquelle ändern zu können, müssen Sie der Quelle löschen und dann mit der neuen Konfiguration erstellen. Wenn andere Anwendungen oder Komponenten die vorhandene Quelle verwenden, erstellen Sie eine neue Datenquelle mit der aktualisierten Konfiguration löschen, statt die vorhandene Datenquelle aus.  
  
> [!NOTE]
>  Wenn eine Quelle in ein Protokoll wurde bereits zugeordnet, und Sie es in ein neues Protokoll ordnen, müssen Sie den Computer für die Änderungen wirksam werden neu starten.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` wenn er noch nicht vorhanden, und einen Eintrag im Ereignisprotokoll schreibt `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht die Registrierung eines Computers nach einer bestimmten Ereignisquelle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name der Ereignisquelle.</param>
        <summary>Bestimmt, ob eine Ereignisquelle auf dem lokalen Computer registriert ist.</summary>
        <returns>
          <see langword="true" />, wenn die Ereignisquelle auf dem lokalen Computer registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um zu bestimmen, ob eine Ereignisquelle auf dem lokalen Computer vorhanden ist. Wenn Sie bestimmen, ob ein Protokoll vorhanden, auf dem lokalen Computer verwenden ist möchten <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Da diese Methode die Registrierung zugreift, müssen Sie die entsprechenden Registrierungswerte-Berechtigungen auf dem lokalen Computer verfügen; andernfalls ein <xref:System.Security.SecurityException> ausgelöst.  
  
> [!NOTE]
>  Um für eine Ereignisquelle in Windows Vista und höher oder Windows Server 2003 zu suchen, müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignisquelle eindeutig ist. Ab Windows Vista sind Benutzer nicht berechtigt, auf das Sicherheitsprotokoll zugreifen.; aus diesem Grund eine <xref:System.Security.SecurityException> ausgelöst.  
>   
>  Ab Windows Vista-Benutzerkontensteuerung (UAC) bestimmt die Berechtigungen eines Benutzers. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Zum Ausführen des Codes, die Leistungsindikatoren zugreift, müssen Sie zuerst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.   
  
> [!NOTE]
>  Ein Dienst, der unter ausgeführt wird die <xref:System.ServiceProcess.ServiceAccount.LocalSystem> Konto verfügt nicht über die erforderlichen Berechtigungen für diese Methode auszuführen. Die Lösung ist, zu prüfen, ob die Ereignisquelle in die <xref:System.ServiceProcess.ServiceInstaller>, und wenn sie nicht vorhanden, um die Quelle in das Installationsprogramm zu erstellen,.  
  
 Da Sie einer neuen Datenquelle können nicht den Namen einer vorhandenen Quelle auf dem gleichen Computer geben, verwenden Sie diese Methode vor dem Aufrufen <xref:System.Diagnostics.EventLog.CreateEventSource%2A> um sicherzustellen, dass eine Quelle mit dem Namen gemäß `source` ist bereits auf dem lokalen Computer nicht vorhanden. Die `source` Parameter wird nicht beachtet.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` wenn er noch nicht vorhanden, und einen Eintrag im Ereignisprotokoll schreibt `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" /> wurde nicht gefunden, aber einige oder alle Ereignisprotokolle konnten nicht durchsucht werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der Name der Ereignisquelle.</param>
        <param name="machineName">Der Name des Computers, auf dem gesucht werden soll, oder "." für den lokalen Computer.</param>
        <summary>Bestimmt, ob eine Ereignisquelle auf einem angegebenen Computer registriert ist.</summary>
        <returns>
          <see langword="true" />, wenn die Ereignisquelle auf dem angegebenen Computer registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um festzustellen, ob eine Ereignisquelle auf dem angegebenen Computer vorhanden ist. die `machineName` Parameter. Wenn Sie bestimmen, ob ein Protokoll vorhanden, auf dem angegebenen Computer verwenden ist möchten <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Da diese Methode die Registrierung zugreift, müssen Sie Registrierungsberechtigungen auf dem betreffenden Server; andernfalls ein <xref:System.Security.SecurityException> ausgelöst.  
  
> [!NOTE]
>  Um für eine Ereignisquelle in Windows Vista und höher oder Windows Server 2003 zu suchen, müssen Sie über Administratorrechte verfügen.  
>   
>  Der Grund für diese Anforderung ist, dass alle Ereignisprotokolle, einschließlich Sicherheit, durchsucht werden müssen, um zu bestimmen, ob die Ereignisquelle eindeutig ist. Ab Windows Vista sind Benutzer nicht berechtigt, auf das Sicherheitsprotokoll zugreifen.; aus diesem Grund eine <xref:System.Security.SecurityException> ausgelöst.  
>   
>  Ab Windows Vista-Benutzerkontensteuerung (UAC) bestimmt die Berechtigungen eines Benutzers. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Zum Ausführen des Codes, die Leistungsindikatoren zugreift, müssen Sie zuerst Ihre Berechtigungen von Standardbenutzer auf Administrator erhöhen. Dazu starten Sie eine Anwendung, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie die Anwendung als Administrator ausführen möchten.   
  
> [!NOTE]
>  Ein Dienst, der unter ausgeführt wird die <xref:System.ServiceProcess.ServiceAccount.LocalSystem> Konto verfügt nicht über die erforderlichen Berechtigungen für diese Methode auszuführen. Die Lösung ist, zu prüfen, ob die Ereignisquelle in die <xref:System.ServiceProcess.ServiceInstaller>, und wenn sie nicht vorhanden, um die Quelle in das Installationsprogramm zu erstellen,.  
  
 Da Sie einer neuen Datenquelle können nicht den Namen einer vorhandenen Quelle auf dem gleichen Computer geben, verwenden Sie diese Methode vor dem Aufrufen <xref:System.Diagnostics.EventLog.CreateEventSource%2A> um sicherzustellen, dass eine Quelle mit dem Namen gemäß `source` ist nicht auf dem Computer bereits vorhanden. Die `source` und `machineName` Parameter sind nicht in der Groß-/Kleinschreibung beachtet.  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> ist eine `static` Methode, sodass sie in der Klasse selbst aufgerufen werden kann. Es ist nicht erforderlich, zum Erstellen einer Instanz von <xref:System.Diagnostics.EventLog> aufzurufende <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` auf dem Computer `MyServer`, und schreibt einen Eintrag im Ereignisprotokoll `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> ist ein ungültiger Computername.</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" /> wurde nicht gefunden, aber einige oder alle Ereignisprotokolle konnten nicht durchsucht werden.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt für das Marshallen der Ereignishandleraufrufe ab, die aufgrund eines Ereignisses für das Schreiben eines <see cref="T:System.Diagnostics.EventLog" />-Eintrags ausgegeben werden, oder legt dieses fest.</summary>
        <value>Das <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> für das Marshallen von Ereignishandleraufrufen, die aufgrund eines <see cref="E:System.Diagnostics.EventLog.EntryWritten" />-Ereignisses im Ereignisprotokoll ausgegeben werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> ist `null`, Methoden zum Behandeln der <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis auf einem Thread vom Threadpool Systems aufgerufen werden. Weitere Informationen zu System Threadpools, finden Sie unter <xref:System.Threading.ThreadPool>.  
  
 Wenn die <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis wird verarbeitet, indem ein visual Windows Forms, Komponente, z. B. eine Schaltfläche, die Zugriff auf die Komponente über den systemthreadpool funktionieren möglicherweise nicht, oder wird möglicherweise eine Ausnahme ausgelöst. Vermeiden Sie dies durch Festlegen von <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> an eine Windows Forms-Komponente, wodurch die Methoden zur Behandlung der <xref:System.Diagnostics.EventLog.EntryWritten> Ereignis, um auf dem gleichen Thread aufgerufen werden, auf dem die Komponente erstellt wurde.  
  
 Wenn die <xref:System.Diagnostics.EventLog> wird verwendet, in [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in einem Windows Forms-Designer <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> wird automatisch festgelegt, um das Steuerelement mit dem <xref:System.Diagnostics.EventLog>. Wenn Sie platzieren z. B. eine <xref:System.Diagnostics.EventLog> in einem Designer für Form1 (erbt von <xref:System.Windows.Forms.Form>) die <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> Eigenschaft <xref:System.Diagnostics.EventLog> festgelegt ist, mit der Instanz von Form1.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt einen Eintrag in das Ereignisprotokoll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <summary>Schreibt einen Eintrag vom Typ Information mit dem angegebenen Meldungstext in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können Sie einen Informationseintrag in das Ereignisprotokoll zugeordneten schreiben <xref:System.Diagnostics.EventLog> Instanz. Wenn Sie alle anderen angeben möchten <xref:System.Diagnostics.EventLogEntryType>, verwenden Sie eine andere Überladung der <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei *n* ist ein Ganzzahlwert (z. B. %1), da es sich bei die Ereignisanzeige behandelt es als Einfügezeichenfolge. Da die Zeichenfolge für ein Internetprotokoll, Version 6 (IPv6)-Adresse, die diese enthalten kann, kann Sie keine ereignismeldung anmelden, die eine IPv6-Adresse enthält.  
  
 Müssen Sie festlegen, die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft Ihre <xref:System.Diagnostics.EventLog> Komponente, bevor Sie Einträge in das Anwendungsprotokoll schreiben können. Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Wenn in die Quelle angegeben die <xref:System.Diagnostics.EventLog.Source%2A> -Eigenschaft dieses <xref:System.Diagnostics.EventLog> Instanz ist nicht registriert, auf dem Computer, die die Komponente, schreibt <xref:System.Diagnostics.EventLog.WriteEntry%2A> Aufrufe <xref:System.Diagnostics.EventLog.CreateEventSource%2A> und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie nicht angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A> für Ihre <xref:System.Diagnostics.EventLog> Instanz vor dem Aufruf <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>, dem lokalen Computer (".") wird davon ausgegangen.  
  
 Wenn das System zum Registrieren der <xref:System.Diagnostics.EventLog.Source%2A> durch einen Aufruf von <xref:System.Diagnostics.EventLog.WriteEntry%2A> und <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft wurde nicht festgelegt wurde, auf Ihre <xref:System.Diagnostics.EventLog> -Instanz das Protokoll wird standardmäßig in das Anwendungsprotokoll.  
  
> [!NOTE]
>  Viele der oben aufgeführten Ausnahmen werden von der während der Registrierung ausgelöste Fehler generiert, die <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Nachricht-Ressourcendatei wird nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldung-Ressourcendatei.  
  
 Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag mit einem Remotecomputer schreiben, der Wert der Nachricht (die Textzeichenfolge) möglicherweise nicht erwartungsgemäß, wenn der Remotecomputer nicht .NET Framework ausgeführt wird.  
  
> [!NOTE]
>  Wenn die `message` Parameter enthält ein NULL-Zeichen, die Meldung im Ereignisprotokoll auf das NUL-Zeichen beendet.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` wenn er noch nicht vorhanden, und einen Eintrag im Ereignisprotokoll schreibt `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" />-Eigenschaft von <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
- oder - 
Die Methode hat versucht, eine neue Ereignisquelle zu registrieren, der Computername in <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist jedoch ungültig.  
  
\- oder – 
Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
\- oder – 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <summary>Schreibt einen Eintrag für einen Fehler, eine Warnung, eine Information, eine Erfolgs- oder Fehlerüberwachung mit dem angegebenen Meldungstext in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Schreiben eines Eintrags von einem angegebenen <xref:System.Diagnostics.EventLogEntryType> in das Ereignisprotokoll geschrieben. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei *n* ist ein Ganzzahlwert (z. B. %1), da es sich bei die Ereignisanzeige behandelt es als Einfügezeichenfolge. Da die Zeichenfolge für ein Internetprotokoll, Version 6 (IPv6)-Adresse, die diese enthalten kann, kann Sie keine ereignismeldung anmelden, die eine IPv6-Adresse enthält.  
  
 Müssen Sie festlegen, die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft Ihre <xref:System.Diagnostics.EventLog> Komponente, bevor Sie Einträge in das Anwendungsprotokoll schreiben können. Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Wenn in die Quelle angegeben die <xref:System.Diagnostics.EventLog.Source%2A> -Eigenschaft dieses <xref:System.Diagnostics.EventLog> Instanz ist nicht registriert, auf dem Computer, die die Komponente, schreibt <xref:System.Diagnostics.EventLog.WriteEntry%2A> Aufrufe <xref:System.Diagnostics.EventLog.CreateEventSource%2A> und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie nicht angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A> für Ihre <xref:System.Diagnostics.EventLog> Instanz vor dem Aufruf <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>, dem lokalen Computer (".") wird davon ausgegangen.  
  
 Wenn das System zum Registrieren der <xref:System.Diagnostics.EventLog.Source%2A> durch einen Aufruf von <xref:System.Diagnostics.EventLog.WriteEntry%2A> und <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft wurde nicht festgelegt wurde, auf Ihre <xref:System.Diagnostics.EventLog> -Instanz das Protokoll wird standardmäßig in das Anwendungsprotokoll.  
  
> [!NOTE]
>  Viele der oben aufgeführten Ausnahmen werden durch Fehler wird ausgelöst, die während der Registrierung generiert die <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Nachricht-Ressourcendatei wird nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldung-Ressourcendatei.  
  
 Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag mit einem Remotecomputer schreiben, der Wert der Nachricht (die Textzeichenfolge) möglicherweise nicht erwartungsgemäß, wenn der Remotecomputer nicht .NET Framework ausgeführt wird.  
  
> [!NOTE]
>  Wenn die `message` Parameter enthält ein NULL-Zeichen, die Meldung im Ereignisprotokoll auf das NUL-Zeichen beendet.  
  
   
  
## Examples  
 Im folgende Beispiel schreibt einen Warnungseintrag an ein Ereignisprotokoll, "MyNewLog", auf dem lokalen Computer.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" />-Eigenschaft von <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
- oder - 
Die Methode hat versucht, eine neue Ereignisquelle zu registrieren, der Computername in <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist jedoch ungültig.  
  
\- oder – 
Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
\- oder – 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <summary>Schreibt einen Eintrag vom Typ Information mit dem angegebenen Meldungstext in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode schreiben Sie einen Informationseintrag in das Ereignisprotokoll, die mithilfe einer Datenquelle, die bereits als Ereignisquelle für das entsprechende Protokoll registriert ist. Wenn Sie alle anderen angeben möchten <xref:System.Diagnostics.EventLogEntryType>, verwenden Sie eine andere Überladung der <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Nachricht-Ressourcendatei wird nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldung-Ressourcendatei.  
  
 Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
> [!NOTE]
>  Wenn die `message` Parameter enthält ein NULL-Zeichen, die Meldung im Ereignisprotokoll auf das NUL-Zeichen beendet.  
>   
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei *n* ist ein Ganzzahlwert (z. B. %1), da es sich bei die Ereignisanzeige behandelt es als Einfügezeichenfolge. Da die Zeichenfolge für ein Internetprotokoll, Version 6 (IPv6)-Adresse, die diese enthalten kann, kann Sie keine ereignismeldung anmelden, die eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Quelle `MySource` wenn er noch nicht vorhanden, und einen Eintrag im Ereignisprotokoll schreibt `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Wert ist eine leere Zeichenfolge ("").  
  
\- oder – 
Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
\- oder – 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext und dem von der Anwendung definierten Ereignisbezeichner in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Schreiben eines Eintrags mit eine anwendungsdefinierte `eventID` in das Ereignisprotokoll geschrieben. Die `eventID` zusammen mit der Quelle ein Ereignis eindeutig. Jede Anwendung kann definieren, seine eigenen nummerierten Ereignisse und die Beschreibungszeichenfolge, die sie zugeordnet. Ereignis-Viewer zeigen diese Zeichenfolgenwerte, damit der Benutzer die Fehlerursache, und welche Maßnahmen zu ergreifen sind.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei *n* ist ein Ganzzahlwert (z. B. %1), da es sich bei die Ereignisanzeige behandelt es als Einfügezeichenfolge. Da die Zeichenfolge für ein Internetprotokoll, Version 6 (IPv6)-Adresse, die diese enthalten kann, kann Sie keine ereignismeldung anmelden, die eine IPv6-Adresse enthält.  
  
 Sie können zusätzlich zu den Ereignis-ID angeben einer <xref:System.Diagnostics.EventLogEntryType> für das Ereignis in das Ereignisprotokoll geschrieben wird. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp, Fehler, Warnung, Informationen, erfolgsüberwachung oder Fehlerüberwachung ist.  
  
 Müssen Sie festlegen, die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft Ihre <xref:System.Diagnostics.EventLog> Komponente, bevor Sie Einträge in das Anwendungsprotokoll schreiben können. Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Wenn in die Quelle angegeben die <xref:System.Diagnostics.EventLog.Source%2A> -Eigenschaft dieses <xref:System.Diagnostics.EventLog> Instanz ist nicht registriert, auf dem Computer, die die Komponente, schreibt <xref:System.Diagnostics.EventLog.WriteEntry%2A> Aufrufe <xref:System.Diagnostics.EventLog.CreateEventSource%2A> und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie nicht angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A> für Ihre <xref:System.Diagnostics.EventLog> Instanz vor dem Aufruf <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>, dem lokalen Computer (".") wird davon ausgegangen.  
  
 Wenn das System zum Registrieren der <xref:System.Diagnostics.EventLog.Source%2A> durch einen Aufruf von <xref:System.Diagnostics.EventLog.WriteEntry%2A> und <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft wurde nicht festgelegt wurde, auf Ihre <xref:System.Diagnostics.EventLog> -Instanz das Protokoll wird standardmäßig in das Anwendungsprotokoll.  
  
> [!NOTE]
>  Viele der oben aufgeführten Ausnahmen werden durch Fehler wird ausgelöst, die während der Registrierung generiert die <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Nachricht-Ressourcendatei wird nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldung-Ressourcendatei.  
  
 Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag mit einem Remotecomputer schreiben, der Wert der Nachricht (die Textzeichenfolge) möglicherweise nicht erwartungsgemäß, wenn der Remotecomputer nicht .NET Framework ausgeführt wird.  
  
> [!NOTE]
>  Wenn die `message` Parameter enthält ein NULL-Zeichen, die Meldung im Ereignisprotokoll auf das NUL-Zeichen beendet.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" />-Eigenschaft von <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
- oder - 
Die Methode hat versucht, eine neue Ereignisquelle zu registrieren, der Computername in <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist jedoch ungültig.  
  
\- oder – 
Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
\- oder – 
 <paramref name="eventID" /> ist kleiner als 0 oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
\- oder – 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <summary>Schreibt einen Eintrag für einen Fehler, eine Warnung, eine Information oder eine Erfolgs- oder Fehlerüberwachung mit dem angegebenen Meldungstext in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Schreiben eines Eintrags von einem angegebenen <xref:System.Diagnostics.EventLogEntryType> in das Ereignisprotokoll, verwenden eine Datenquelle bereits als Ereignisquelle für das entsprechende Protokoll registriert. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei *n* ist ein Ganzzahlwert (z. B. %1), da es sich bei die Ereignisanzeige behandelt es als Einfügezeichenfolge. Da die Zeichenfolge für ein Internetprotokoll, Version 6 (IPv6)-Adresse, die diese enthalten kann, kann Sie keine ereignismeldung anmelden, die eine IPv6-Adresse enthält.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Nachricht-Ressourcendatei wird nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldung-Ressourcendatei.  
  
 Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
> [!NOTE]
>  Wenn die `message` Parameter enthält ein NULL-Zeichen, die Meldung im Ereignisprotokoll auf das NUL-Zeichen beendet.  
  
   
  
## Examples  
 Im folgende Beispiel schreibt einen Warnungseintrag an ein Ereignisprotokoll, "MyNewLog", auf dem lokalen Computer.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Wert ist eine leere Zeichenfolge ("").  
  
\- oder – 
Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
\- oder – 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <param name="category">Die der Meldung zugeordnete anwendungsspezifische Unterkategorie.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext, dem von der Anwendung definierten Ereignisbezeichner und der Kategorie in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Schreiben eines Eintrags mit eine anwendungsdefinierte `category` in das Ereignisprotokoll geschrieben. Die Ereignisanzeige verwendet, Kategorie, die Ereignisse filtern, die von einer Ereignisquelle geschrieben wird. Der Ereignisanzeige können die Kategorie als numerischen Wert anzeigen, oder es kann die Kategorie als eine Ressourcen-ID verwenden, um eine lokalisierte Kategorie-Zeichenfolge anzuzeigen.  
  
> [!NOTE]
>  Die `category` Parameter muss ein positiver Wert sein. Negative Kategoriewerte werden im Viewer als komplementäre positive Zahl angezeigt. Beispielsweise wird die-10 als 65.526,-1 als 65.535 angezeigt.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei *n* ist ein Ganzzahlwert (z. B. %1), da es sich bei die Ereignisanzeige behandelt es als Einfügezeichenfolge. Da die Zeichenfolge für ein Internetprotokoll, Version 6 (IPv6)-Adresse, die diese enthalten kann, kann Sie keine ereignismeldung anmelden, die eine IPv6-Adresse enthält.  
  
 Um lokalisierte Kategoriezeichenfolgen in der Ereignisanzeige anzuzeigen, müssen Sie eine Ereignisquelle mit einer Kategorieressourcendatei konfiguriert, und legen Sie verwenden die `category` zu einer Ressource-ID in der Kategorieressourcendatei. Wenn die Ereignisquelle einen konfigurierten Kategorieressourcendatei verwendet werden soll, oder das angegebene keinen `category` indizieren eine Zeichenfolge in der Kategorieressourcendatei, nicht, wird die Ereignisanzeige die Kategorie "numeric"-Wert für diesen Eintrag angezeigt. Konfigurieren die Kategorieressourcendatei, sowie die Anzahl der der Kategoriezeichenfolgen in der Ressourcendatei, über die <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventSourceCreationData> Klasse.  
  
 Neben der Kategorie können Sie für das Ereignis in das Ereignisprotokoll geschrieben wird Ereignis-ID angeben. Ereignis-IDs, zusammen mit der Ereignisquelle wird ein Ereignis eindeutig identifiziert. Jede Anwendung kann definieren, seine eigenen nummerierten Ereignisse und die Beschreibungszeichenfolge, die sie zugeordnet. Ereignis-Viewer zeigen diese Zeichenfolgenwerte, damit der Benutzer die Fehlerursache, und welche Maßnahmen zu ergreifen sind.  
  
 Schließlich können Sie angeben einer <xref:System.Diagnostics.EventLogEntryType> für das Ereignis in das Ereignisprotokoll geschrieben wird. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp, Fehler, Warnung, Informationen, erfolgsüberwachung oder Fehlerüberwachung ist.  
  
 Müssen Sie festlegen, die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft Ihre <xref:System.Diagnostics.EventLog> Komponente, bevor Sie Einträge in das Anwendungsprotokoll schreiben können. Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Wenn in die Quelle angegeben die <xref:System.Diagnostics.EventLog.Source%2A> -Eigenschaft dieses <xref:System.Diagnostics.EventLog> Instanz ist nicht registriert, auf dem Computer, die die Komponente, schreibt <xref:System.Diagnostics.EventLog.WriteEntry%2A> Aufrufe <xref:System.Diagnostics.EventLog.CreateEventSource%2A> und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie nicht angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A> für Ihre <xref:System.Diagnostics.EventLog> Instanz vor dem Aufruf <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>, dem lokalen Computer (".") wird davon ausgegangen.  
  
 Wenn das System zum Registrieren der <xref:System.Diagnostics.EventLog.Source%2A> durch einen Aufruf von <xref:System.Diagnostics.EventLog.WriteEntry%2A> und <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft wurde nicht festgelegt wurde, auf Ihre <xref:System.Diagnostics.EventLog> -Instanz das Protokoll wird standardmäßig in das Anwendungsprotokoll.  
  
> [!NOTE]
>  Viele der oben aufgeführten Ausnahmen werden durch Fehler wird ausgelöst, die während der Registrierung generiert die <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Nachricht-Ressourcendatei wird nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldung-Ressourcendatei.  
  
 Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag mit einem Remotecomputer schreiben, der Wert der Nachricht (die Textzeichenfolge) möglicherweise nicht erwartungsgemäß, wenn der Remotecomputer nicht .NET Framework ausgeführt wird.  
  
> [!NOTE]
>  Wenn die `message` Parameter enthält ein NULL-Zeichen, die Meldung im Ereignisprotokoll auf das NUL-Zeichen beendet.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" />-Eigenschaft von <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
- oder - 
Die Methode hat versucht, eine neue Ereignisquelle zu registrieren, der Computername in <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist jedoch ungültig.  
  
\- oder – 
Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
\- oder – 
 <paramref name="eventID" /> ist kleiner als 0 oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
\- oder – 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext und dem von der Anwendung definierten Ereignisbezeichner in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Schreiben eines Eintrags mit eine anwendungsdefinierte `eventID` in das Ereignisprotokoll, verwenden eine Datenquelle bereits als Ereignisquelle für das entsprechende Protokoll registriert. Die `eventID`, zusammen mit der Quelle und ein Ereignis eindeutig. Jede Anwendung kann definieren, seine eigenen nummerierten Ereignisse und die Beschreibungszeichenfolge, die sie zugeordnet. Ereignis-Viewer zeigen diese Zeichenfolgen für dem Benutzer, denen der Benutzer zu verstehen, was falsch gelaufen ist und welche Maßnahmen zu ergreifen sind.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei *n* ist ein Ganzzahlwert (z. B. %1), da es sich bei die Ereignisanzeige behandelt es als Einfügezeichenfolge. Da die Zeichenfolge für ein Internetprotokoll, Version 6 (IPv6)-Adresse, die diese enthalten kann, kann Sie keine ereignismeldung anmelden, die eine IPv6-Adresse enthält.  
  
 Zusätzlich zu den Ereignis-ID, diese Überladung von <xref:System.Diagnostics.EventLog.WriteEntry%2A> ermöglicht die Angabe einer <xref:System.Diagnostics.EventLogEntryType> für das Ereignis in das Ereignisprotokoll geschrieben wird. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp, Fehler, Warnung, Informationen, erfolgsüberwachung oder Fehlerüberwachung ist.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Nachricht-Ressourcendatei wird nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldung-Ressourcendatei.  
  
 Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
> [!NOTE]
>  Wenn die `message` Parameter enthält ein NULL-Zeichen, die Meldung im Ereignisprotokoll auf das NUL-Zeichen beendet.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Wert ist eine leere Zeichenfolge ("").  
  
\- oder – 
Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
\- oder – 
 <paramref name="eventID" /> ist kleiner als 0 oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
\- oder – 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <param name="category">Die der Meldung zugeordnete anwendungsspezifische Unterkategorie.</param>
        <param name="rawData">Ein Bytearray mit den dem Eintrag zugeordneten Binärdaten.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext, dem von der Anwendung definierten Ereignisbezeichner und der Kategorie in das Ereignisprotokoll und fügt Binärdaten an die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um anwendungsdefinierte ereignisspezifische Daten in das Ereignisprotokoll zu schreiben. Die Ereignisanzeige interpretiert diese Daten nicht; Es zeigt die unformatierte Daten nur in einem kombinierten hexadezimaler Schreibweise und im Text-Format. Verwenden Sie die ereignisspezifischen Daten nur selten, einschließlich es nur, wenn Sie sicher, dass es an eine Person das Problem Debuggen nützlich sind. Sie können auch ereignisspezifische Daten verwenden, um Informationen zu speichern, die die Anwendung unabhängig von der Ereignisanzeige verarbeiten kann. Beispielsweise können einen Viewer speziell für die Ereignisse zu schreiben oder schreiben ein Programm, das die Protokolldatei scannt und erstellt Berichte, die Informationen aus den ereignisspezifischen Daten enthalten.  
  
 Zusätzlich zu den binären Daten können Sie eine Kategorie und der Anwendung definierten Ereignisbezeichner angeben. Die Ereignisanzeige verwendet, Kategorie, die Ereignisse filtern, die von einer Ereignisquelle geschrieben wird. Der Ereignisanzeige können die Kategorie als numerischen Wert anzeigen, oder es kann die Kategorie als eine Ressourcen-ID verwenden, um eine lokalisierte Kategorie-Zeichenfolge anzuzeigen.  
  
> [!NOTE]
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei *n* ist ein Ganzzahlwert (z. B. %1), da es sich bei die Ereignisanzeige behandelt es als Einfügezeichenfolge. Da die Zeichenfolge für ein Internetprotokoll, Version 6 (IPv6)-Adresse, die diese enthalten kann, kann Sie keine ereignismeldung anmelden, die eine IPv6-Adresse enthält.  
  
> [!NOTE]
>  Die `category` Parameter muss ein positiver Wert sein. Negative Kategoriewerte werden im Viewer als komplementäre positive Zahl angezeigt. Beispielsweise wird die-10 als 65.526,-1 als 65.535 angezeigt.  
  
 Um lokalisierte Kategoriezeichenfolgen in der Ereignisanzeige anzuzeigen, müssen Sie eine Ereignisquelle mit einer Kategorieressourcendatei konfiguriert, und legen Sie verwenden die `category` zu einer Ressource-ID in der Kategorieressourcendatei. Wenn die Ereignisquelle einen konfigurierten Kategorieressourcendatei verwendet werden soll, oder das angegebene keinen `category` indizieren eine Zeichenfolge in der Kategorieressourcendatei, nicht, wird die Ereignisanzeige die Kategorie "numeric"-Wert für diesen Eintrag angezeigt. Konfigurieren die Kategorieressourcendatei, sowie die Anzahl der der Kategoriezeichenfolgen in der Ressourcendatei, über die <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventSourceCreationData> Klasse.  
  
 Ereignis-IDs, zusammen mit der Ereignisquelle wird ein Ereignis eindeutig identifiziert. Jede Anwendung kann definieren, seine eigenen nummerierten Ereignisse und die Beschreibungszeichenfolge, die sie zugeordnet. Ereignis-Viewer zeigen diese Zeichenfolgenwerte, damit der Benutzer die Fehlerursache, und welche Maßnahmen zu ergreifen sind.  
  
 Schließlich können Sie angeben einer <xref:System.Diagnostics.EventLogEntryType> für das Ereignis in das Ereignisprotokoll geschrieben wird. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp, Fehler, Warnung, Informationen, erfolgsüberwachung oder Fehlerüberwachung ist.  
  
 Müssen Sie festlegen, die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft Ihre <xref:System.Diagnostics.EventLog> Komponente, bevor Sie Einträge in das Anwendungsprotokoll schreiben können. Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle.  
  
 Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Wenn in die Quelle angegeben die <xref:System.Diagnostics.EventLog.Source%2A> -Eigenschaft dieses <xref:System.Diagnostics.EventLog> Instanz ist nicht registriert, auf dem Computer, die die Komponente, schreibt <xref:System.Diagnostics.EventLog.WriteEntry%2A> Aufrufe <xref:System.Diagnostics.EventLog.CreateEventSource%2A> und registriert die Quelle.  
  
> [!NOTE]
>  Wenn Sie nicht angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A> für Ihre <xref:System.Diagnostics.EventLog> Instanz vor dem Aufruf <xref:System.Diagnostics.EventLog.CreateEventSource%2A> oder <xref:System.Diagnostics.EventLog.WriteEntry%2A>, dem lokalen Computer (".") wird davon ausgegangen.  
  
 Wenn das System zum Registrieren der <xref:System.Diagnostics.EventLog.Source%2A> durch einen Aufruf von <xref:System.Diagnostics.EventLog.WriteEntry%2A> und <xref:System.Diagnostics.EventLog.Log%2A> Eigenschaft wurde nicht festgelegt wurde, auf Ihre <xref:System.Diagnostics.EventLog> -Instanz das Protokoll wird standardmäßig in das Anwendungsprotokoll.  
  
> [!NOTE]
>  Viele der oben aufgeführten Ausnahmen werden durch Fehler wird ausgelöst, die während der Registrierung generiert die <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Nachricht-Ressourcendatei wird nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldung-Ressourcendatei.  
  
 Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag mit einem Remotecomputer schreiben, der Wert der Nachricht (die Textzeichenfolge) möglicherweise nicht erwartungsgemäß, wenn der Remotecomputer nicht .NET Framework ausgeführt wird.  
  
> [!NOTE]
>  Wenn die `message` Parameter enthält ein NULL-Zeichen, die Meldung im Ereignisprotokoll auf das NUL-Zeichen beendet.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" />-Eigenschaft von <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
- oder - 
Die Methode hat versucht, eine neue Ereignisquelle zu registrieren, der Computername in <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist jedoch ungültig.  
  
\- oder – 
Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
\- oder – 
 <paramref name="eventID" /> ist kleiner als 0 oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
\- oder – 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <param name="category">Die der Meldung zugeordnete anwendungsspezifische Unterkategorie.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext, dem von der Anwendung definierten Ereignisbezeichner und der Kategorie in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird. Anhand der <paramref name="category" /> kann die Ereignisanzeige Ereignisse im Protokoll filtern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Schreiben eines Eintrags mit eine anwendungsdefinierte `category` verwenden Sie in das Ereignisprotokoll, einer Datenquelle, die bereits als Ereignisquelle für das entsprechende Protokoll registriert ist. Die Ereignisanzeige verwendet, Kategorie, die Ereignisse filtern, die von einer Ereignisquelle geschrieben wird. Der Ereignisanzeige können die Kategorie als numerischen Wert anzeigen, oder es kann die Kategorie als eine Ressourcen-ID verwenden, um eine lokalisierte Kategorie-Zeichenfolge anzuzeigen.  
  
> [!NOTE]
>  Die `category` Parameter muss ein positiver Wert sein. Negative Kategoriewerte werden im Viewer als komplementäre positive Zahl angezeigt. Beispielsweise wird die-10 als 65.526,-1 als 65.535 angezeigt.  
  
 Um lokalisierte Kategoriezeichenfolgen in der Ereignisanzeige anzuzeigen, müssen Sie eine Ereignisquelle mit einer Kategorieressourcendatei konfiguriert, und legen Sie verwenden die `category` zu einer Ressource-ID in der Kategorieressourcendatei. Wenn die Ereignisquelle einen konfigurierten Kategorieressourcendatei verwendet werden soll, oder das angegebene keinen `category` indizieren eine Zeichenfolge in der Kategorieressourcendatei, nicht, wird die Ereignisanzeige die Kategorie "numeric"-Wert für diesen Eintrag angezeigt. Konfigurieren die Kategorieressourcendatei, sowie die Anzahl der der Kategoriezeichenfolgen in der Ressourcendatei, über die <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventSourceCreationData> Klasse.  
  
 Neben der Kategorie können Sie für das Ereignis in das Ereignisprotokoll geschrieben wird Ereignis-ID angeben. Ereignis-IDs, zusammen mit der Ereignisquelle wird ein Ereignis eindeutig identifiziert. Jede Anwendung kann definieren, seine eigenen nummerierten Ereignisse und die Beschreibungszeichenfolge, die sie zugeordnet. Ereignis-Viewer zeigen diese Zeichenfolgenwerte, damit der Benutzer die Fehlerursache, und welche Maßnahmen zu ergreifen sind.  
  
 Schließlich können Sie angeben einer <xref:System.Diagnostics.EventLogEntryType> für das Ereignis in das Ereignisprotokoll geschrieben wird. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp, Fehler, Warnung, Informationen, erfolgsüberwachung oder Fehlerüberwachung ist.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Nachricht-Ressourcendatei wird nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldung-Ressourcendatei.  
  
 Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
> [!NOTE]
>  Wenn die `message` Parameter enthält ein NULL-Zeichen, die Meldung im Ereignisprotokoll auf das NUL-Zeichen beendet.  
>   
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei *n* ist ein Ganzzahlwert (z. B. %1), da es sich bei die Ereignisanzeige behandelt es als Einfügezeichenfolge. Da die Zeichenfolge für ein Internetprotokoll, Version 6 (IPv6)-Adresse, die diese enthalten kann, kann Sie keine ereignismeldung anmelden, die eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Wert ist eine leere Zeichenfolge ("").  
  
\- oder – 
Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
\- oder – 
 <paramref name="eventID" /> ist kleiner als 0 oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
\- oder – 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, unter der die Anwendung auf dem angegebenen Computer registriert ist.</param>
        <param name="message">Die in das Ereignisprotokoll zu schreibende Zeichenfolge.</param>
        <param name="type">Einer der <see cref="T:System.Diagnostics.EventLogEntryType" />-Werte.</param>
        <param name="eventID">Der anwendungsspezifische Bezeichner für das Ereignis.</param>
        <param name="category">Die der Meldung zugeordnete anwendungsspezifische Unterkategorie.</param>
        <param name="rawData">Ein Bytearray mit den dem Eintrag zugeordneten Binärdaten.</param>
        <summary>Schreibt einen Eintrag mit dem angegebenen Meldungstext, dem von der Anwendung definierten Ereignisbezeichner und der Kategorie in das Ereignisprotokoll, wobei die angegebene registrierte Ereignisquelle verwendet wird, und fügt Binärdaten an die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um anwendungsdefinierte ereignisspezifischen Daten in das Ereignisprotokoll, und Verwenden einer Datenquelle, die bereits als Ereignisquelle für das entsprechende Protokoll registriert zu schreiben. Die Ereignisanzeige interpretiert diese Daten nicht; Es zeigt die unformatierte Daten nur in einem kombinierten hexadezimaler Schreibweise und im Text-Format. Verwenden Sie nur selten ereignisspezifischen Daten; Fügen Sie ihn nur, wenn Sie wirklich nützlich sind. Sie können auch ereignisspezifische Daten verwenden, um Informationen zu speichern, die die Anwendung unabhängig von der Ereignisanzeige verarbeiten kann. Beispielsweise können einen Viewer speziell für die Ereignisse zu schreiben oder schreiben ein Programm, das die Protokolldatei scannt und erstellt Berichte, die Informationen aus den ereignisspezifischen Daten enthalten.  
  
 Zusätzlich zu den binären Daten können Sie eine Kategorie und der Anwendung definierten Ereignisbezeichner angeben. Die Ereignisanzeige verwendet, Kategorie, die Ereignisse filtern, die von einer Ereignisquelle geschrieben wird. Der Ereignisanzeige können die Kategorie als numerischen Wert anzeigen, oder es kann die Kategorie als eine Ressourcen-ID verwenden, um eine lokalisierte Kategorie-Zeichenfolge anzuzeigen.  
  
> [!NOTE]
>  Die `category` Parameter muss ein positiver Wert sein. Negative Kategoriewerte werden im Viewer als komplementäre positive Zahl angezeigt. Beispielsweise erscheint-10 als 65.526 und-1 als 65.535.  
  
 Um lokalisierte Kategoriezeichenfolgen in der Ereignisanzeige anzuzeigen, müssen Sie eine Ereignisquelle mit einer Kategorieressourcendatei konfiguriert, und legen Sie verwenden die `category` zu einer Ressource-ID in der Kategorieressourcendatei. Wenn die Ereignisquelle einen konfigurierten Kategorieressourcendatei verwendet werden soll, oder das angegebene keinen `category` indizieren eine Zeichenfolge in der Kategorieressourcendatei, nicht, wird die Ereignisanzeige die Kategorie "numeric"-Wert für diesen Eintrag angezeigt. Konfigurieren die Kategorieressourcendatei, sowie die Anzahl der der Kategoriezeichenfolgen in der Ressourcendatei, über die <xref:System.Diagnostics.EventLogInstaller> oder <xref:System.Diagnostics.EventSourceCreationData> Klasse.  
  
 Ereignis-IDs, zusammen mit der Ereignisquelle wird ein Ereignis eindeutig identifiziert. Jede Anwendung kann definieren, seine eigenen nummerierten Ereignisse und die Beschreibungszeichenfolge, die sie zugeordnet. Ereignis-Viewer zeigen diese Zeichenfolgenwerte, damit der Benutzer die Fehlerursache, und welche Maßnahmen zu ergreifen sind.  
  
 Schließlich können Sie angeben einer <xref:System.Diagnostics.EventLogEntryType> für das Ereignis in das Ereignisprotokoll geschrieben wird. Die `type` wird durch ein Symbol und Text in der Spalte "Typ" in der Ereignisanzeige für ein Protokoll angegeben. Dieser Parameter gibt an, ob der Ereignistyp, Fehler, Warnung, Informationen, erfolgsüberwachung oder Fehlerüberwachung ist.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Die <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode schreibt die angegebene Zeichenfolge direkt in das Ereignisprotokoll schreiben; eine lokalisierbare Nachricht-Ressourcendatei wird nicht verwendet. Verwenden der <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode zum Schreiben von Ereignissen, die mit der eine lokalisierte Meldung-Ressourcendatei.  
  
 Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
> [!NOTE]
>  Wenn die `message` Parameter enthält ein NULL-Zeichen, die Meldung im Ereignisprotokoll auf das NUL-Zeichen beendet.  
>   
>  Die `message` Zeichenfolge darf keine % enthalten*n*, wobei *n* ist ein Ganzzahlwert (z. B. %1), da es sich bei die Ereignisanzeige behandelt es als Einfügezeichenfolge. Da die Zeichenfolge für ein Internetprotokoll, Version 6 (IPv6)-Adresse, die diese enthalten kann, kann Sie keine ereignismeldung anmelden, die eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Wert ist eine leere Zeichenfolge ("").  
  
\- oder – 
Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
\- oder – 
 <paramref name="eventID" /> ist kleiner als 0 oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
\- oder – 
Die Meldungszeichenfolge ist länger als 31.839 Bytes (32.766 Bytes auf Windows-Betriebssystemen vor Windows Vista).  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt einen lokalisierten Ereigniseintrag in das Ereignisprotokoll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Eine <see cref="T:System.Diagnostics.EventInstance" />-Instanz, die einen lokalisierten Ereignisprotokolleintrag darstellt.</param>
        <param name="values">Ein Array von Zeichenfolgen, die mit dem Meldungstext des Ereignisprotokolleintrags zusammengeführt werden sollen.</param>
        <summary>Schreibt einen lokalisierten Eintrag in das Ereignisprotokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen lokalisierten Eintrag in das Ereignisprotokoll zu schreiben. Sie geben die Ereigniseigenschaften, mit Ressourcen-IDs und nicht als Zeichenfolgenwerte. Die Ereignisanzeige verwendet die Ressourcen-IDs zum Anzeigen der entsprechenden Zeichenfolgen aus der lokalisierten Ressourcendatei für die <xref:System.Diagnostics.EventLog.Source%2A>. Sie müssen die Quelle mit der entsprechenden Ressourcendatei registrieren, vor dem Schreiben von Ereignissen mithilfe von Ressourcenbezeichnern.  
  
 Die Eingabe `instance` Instanz angibt, die ereignismeldung und Eigenschaften. Legen Sie die <xref:System.Diagnostics.EventInstance.InstanceId%2A> von der `instance` Eingabe der definierten Meldung in der Meldungsressourcendatei der Quelle. Sie können optional festlegen, die <xref:System.Diagnostics.EventInstance.CategoryId%2A> und <xref:System.Diagnostics.EventInstance.EntryType%2A> von der `instance` Eingabe für die Kategorie und den Ereignistyp des Ereigniseintrags definieren. Sie können auch ein Array von Zeichenfolgen von sprachunabhängige zum Einfügen in den Text für die lokalisierte Meldung angeben. Legen Sie `values` zu `null` Wenn in der ereignismeldung wird keine Formatierung Platzhalter für Ersetzungszeichenfolgen enthält.  
  
 Sie müssen festlegen, die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft Ihrer <xref:System.Diagnostics.EventLog> Komponente vor der Verwendung von <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Die angegebene Quelle muss so konfiguriert werden, zum Schreiben lokalisierter Einträge im Protokoll. die Quelle muss mindestens eine Meldungsressourcendatei definiert haben.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Verwenden der <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode, wenn die Anwendung die Werte direkt in das Ereignisprotokoll schreibt.  
  
 Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag mit einem Remotecomputer, den Wert der Schreiben der `message` Zeichenfolge möglicherweise nicht erwartungsgemäß, wenn der Remotecomputer nicht .NET Framework ausgeführt wird. Darüber hinaus die `message` Zeichenfolge darf keine % enthalten*n*, wobei *n* ist ein Ganzzahlwert (z. B. %1), da es sich bei die Ereignisanzeige behandelt es als Einfügezeichenfolge. Da die Zeichenfolge für ein Internetprotokoll, Version 6 (IPv6)-Adresse, die diese enthalten kann, kann Sie keine ereignismeldung anmelden, die eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt zwei Einträge im Ereignisprotokoll Überwachen `myNewLog`. Im Beispiel wird eine neue Ereignisquelle und ein neues Ereignisprotokoll erstellt, wenn sie nicht auf dem lokalen Computer vorhanden sind. Der Ereignismeldungstext wird über eine Ressourcen-ID in einer Ressourcendatei angegeben.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 Im Beispiel wird die folgende Meldung-Textdatei, die Ressourcenbibliothek EventLogMsgs.dll integriert. Eine Nachricht Text-Datei ist die Quelle, aus der Meldungsressourcendatei erstellt wird. Die Nachricht-Text-Datei definiert die Ressourcen-IDs und der Text für die Kategorie, ereignismeldung und Parameter einfügen-Zeichenfolgen.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" />-Eigenschaft von <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
- oder - 
Die Methode hat versucht, eine neue Ereignisquelle zu registrieren, der Computername in <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist jedoch ungültig.  
  
\- oder – 
Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
\- oder – 
 <paramref name="instance.InstanceId" /> ist kleiner als 0 oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
\- oder – 
 <paramref name="values" /> enthält mehr als 256 Elemente.  
  
\- oder – 
Eines der <paramref name="values" />-Elemente ist länger als 32.766 Bytes.  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Eine <see cref="T:System.Diagnostics.EventInstance" />-Instanz, die einen lokalisierten Ereignisprotokolleintrag darstellt.</param>
        <param name="data">Ein Bytearray mit den dem Eintrag zugeordneten Binärdaten.</param>
        <param name="values">Ein Array von Zeichenfolgen, die mit dem Meldungstext des Ereignisprotokolleintrags zusammengeführt werden sollen.</param>
        <summary>Schreibt einen Ereignisprotokolleintrag mit den angegebenen Ereignisdaten, Meldungsersetzungszeichenfolgen und zugeordneten Binärdaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen lokalisierten Eintrag mit zusätzlichen ereignisspezifische Daten in das Ereignisprotokoll zu schreiben. Sie geben die Ereigniseigenschaften, mit Ressourcen-IDs und nicht als Zeichenfolgenwerte. Die Ereignisanzeige verwendet die Ressourcen-IDs zum Anzeigen der entsprechenden Zeichenfolgen aus der lokalisierten Ressourcendatei für die <xref:System.Diagnostics.EventLog.Source%2A>. Sie müssen die Quelle mit der entsprechenden Ressourcendatei registrieren, vor dem Schreiben von Ereignissen mithilfe von Ressourcenbezeichnern.  
  
 Die Eingabe `instance` Instanz angibt, die ereignismeldung und Eigenschaften. Legen Sie die <xref:System.Diagnostics.EventInstance.InstanceId%2A> von der `instance` Eingabe der definierten Meldung in der Meldungsressourcendatei der Quelle. Sie können optional festlegen, die <xref:System.Diagnostics.EventInstance.CategoryId%2A> und <xref:System.Diagnostics.EventInstance.EntryType%2A> von der `instance` Eingabe für die Kategorie und den Ereignistyp des Ereigniseintrags definieren. Sie können auch ein Array von Zeichenfolgen von sprachunabhängige zum Einfügen in den Text für die lokalisierte Meldung angeben. Legen Sie `values` zu `null` Wenn in der ereignismeldung wird keine Formatierung Platzhalter für Ersetzungszeichenfolgen enthält.  
  
 Geben Sie binäre Daten mit einem Ereignis, bei Bedarf zusätzliche Details für das Ereignis bereit. Beispielsweise verwenden die `data` Parameter, um Informationen zu einem bestimmten Fehler enthält. Der Ereignisanzeige kann nicht die zugehörigen Daten interpretieren; Es zeigt die Daten in einem kombinierten hexadezimaler Schreibweise und im Text-Format. Verwenden Sie nur selten ereignisspezifischen Daten; Fügen Sie ihn nur, wenn Sie wirklich nützlich sind. Sie können auch ereignisspezifische Daten verwenden, um Informationen zu speichern, die die Anwendung unabhängig von der Ereignisanzeige verarbeiten kann. Beispielsweise können einen Viewer speziell für die Ereignisse zu schreiben oder ein Programm schreiben, überprüft das Ereignisprotokoll und erstellt Berichte, die Informationen aus den ereignisspezifischen Daten enthalten.  
  
 Sie müssen festlegen, die <xref:System.Diagnostics.EventLog.Source%2A> Eigenschaft Ihre <xref:System.Diagnostics.EventLog> -Komponente vor der Verwendung von <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Die angegebene Quelle muss so konfiguriert werden, zum Schreiben lokalisierter Einträge im Protokoll. die Quelle muss mindestens eine Meldungsressourcendatei definiert haben.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
> [!NOTE]
>  Wenn Sie nicht angeben einer <xref:System.Diagnostics.EventLog.MachineName%2A> für Ihre <xref:System.Diagnostics.EventLog> Instanz vor dem Aufruf <xref:System.Diagnostics.EventLog.WriteEvent%2A>, dem lokalen Computer (".") wird davon ausgegangen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Verwenden der <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode, wenn die Anwendung die Werte direkt in das Ereignisprotokoll schreibt.  
  
 Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
> [!NOTE]
>  Wenn Sie einen Eintrag mit einem Remotecomputer, den Wert der Schreiben der `message` Zeichenfolge möglicherweise nicht erwartungsgemäß, wenn der Remotecomputer nicht .NET Framework ausgeführt wird. Darüber hinaus die `message` Zeichenfolge darf keine % enthalten*n*, wobei *n* ist ein Ganzzahlwert (z. B. %1), da es sich bei die Ereignisanzeige behandelt es als Einfügezeichenfolge. Da die Zeichenfolge für ein Internetprotokoll, Version 6 (IPv6)-Adresse, die diese enthalten kann, kann Sie keine ereignismeldung anmelden, die eine IPv6-Adresse enthält.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt zwei Einträge im Ereignisprotokoll Überwachen `myNewLog`. Im Beispiel wird eine neue Ereignisquelle und ein neues Ereignisprotokoll erstellt, wenn sie nicht auf dem lokalen Computer vorhanden sind. Der Ereignismeldungstext wird über eine Ressourcen-ID in einer Ressourcendatei angegeben.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 Im Beispiel wird die folgende Meldung-Textdatei, die Ressourcenbibliothek EventLogMsgs.dll integriert. Eine Nachricht Text-Datei ist die Quelle, aus der Meldungsressourcendatei erstellt wird. Die Nachricht-Text-Datei definiert die Ressourcen-IDs und der Text für die Kategorie, ereignismeldung und Parameter einfügen-Zeichenfolgen.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Diagnostics.EventLog.Source" />-Eigenschaft von <see cref="T:System.Diagnostics.EventLog" /> wurde nicht festgelegt.  
  
- oder - 
Die Methode hat versucht, eine neue Ereignisquelle zu registrieren, der Computername in <see cref="P:System.Diagnostics.EventLog.MachineName" /> ist jedoch ungültig.  
  
\- oder – 
Die Quelle ist bereits für ein anderes Ereignisprotokoll registriert.  
  
\- oder – 
 <paramref name="instance.InstanceId" /> ist kleiner als 0 oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
\- oder – 
 <paramref name="values" /> enthält mehr als 256 Elemente.  
  
\- oder – 
Eines der <paramref name="values" />-Elemente ist länger als 32.766 Bytes.  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Der Name der für die Anwendung auf dem angegebenen Computer registrierten Ereignisquelle.</param>
        <param name="instance">Eine <see cref="T:System.Diagnostics.EventInstance" />-Instanz, die einen lokalisierten Ereignisprotokolleintrag darstellt.</param>
        <param name="values">Ein Array von Zeichenfolgen, die mit dem Meldungstext des Ereignisprotokolleintrags zusammengeführt werden sollen.</param>
        <summary>Schreibt unter Verwendung der angegebenen registrierten Ereignisquelle einen Ereignisprotokolleintrag mit den angegebenen Ereignisdaten und Meldungsersetzungszeichenfolgen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen lokalisierten Eintrag in das Ereignisprotokoll, und Verwenden einer Datenquelle, die bereits registriert als Ereignisquelle für das entsprechende Protokoll schreiben. Sie geben die Ereigniseigenschaften, mit Ressourcen-IDs und nicht als Zeichenfolgenwerte. Die Ereignisanzeige verwendet die Ressourcen-IDs, um die entsprechenden Zeichenfolgen aus der lokalisierten Ressourcendatei für die Datenquelle anzuzeigen. Sie müssen die Quelle mit der entsprechenden Ressourcendatei registrieren, vor dem Schreiben von Ereignissen mithilfe von Ressourcenbezeichnern.  
  
 Die Eingabe `instance` Instanz angibt, die ereignismeldung und Eigenschaften. Legen Sie die <xref:System.Diagnostics.EventInstance.InstanceId%2A> von der `instance` Eingabe der definierten Meldung in der Meldungsressourcendatei der Quelle. Sie können optional festlegen, die <xref:System.Diagnostics.EventInstance.CategoryId%2A> und <xref:System.Diagnostics.EventInstance.EntryType%2A> von der `instance` Eingabe für die Kategorie und den Ereignistyp des Ereigniseintrags definieren. Sie können auch ein Array von Zeichenfolgen von sprachunabhängige zum Einfügen in den Text für die lokalisierte Meldung angeben. Legen Sie `values` zu `null` Wenn in der ereignismeldung wird keine Formatierung Platzhalter für Ersetzungszeichenfolgen enthält.  
  
 Die angegebene Quelle muss für ein Ereignisprotokoll registriert werden, vor der Verwendung von <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Die angegebene Quelle muss so konfiguriert werden, zum Schreiben lokalisierter Einträge im Protokoll. die Quelle muss mindestens eine Meldungsressourcendatei definiert haben.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Verwenden der <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode, wenn die Anwendung die Werte direkt in das Ereignisprotokoll schreibt.  
  
 Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
   
  
## Examples  
 Im folgende Beispiel schreibt ein Informationsereignis-Eintrag und einen Warnungseintrag-Ereignis in einem vorhandenen Ereignisprotokoll. Der Ereignismeldungstext wird über eine Ressourcen-ID in einer Ressourcendatei angegeben. Im Beispiel wird davon ausgegangen, dass die entsprechende Ressourcendatei für die Datenquelle registriert wurde.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 Im Beispiel wird die folgende Meldung-Textdatei, die Ressourcenbibliothek EventLogMsgs.dll integriert. Eine Nachricht Text-Datei ist die Quelle, aus der Meldungsressourcendatei erstellt wird. Die Nachricht-Text-Datei definiert die Ressourcen-IDs und der Text für die Kategorie, ereignismeldung und Parameter einfügen-Zeichenfolgen.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Wert ist eine leere Zeichenfolge ("").  
  
\- oder – 
Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
\- oder – 
 <paramref name="instance.InstanceId" /> ist kleiner als 0 oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
\- oder – 
 <paramref name="values" /> enthält mehr als 256 Elemente.  
  
\- oder – 
Eines der <paramref name="values" />-Elemente ist länger als 32.766 Bytes.  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Der Name der für die Anwendung auf dem angegebenen Computer registrierten Ereignisquelle.</param>
        <param name="instance">Eine <see cref="T:System.Diagnostics.EventInstance" />-Instanz, die einen lokalisierten Ereignisprotokolleintrag darstellt.</param>
        <param name="data">Ein Bytearray mit den dem Eintrag zugeordneten Binärdaten.</param>
        <param name="values">Ein Array von Zeichenfolgen, die mit dem Meldungstext des Ereignisprotokolleintrags zusammengeführt werden sollen.</param>
        <summary>Schreibt einen Ereignisprotokolleintrag mit den angegebenen Ereignisdaten, Meldungsersetzungszeichenfolgen und zugeordneten Binärdaten und unter Verwendung der angegebenen registrierten Ereignisquelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um einen lokalisierten Eintrag mit zusätzlichen ereignisspezifische Daten in das Ereignisprotokoll, und Verwenden einer Datenquelle, die bereits registriert als Ereignisquelle für das entsprechende Protokoll schreiben. Sie geben die Ereigniseigenschaften, mit Ressourcen-IDs und nicht als Zeichenfolgenwerte. Die Ereignisanzeige verwendet die Ressourcen-IDs, um die entsprechenden Zeichenfolgen aus der lokalisierten Ressourcendatei für die Datenquelle anzuzeigen. Sie müssen die Quelle mit der entsprechenden Ressourcendatei registrieren, vor dem Schreiben von Ereignissen mithilfe von Ressourcenbezeichnern.  
  
 Die Eingabe `instance` Instanz angibt, die ereignismeldung und Eigenschaften. Legen Sie die <xref:System.Diagnostics.EventInstance.InstanceId%2A> von der `instance` Eingabe der definierten Meldung in der Meldungsressourcendatei der Quelle. Sie können optional festlegen, die <xref:System.Diagnostics.EventInstance.CategoryId%2A> und <xref:System.Diagnostics.EventInstance.EntryType%2A> von der `instance` Eingabe für die Kategorie und den Ereignistyp des Ereigniseintrags definieren. Sie können auch ein Array von Zeichenfolgen von sprachunabhängige zum Einfügen in den Text für die lokalisierte Meldung angeben. Legen Sie `values` zu `null` Wenn in der ereignismeldung wird keine Formatierung Platzhalter für Ersetzungszeichenfolgen enthält.  
  
 Geben Sie binäre Daten mit einem Ereignis, bei Bedarf zusätzliche Details für das Ereignis bereit. Beispielsweise verwenden die `data` Parameter, um Informationen zu einem bestimmten Fehler enthält. Der Ereignisanzeige kann nicht die zugehörigen Daten interpretieren; Es zeigt die Daten in einem kombinierten hexadezimaler Schreibweise und im Text-Format. Verwenden Sie nur selten ereignisspezifischen Daten; Fügen Sie ihn nur, wenn Sie wirklich nützlich sind. Sie können auch ereignisspezifische Daten verwenden, um Informationen zu speichern, die die Anwendung unabhängig von der Ereignisanzeige verarbeiten kann. Beispielsweise können einen Viewer speziell für die Ereignisse zu schreiben oder ein Programm schreiben, überprüft das Ereignisprotokoll und erstellt Berichte, die Informationen aus den ereignisspezifischen Daten enthalten.  
  
 Die angegebene Quelle muss für ein Ereignisprotokoll registriert werden, vor der Verwendung von <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Die angegebene Quelle muss so konfiguriert werden, zum Schreiben lokalisierter Einträge im Protokoll. die Quelle muss mindestens eine Meldungsressourcendatei definiert haben.  
  
 Sie müssen erstellen und konfigurieren die Ereignisquelle, vor dem Schreiben des ersten Eintrags mit der Quelle. Erstellen Sie die neue Ereignisquelle, während der Installation der Anwendung. Dadurch wird die Zeit für das Betriebssystem, um die Liste der registrierten Ereignisquellen und deren Konfiguration zu aktualisieren. Wenn das Betriebssystem nicht die Liste der unterstützten Ereignisquellen aktualisiert wurde, und Sie versuchen, ein Ereignis mit den neuen Quellserver, Schreiben der Write-Vorgang fehl. Sie können konfigurieren, einer neuen Datenquelle mithilfe einer <xref:System.Diagnostics.EventLogInstaller>, oder die <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Methode. Sie müssen über Administratorrechte verfügen, auf dem Computer, um eine neue Ereignisquelle zu erstellen.  
  
 Die Quelle muss zum Schreiben lokalisierter Einträge oder für das Schreiben von direkter Zeichenfolgen konfiguriert werden. Verwenden der <xref:System.Diagnostics.EventLog.WriteEntry%2A> Methode, wenn die Anwendung die Werte direkt in das Ereignisprotokoll schreibt.  
  
 Wenn Ihre Anwendung mit Ressourcen-IDs und Zeichenfolgenwerte Einträge schreibt, müssen Sie zwei verschiedene Informationsquellen registrieren. Z. B. eine Quelle mit Ressourcendateien konfigurieren und verwenden Sie dann diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEvent%2A> Methode, um die Einträge mithilfe der Ressourcen-IDs in das Ereignisprotokoll zu schreiben. Erstellen Sie eine andere Quelle ohne Ressourcendateien, und verwenden Sie diese Quelle in die <xref:System.Diagnostics.EventLog.WriteEntry%2A> -Methode zum Schreiben von Zeichenfolgen direkt in das Ereignisprotokoll, die mithilfe dieser Quelle.  
  
   
  
## Examples  
 Im folgende Beispiel schreibt ein Informationsereignis-Eintrag und einen Warnungseintrag-Ereignis in einem vorhandenen Ereignisprotokoll. Der Ereignismeldungstext wird über eine Ressourcen-ID in einer Ressourcendatei angegeben. Im Beispiel wird davon ausgegangen, dass die entsprechende Ressourcendatei für die Datenquelle registriert wurde.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 Im Beispiel wird die folgende Meldung-Textdatei, die Ressourcenbibliothek EventLogMsgs.dll integriert. Eine Nachricht Text-Datei ist die Quelle, aus der Meldungsressourcendatei erstellt wird. Die Nachricht-Text-Datei definiert die Ressourcen-IDs und der Text für die Kategorie, ereignismeldung und Parameter einfügen-Zeichenfolgen.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="source" />-Wert ist eine leere Zeichenfolge ("").  
  
\- oder – 
Der <paramref name="source" />-Wert ist <see langword="null" />.  
  
\- oder – 
 <paramref name="instance.InstanceId" /> ist kleiner als 0 oder größer als <see cref="F:System.UInt16.MaxValue" />.  
  
\- oder – 
 <paramref name="values" /> enthält mehr als 256 Elemente.  
  
\- oder – 
Eines der <paramref name="values" />-Elemente ist länger als 32.766 Bytes.  
  
\- oder – 
Der Quellenname führt dazu, dass der Registrierungsschlüsselpfad länger als 254 Zeichen ist.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Registrierungsschlüssel für das Ereignisprotokoll konnte nicht geöffnet werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Das Betriebssystem hat beim Schreiben des Ereigniseintrags in das Ereignisprotokoll einen Fehler gemeldet. Es ist kein Windows-Fehlercode verfügbar.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">zum Schreiben der Ereignisprotokollinformationen, auf dem Computer an. Zugeordnete Enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>