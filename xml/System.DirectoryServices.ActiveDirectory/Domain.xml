<Type Name="Domain" FullName="System.DirectoryServices.ActiveDirectory.Domain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="20821f01042a9f1e9e07660b8f65d53fec1b2b16" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46664873" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Domain : System.DirectoryServices.ActiveDirectory.ActiveDirectoryPartition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Domain extends System.DirectoryServices.ActiveDirectory.ActiveDirectoryPartition" />
  <TypeSignature Language="DocId" Value="T:System.DirectoryServices.ActiveDirectory.Domain" />
  <TypeSignature Language="VB.NET" Value="Public Class Domain&#xA;Inherits ActiveDirectoryPartition" />
  <TypeSignature Language="C++ CLI" Value="public ref class Domain : System::DirectoryServices::ActiveDirectory::ActiveDirectoryPartition" />
  <TypeSignature Language="F#" Value="type Domain = class&#xA;    inherit ActiveDirectoryPartition" />
  <AssemblyInfo>
    <AssemblyName>System.DirectoryServices</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.DirectoryServices.ActiveDirectory.ActiveDirectoryPartition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Die <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />-Klasse stellt eine Active Directory-Domäne dar.</summary>
    <remarks>To be added.</remarks>
    <permission cref="T:System.DirectoryServices.DirectoryServicesPermission">Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
    <related type="Article" href="https://msdn.microsoft.com/library/e1df3378-17b0-4429-91c7-13d4a457fb6e">Gewusst wie: Arbeiten mit Vertrauensstellungen</related>
  </Docs>
  <Members>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.DomainCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.DirectoryServices.ActiveDirectory.DomainCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.ActiveDirectory.Domain.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As DomainCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::DirectoryServices::ActiveDirectory::DomainCollection ^ Children { System::DirectoryServices::ActiveDirectory::DomainCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.DirectoryServices.ActiveDirectory.DomainCollection" Usage="System.DirectoryServices.ActiveDirectory.Domain.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.DomainCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Domänen ab, die untergeordnete Elemente dieser Domäne sind.</summary>
        <value>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.DomainCollection" />-Objekt, das die untergeordneten Domänen enthält.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainCollection" />
      </Docs>
    </Member>
    <Member MemberName="CreateLocalSideOfTrustRelationship">
      <MemberSignature Language="C#" Value="public void CreateLocalSideOfTrustRelationship (string targetDomainName, System.DirectoryServices.ActiveDirectory.TrustDirection direction, string trustPassword);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateLocalSideOfTrustRelationship(string targetDomainName, valuetype System.DirectoryServices.ActiveDirectory.TrustDirection direction, string trustPassword) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.CreateLocalSideOfTrustRelationship(System.String,System.DirectoryServices.ActiveDirectory.TrustDirection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateLocalSideOfTrustRelationship (targetDomainName As String, direction As TrustDirection, trustPassword As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateLocalSideOfTrustRelationship(System::String ^ targetDomainName, System::DirectoryServices::ActiveDirectory::TrustDirection direction, System::String ^ trustPassword);" />
      <MemberSignature Language="F#" Value="member this.CreateLocalSideOfTrustRelationship : string * System.DirectoryServices.ActiveDirectory.TrustDirection * string -&gt; unit" Usage="domain.CreateLocalSideOfTrustRelationship (targetDomainName, direction, trustPassword)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomainName" Type="System.String" />
        <Parameter Name="direction" Type="System.DirectoryServices.ActiveDirectory.TrustDirection" />
        <Parameter Name="trustPassword" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetDomainName">Der DNS-Name der Domäne, mit der die Vertrauensstellung erstellt wird.</param>
        <param name="direction">Einer der <see cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />-Member, der die Richtung der Vertrauensstellung relativ zu dieser Domäne bestimmt.</param>
        <param name="trustPassword">Das Kennwort für die Vertrauensstellung.</param>
        <summary>Erstellt die lokale Seite einer Vertrauensstellung mit der angegebenen Domäne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine Seite einer Vertrauensstellung. Die Vertrauensstellung ist nicht festgelegt werden, bis beide Seiten der Vertrauensstellung erstellt wurden.  
  
 Die `trustPassword` Parameter ordnet ein Kennwort mit der erstellten Vertrauensstellung. Wenn die anderen Seite der Vertrauensstellung erstellt wird, wird das gleiche Kennwort wird bereitgestellt, und die beiden lokalen Vertrauensstellungen werden dann miteinander gebunden.  
  
 Um beide Seiten einer Vertrauensstellung in einem einzelnen Methodenaufruf programmgesteuert zu erstellen, verwenden die <xref:System.DirectoryServices.ActiveDirectory.Domain.CreateTrustRelationship%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectExistsException">Die Vertrauensstellung ist bereits vorhanden.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetDomainName" /> oder <paramref name="trustPassword" /> ist leer.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomainName" /> oder <paramref name="trustPassword" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="direction" /> ist kein gültiger <see cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />-Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <altmember cref="M:System.DirectoryServices.ActiveDirectory.Domain.CreateTrustRelationship(System.DirectoryServices.ActiveDirectory.Domain,System.DirectoryServices.ActiveDirectory.TrustDirection)" />
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />
        <related type="Article" href="https://msdn.microsoft.com/library/e1df3378-17b0-4429-91c7-13d4a457fb6e">Gewusst wie: Arbeiten mit Vertrauensstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="CreateTrustRelationship">
      <MemberSignature Language="C#" Value="public void CreateTrustRelationship (System.DirectoryServices.ActiveDirectory.Domain targetDomain, System.DirectoryServices.ActiveDirectory.TrustDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateTrustRelationship(class System.DirectoryServices.ActiveDirectory.Domain targetDomain, valuetype System.DirectoryServices.ActiveDirectory.TrustDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.CreateTrustRelationship(System.DirectoryServices.ActiveDirectory.Domain,System.DirectoryServices.ActiveDirectory.TrustDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateTrustRelationship (targetDomain As Domain, direction As TrustDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateTrustRelationship(System::DirectoryServices::ActiveDirectory::Domain ^ targetDomain, System::DirectoryServices::ActiveDirectory::TrustDirection direction);" />
      <MemberSignature Language="F#" Value="member this.CreateTrustRelationship : System.DirectoryServices.ActiveDirectory.Domain * System.DirectoryServices.ActiveDirectory.TrustDirection -&gt; unit" Usage="domain.CreateTrustRelationship (targetDomain, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomain" Type="System.DirectoryServices.ActiveDirectory.Domain" />
        <Parameter Name="direction" Type="System.DirectoryServices.ActiveDirectory.TrustDirection" />
      </Parameters>
      <Docs>
        <param name="targetDomain">Ein <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />-Objekt, das die Domäne darstellt, mit der die Vertrauensstellung hergestellt wird.</param>
        <param name="direction">Einer der <see cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />-Member, der die Richtung der Vertrauensstellung relativ zu dieser Domäne bestimmt.</param>
        <summary>Erstellt beide Seiten einer Vertrauensstellung mit der angegebenen Domäne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt beide Seiten einer Vertrauensstellung mit einem einzelnen Methodenaufruf an. Die <xref:System.DirectoryServices.ActiveDirectory.Domain.CreateLocalSideOfTrustRelationship%2A?displayProperty=nameWithType> Methode wird verwendet, um nur eine Seite einer Vertrauensstellung zu erstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectExistsException">Die Vertrauensstellung ist bereits vorhanden.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomain" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="direction" /> ist kein gültiger <see cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />-Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <altmember cref="M:System.DirectoryServices.ActiveDirectory.Domain.CreateLocalSideOfTrustRelationship(System.String,System.DirectoryServices.ActiveDirectory.TrustDirection,System.String)" />
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />
        <related type="Article" href="https://msdn.microsoft.com/library/e1df3378-17b0-4429-91c7-13d4a457fb6e">Gewusst wie: Arbeiten mit Vertrauensstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteLocalSideOfTrustRelationship">
      <MemberSignature Language="C#" Value="public void DeleteLocalSideOfTrustRelationship (string targetDomainName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteLocalSideOfTrustRelationship(string targetDomainName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.DeleteLocalSideOfTrustRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteLocalSideOfTrustRelationship (targetDomainName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteLocalSideOfTrustRelationship(System::String ^ targetDomainName);" />
      <MemberSignature Language="F#" Value="member this.DeleteLocalSideOfTrustRelationship : string -&gt; unit" Usage="domain.DeleteLocalSideOfTrustRelationship targetDomainName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomainName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetDomainName">Der DNS-Name der Domäne, mit der die Vertrauensstellung besteht.</param>
        <summary>Löscht die lokale Seite einer Vertrauensstellung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Seite einer Vertrauensstellung gelöscht wird, ist die Vertrauensstellung nicht mehr vorhanden.  
  
 Um beide Seiten einer Vertrauensstellung mit einem Methodenaufruf zu löschen, verwenden die <xref:System.DirectoryServices.ActiveDirectory.Domain.DeleteTrustRelationship%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es ist keine Vertrauensstellung mit dem <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />-Objekt vorhanden, das durch den <paramref name="targetDomainName" />-Parameter angegeben ist.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetDomainName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomainName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <altmember cref="M:System.DirectoryServices.ActiveDirectory.Domain.CreateLocalSideOfTrustRelationship(System.String,System.DirectoryServices.ActiveDirectory.TrustDirection,System.String)" />
        <altmember cref="M:System.DirectoryServices.ActiveDirectory.Domain.DeleteTrustRelationship(System.DirectoryServices.ActiveDirectory.Domain)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e1df3378-17b0-4429-91c7-13d4a457fb6e">Gewusst wie: Arbeiten mit Vertrauensstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteTrustRelationship">
      <MemberSignature Language="C#" Value="public void DeleteTrustRelationship (System.DirectoryServices.ActiveDirectory.Domain targetDomain);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteTrustRelationship(class System.DirectoryServices.ActiveDirectory.Domain targetDomain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.DeleteTrustRelationship(System.DirectoryServices.ActiveDirectory.Domain)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteTrustRelationship (targetDomain As Domain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteTrustRelationship(System::DirectoryServices::ActiveDirectory::Domain ^ targetDomain);" />
      <MemberSignature Language="F#" Value="member this.DeleteTrustRelationship : System.DirectoryServices.ActiveDirectory.Domain -&gt; unit" Usage="domain.DeleteTrustRelationship targetDomain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomain" Type="System.DirectoryServices.ActiveDirectory.Domain" />
      </Parameters>
      <Docs>
        <param name="targetDomain">Ein <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />-Objekt, das die Domäne darstellt, mit der die Vertrauensstellung besteht.</param>
        <summary>Löscht beide Seiten einer Vertrauensstellung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um nur eine Seite einer Vertrauensstellung zu löschen, verwenden die <xref:System.DirectoryServices.ActiveDirectory.Domain.DeleteLocalSideOfTrustRelationship%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es besteht keine Vertrauensstellung mit der angegebenen <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomain" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <altmember cref="M:System.DirectoryServices.ActiveDirectory.Domain.DeleteLocalSideOfTrustRelationship(System.String)" />
        <altmember cref="M:System.DirectoryServices.ActiveDirectory.Domain.CreateTrustRelationship(System.DirectoryServices.ActiveDirectory.Domain,System.DirectoryServices.ActiveDirectory.TrustDirection)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e1df3378-17b0-4429-91c7-13d4a457fb6e">Gewusst wie: Arbeiten mit Vertrauensstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="DomainControllers">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.DomainControllerCollection DomainControllers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.DirectoryServices.ActiveDirectory.DomainControllerCollection DomainControllers" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.ActiveDirectory.Domain.DomainControllers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainControllers As DomainControllerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::DirectoryServices::ActiveDirectory::DomainControllerCollection ^ DomainControllers { System::DirectoryServices::ActiveDirectory::DomainControllerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainControllers : System.DirectoryServices.ActiveDirectory.DomainControllerCollection" Usage="System.DirectoryServices.ActiveDirectory.Domain.DomainControllers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.DomainControllerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Domänencontroller in dieser Domäne ab.</summary>
        <value>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.DomainControllerCollection" />-Objekt, das die Domänencontroller in dieser Domäne enthält.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainControllerCollection" />
      </Docs>
    </Member>
    <Member MemberName="DomainMode">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.DomainMode DomainMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DirectoryServices.ActiveDirectory.DomainMode DomainMode" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.ActiveDirectory.Domain.DomainMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainMode As DomainMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::DirectoryServices::ActiveDirectory::DomainMode DomainMode { System::DirectoryServices::ActiveDirectory::DomainMode get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainMode : System.DirectoryServices.ActiveDirectory.DomainMode" Usage="System.DirectoryServices.ActiveDirectory.Domain.DomainMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.DomainMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Modus ab, in dem diese Domäne ausgeführt wird.</summary>
        <value>Einer der <see cref="T:System.DirectoryServices.ActiveDirectory.DomainMode" />-Werte, der den Modus angibt, in dem diese Domäne ausgeführt wird.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainMode" />
      </Docs>
    </Member>
    <Member MemberName="DomainModeLevel">
      <MemberSignature Language="C#" Value="public int DomainModeLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DomainModeLevel" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.ActiveDirectory.Domain.DomainModeLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainModeLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DomainModeLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainModeLevel : int" Usage="System.DirectoryServices.ActiveDirectory.Domain.DomainModeLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Modusebene ab, auf der diese Domäne ausgeführt wird.</summary>
        <value>Die Modusebene der Domäne.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindAllDiscoverableDomainControllers">
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Findet alle erkennbaren Domänencontroller in dieser Domäne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindAllDiscoverableDomainControllers">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.DomainControllerCollection FindAllDiscoverableDomainControllers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.DirectoryServices.ActiveDirectory.DomainControllerCollection FindAllDiscoverableDomainControllers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.FindAllDiscoverableDomainControllers" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAllDiscoverableDomainControllers () As DomainControllerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::DirectoryServices::ActiveDirectory::DomainControllerCollection ^ FindAllDiscoverableDomainControllers();" />
      <MemberSignature Language="F#" Value="member this.FindAllDiscoverableDomainControllers : unit -&gt; System.DirectoryServices.ActiveDirectory.DomainControllerCollection" Usage="domain.FindAllDiscoverableDomainControllers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.DomainControllerCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Findet alle erkennbaren Domänencontroller in dieser Domäne.</summary>
        <returns>Eine <see cref="T:System.DirectoryServices.ActiveDirectory.DomainControllerCollection" />, die die von dieser Methode gefundenen Domänencontrollerobjekte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können erkennbaren Domänencontroller finden, indem Sie Abfragen von DNS-SRV-Einträge. Nur Domänencontroller, die registriert wird, die generische, nicht-Site-spezifische, SRV-Eintrag für Domäne-Controller werden von dieser Methode zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainControllerCollection" />
      </Docs>
    </Member>
    <Member MemberName="FindAllDiscoverableDomainControllers">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.DomainControllerCollection FindAllDiscoverableDomainControllers (string siteName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.DirectoryServices.ActiveDirectory.DomainControllerCollection FindAllDiscoverableDomainControllers(string siteName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.FindAllDiscoverableDomainControllers(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAllDiscoverableDomainControllers (siteName As String) As DomainControllerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::DirectoryServices::ActiveDirectory::DomainControllerCollection ^ FindAllDiscoverableDomainControllers(System::String ^ siteName);" />
      <MemberSignature Language="F#" Value="member this.FindAllDiscoverableDomainControllers : string -&gt; System.DirectoryServices.ActiveDirectory.DomainControllerCollection" Usage="domain.FindAllDiscoverableDomainControllers siteName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.DomainControllerCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="siteName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="siteName">Der Name des Standorts für die Suche nach den Domänencontrollern.</param>
        <summary>Sucht alle erkennbaren Domänencontroller in dieser Domäne, die sich auch am angegebenen Standort befinden.</summary>
        <returns>Eine <see cref="T:System.DirectoryServices.ActiveDirectory.DomainControllerCollection" />, die die von dieser Methode gefundenen Domänencontrollerobjekte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können erkennbaren Domänencontroller finden, indem Sie Abfragen von DNS-SRV-Einträge.  Wenn Sie einen SRV-Eintrag für den angegebenen Standort nicht von ein Domänencontroller registriert wird, wird er nicht von dieser Methode zurückgegeben wird, selbst wenn der Domänencontroller physisch in diesem Standort befindet.  
  
 Alle Domänencontroller, die registrieren einen SRV-Eintrag für den angegebenen Standort, werden von dieser Methode zurückgegeben werden, auch wenn sie nicht physisch in diesem Standort sind.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="siteName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="siteName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainControllerCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindAllDomainControllers">
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach allen Domänencontrollern in dieser Domäne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindAllDomainControllers">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.DomainControllerCollection FindAllDomainControllers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.DirectoryServices.ActiveDirectory.DomainControllerCollection FindAllDomainControllers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.FindAllDomainControllers" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAllDomainControllers () As DomainControllerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::DirectoryServices::ActiveDirectory::DomainControllerCollection ^ FindAllDomainControllers();" />
      <MemberSignature Language="F#" Value="member this.FindAllDomainControllers : unit -&gt; System.DirectoryServices.ActiveDirectory.DomainControllerCollection" Usage="domain.FindAllDomainControllers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.DomainControllerCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sucht nach allen Domänencontrollern in dieser Domäne.</summary>
        <returns>Eine <see cref="T:System.DirectoryServices.ActiveDirectory.DomainControllerCollection" />, die die von dieser Methode gefundenen Domänencontrollerobjekte enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainControllerCollection" />
      </Docs>
    </Member>
    <Member MemberName="FindAllDomainControllers">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.DomainControllerCollection FindAllDomainControllers (string siteName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.DirectoryServices.ActiveDirectory.DomainControllerCollection FindAllDomainControllers(string siteName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.FindAllDomainControllers(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAllDomainControllers (siteName As String) As DomainControllerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::DirectoryServices::ActiveDirectory::DomainControllerCollection ^ FindAllDomainControllers(System::String ^ siteName);" />
      <MemberSignature Language="F#" Value="member this.FindAllDomainControllers : string -&gt; System.DirectoryServices.ActiveDirectory.DomainControllerCollection" Usage="domain.FindAllDomainControllers siteName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.DomainControllerCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="siteName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="siteName">Der Name des Standorts für die Suche nach den Domänencontrollern.</param>
        <summary>Sucht alle Domänencontroller in dieser Domäne, die sich auch am angegebenen Standort befinden.</summary>
        <returns>Eine <see cref="T:System.DirectoryServices.ActiveDirectory.DomainControllerCollection" />, die die von dieser Methode gefundenen Domänencontrollerobjekte enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="siteName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="siteName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainControllerCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindDomainController">
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Findet Domänencontroller in dieser Domäne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindDomainController">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.DomainController FindDomainController ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.DirectoryServices.ActiveDirectory.DomainController FindDomainController() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.FindDomainController" />
      <MemberSignature Language="VB.NET" Value="Public Function FindDomainController () As DomainController" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::DirectoryServices::ActiveDirectory::DomainController ^ FindDomainController();" />
      <MemberSignature Language="F#" Value="member this.FindDomainController : unit -&gt; System.DirectoryServices.ActiveDirectory.DomainController" Usage="domain.FindDomainController " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.DomainController</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Findet Domänencontroller in dieser Domäne.</summary>
        <returns>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />, der den von dieser Methode gefundenen Domänencontroller darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht alle Domänencontroller in der Domäne. Es gibt keine Garantie, die durch einen anderen Aufruf dieser Methode der gleichen Domänencontroller gefunden werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Ein Domänencontroller kann nicht gefunden werden.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />
      </Docs>
    </Member>
    <Member MemberName="FindDomainController">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.DomainController FindDomainController (System.DirectoryServices.ActiveDirectory.LocatorOptions flag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.DirectoryServices.ActiveDirectory.DomainController FindDomainController(valuetype System.DirectoryServices.ActiveDirectory.LocatorOptions flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.FindDomainController(System.DirectoryServices.ActiveDirectory.LocatorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindDomainController (flag As LocatorOptions) As DomainController" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::DirectoryServices::ActiveDirectory::DomainController ^ FindDomainController(System::DirectoryServices::ActiveDirectory::LocatorOptions flag);" />
      <MemberSignature Language="F#" Value="member this.FindDomainController : System.DirectoryServices.ActiveDirectory.LocatorOptions -&gt; System.DirectoryServices.ActiveDirectory.DomainController" Usage="domain.FindDomainController flag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.DomainController</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.DirectoryServices.ActiveDirectory.LocatorOptions" />
      </Parameters>
      <Docs>
        <param name="flag">Eine Kombination von einem oder mehreren der <see cref="T:System.DirectoryServices.ActiveDirectory.LocatorOptions" />-Member, mit der der Typ des zu suchenden Domänencontrollers definiert wird.</param>
        <summary>Sucht nach einem Domänencontroller in dieser Domäne, der die angegebenen Kriterien erfüllt.</summary>
        <returns>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />, der den von dieser Methode gefundenen Domänencontroller darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Ein Domänencontroller kann nicht gefunden werden.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="flag" />-Parameter hat einen ungültigen Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.LocatorOptions" />
      </Docs>
    </Member>
    <Member MemberName="FindDomainController">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.DomainController FindDomainController (string siteName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.DirectoryServices.ActiveDirectory.DomainController FindDomainController(string siteName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.FindDomainController(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindDomainController (siteName As String) As DomainController" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::DirectoryServices::ActiveDirectory::DomainController ^ FindDomainController(System::String ^ siteName);" />
      <MemberSignature Language="F#" Value="member this.FindDomainController : string -&gt; System.DirectoryServices.ActiveDirectory.DomainController" Usage="domain.FindDomainController siteName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.DomainController</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="siteName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="siteName">Der Name des Standorts für die Suche nach dem Domänencontroller.</param>
        <summary>Sucht nach einem Domänencontroller in dieser Domäne und am angegebenen Standort.</summary>
        <returns>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />-Objekt, das den von dieser Methode gefundenen Domänencontroller darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Ein Domänencontroller kann nicht gefunden werden.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="siteName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="siteName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />
      </Docs>
    </Member>
    <Member MemberName="FindDomainController">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.DomainController FindDomainController (string siteName, System.DirectoryServices.ActiveDirectory.LocatorOptions flag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.DirectoryServices.ActiveDirectory.DomainController FindDomainController(string siteName, valuetype System.DirectoryServices.ActiveDirectory.LocatorOptions flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.FindDomainController(System.String,System.DirectoryServices.ActiveDirectory.LocatorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindDomainController (siteName As String, flag As LocatorOptions) As DomainController" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::DirectoryServices::ActiveDirectory::DomainController ^ FindDomainController(System::String ^ siteName, System::DirectoryServices::ActiveDirectory::LocatorOptions flag);" />
      <MemberSignature Language="F#" Value="member this.FindDomainController : string * System.DirectoryServices.ActiveDirectory.LocatorOptions -&gt; System.DirectoryServices.ActiveDirectory.DomainController" Usage="domain.FindDomainController (siteName, flag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.DomainController</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="siteName" Type="System.String" />
        <Parameter Name="flag" Type="System.DirectoryServices.ActiveDirectory.LocatorOptions" />
      </Parameters>
      <Docs>
        <param name="siteName">Der Name des Standorts für die Suche nach dem Domänencontroller.</param>
        <param name="flag">Eine Kombination von einem oder mehreren der <see cref="T:System.DirectoryServices.ActiveDirectory.LocatorOptions" />-Member, mit der der Typ des zu suchenden Domänencontrollers definiert wird.</param>
        <summary>Sucht nach einem Domänencontroller in dieser Domäne und am angegebenen Standort, der die angegebenen Kriterien erfüllt.</summary>
        <returns>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />-Objekt, das den von dieser Methode gefundenen Domänencontroller darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Ein Domänencontroller kann nicht gefunden werden.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme tritt aus folgenden Gründen auf.  
  
-   <paramref name="siteName" /> ist eine leere Zeichenfolge.  
  
-   <paramref name="flag" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="siteName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.LocatorOptions" />
      </Docs>
    </Member>
    <Member MemberName="Forest">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.Forest Forest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.DirectoryServices.ActiveDirectory.Forest Forest" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.ActiveDirectory.Domain.Forest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Forest As Forest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::DirectoryServices::ActiveDirectory::Forest ^ Forest { System::DirectoryServices::ActiveDirectory::Forest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Forest : System.DirectoryServices.ActiveDirectory.Forest" Usage="System.DirectoryServices.ActiveDirectory.Domain.Forest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.Forest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtstruktur ab, der diese Domäne angehört.</summary>
        <value>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.Forest" />-Objekt, das die Gesamtstruktur darstellt, in der diese Domäne als Member enthalten ist.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.Forest" />
      </Docs>
    </Member>
    <Member MemberName="GetAllTrustRelationships">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.TrustRelationshipInformationCollection GetAllTrustRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.DirectoryServices.ActiveDirectory.TrustRelationshipInformationCollection GetAllTrustRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.GetAllTrustRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllTrustRelationships () As TrustRelationshipInformationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::DirectoryServices::ActiveDirectory::TrustRelationshipInformationCollection ^ GetAllTrustRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetAllTrustRelationships : unit -&gt; System.DirectoryServices.ActiveDirectory.TrustRelationshipInformationCollection" Usage="domain.GetAllTrustRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.TrustRelationshipInformationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft alle Vertrauensstellungen für diese Domäne ab.</summary>
        <returns>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.TrustRelationshipInformationCollection" />-Objekt, das alle Vertrauensstellungen für diese Domäne enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.TrustRelationshipInformationCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetComputerDomain">
      <MemberSignature Language="C#" Value="public static System.DirectoryServices.ActiveDirectory.Domain GetComputerDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.DirectoryServices.ActiveDirectory.Domain GetComputerDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.GetComputerDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComputerDomain () As Domain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::DirectoryServices::ActiveDirectory::Domain ^ GetComputerDomain();" />
      <MemberSignature Language="F#" Value="static member GetComputerDomain : unit -&gt; System.DirectoryServices.ActiveDirectory.Domain" Usage="System.DirectoryServices.ActiveDirectory.Domain.GetComputerDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.Domain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft das <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />-Objekt ab, das die Domäne darstellt, mit der der lokale Computer verbunden wird.</summary>
        <returns>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />-Objekt, das die Domäne darstellt, mit der der lokale Computer verbunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert von der <xref:System.DirectoryServices.ActiveDirectory.Domain.GetComputerDomain%2A> Methode ist eine <xref:System.DirectoryServices.ActiveDirectory.Domain> Objekt, das die Domäne, die der Computer mit der Anwendung hinzugefügt wird, darstellt.  Dieser Rückgabewert ist unabhängig von den Anmeldeinformationen für die Domäne unter denen die Anwendung ausgeführt wird. Diese Methode wird der Domäne des Computers unabhängig von den Anmeldeinformationen für vertrauenswürdiges Konto die Domäne abrufen, die unter dem er ausgeführt wird.  Zum Abrufen der <xref:System.DirectoryServices.ActiveDirectory.Domain> -Objekt, das die Domäne für den Benutzer darstellt, Anmeldeinformationen in Kraft für den Sicherheitskontext an, unter dem die Anwendung ausgeführt wird, verwenden Sie die <xref:System.DirectoryServices.ActiveDirectory.Domain.GetCurrentDomain%2A> Methode stattdessen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es konnte keine Verbindung mit der Domäne hergestellt werden.</exception>
        <altmember cref="M:System.DirectoryServices.ActiveDirectory.Domain.GetCurrentDomain" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDomain">
      <MemberSignature Language="C#" Value="public static System.DirectoryServices.ActiveDirectory.Domain GetCurrentDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.DirectoryServices.ActiveDirectory.Domain GetCurrentDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.GetCurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentDomain () As Domain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::DirectoryServices::ActiveDirectory::Domain ^ GetCurrentDomain();" />
      <MemberSignature Language="F#" Value="static member GetCurrentDomain : unit -&gt; System.DirectoryServices.ActiveDirectory.Domain" Usage="System.DirectoryServices.ActiveDirectory.Domain.GetCurrentDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.Domain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft das <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />-Objekt für die aktuellen Benutzeranmeldeinformationen ab, die für den Sicherheitskontext gültig sind, in dem die Anwendung ausgeführt wird.</summary>
        <returns>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />-Objekt, das die Domäne für die angegebenen Benutzeranmeldeinformationen abruft, die für den Sicherheitskontext gültig sind, in dem die Anwendung ausgeführt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DirectoryServices.ActiveDirectory.Domain.GetCurrentDomain%2A> Methode richtet sich nach den Anmeldeinformationen für die Domäne, unter denen die Anwendung ausgeführt wird.  Zum Abrufen der <xref:System.DirectoryServices.ActiveDirectory.Domain> Objekt, auf die Domäne darstellt, zu der des Computers, die Ausführung der Anwendung hinzugefügt werden, unabhängig von der Anwendung zugeordneten Anmeldeinformationen, verwenden Sie die <xref:System.DirectoryServices.ActiveDirectory.Domain.GetComputerDomain%2A> Methode stattdessen.  
  
## <a name="see-also"></a>Siehe auch  
 <xref:System.DirectoryServices.ActiveDirectory.Domain.GetComputerDomain%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es konnte keine Verbindung mit dem aktuellen Kontext hergestellt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryEntry">
      <MemberSignature Language="C#" Value="public override System.DirectoryServices.DirectoryEntry GetDirectoryEntry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.DirectoryServices.DirectoryEntry GetDirectoryEntry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.GetDirectoryEntry" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDirectoryEntry () As DirectoryEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::DirectoryServices::DirectoryEntry ^ GetDirectoryEntry();" />
      <MemberSignature Language="F#" Value="override this.GetDirectoryEntry : unit -&gt; System.DirectoryServices.DirectoryEntry" Usage="domain.GetDirectoryEntry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.DirectoryEntry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.DirectoryServices.DirectoryEntry" />-Objekt ab, das den Standardnamenskontext der Domäne darstellt.</summary>
        <returns>Ein <see cref="T:System.DirectoryServices.DirectoryEntry" />-Objekt, das die Domäne darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Das aktuelle Objekt wurde verworfen.</exception>
        <permission cref="T:System.DirectoryServices.DirectoryServicesPermission">Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /></permission>
        <altmember cref="T:System.DirectoryServices.DirectoryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static System.DirectoryServices.ActiveDirectory.Domain GetDomain (System.DirectoryServices.ActiveDirectory.DirectoryContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.DirectoryServices.ActiveDirectory.Domain GetDomain(class System.DirectoryServices.ActiveDirectory.DirectoryContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.GetDomain(System.DirectoryServices.ActiveDirectory.DirectoryContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain (context As DirectoryContext) As Domain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::DirectoryServices::ActiveDirectory::Domain ^ GetDomain(System::DirectoryServices::ActiveDirectory::DirectoryContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetDomain : System.DirectoryServices.ActiveDirectory.DirectoryContext -&gt; System.DirectoryServices.ActiveDirectory.Domain" Usage="System.DirectoryServices.ActiveDirectory.Domain.GetDomain context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.Domain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.DirectoryServices.ActiveDirectory.DirectoryContext" />
      </Parameters>
      <Docs>
        <param name="context">Ein <see cref="T:System.DirectoryServices.ActiveDirectory.DirectoryContext" />-Objekt, das das Ziel und die Anmeldeinformationen zum Abrufen des Objekts enthält. Der Kontexttyp muss eine Domäne oder ein Verzeichnisserver sein.</param>
        <summary>Ruft das <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />-Objekt für den angegebenen Kontext ab.</summary>
        <returns>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />-Objekt, das die Domäne für den angegebenen Kontext darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es konnte keine Verbindung zu dem in <paramref name="context" /> angegebenen Ziel hergestellt werden.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="context" /> ist nicht gültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DirectoryContext" />
      </Docs>
    </Member>
    <Member MemberName="GetSelectiveAuthenticationStatus">
      <MemberSignature Language="C#" Value="public bool GetSelectiveAuthenticationStatus (string targetDomainName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetSelectiveAuthenticationStatus(string targetDomainName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.GetSelectiveAuthenticationStatus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSelectiveAuthenticationStatus (targetDomainName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetSelectiveAuthenticationStatus(System::String ^ targetDomainName);" />
      <MemberSignature Language="F#" Value="member this.GetSelectiveAuthenticationStatus : string -&gt; bool" Usage="domain.GetSelectiveAuthenticationStatus targetDomainName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomainName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetDomainName">Der DNS-Name der Domäne, für die die Vertrauensstellung vorhanden ist.</param>
        <summary>Bestimmt den Authentifizierungstyp einer eingehenden Vertrauensstellung.</summary>
        <returns>
          <see langword="true" />, wenn die Authentifizierung der Vertrauensstellung selektiv ist, <see langword="false" />, wenn sich die Authentifizierung auf die gesamte Domäne bezieht.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es ist keine Vertrauensstellung mit dem <see cref="T:System.DirectoryServices.ActiveDirectory.Forest" />-Objekt vorhanden, das durch den <paramref name="targetForestName" />-Parameter angegeben ist.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Beim Aufruf von LsaQueryTrustedDomainInfoByName ist ein Fehler aufgetreten. Weitere Informationen finden Sie unter dem Thema [LsaQueryTrustedDomainInfoByName](http://msdn.microsoft.com/library/default.asp?url=/library/en-us/secmgmt/security/lsaquerytrusteddomaininfobyname.asp) in der MSDN Library unter [http://msdn.microsoft.com/library](http://msdn.microsoft.com/library).</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetDomainName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomainName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das aktuelle Objekt wurde verworfen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <altmember cref="M:System.DirectoryServices.ActiveDirectory.Domain.SetSelectiveAuthenticationStatus(System.String,System.Boolean)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e1df3378-17b0-4429-91c7-13d4a457fb6e">Gewusst wie: Arbeiten mit Vertrauensstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetSidFilteringStatus">
      <MemberSignature Language="C#" Value="public bool GetSidFilteringStatus (string targetDomainName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetSidFilteringStatus(string targetDomainName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.GetSidFilteringStatus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSidFilteringStatus (targetDomainName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetSidFilteringStatus(System::String ^ targetDomainName);" />
      <MemberSignature Language="F#" Value="member this.GetSidFilteringStatus : string -&gt; bool" Usage="domain.GetSidFilteringStatus targetDomainName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomainName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetDomainName">Der DNS-Name der Domäne, für die die Vertrauensstellung vorhanden ist.</param>
        <summary>Bestimmt den Status der SID-Filterung einer Vertrauensstellung.</summary>
        <returns>
          <see langword="true" />, wenn die SID-Filterung aktiviert ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es ist keine Vertrauensstellung mit dem <see cref="T:System.DirectoryServices.ActiveDirectory.Forest" />-Objekt vorhanden, das durch den <paramref name="targetForestName" />-Parameter angegeben ist.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetDomainName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomainName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das aktuelle Objekt wurde verworfen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <altmember cref="M:System.DirectoryServices.ActiveDirectory.Domain.SetSidFilteringStatus(System.String,System.Boolean)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e1df3378-17b0-4429-91c7-13d4a457fb6e">Gewusst wie: Arbeiten mit Vertrauensstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetTrustRelationship">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.TrustRelationshipInformation GetTrustRelationship (string targetDomainName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.DirectoryServices.ActiveDirectory.TrustRelationshipInformation GetTrustRelationship(string targetDomainName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.GetTrustRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTrustRelationship (targetDomainName As String) As TrustRelationshipInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::DirectoryServices::ActiveDirectory::TrustRelationshipInformation ^ GetTrustRelationship(System::String ^ targetDomainName);" />
      <MemberSignature Language="F#" Value="member this.GetTrustRelationship : string -&gt; System.DirectoryServices.ActiveDirectory.TrustRelationshipInformation" Usage="domain.GetTrustRelationship targetDomainName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.TrustRelationshipInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomainName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetDomainName">Der DNS-Name der Domäne, mit der die Vertrauensstellung vorhanden ist.</param>
        <summary>Ruft die Vertrauensstellung zwischen dieser Domäne und der angegebenen Domäne ab.</summary>
        <returns>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.TrustRelationshipInformation" />-Objekt, das die Vertrauensstellung zwischen dieser Domäne und der angegebenen Domäne darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es ist keine Vertrauensstellung mit dem <see cref="T:System.DirectoryServices.ActiveDirectory.Forest" />-Objekt vorhanden, das durch den <paramref name="targetForestName" />-Parameter angegeben ist.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetDomainName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomainName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das aktuelle Objekt wurde verworfen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.TrustRelationshipInformation" />
      </Docs>
    </Member>
    <Member MemberName="InfrastructureRoleOwner">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.DomainController InfrastructureRoleOwner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.DirectoryServices.ActiveDirectory.DomainController InfrastructureRoleOwner" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.ActiveDirectory.Domain.InfrastructureRoleOwner" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InfrastructureRoleOwner As DomainController" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::DirectoryServices::ActiveDirectory::DomainController ^ InfrastructureRoleOwner { System::DirectoryServices::ActiveDirectory::DomainController ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InfrastructureRoleOwner : System.DirectoryServices.ActiveDirectory.DomainController" Usage="System.DirectoryServices.ActiveDirectory.Domain.InfrastructureRoleOwner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.DomainController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Besitzer der Infrastrukturrolle für diese Domäne ab.</summary>
        <value>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />-Objekt, das den Domänencontroller mit der Infrastrukturbesitzer-Rolle darstellt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.Domain Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.DirectoryServices.ActiveDirectory.Domain Parent" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.ActiveDirectory.Domain.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Domain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::DirectoryServices::ActiveDirectory::Domain ^ Parent { System::DirectoryServices::ActiveDirectory::Domain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.DirectoryServices.ActiveDirectory.Domain" Usage="System.DirectoryServices.ActiveDirectory.Domain.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.Domain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die übergeordnete Domäne dieser Domäne ab.</summary>
        <value>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />-Objekt, das die übergeordnete Domäne dieser Domäne darstellt. <see langword="null" />, wenn diese Domäne keine übergeordnete Domäne hat.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="PdcRoleOwner">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.DomainController PdcRoleOwner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.DirectoryServices.ActiveDirectory.DomainController PdcRoleOwner" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.ActiveDirectory.Domain.PdcRoleOwner" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PdcRoleOwner As DomainController" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::DirectoryServices::ActiveDirectory::DomainController ^ PdcRoleOwner { System::DirectoryServices::ActiveDirectory::DomainController ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PdcRoleOwner : System.DirectoryServices.ActiveDirectory.DomainController" Usage="System.DirectoryServices.ActiveDirectory.Domain.PdcRoleOwner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.DomainController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />-Objekt mit dem primären Domänencontroller (PDC) für diese Domäne ab.</summary>
        <value>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />-Objekt, das den Domänencontroller mit der PDC-Emulatorrolle für diese Domäne darstellt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />
      </Docs>
    </Member>
    <Member MemberName="RaiseDomainFunctionality">
      <MemberSignature Language="C#" Value="public void RaiseDomainFunctionality (System.DirectoryServices.ActiveDirectory.DomainMode domainMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RaiseDomainFunctionality(valuetype System.DirectoryServices.ActiveDirectory.DomainMode domainMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.RaiseDomainFunctionality(System.DirectoryServices.ActiveDirectory.DomainMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RaiseDomainFunctionality(System::DirectoryServices::ActiveDirectory::DomainMode domainMode);" />
      <MemberSignature Language="F#" Value="member this.RaiseDomainFunctionality : System.DirectoryServices.ActiveDirectory.DomainMode -&gt; unit" Usage="domain.RaiseDomainFunctionality domainMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainMode" Type="System.DirectoryServices.ActiveDirectory.DomainMode" />
      </Parameters>
      <Docs>
        <param name="domainMode">Ein <see cref="T:System.DirectoryServices.ActiveDirectory.DomainMode" />-Enumerationswert, der die neue Betriebsebene für die Domäne angibt.</param>
        <summary>Löst den Betriebsmodus für die Domäne aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.DirectoryServices.ActiveDirectory.DomainMode> Wert ausgelöst, aber nicht verringert werden kann. Dies bedeutet, dass das Auslösen der Funktionsebene der Domäne nicht rückgängig gemacht werden kann und die Entscheidung zu diesem Zweck sorgfältig gemacht werden sollen.  
  
 Weitere Informationen zu den Domänenbetriebsmodi finden Sie unter [Domänen-und Gesamtstrukturfunktionalität](http://www.microsoft.com/resources/documentation/WindowsServ/2003/standard/proddocs/en-us/sag_levels.asp).  
  
 Der folgenden Tabelle werden die gültigen Werte für `domainMode` basierend auf dem aktuellen Betriebsmodus der Domäne.  
  
|Der aktuelle Modus|Modus kann mit potenziert werden soll|  
|------------------|---------------------------|  
|<xref:System.DirectoryServices.ActiveDirectory.DomainMode.Windows2000MixedDomain>|<xref:System.DirectoryServices.ActiveDirectory.DomainMode.Windows2000NativeDomain><br /><br /> <xref:System.DirectoryServices.ActiveDirectory.DomainMode.Windows2003InterimDomain><br /><br /> <xref:System.DirectoryServices.ActiveDirectory.DomainMode.Windows2003Domain>|  
|<xref:System.DirectoryServices.ActiveDirectory.DomainMode.Windows2000NativeDomain>|<xref:System.DirectoryServices.ActiveDirectory.DomainMode.Windows2003Domain>|  
|<xref:System.DirectoryServices.ActiveDirectory.DomainMode.Windows2003InterimDomain>|<xref:System.DirectoryServices.ActiveDirectory.DomainMode.Windows2003Domain>|  
|<xref:System.DirectoryServices.ActiveDirectory.DomainMode.Windows2003Domain>|Keiner|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentException">Der für <paramref name="domainMode" /> angegebene Wert ist bezogen auf den aktuellen Betriebsmodus der Domäne ungültig.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="domainMode" /> ist kein gültiger <see cref="T:System.DirectoryServices.ActiveDirectory.DomainMode" />-Enumerationswert.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainMode" />
      </Docs>
    </Member>
    <Member MemberName="RaiseDomainFunctionalityLevel">
      <MemberSignature Language="C#" Value="public void RaiseDomainFunctionalityLevel (int domainMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RaiseDomainFunctionalityLevel(int32 domainMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.RaiseDomainFunctionalityLevel(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseDomainFunctionalityLevel (domainMode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RaiseDomainFunctionalityLevel(int domainMode);" />
      <MemberSignature Language="F#" Value="member this.RaiseDomainFunctionalityLevel : int -&gt; unit" Usage="domain.RaiseDomainFunctionalityLevel domainMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainMode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="domainMode">Ein Wert, der die neue Stufe angibt.</param>
        <summary>Hebt die Funktionalitätsstufe für die Domäne an.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RepairTrustRelationship">
      <MemberSignature Language="C#" Value="public void RepairTrustRelationship (System.DirectoryServices.ActiveDirectory.Domain targetDomain);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RepairTrustRelationship(class System.DirectoryServices.ActiveDirectory.Domain targetDomain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.RepairTrustRelationship(System.DirectoryServices.ActiveDirectory.Domain)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RepairTrustRelationship (targetDomain As Domain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RepairTrustRelationship(System::DirectoryServices::ActiveDirectory::Domain ^ targetDomain);" />
      <MemberSignature Language="F#" Value="member this.RepairTrustRelationship : System.DirectoryServices.ActiveDirectory.Domain -&gt; unit" Usage="domain.RepairTrustRelationship targetDomain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomain" Type="System.DirectoryServices.ActiveDirectory.Domain" />
      </Parameters>
      <Docs>
        <param name="targetDomain">Ein <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />-Objekt, das die Domäne darstellt, für die die Vertrauensstellung vorhanden ist.</param>
        <summary>Repariert eine Vertrauensstellung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird die Vertrauensstellung repariert, durch den sicheren Kanal für die Vertrauensstellung zurücksetzen. Wenn der Vorgang fehlschlägt, den sicheren Kanal zurückzusetzen, wird er auch das Vertrauensstellungskennwort zurückgesetzt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es ist keine Vertrauensstellung mit der von <paramref name="targetDomain" /> angegebenen <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" /> vorhanden.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Ziel- oder Quellserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomain" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.Domain" />
      </Docs>
    </Member>
    <Member MemberName="RidRoleOwner">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.ActiveDirectory.DomainController RidRoleOwner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.DirectoryServices.ActiveDirectory.DomainController RidRoleOwner" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.ActiveDirectory.Domain.RidRoleOwner" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RidRoleOwner As DomainController" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::DirectoryServices::ActiveDirectory::DomainController ^ RidRoleOwner { System::DirectoryServices::ActiveDirectory::DomainController ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RidRoleOwner : System.DirectoryServices.ActiveDirectory.DomainController" Usage="System.DirectoryServices.ActiveDirectory.Domain.RidRoleOwner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.ActiveDirectory.DomainController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Inhaber der RID-Masterrolle für diese Domäne ab.</summary>
        <value>Ein <see cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />-Objekt, das den Domänencontroller darstellt, der die RID-Masterrolle (RID - relative ID) für diese Domäne besitzt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.DomainController" />
      </Docs>
    </Member>
    <Member MemberName="SetSelectiveAuthenticationStatus">
      <MemberSignature Language="C#" Value="public void SetSelectiveAuthenticationStatus (string targetDomainName, bool enable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSelectiveAuthenticationStatus(string targetDomainName, bool enable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.SetSelectiveAuthenticationStatus(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSelectiveAuthenticationStatus (targetDomainName As String, enable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSelectiveAuthenticationStatus(System::String ^ targetDomainName, bool enable);" />
      <MemberSignature Language="F#" Value="member this.SetSelectiveAuthenticationStatus : string * bool -&gt; unit" Usage="domain.SetSelectiveAuthenticationStatus (targetDomainName, enable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomainName" Type="System.String" />
        <Parameter Name="enable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetDomainName">Der DNS-Name der Domäne, für die die eingehende Vertrauensstellung vorhanden ist.</param>
        <param name="enable">
          <see langword="true" />, wenn die selektive Authentifizierung aktiviert ist, andernfalls <see langword="false" />.</param>
        <summary>Aktiviert oder deaktiviert die selektive Authentifizierung für eine eingehende Vertrauensstellung.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es ist keine Vertrauensstellung mit dem von <paramref name="targetDomainName" /> angegebenen Domänencontroller vorhanden.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetDomainName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomainName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das aktuelle Objekt wurde verworfen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <altmember cref="M:System.DirectoryServices.ActiveDirectory.Domain.GetSelectiveAuthenticationStatus(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e1df3378-17b0-4429-91c7-13d4a457fb6e">Gewusst wie: Arbeiten mit Vertrauensstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="SetSidFilteringStatus">
      <MemberSignature Language="C#" Value="public void SetSidFilteringStatus (string targetDomainName, bool enable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSidFilteringStatus(string targetDomainName, bool enable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.SetSidFilteringStatus(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSidFilteringStatus (targetDomainName As String, enable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSidFilteringStatus(System::String ^ targetDomainName, bool enable);" />
      <MemberSignature Language="F#" Value="member this.SetSidFilteringStatus : string * bool -&gt; unit" Usage="domain.SetSidFilteringStatus (targetDomainName, enable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomainName" Type="System.String" />
        <Parameter Name="enable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetDomainName">Der DNS-Name der Domäne, mit der die Vertrauensstellung vorhanden ist.</param>
        <param name="enable">
          <see langword="true" />, wenn die SID-Filterung aktiviert werden muss, andernfalls <see langword="false" />.</param>
        <summary>Legt den SID-Filterstatus für die angegebene Domäne fest.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es ist keine Vertrauensstellung mit der von <paramref name="targetDomainName" /> angegebenen Domäne vorhanden.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetDomainName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomainName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das aktuelle Objekt wurde verworfen.</exception>
        <altmember cref="M:System.DirectoryServices.ActiveDirectory.Domain.GetSidFilteringStatus(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e1df3378-17b0-4429-91c7-13d4a457fb6e">Gewusst wie: Arbeiten mit Vertrauensstellungen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateLocalSideOfTrustRelationship">
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualisiert die lokale Seite einer Vertrauensstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateLocalSideOfTrustRelationship">
      <MemberSignature Language="C#" Value="public void UpdateLocalSideOfTrustRelationship (string targetDomainName, string newTrustPassword);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateLocalSideOfTrustRelationship(string targetDomainName, string newTrustPassword) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.UpdateLocalSideOfTrustRelationship(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateLocalSideOfTrustRelationship (targetDomainName As String, newTrustPassword As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateLocalSideOfTrustRelationship(System::String ^ targetDomainName, System::String ^ newTrustPassword);" />
      <MemberSignature Language="F#" Value="member this.UpdateLocalSideOfTrustRelationship : string * string -&gt; unit" Usage="domain.UpdateLocalSideOfTrustRelationship (targetDomainName, newTrustPassword)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomainName" Type="System.String" />
        <Parameter Name="newTrustPassword" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetDomainName">Der DNS-Name der Domäne, mit der eine Vertrauensstellung vorhanden ist.</param>
        <param name="newTrustPassword">Das neue Kennwort für die Vertrauensstellung.</param>
        <summary>Aktualisiert das Kennwort für die lokale Seite einer Vertrauensstellung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die Vertrauensstellung erneut hergestellt haben, müssen beide Seiten der Vertrauensstellung mit dem gleichen Kennwort aktualisiert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es ist keine Vertrauensstellung mit der von <paramref name="targetDomainName" /> angegebenen Domäne vorhanden.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetDomainName" /> oder <paramref name="newTrustPassword" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomainName" /> oder <paramref name="newTrustPassword" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/e1df3378-17b0-4429-91c7-13d4a457fb6e">Gewusst wie: Arbeiten mit Vertrauensstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="UpdateLocalSideOfTrustRelationship">
      <MemberSignature Language="C#" Value="public void UpdateLocalSideOfTrustRelationship (string targetDomainName, System.DirectoryServices.ActiveDirectory.TrustDirection newTrustDirection, string newTrustPassword);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateLocalSideOfTrustRelationship(string targetDomainName, valuetype System.DirectoryServices.ActiveDirectory.TrustDirection newTrustDirection, string newTrustPassword) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.UpdateLocalSideOfTrustRelationship(System.String,System.DirectoryServices.ActiveDirectory.TrustDirection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateLocalSideOfTrustRelationship (targetDomainName As String, newTrustDirection As TrustDirection, newTrustPassword As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateLocalSideOfTrustRelationship(System::String ^ targetDomainName, System::DirectoryServices::ActiveDirectory::TrustDirection newTrustDirection, System::String ^ newTrustPassword);" />
      <MemberSignature Language="F#" Value="member this.UpdateLocalSideOfTrustRelationship : string * System.DirectoryServices.ActiveDirectory.TrustDirection * string -&gt; unit" Usage="domain.UpdateLocalSideOfTrustRelationship (targetDomainName, newTrustDirection, newTrustPassword)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomainName" Type="System.String" />
        <Parameter Name="newTrustDirection" Type="System.DirectoryServices.ActiveDirectory.TrustDirection" />
        <Parameter Name="newTrustPassword" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetDomainName">Der DNS-Name der Domäne, mit der eine Vertrauensstellung vorhanden ist.</param>
        <param name="newTrustDirection">Ein <see cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />-Wert, der die neue Vertrauensrichtung für die Vertrauensstellung angibt.</param>
        <param name="newTrustPassword">Das neue Kennwort für die Vertrauensstellung.</param>
        <summary>Aktualisiert das Kennwort und die Vertrauensrichtung für die lokale Seite einer Vertrauensstellung.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es ist keine Vertrauensstellung mit der vom <paramref name="targetDomainName" />-Parameter angegebenen Domäne vorhanden.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetDomainName" /> oder <paramref name="newTrustPassword" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomainName" /> oder <paramref name="newTrustPassword" /> sind <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="newTrustDirection" /> ist kein gültiger <see cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />-Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />
        <related type="Article" href="https://msdn.microsoft.com/library/e1df3378-17b0-4429-91c7-13d4a457fb6e">Gewusst wie: Arbeiten mit Vertrauensstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="UpdateTrustRelationship">
      <MemberSignature Language="C#" Value="public void UpdateTrustRelationship (System.DirectoryServices.ActiveDirectory.Domain targetDomain, System.DirectoryServices.ActiveDirectory.TrustDirection newTrustDirection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateTrustRelationship(class System.DirectoryServices.ActiveDirectory.Domain targetDomain, valuetype System.DirectoryServices.ActiveDirectory.TrustDirection newTrustDirection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.UpdateTrustRelationship(System.DirectoryServices.ActiveDirectory.Domain,System.DirectoryServices.ActiveDirectory.TrustDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateTrustRelationship (targetDomain As Domain, newTrustDirection As TrustDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateTrustRelationship(System::DirectoryServices::ActiveDirectory::Domain ^ targetDomain, System::DirectoryServices::ActiveDirectory::TrustDirection newTrustDirection);" />
      <MemberSignature Language="F#" Value="member this.UpdateTrustRelationship : System.DirectoryServices.ActiveDirectory.Domain * System.DirectoryServices.ActiveDirectory.TrustDirection -&gt; unit" Usage="domain.UpdateTrustRelationship (targetDomain, newTrustDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomain" Type="System.DirectoryServices.ActiveDirectory.Domain" />
        <Parameter Name="newTrustDirection" Type="System.DirectoryServices.ActiveDirectory.TrustDirection" />
      </Parameters>
      <Docs>
        <param name="targetDomain">Ein <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />-Objekt, das die Domäne darstellt, für die die Vertrauensstellung vorhanden ist.</param>
        <param name="newTrustDirection">Ein <see cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />-Wert, der die neue Vertrauensrichtung für die Vertrauensstellung angibt.</param>
        <summary>Aktualisiert die Richtung der Vertrauensstellung für eine vorhandene Vertrauensstellung. Die Richtungen der Vertrauensstellung werden auf beiden Seiten der Vertrauensstellung aktualisiert.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es ist keine Vertrauensstellung mit der vom <paramref name="targetDomain" />-Parameter angegebenen Domäne vorhanden.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomain" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="newTrustDirection" /> ist kein gültiger <see cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />-Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />
        <related type="Article" href="https://msdn.microsoft.com/library/e1df3378-17b0-4429-91c7-13d4a457fb6e">Gewusst wie: Arbeiten mit Vertrauensstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="VerifyOutboundTrustRelationship">
      <MemberSignature Language="C#" Value="public void VerifyOutboundTrustRelationship (string targetDomainName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void VerifyOutboundTrustRelationship(string targetDomainName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.VerifyOutboundTrustRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub VerifyOutboundTrustRelationship (targetDomainName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void VerifyOutboundTrustRelationship(System::String ^ targetDomainName);" />
      <MemberSignature Language="F#" Value="member this.VerifyOutboundTrustRelationship : string -&gt; unit" Usage="domain.VerifyOutboundTrustRelationship targetDomainName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomainName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetDomainName">Der DNS-Name der Domäne, mit der die Vertrauensstellung vorhanden ist.</param>
        <summary>Überprüft, ob eine zuvor eingerichtete ausgehenden Vertrauensstellung mit der angegebenen Domäne gültig ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um sicherzustellen, dass eine Vertrauensstellung vollständig eingerichtet wurde. Die Vertrauensstellung ist nicht festgelegt werden, bis beide Seiten der Vertrauensstellung erstellt wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es ist keine ausgehende Vertrauensstellung mit der von <paramref name="targetDomainName" /> angegebenen Domäne vorhanden.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetDomainName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomainName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/e1df3378-17b0-4429-91c7-13d4a457fb6e">Gewusst wie: Arbeiten mit Vertrauensstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="VerifyTrustRelationship">
      <MemberSignature Language="C#" Value="public void VerifyTrustRelationship (System.DirectoryServices.ActiveDirectory.Domain targetDomain, System.DirectoryServices.ActiveDirectory.TrustDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void VerifyTrustRelationship(class System.DirectoryServices.ActiveDirectory.Domain targetDomain, valuetype System.DirectoryServices.ActiveDirectory.TrustDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.ActiveDirectory.Domain.VerifyTrustRelationship(System.DirectoryServices.ActiveDirectory.Domain,System.DirectoryServices.ActiveDirectory.TrustDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub VerifyTrustRelationship (targetDomain As Domain, direction As TrustDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void VerifyTrustRelationship(System::DirectoryServices::ActiveDirectory::Domain ^ targetDomain, System::DirectoryServices::ActiveDirectory::TrustDirection direction);" />
      <MemberSignature Language="F#" Value="member this.VerifyTrustRelationship : System.DirectoryServices.ActiveDirectory.Domain * System.DirectoryServices.ActiveDirectory.TrustDirection -&gt; unit" Usage="domain.VerifyTrustRelationship (targetDomain, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDomain" Type="System.DirectoryServices.ActiveDirectory.Domain" />
        <Parameter Name="direction" Type="System.DirectoryServices.ActiveDirectory.TrustDirection" />
      </Parameters>
      <Docs>
        <param name="targetDomain">Ein <see cref="T:System.DirectoryServices.ActiveDirectory.Domain" />-Objekt, das die Domäne darstellt, für die die Vertrauensstellung vorhanden ist.</param>
        <param name="direction">Ein <see cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />-Wert, der relativ zu dieser Domäne die Richtung der Vertrauensstellung angibt.</param>
        <summary>Überprüft, ob eine zuvor eingerichtete Vertrauensstellung mit der angegebenen Domäne gültig ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft, dass eine Vertrauensstellung vollständig eingerichtet wurde. Die Vertrauensstellung ist nicht festgelegt werden, bis beide Seiten der Vertrauensstellung erstellt wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException">Es ist keine Vertrauensstellung mit der vom <paramref name="targetDomain" />-Parameter angegebenen Domäne vorhanden, oder die Zieldomäne weist nicht die vom <paramref name="direction" />-Parameter angegebene Vertrauensrichtung auf.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryOperationException">Bei einem Aufruf des zugrunde liegenden Verzeichnisdiensts ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException">Der Zielserver ist entweder ausgelastet oder nicht verfügbar.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetDomain" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="direction" /> ist kein gültiger <see cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />-Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde freigegeben.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das angegebene Konto verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <altmember cref="T:System.DirectoryServices.ActiveDirectory.TrustDirection" />
        <related type="Article" href="https://msdn.microsoft.com/library/e1df3378-17b0-4429-91c7-13d4a457fb6e">Gewusst wie: Arbeiten mit Vertrauensstellungen</related>
      </Docs>
    </Member>
  </Members>
</Type>