<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5d4d49377e7c4e816ae8c9fb2923fb521563cbfb" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86654524" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpServerUtility" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpServerUtility sealed" />
  <TypeSignature Language="F#" Value="type HttpServerUtility = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Hilfsmethoden für die Verarbeitung von Webanforderungen zur Verfügung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden und Eigenschaften der-Klasse werden durch das systeminterne-Objekt verfügbar gemacht, das <xref:System.Web.HttpServerUtility> <xref:System.Web.HttpContext.Server%2A> von ASP.NET bereitgestellt wird.  
  
   
  
## Examples  
 Für dieses Thema steht ein Visual Studio-Website Projekt mit Quellcode zur Verfügung: [herunterladen](https://go.microsoft.com/fwlink/?LinkId=192870).  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Web.HttpServerUtility.HtmlEncode%2A> -Methode und die- <xref:System.Web.HttpServerUtility.UrlEncode%2A> Methode der-Klasse verwendet werden <xref:System.Web.HttpServerUtility> . Mit der- <xref:System.Web.HttpServerUtility.HtmlEncode%2A> Methode wird sichergestellt, dass jede vom Benutzer angegebene Zeichen folgen Eingabe als statischer Text in Browsern anstelle eines ausführbaren Skripts oder HTML-Elements gerendert wird Die- <xref:System.Web.HttpServerUtility.UrlEncode%2A> Methode codiert URLs, damit Sie ordnungsgemäß im HTTP-Datenstrom übertragen werden.  
  
 [!code-aspx-csharp[System.Web.HttpServerUtility1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpServerUtility1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.HttpContext" />
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpServerUtility.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die vorhergehende Ausnahme.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die letzte Ausnahme gelöscht, die ausgelöst wurde.  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.GetLastError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Serverinstanz eines COM-Objekts.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : string -&gt; obj" Usage="httpServerUtility.CreateObject progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Die Klasse oder der Typ des Objekts, von dem eine Instanz erstellt werden soll.</param>
        <summary>Erstellt eine Serverinstanz eines COM-Objekts, das durch den Programmbezeichner (ProgID) des Objekts gekennzeichnet ist.</summary>
        <returns>Das neue Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird ein-Objekt mithilfe der ProgID des-Objekts erstellt.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Es konnte keine Instanz des Objekts erstellt werden.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (type As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : Type -&gt; obj" Usage="httpServerUtility.CreateObject type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Ein <see cref="T:System.Type" />, der das zu erstellende Objekt darstellt.</param>
        <summary>Erstellt eine Serverinstanz eines COM-Objekts, das durch den Objekttyp identifiziert wird.</summary>
        <returns>Das neue Objekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectFromClsid (clsid As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObjectFromClsid(System::String ^ clsid);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectFromClsid : string -&gt; obj" Usage="httpServerUtility.CreateObjectFromClsid clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Der Klassenbezeichner des Objekts, von dem eine Instanz erstellt werden soll.</param>
        <summary>Erstellt eine Serverinstanz eines COM-Objekts, das durch die Klassen-ID (Class Identifier, CLSID) des Objekts gekennzeichnet ist.</summary>
        <returns>Das neue Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die-Methode verwendet wird <xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A> , um eine Serverinstanz eines COM-Objekts zu erstellen.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Es konnte keine Instanz des Objekts erstellt werden.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Execute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt den Handler für eine angegebene Ressource im Kontext der aktuellen Anforderung aus und gibt die Ausführung an die aufrufende Seite zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Execute : string -&gt; unit" Usage="httpServerUtility.Execute path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der auszuführende URL-Pfad.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Web.HttpServerUtility.Execute%2A> Methode setzt die Ausführung der ursprünglichen Seite fort, nachdem die Ausführung der neuen Seite abgeschlossen wurde. Die- <xref:System.Web.HttpServerUtility.Transfer%2A> Methode überträgt die Ausführung bedingungslos an einen anderen Handler.  
  
 ASP.NET überprüft nicht, ob der aktuelle Benutzer autorisiert ist, die von der-Methode gelieferte Ressource anzuzeigen <xref:System.Web.HttpServerUtility.Execute%2A> . Obwohl die ASP.net-Autorisierungs-und Authentifizierungs Logik vor dem Aufrufen des ursprünglichen Ressourcen Handlers ausgeführt wird, ruft ASP.net direkt den von der <xref:System.Web.HttpServerUtility.Execute%2A> -Methode bezeichneten Handler auf und führt keine Authentifizierungs-und Autorisierungs Logik für die neue Ressource erneut aus. Wenn die Sicherheitsrichtlinie Ihrer Anwendung erfordert, dass Clients über die entsprechende Autorisierung für den Zugriff auf die Ressource verfügen, sollte die Anwendung die erneute Autorisierung erzwingen oder einen benutzerdefinierten Mechanismus zur Zugriffs Steuerung bereitstellen.  
  
 Sie können die erneute Autorisierung erzwingen, indem Sie <xref:System.Web.HttpResponse.Redirect%2A> anstelle der-Methode die-Methode verwenden <xref:System.Web.HttpServerUtility.Execute%2A> . <xref:System.Web.HttpResponse.Redirect%2A> führt eine Client seitige Umleitung aus, bei der der Browser die neue Ressource anfordert. Da diese Umleitung eine neue Anforderung ist, die in das System eintritt, wird Sie der gesamten Authentifizierungs-und Autorisierungs Logik sowohl der Internetinformationsdienste (IIS) als auch der ASP.NET-Sicherheitsrichtlinie unterzogen.  
  
 Sie können überprüfen, ob der Benutzer über die Berechtigung zum Anzeigen der Ressource verfügt, indem Sie eine benutzerdefinierte Autorisierungs Methode einbinden, die die Methode verwendet, <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> bevor die Anwendung die- <xref:System.Web.HttpServerUtility.Execute%2A> Methode aufruft  
  
   
  
## Examples  
 Im folgenden Beispiel wird die ASPX-Seite "updateingefo. aspx" im aktuellen Verzeichnis angezeigt. Die Programmausführung wird auf die Startseite zurückgegeben, nachdem die Seite "Updateinfo. aspx" angezeigt wird.  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.  
  
- oder - 
Fehler beim Ausführen des von <paramref name="path" /> angegebenen Handlers.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="path" /> ist kein virtueller Pfad.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * bool -&gt; unit" Usage="httpServerUtility.Execute (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der auszuführende URL-Pfad.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung aus und gibt an, ob die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung gelöscht werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die ASPX-Seite `Updateinfo.aspx` in der aktuellen Anforderung ausgeführt wird und die-Auflistung und die-Auflistung beibehalten werden <xref:System.Web.HttpRequest.QueryString%2A> <xref:System.Web.HttpRequest.Form%2A> . Die Programmausführung wird zur Startseite zurückkehren, nachdem `Updateinfo.aspx` angezeigt wird.  
  
 [!code-csharp[HttpServerUtility.Execute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.  
  
- oder - 
Fehler beim Ausführen des von <paramref name="path" /> angegebenen Handlers.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="path" /> ist kein virtueller Pfad.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.Execute (path, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">Der auszuführende URL-Pfad.</param>
        <param name="writer">Der zum Aufzeichnen der Ausgabe zu verwendende <see cref="T:System.IO.TextWriter" />.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung aus. Ein <see cref="T:System.IO.TextWriter" /> zeichnet die Ausgabe des ausgeführten Handlers auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Web.HttpServerUtility.Execute%2A> Methode setzt die Ausführung der ursprünglichen Anforderung fort, nachdem die angegebene Ausführung des virtuellen Pfads abgeschlossen wurde. Die- <xref:System.Web.HttpServerUtility.Transfer%2A> Methode überträgt die Ausführung bedingungslos an einen anderen Handler.  
  
 ASP.NET überprüft nicht, ob der aktuelle Benutzer autorisiert ist, die von der-Methode gelieferte Ressource anzuzeigen <xref:System.Web.HttpServerUtility.Execute%2A> . Obwohl die ASP.net-Autorisierungs-und Authentifizierungs Logik vor dem Aufrufen des ursprünglichen Ressourcen Handlers ausgeführt wird, ruft ASP.net direkt den von der <xref:System.Web.HttpServerUtility.Execute%2A> -Methode bezeichneten Handler auf und führt keine Authentifizierungs-und Autorisierungs Logik für die neue Ressource erneut aus. Wenn die Sicherheitsrichtlinie Ihrer Anwendung erfordert, dass Clients über die entsprechende Autorisierung für den Zugriff auf die Ressource verfügen, sollte die Anwendung die erneute Autorisierung erzwingen oder einen benutzerdefinierten Mechanismus zur Zugriffs Steuerung bereitstellen.  
  
 Sie können die erneute Autorisierung erzwingen, indem Sie <xref:System.Web.HttpResponse.Redirect%2A> anstelle der-Methode die-Methode verwenden <xref:System.Web.HttpServerUtility.Execute%2A> . <xref:System.Web.HttpResponse.Redirect%2A> führt eine Client seitige Umleitung aus, bei der der Browser die neue Ressource anfordert. Da diese Umleitung eine neue Anforderung ist, die in das System eintritt, wird Sie der gesamten Authentifizierungs-und Autorisierungs Logik sowohl der Internetinformationsdienste (IIS) als auch der ASP.NET-Sicherheitsrichtlinie unterzogen.  
  
 Sie können überprüfen, ob der Benutzer über die Berechtigung zum Anzeigen der Ressource verfügt, indem Sie eine benutzerdefinierte Autorisierungs Methode einbinden, die die Methode verwendet, <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> bevor die Anwendung die- <xref:System.Web.HttpServerUtility.Execute%2A> Methode aufruft  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Login.aspx` Seite auf dem Server im aktuellen Verzeichnis ausgeführt, und die Ausgabe der Seite wird durch das- <xref:System.IO.StringWriter> Objekt empfangen `writer` . Der von empfangene HTML-Datenstrom wird `writer` in den HTTP-Ausgabestream geschrieben.  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.  
  
- oder - 
Fehler beim Ausführen des von <paramref name="path" /> angegebenen Handlers.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="path" /> ist kein virtueller Pfad.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (path, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der auszuführende URL-Pfad.</param>
        <param name="writer">Der zum Aufzeichnen der Ausgabe zu verwendende <see cref="T:System.IO.TextWriter" />.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung aus. Ein <see cref="T:System.IO.TextWriter" /> zeichnet die Ausgabe der Seite auf, und ein boolescher Parameter gibt an, ob die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung gelöscht werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Web.HttpServerUtility.Execute%2A> Methode setzt die Ausführung der ursprünglichen Anforderung fort, nachdem die Ausführung des angegebenen virtuellen Pfads abgeschlossen wurde. Die- <xref:System.Web.HttpServerUtility.Transfer%2A> Methode überträgt die Ausführung bedingungslos an einen anderen Handler.  
  
 ASP.NET überprüft nicht, ob der aktuelle Benutzer autorisiert ist, die von der-Methode gelieferte Ressource anzuzeigen <xref:System.Web.HttpServerUtility.Execute%2A> . Obwohl die ASP.net-Autorisierungs-und Authentifizierungs Logik vor dem Aufrufen des ursprünglichen Ressourcen Handlers ausgeführt wird, ruft ASP.net direkt den von der <xref:System.Web.HttpServerUtility.Execute%2A> -Methode bezeichneten Handler auf und führt keine Authentifizierungs-und Autorisierungs Logik für die neue Ressource erneut aus. Wenn die Sicherheitsrichtlinie Ihrer Anwendung erfordert, dass Clients über die entsprechende Autorisierung für den Zugriff auf die Ressource verfügen, sollte die Anwendung die erneute Autorisierung erzwingen oder einen benutzerdefinierten Mechanismus zur Zugriffs Steuerung bereitstellen.  
  
 Sie können die erneute Autorisierung erzwingen, indem Sie <xref:System.Web.HttpResponse.Redirect%2A> anstelle der-Methode die-Methode verwenden <xref:System.Web.HttpServerUtility.Execute%2A> . <xref:System.Web.HttpResponse.Redirect%2A> führt eine Client seitige Umleitung aus, bei der der Browser die neue Ressource anfordert. Da diese Umleitung eine neue Anforderung ist, die in das System eintritt, wird Sie der gesamten Authentifizierungs-und Autorisierungs Logik sowohl der Internetinformationsdienste (IIS) als auch der ASP.NET-Sicherheitsrichtlinie unterzogen.  
  
 Sie können überprüfen, ob der Benutzer über die Berechtigung zum Anzeigen der Ressource verfügt, indem Sie eine benutzerdefinierte Autorisierungs Methode einbinden, die die Methode verwendet, <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> bevor die Anwendung die- <xref:System.Web.HttpServerUtility.Execute%2A> Methode aufruft  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Login.aspx` Seite auf dem Server im aktuellen Verzeichnis ausgeführt, und die Ausgabe der Seite wird durch das- <xref:System.IO.StringWriter> Objekt empfangen `writer` . Der von empfangene HTML-Datenstrom wird `writer` in den HTTP-Ausgabestream geschrieben. Der Inhalt der <xref:System.Web.HttpRequest.Form%2A> -Auflistung und der-Auflistung <xref:System.Web.HttpRequest.QueryString%2A> wird beibehalten.  
  
 [!code-csharp[HttpServerUtility.Execute02#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der aktuelle <see cref="T:System.Web.HttpContext" /> ist ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic).  
  
- oder - 
 <paramref name="path" /> endet mit einem Punkt (.).  
  
- oder - 
Fehler beim Ausführen des von <paramref name="path" /> angegebenen Handlers.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist kein virtueller Pfad.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (handler As IHttpHandler, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Web::IHttpHandler ^ handler, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : System.Web.IHttpHandler * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (handler, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">Der HTTP-Handler, der den <see cref="T:System.Web.IHttpHandler" /> implementiert, an den die aktuelle Anforderung übertragen werden soll.</param>
        <param name="writer">Der zum Aufzeichnen der Ausgabe zu verwendende <see cref="T:System.IO.TextWriter" />.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung aus. Ein <see cref="T:System.IO.TextWriter" /> zeichnet die Ausgabe des ausgeführten Handlers auf, und ein boolescher Parameter gibt an, ob die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung gelöscht werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können benutzerdefinierte HTTP-Handler schreiben, um bestimmte, vordefinierte Typen von HTTP-Anforderungen in jeder Sprache zu verarbeiten, die mit den Common Language Specification (CLS) kompatibel ist. Ausführbarer Code, der in den HTTP-Handlerklassen anstelle von herkömmlichen ASP-Seiten (auch als klassisches ASP bezeichnet) oder ASP.NET-Seiten definiert ist, antwortet auf diese speziellen Anforderungen. HTTP-Handler ermöglichen die Interaktion mit den Anforderungs-und Antwort Diensten auf niedriger Ebene eines Webservers, auf dem Internetinformationsdienste (IIS) ausgeführt wird, und bieten Funktionen, die ISAPI-Erweiterungen ähnlich sind, jedoch mit einem einfacheren Programmiermodell.  
  
 ASP.NET überprüft nicht, ob der aktuelle Benutzer autorisiert ist, die von der-Methode gelieferte Ressource anzuzeigen <xref:System.Web.HttpServerUtility.Execute%2A> . Obwohl die ASP.net-Autorisierungs-und Authentifizierungs Logik vor dem Aufrufen des ursprünglichen Ressourcen Handlers ausgeführt wird, ruft ASP.net direkt den von der <xref:System.Web.HttpServerUtility.Execute%2A> -Methode bezeichneten Handler auf und führt keine Authentifizierungs-und Autorisierungs Logik für die neue Ressource erneut aus. Wenn die Sicherheitsrichtlinie für Ihre Anwendung erfordert, dass Clients über die entsprechende Autorisierung verfügen, um Zugriff auf die Ressource zu erhalten, sollte die Anwendung die erneute Autorisierung erzwingen oder einen benutzerdefinierten Mechanismus zur Zugriffs Steuerung bereitstellen.  
  
 Sie können die erneute Autorisierung erzwingen, indem Sie <xref:System.Web.HttpResponse.Redirect%2A> anstelle der-Methode die-Methode verwenden <xref:System.Web.HttpServerUtility.Execute%2A> . <xref:System.Web.HttpResponse.Redirect%2A>Führt eine Client seitige Umleitung aus, bei der der Browser die neue Ressource anfordert. Da diese Umleitung eine neue Anforderung ist, die in das System eintritt, wird Sie der gesamten Authentifizierungs-und Autorisierungs Logik der IIS-und ASP.NET-Sicherheitsrichtlinie unterzogen.  
  
 Sie können überprüfen, ob der Benutzer über die Berechtigung zum Anzeigen der Ressource verfügt, indem Sie eine benutzerdefinierte Autorisierungs Methode einbinden, die die Methode verwendet, <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> bevor die Anwendung die- <xref:System.Web.HttpServerUtility.Execute%2A> Methode aufruft  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Fehler beim Ausführen des von <paramref name="handler" /> angegebenen Handlers.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="handler" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastError () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ GetLastError();" />
      <MemberSignature Language="F#" Value="member this.GetLastError : unit -&gt; Exception" Usage="httpServerUtility.GetLastError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die vorhergehende Ausnahme zurück.</summary>
        <returns>Die zuletzt ausgelöste Ausnahme.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine Beschreibung des letzten Fehlers der Anwendung in den HTTP-Ausgabestream ausgegeben. Wenn keine Fehler aufgetreten sind, werden "keine Fehler" ausgegeben.  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.ClearError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodiert eine Zeichenfolge, die codiert wurde, um ungültige HTML-Zeichen zu entfernen.  
  
Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <see cref="T:System.Net.WebUtility" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string -&gt; string" Usage="httpServerUtility.HtmlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die zu decodierende HTML-Zeichenfolge.</param>
        <summary>Decodiert eine HTML-codierte Zeichenfolge und gibt die decodierte Zeichenfolge zurück.</summary>
        <returns>Der decodierte Text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die HTML-Codierung stellt sicher, dass der Text im Browser korrekt angezeigt und nicht vom Browser als HTML interpretiert wird. Wenn eine Text Zeichenfolge z. b. ein kleiner-als-Zeichen ( \<) or greater than sign (> ) enthält, interpretiert der Browser diese Zeichen als öffnende oder schließende Klammer eines HTML-Tags. Wenn die Zeichen HTML-codiert sind, werden Sie in die `&lt;` Zeichen folgen und konvertiert `&gt;` . Dies bewirkt, dass der Browser das kleiner-als-Zeichen und das größer als-Zeichen korrekt anzeigt. <xref:System.Web.HttpServerUtility.HtmlDecode%2A> decodiert Text, der an den Server übertragen wurde.  
  
 Diese Methode ist eine bequeme Möglichkeit, zur <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> Laufzeit von einer ASP.NET-Anwendung aus auf die Methode zuzugreifen. Intern verwendet diese Methode <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> , um Zeichen folgen zu decodieren.  
  
 Greifen Sie in der Code Behind-Datei für eine ASP.NET-Webseite mithilfe der-Eigenschaft auf eine Instanz der- <xref:System.Web.HttpServerUtility> Klasse zu `Server` . Verwenden Sie in einer Klasse, die sich nicht in einer Code Behind-Datei befindet, `HttpContext.Current.Server` für den Zugriff auf eine Instanz der- <xref:System.Web.HttpServerUtility> Klasse.  
  
 Verwenden Sie außerhalb einer Webanwendung die- <xref:System.Net.WebUtility> Klasse, um Werte zu codieren oder zu decodieren.  
  
   
  
## Examples  
 Das folgende Beispiel enthält die `LoadDecodedFile` -Funktion, mit der die Daten aus einer Datei decodiert und in eine Zeichenfolge kopiert werden.  
  
 [!code-aspx-csharp[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-aspx-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Die zu decodierende HTML-Zeichenfolge.</param>
        <param name="output">Der <see cref="T:System.IO.TextWriter" />-Ausgabestream, der die dekodierte Zeichenfolge enthält.</param>
        <summary>Decodiert eine HTML-codierte Zeichenfolge und sendet die Ausgabe an einen <see cref="T:System.IO.TextWriter" />-Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die HTML-Codierung stellt sicher, dass der Text im Browser korrekt angezeigt und nicht vom Browser als HTML interpretiert wird. Wenn eine Text Zeichenfolge z. b. ein kleiner-als-Zeichen ( \<) or greater than sign (> ) enthält, interpretiert der Browser diese Zeichen als öffnende oder schließende Klammer eines HTML-Tags. Wenn die Zeichen HTML-codiert sind, werden Sie in die `&lt;` Zeichen folgen und konvertiert `&gt;` . Dies bewirkt, dass der Browser das kleiner-als-Zeichen und das größer als-Zeichen korrekt anzeigt.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> decodiert Text, der an den Server übertragen wurde.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> ist eine bequeme Möglichkeit, zur <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> Laufzeit von einer ASP.NET-Anwendung aus auf die Methode zuzugreifen. Intern <xref:System.Web.HttpServerUtility.HtmlDecode%2A> verwendet <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> zum Decodieren von Zeichen folgen.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge decodiert, die für die Übertragung über HTTP HTML-codiert wurde. Die angegebene Zeichenfolge `EncodedString` mit dem Text "This is a &lt; Test String" wird decodiert &gt; und in die Zeichenfolge mit dem Namen `DecodedString` "This is a \<Test String> ." kopiert.  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codiert eine Zeichenfolge, die in einem Browser angezeigt werden soll.  
  
Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <see cref="T:System.Net.WebUtility" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string -&gt; string" Usage="httpServerUtility.HtmlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die zu codierende Textzeichenfolge.</param>
        <summary>Codiert eine Zeichenfolge in HTML und gibt diese codiert zurück.</summary>
        <returns>Der HTML-codierte Text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die HTML-Codierung stellt sicher, dass der Text im Browser korrekt angezeigt und nicht vom Browser als HTML interpretiert wird. Wenn eine Text Zeichenfolge z. b. ein kleiner-als-Zeichen ( \<) or greater than sign (> ) enthält, interpretiert der Browser diese Zeichen als öffnende oder schließende Klammer eines HTML-Tags. Wenn die Zeichen HTML-codiert sind, werden Sie in die `&lt;` Zeichen folgen und konvertiert `&gt;` . Dies bewirkt, dass der Browser das kleiner-als-Zeichen und das größer als-Zeichen korrekt anzeigt.  
  
 Diese Methode ist eine bequeme Möglichkeit, zur <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> Laufzeit von einer ASP.NET-Anwendung aus auf die Methode zuzugreifen. Intern verwendet diese Methode <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> , um Zeichen folgen zu codieren.  
  
 Greifen Sie in der Code Behind-Datei für eine ASP.NET-Webseite mithilfe der-Eigenschaft auf eine Instanz der- <xref:System.Web.HttpServerUtility> Klasse zu `Server` . Verwenden Sie in einer Klasse, die sich nicht in einer Code Behind-Datei befindet, `HttpContext.Current.Server` für den Zugriff auf eine Instanz der- <xref:System.Web.HttpServerUtility> Klasse.  
  
 Verwenden Sie außerhalb einer Webanwendung die- <xref:System.Net.WebUtility> Klasse, um Werte zu codieren oder zu decodieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein Wert, der potenziell unsicheren Code codiert, von einem HTML-codiert wird. Der Code befindet sich in der Code-Behind-Datei für eine Webseite. Der zu codierende Wert ist nur in diesem Beispiel hart codiert, um das Beispiel zu vereinfachen und den Typ des Werts anzuzeigen, den Sie in HTML-codieren können. In der Regel würden Sie einen Wert, den Sie vom Benutzer oder von der Anforderung erhalten haben, HTML-codieren. `Result` verweist auf ein- `Literal` Steuerelement.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 Das nächste Beispiel ähnelt dem vorherigen Beispiel, aber es zeigt, wie ein Wert in einer Klasse, die nicht in der Code Behind-Datei ist, in HTML-codiert wird.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Die zu codierende Zeichenfolge.</param>
        <param name="output">Der <see cref="T:System.IO.TextWriter" />-Ausgabestream, der die kodierte Zeichenfolge enthält.</param>
        <summary>Codiert eine Zeichenfolge in HTML und sendet die Ausgabe an einen <see cref="T:System.IO.TextWriter" />-Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die HTML-Codierung stellt sicher, dass der Text im Browser ordnungsgemäß angezeigt wird, und nicht vom Browser als HTML interpretiert wird. Wenn eine Text Zeichenfolge z. b. ein kleiner-als-Zeichen ( \<) or greater than sign (> ) enthält, interpretiert der Browser diese Zeichen als öffnende oder schließende Klammer eines HTML-Tags. Die HTML-Codierung dieser zwei Zeichen ist `&lt;` `&gt;` bzw., was bewirkt, dass der Browser das kleiner-als-Vorzeichen und das größer als-Zeichen korrekt anzeigt.  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> ist eine bequeme Möglichkeit, zur <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> Laufzeit von einer ASP.NET-Anwendung aus auf die Methode zuzugreifen. Intern verwendet, um Zeichen folgen <xref:System.Web.HttpServerUtility.HtmlEncode%2A> <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> zu codieren.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge für die Übertragung durch HTTP codiert. Sie codiert die Zeichenfolge `TestString` mit dem Namen, die den Text "This is a \<Test String> " enthält, und kopiert sie in die Zeichenfolge `EncodedString` "This is a &lt; Test String &gt; ".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Web.HttpServerUtility.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Computernamen des Servers ab.</summary>
        <value>Der Name des lokalen Computers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird der Computername des Servers als Zeichen folgen Variable gespeichert.  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der Computername wurde nicht gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpServerUtility.MapPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der virtuelle Pfad zur Webanwendung.</param>
        <summary>Gibt den physischen Dateipfad zurück, der dem angegebenen virtuellen Pfad entspricht.</summary>
        <returns>Der physische Dateipfad auf dem Webserver, der <paramref name="path" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `path` ist `null` , <xref:System.Web.HttpServerUtility.MapPath%2A> gibt die Methode den vollständigen physischen Pfad des Verzeichnisses zurück, das die aktuelle Anforderung für den Pfad enthält. Der relative Pfad muss keine vorhandene Datei oder einen vorhandenen Ordner angeben, damit diese Methode einen Wert zurückgibt. Es ist jedoch nicht möglich, einen Pfad außerhalb der Webanwendung anzugeben.  
  
> [!IMPORTANT]
>  Die- <xref:System.Web.HttpServerUtility.MapPath%2A> Methode enthält möglicherweise sensible Informationen über die Host Umgebung. Der Rückgabewert sollte Benutzern nicht angezeigt werden.  
  
 Eine Webanwendung, die sich unter befindet, `C:\ExampleSites\TestMapPath` würde die folgenden Ergebnisse zurückgeben:  
  
|Anforderung von|`path`|Rückgabewert|  
|------------------|------------|--------------------|  
|Rootlevelpage. aspx|`null`|C:\examplesites\testmappath|  
|Rootlevelpage. aspx|"/DownOneLevel/DownLevelPage.aspx"|C:\examplesites\testmappath\downonelevel\downlevelpage.aspx|  
|Rootlevelpage. aspx|"/NotRealFolder"|C:\examplesites\testmappath\notrealfolder|  
|Rootlevelpage. aspx|".. /OutsideApplication"|<xref:System.Web.HttpException>|  
|/DownOneLevel/DownLevelPage.aspx|`null`|C:\examplesites\testmappath\downonelevel|  
|/DownOneLevel/DownLevelPage.aspx|".. /RootLevelPage.aspx"|C:\examplesites\testmappath\rootlevelpage.aspx|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die physische Datei eines relativen virtuellen Pfads abgerufen wird. Der Code befindet sich in der Code-Behind-Datei für eine Webseite und verwendet das Standard `Server` Objekt.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 Das nächste Beispiel ähnelt dem vorherigen Beispiel, aber es zeigt, wie ein physischer Pfad aus einer Klasse abgerufen wird, die nicht in der Code Behind-Datei ist.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.
        
- oder - 
<paramref name="path" /> ist ein physischer Pfad, es wurde aber ein virtueller Pfad erwartet.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScriptTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptTimeout : int with get, set" Usage="System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Timeoutwert der Anforderung (in Sekunden) ab oder legt diesen fest.</summary>
        <value>Die Timeoutwert-Einstellung für Anforderungen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> Eigenschaft kann in der Web.config-Datei festgelegt werden, indem das- `executionTimeout` Attribut des [HttpRuntime](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/e1f13641(v=vs.100)) -Elements festgelegt wird. Wenn das Timeout Programm gesteuert mit der-Eigenschaft festgelegt wird, hat dies <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> Vorrang vor der Web.config Einstellung.  
  
> [!NOTE]
>  Wenn Sie das- `debug` Attribut des [HttpRuntime](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/e1f13641(v=vs.100)) -Elements `true` in der Web.config-Datei auf festlegen, wird der Wert von <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> ignoriert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Timeout Zeitraum für die Anforderung auf 60 Sekunden festgelegt.  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Timeoutspanne ist <see langword="null" /> oder konnte nicht festgelegt werden.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transfer">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet die Ausführung der aktuellen Seite und startet die Ausführung einer neuen Seite für die aktuelle Anforderung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string -&gt; unit" Usage="httpServerUtility.Transfer path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <summary>Beendet für die aktuelle Anforderung die Ausführung der aktuellen Seite und startet die Ausführung einer neuen Seite unter Verwendung des angegebenen URL-Pfads für die Seite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die an übertragene Seite muss eine andere ASPX-Seite sein. Beispielsweise ist eine Übertragung an eine ASP-oder ASMX-Seite ungültig. Die <xref:System.Web.HttpServerUtility.Transfer%2A> -Methode bewahrt die <xref:System.Web.HttpRequest.QueryString%2A> -Auflistung und die-Auflistung <xref:System.Web.HttpRequest.Form%2A> .  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> Ruft <xref:System.Web.HttpResponse.End%2A> auf, wodurch beim Abschluss eine-Ausnahme ausgelöst wird <xref:System.Threading.ThreadAbortException> .  
  
 ASP.NET überprüft nicht, ob der aktuelle Benutzer autorisiert ist, die von der-Methode gelieferte Ressource anzuzeigen <xref:System.Web.HttpServerUtility.Transfer%2A> . Obwohl die ASP.net-Autorisierungs-und Authentifizierungs Logik vor dem Aufrufen des ursprünglichen Ressourcen Handlers ausgeführt wird, ruft ASP.net direkt den von der <xref:System.Web.HttpServerUtility.Transfer%2A> -Methode bezeichneten Handler auf und führt keine Authentifizierungs-und Autorisierungs Logik für die neue Ressource erneut aus. Wenn die Sicherheitsrichtlinie Ihrer Anwendung erfordert, dass Clients über die entsprechende Autorisierung für den Zugriff auf die Ressource verfügen, sollte die Anwendung die erneute Autorisierung erzwingen oder einen benutzerdefinierten Mechanismus zur Zugriffs Steuerung bereitstellen.  
  
 Sie können die erneute Autorisierung erzwingen, indem Sie <xref:System.Web.HttpResponse.Redirect%2A> anstelle der-Methode die-Methode verwenden <xref:System.Web.HttpServerUtility.Transfer%2A> . Die <xref:System.Web.HttpResponse.Redirect%2A> -Methode führt eine Client seitige Umleitung aus, bei der der Browser die neue Ressource anfordert. Da diese Umleitung eine neue Anforderung ist, die in das System eintritt, wird Sie der gesamten Authentifizierungs-und Autorisierungs Logik sowohl der Internetinformationsdienste (IIS) als auch der ASP.NET-Sicherheitsrichtlinie unterzogen.  
  
 Sie können überprüfen, ob der Benutzer über die Berechtigung zum Anzeigen der Ressource verfügt, indem Sie eine benutzerdefinierte Autorisierungs Methode einbinden, die die Methode verwendet, <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> bevor die Anwendung die- <xref:System.Web.HttpServerUtility.Transfer%2A> Methode aufruft  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string * bool -&gt; unit" Usage="httpServerUtility.Transfer (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Beendet die Ausführung der aktuellen Seite und startet die Ausführung einer neuen Seite unter Verwendung des angegebenen URL-Pfads für die Seite. Gibt an, ob die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung gelöscht werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die an übertragene Seite muss eine andere ASPX-Seite sein. Beispielsweise ist eine Übertragung an eine ASP-oder ASMX-Seite ungültig.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> Ruft <xref:System.Web.HttpResponse.End%2A> auf, wodurch beim Abschluss eine-Ausnahme ausgelöst wird <xref:System.Threading.ThreadAbortException> .  
  
 Wenn Sie den- `preserveForm` Parameter auf festlegen `true` , kann auf der Zielseite mithilfe der-Eigenschaft auf den Ansichts Zustand der vorherigen Seite zugegriffen werden <xref:System.Web.UI.Page.PreviousPage%2A> .  
  
 Aus Sicherheitsgründen sollten Sie das- `enableViewStateMac` Attribut auf festgelegt halten `true` . ASP.NET überprüft nicht, ob der aktuelle Benutzer autorisiert ist, die von der-Methode gelieferte Ressource anzuzeigen <xref:System.Web.HttpServerUtility.Transfer%2A> . Obwohl die ASP.net-Autorisierungs-und Authentifizierungs Logik vor dem Aufrufen des ursprünglichen Ressourcen Handlers ausgeführt wird, ruft ASP.net direkt den von der <xref:System.Web.HttpServerUtility.Transfer%2A> -Methode bezeichneten Handler auf und führt keine Authentifizierungs-und Autorisierungs Logik für die neue Ressource erneut aus. Wenn die Sicherheitsrichtlinie Ihrer Anwendung erfordert, dass Clients über die entsprechende Autorisierung für den Zugriff auf die Ressource verfügen, sollte die Anwendung die erneute Autorisierung erzwingen oder einen benutzerdefinierten Mechanismus zur Zugriffs Steuerung bereitstellen.  
  
 Sie können die erneute Autorisierung erzwingen, indem Sie <xref:System.Web.HttpResponse.Redirect%2A> anstelle der-Methode die-Methode verwenden <xref:System.Web.HttpServerUtility.Transfer%2A> . Die <xref:System.Web.HttpResponse.Redirect%2A> -Methode führt eine Client seitige Umleitung aus, bei der der Browser die neue Ressource anfordert. Da diese Umleitung eine neue Anforderung ist, die in das System eintritt, wird Sie der gesamten Authentifizierungs-und Autorisierungs Logik sowohl der Internetinformationsdienste (IIS) als auch der ASP.NET-Sicherheitsrichtlinie unterzogen.  
  
 Sie können überprüfen, ob der Benutzer über die Berechtigung zum Anzeigen der Ressource verfügt, indem Sie eine benutzerdefinierte Autorisierungs Methode einbinden, die die Methode verwendet, <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> bevor die Anwendung die- <xref:System.Web.HttpServerUtility.Transfer%2A> Methode aufruft  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine neue Seite im gleichen Verzeichnis wie die aktuelle Seite ausgeführt.  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Die aktuelle Seitenanforderung ist ein Rückruf.</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (handler As IHttpHandler, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::Web::IHttpHandler ^ handler, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : System.Web.IHttpHandler * bool -&gt; unit" Usage="httpServerUtility.Transfer (handler, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">Der HTTP-Handler, der den <see cref="T:System.Web.IHttpHandler" /> implementiert, an den die aktuelle Anforderung übertragen werden soll.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Beendet die Ausführung der aktuellen Seite und beginnt die Ausführung einer neuen Anforderung mithilfe eines benutzerdefinierten HTTP-Handlers, der die <see cref="T:System.Web.IHttpHandler" />-Schnittstelle implementiert und angibt, ob die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung gelöscht werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können benutzerdefinierte HTTP-Handler schreiben, um bestimmte, vordefinierte Typen von HTTP-Anforderungen in jeder Sprache zu verarbeiten, die mit den Common Language Specification (CLS) kompatibel ist. Ausführbarer Code, der in den HTTP-Handlerklassen anstelle von herkömmlichen ASP-Seiten (auch als klassisches ASP bezeichnet) oder ASP.NET-Seiten definiert ist, antwortet auf diese speziellen Anforderungen. HTTP-Handler ermöglichen die Interaktion mit den Anforderungs-und Antwort Diensten auf niedriger Ebene eines Webservers, auf dem Internetinformationsdienste (IIS) ausgeführt wird, und bieten Funktionen, die ISAPI-Erweiterungen ähnlich sind, jedoch mit einem einfacheren Programmiermodell.  
  
 Wenn Sie den- `preserveForm` Parameter auf festlegen `true` , kann auf der Zielseite mithilfe der-Eigenschaft auf den Ansichts Zustand der vorherigen Seite zugegriffen werden <xref:System.Web.UI.Page.PreviousPage%2A> .  
  
 Aus Sicherheitsgründen sollten Sie das- `enableViewStateMac` Attribut auf festgelegt halten `true` . ASP.NET überprüft nicht, ob der aktuelle Benutzer autorisiert ist, die von der-Methode gelieferte Ressource anzuzeigen <xref:System.Web.HttpServerUtility.Transfer%2A> . Obwohl die ASP.net-Autorisierungs-und Authentifizierungs Logik vor dem Aufrufen des ursprünglichen Ressourcen Handlers ausgeführt wird, ruft ASP.net direkt den von der-Methode bezeichneten Handler <xref:System.Web.HttpServerUtility.Transfer%2A> auf und führt keine Authentifizierungs-und Autorisierungs Logik für die neue Ressource erneut aus. Wenn die Sicherheitsrichtlinie für Ihre Anwendung erfordert, dass Clients über die entsprechende Autorisierung für den Zugriff auf die Ressource verfügen, sollte die Anwendung die erneute Autorisierung erzwingen oder einen benutzerdefinierten Mechanismus zur Zugriffs Steuerung bereitstellen.  
  
 Sie können die erneute Autorisierung erzwingen, indem Sie <xref:System.Web.HttpResponse.Redirect%2A> anstelle der-Methode die-Methode verwenden <xref:System.Web.HttpServerUtility.Transfer%2A> . Die <xref:System.Web.HttpResponse.Redirect%2A> -Methode führt eine Client seitige Umleitung aus, bei der der Browser die neue Ressource anfordert. Da diese Umleitung eine neue Anforderung ist, die in das System eintritt, wird Sie der gesamten Authentifizierungs-und Autorisierungs Logik der IIS-und ASP.NET-Sicherheitsrichtlinie unterzogen.  
  
 Sie können überprüfen, ob der Benutzer über die Berechtigung zum Anzeigen der Ressource verfügt, indem Sie eine benutzerdefinierte Autorisierungs Methode einbinden, die die Methode verwendet, <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> bevor die Anwendung die- <xref:System.Web.HttpServerUtility.Transfer%2A> Methode aufruft  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Die aktuelle Seitenanforderung ist ein Rückruf.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt die angegebene URL asynchron aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> wurde in der .NET Framework Version 3,5 eingeführt. Zusammenfassende Informationen zum .NET Framework finden Sie unter [Versionen und Abhängigkeiten](/dotnet/framework/migration-guide/versions-and-dependencies).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string -&gt; unit" Usage="httpServerUtility.TransferRequest path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <summary>Führt die angegebene URL asynchron aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methoden Überladung ruft die <xref:System.Web.HttpServerUtility.TransferRequest%2A> -Überladung auf, bei der der-Parameter auf festgelegt `preserveForm` ist, der-Parameter auf festgelegt `false` `method` `null` ist, `headers` und der `null` - `preserveUser` `true` Parameter auf festgelegt ist. Weitere Informationen finden Sie im Abschnitt "Hinweise" in der Überladung <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Anforderung erfordert den integrierten Pipelinemodus von [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Der Server ist nicht verfügbar, um die Anforderung zu verarbeiten.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Führt die angegebene URL asynchron aus und behält die Parameter der Abfragezeichenfolge bei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ruft die- <xref:System.Web.HttpServerUtility.TransferRequest%2A> Überladung auf, bei der der- `preserveForm` Parameter auf den übergebenen Wert, den-Parameter auf festgelegt ist, der-Parameter auf festgelegt ist `method` `null` `headers` `null` und der- `preserveUser` Parameter auf `true` Weitere Informationen finden Sie im Abschnitt "Hinweise" unter <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> .  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> wird in der .NET Framework Version 3,5 eingeführt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](/dotnet/framework/migration-guide/versions-and-dependencies).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Anforderung erfordert den integrierten Pipelinemodus von [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Der Server ist nicht verfügbar, um die Anforderung zu verarbeiten.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <param name="method">Die HTTP-Methode, die für die Ausführung der neuen Anforderung verwendet werden soll.</param>
        <param name="headers">Eine <see cref="T:System.Collections.Specialized.NameValueCollection" /> von Anforderungsheadern für die neue Anforderung.</param>
        <summary>Führt die angegebene URL mit der angegebenen HTTP-Methode und den angegebenen HTTP-Headern asynchron aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, wenn mit dem integrierten Pipeline Modus in ausgeführt wird [!INCLUDE[iisver](~/includes/iisver-md.md)] , um die Übertragung der Anforderungs Verarbeitung von einem Ressourcentyp zum anderen beim Ausführen der Ziel Anforderung mit dem richtigen Anforderungs Kontext zuzulassen. Beispielsweise können Sie die- <xref:System.Web.HttpServerUtility.TransferRequest%2A> Methode verwenden, um eine Anforderung für eine ASPX-Seite an eine Anforderung für eine XML-Seite zu übertragen.  
  
 Die- <xref:System.Web.HttpServerUtility.TransferRequest%2A> Methode führt eine asynchrone untergeordnete Ausführung der angegebenen URL mit den folgenden Bedingungen aus:  
  
-   Wenn der- `path` Parameter eine Abfrage Zeichenfolge angibt, wird er als neue Abfrage Zeichenfolge verwendet. Wenn keine Abfrage Zeichenfolge enthalten ist, wird die Abfrage Zeichenfolge der Anforderung erneut verwendet.  
  
-   Wenn der- `method` Parameter angegeben wird, wird er verwendet. Wenn dies der Fall ist `null` , wird die HTTP-Methode der ursprünglichen Anforderung verwendet.  
  
-   Wenn der- `preserveForm` Parameter ist `true` , ist der aktuelle Entitäts Text der Anforderung für die Ziel Anforderung verfügbar. Dies ermöglicht das Übertragen von Formular Beiträgen und Uploads.  
  
-   Wenn die Benutzeridentität aktuell für die ursprüngliche Anforderung festgelegt ist, wird die Identität an die neue Anforderung übertragen. Dadurch können authentifizierte Anforderungen das Ergebnis der Authentifizierung für die neue Anforderung erneut verwenden. Wenn Sie nicht möchten, dass der Benutzer übertragen werden soll, legen Sie den Benutzer `null` vor der Übertragung auf die ursprüngliche Anforderung fest.  
  
-   Wenn der- `headers` Parameter angegeben wird, wird die neue Anforderung mit den angegebenen Headern ausgeführt. Dies kann verwendet werden, um die Anforderungs Header und Cookies für die neue Anforderung zu ändern oder um einen speziellen Header hinzuzufügen, der angibt, wo die ursprüngliche Anforderung empfangen wurde.  
  
     Diese Methode ruft die <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29> Methoden Überladung auf, wobei der- `preserveUser` Parameter auf festgelegt ist `true` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Anforderung erfordert, dass [!INCLUDE[iisver](~/includes/iisver-md.md)] im integrierten Modus ausgeführt wird.</exception>
        <exception cref="T:System.Web.HttpException">Der Server ist nicht verfügbar, um die Anforderung zu verarbeiten.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection, preserveUser As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers, bool preserveUser);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers, preserveUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveUser" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <param name="method">Die HTTP-Methode für die neue Anforderung.</param>
        <param name="headers">Ein <see cref="T:System.Collections.Specialized.NameValueCollection" />-Objekt, das Anforderungsheader für die neue Anforderung enthält.</param>
        <param name="preserveUser"><see langword="true" />, um die Benutzeridentität zu erhalten; andernfalls <see langword="false" />. Die anderen Überladungen dieser Methode rufen diese Überladung mit diesem auf <see langword="true" /> gesetzten Parameter auf.</param>
        <summary>Nimmt eine asynchrone Ausführung der angegebenen URL mit der angegebenen HTTP-Methode, den angegebenen HTTP-Headern und dem angegebenen HTTP-Pfad vor und behält die Formularwerte und Benutzeridentität optional bei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" unter <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Anforderung erfordert den integrierten Pipelinemodus von [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Der Server ist nicht verfügbar, um die Anforderung zu verarbeiten.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist ungültig.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodiert eine Zeichenfolge, die für eine HTTP-Übertragung codiert und in einer URL an den Server gesendet wurde.  
  
Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <see cref="T:System.Net.WebUtility" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string -&gt; string" Usage="httpServerUtility.UrlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die zu decodierende Textzeichenfolge.</param>
        <summary>Decodiert eine URL-Zeichenfolge und gibt die decodierte Zeichenfolge zurück.</summary>
        <returns>Der decodierte Text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die URL-Codierung stellt sicher, dass alle Browser Text in URL-Zeichen folgen korrekt übertragen. Zeichen, z. b. ein Fragezeichen (?), kaufmännisches und-Zeichen (&), Schrägstrich (/) und Leerzeichen können von einigen Browsern abgeschnitten oder beschädigt werden. Folglich müssen diese Zeichen in `<a>` Tags oder in Abfrage Zeichenfolgen codiert werden, in denen die Zeichen folgen von einem Browser in einer Anforderungs Zeichenfolge erneut gesendet werden können.  
  
 Diese Methode ist eine bequeme Möglichkeit, zur <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> Laufzeit von einer ASP.NET-Anwendung aus auf die Methode zuzugreifen. Intern verwendet diese Methode <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> , um Zeichen folgen zu decodieren.  
  
 Greifen Sie in der Code Behind-Datei für eine ASP.NET-Webseite mithilfe der-Eigenschaft auf eine Instanz der- <xref:System.Web.HttpServerUtility> Klasse zu `Server` . Verwenden Sie in einer Klasse, die sich nicht in einer Code Behind-Datei befindet, `HttpContext.Current.Server` für den Zugriff auf eine Instanz der- <xref:System.Web.HttpServerUtility> Klasse.  
  
 Verwenden Sie außerhalb einer Webanwendung die- <xref:System.Net.WebUtility> Klasse, um Werte zu codieren oder zu decodieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein Wert, der aus der Abfrage Zeichenfolge abgerufen wird, per URL decodiert wird. Der Code befindet sich in der Code-Behind-Datei für eine Webseite. `ReturnPage` verweist auf ein- `HyperLink` Steuerelement.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 Das nächste Beispiel ähnelt dem vorherigen Beispiel, aber es zeigt, wie ein Wert aus einer Klasse, die nicht in der Code Behind-Datei ist, per URL decodiert wird.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Die zu decodierende HTML-Zeichenfolge.</param>
        <param name="output">Der <see cref="T:System.IO.TextWriter" />-Ausgabestream, der die dekodierte Zeichenfolge enthält.</param>
        <summary>Decodiert eine HTML-Zeichenfolge, die in einer URL empfangen wurde, und sendet die Ausgabe an einen <see cref="T:System.IO.TextWriter" />-Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die URL-Codierung stellt sicher, dass alle Browser Text in URL-Zeichen folgen korrekt übertragen. Zeichen, z. b. ein Fragezeichen (?), kaufmännisches und-Zeichen (&), Schrägstrich (/) und Leerzeichen können von einigen Browsern abgeschnitten oder beschädigt werden. Folglich müssen diese Zeichen in `<a>` Tags oder in Abfrage Zeichenfolgen codiert werden, in denen die Zeichen folgen von einem Browser in einer Anforderungs Zeichenfolge erneut gesendet werden können.  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A> ist eine bequeme Möglichkeit, zur <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> Laufzeit von einer ASP.NET-Anwendung aus auf die Methode zuzugreifen. Intern <xref:System.Web.HttpServerUtility.UrlDecode%2A> verwendet <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> zum Decodieren von Zeichen folgen.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Zeichenfolge mit dem Namen `EncodedString` (empfangen in einer URL) in die Zeichenfolge decodiert `DecodedString` .  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codiert eine Zeichenfolge für eine zuverlässige HTTP-Übertragung vom Webserver an einen Client über die URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> ist eine bequeme Möglichkeit, zur <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> Laufzeit von einer ASP.NET-Anwendung aus auf die Methode zuzugreifen. Intern verwendet, um Zeichen folgen <xref:System.Web.HttpServerUtility.UrlEncode%2A> <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> zu codieren.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string -&gt; string" Usage="httpServerUtility.UrlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Der als URL zu codierende Text.</param>
        <summary>Codiert eine Zeichenfolge als URL und gibt die codierte Zeichenfolge zurück.</summary>
        <returns>Der URL-codierte Text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die URL-Codierung stellt sicher, dass alle Browser Text in URL-Zeichen folgen korrekt übertragen. Zeichen, z. b. ein Fragezeichen (?), kaufmännisches und-Zeichen (&), Schrägstrich (/) und Leerzeichen können von einigen Browsern abgeschnitten oder beschädigt werden. Folglich müssen diese Zeichen in `<a>` Tags oder in Abfrage Zeichenfolgen codiert werden, in denen die Zeichen folgen von einem Browser in einer Anforderungs Zeichenfolge erneut gesendet werden können.  
  
 Diese Methode ist eine bequeme Möglichkeit, zur <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> Laufzeit von einer ASP.NET-Anwendung aus auf die Methode zuzugreifen. Intern verwendet diese Methode <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> , um Zeichen folgen zu codieren.  
  
 Greifen Sie in der Code Behind-Datei für eine ASP.NET-Webseite mithilfe der-Eigenschaft auf eine Instanz der- <xref:System.Web.HttpServerUtility> Klasse zu `Server` . Verwenden Sie in einer Klasse, die sich nicht in einer Code Behind-Datei befindet, `HttpContext.Current.Server` für den Zugriff auf eine Instanz der- <xref:System.Web.HttpServerUtility> Klasse.  
  
 Verwenden Sie außerhalb einer Webanwendung die- <xref:System.Net.WebUtility> Klasse, um Werte zu codieren oder zu decodieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein Wert, der als Abfrage Zeichenfolgen-Wert eines Hyperlinks verwendet wird, als URL codiert wird. Der Code befindet sich in der Code-Behind-Datei für eine Webseite. Der zu codierende Wert ist nur in diesem Beispiel hart codiert, um das Beispiel zu vereinfachen und den Typ des Werts anzuzeigen, den Sie als URL codieren können. In der Regel würden Sie einen Wert, den Sie vom Benutzer oder von der Anforderung erhalten haben, per URL codieren. `NextPage` verweist auf ein- `HyperLink` Steuerelement.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 Das nächste Beispiel ähnelt dem vorherigen Beispiel, aber es zeigt, wie ein Wert in einer Klasse, die nicht in der Code Behind-Datei ist, per URL codiert wird.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Die zu codierende Textzeichenfolge.</param>
        <param name="output">Der <see cref="T:System.IO.TextWriter" />-Ausgabestream, der die kodierte Zeichenfolge enthält.</param>
        <summary>Codiert eine Zeichenfolge als URL und sendet die Ausgabe an einen <see cref="T:System.IO.TextWriter" />-Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die URL-Codierung stellt sicher, dass alle Browser Text in URL-Zeichen folgen korrekt übertragen. Zeichen, z. b. ein Fragezeichen (?), kaufmännisches und-Zeichen (&), Schrägstrich (/) und Leerzeichen können von einigen Browsern abgeschnitten oder beschädigt werden. Folglich müssen diese Zeichen in `<a>` Tags oder in Abfrage Zeichenfolgen codiert werden, in denen die Zeichen folgen von einem Browser in einer Anforderungs Zeichenfolge erneut gesendet werden können.  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> ist eine bequeme Möglichkeit, zur <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> Laufzeit von einer ASP.NET-Anwendung aus auf die Methode zuzugreifen. Intern verwendet, um Zeichen folgen <xref:System.Web.HttpServerUtility.UrlEncode%2A> <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> zu codieren.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge für die Übertragung durch HTTP codiert. Sie codiert die Zeichenfolge `TestString` mit dem Namen, die den Text "This is a \<Test String> " enthält, und kopiert ihn in die Zeichenfolge mit dem Namen `EncodedString` "This + is + a +% 3cTest + String% 3e.".  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlPathEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlPathEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlPathEncode : string -&gt; string" Usage="httpServerUtility.UrlPathEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Der als URL zu codierende Text.</param>
        <summary>Nicht verwenden. Nur für die Browserkompatibilität vorgesehen. Verwenden Sie <see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />.</summary>
        <returns>Der URL-codierte Text.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenDecode (input As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ UrlTokenDecode(System::String ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenDecode : string -&gt; byte[]" Usage="System.Web.HttpServerUtility.UrlTokenDecode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="input">Das zu decodierende URL-Zeichenfolgentoken.</param>
        <summary>Decodiert ein URL-Zeichenfolgentoken in sein entsprechendes Bytearray mit Base-64-Ziffern.</summary>
        <returns>Das Bytearray, das das decodierte URL-Zeichenfolgentoken enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> Methode konvertiert ein URL-Zeichen folgen Token, das Binärdaten als Basis-64-Ziffern codiert, in die entsprechende Bytearray-Darstellung. Verwenden <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> Sie die-Methode zum Decodieren von Token, die über die URL übertragen und mit codiert werden <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> .  
  
 Die- <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> Methode gibt ein leeres Bytearray zurück, wenn der- `input` Parameter eine Länge von weniger als 1 hat.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert des <paramref name="input" />-Parameters ist <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenEncode (input As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UrlTokenEncode(cli::array &lt;System::Byte&gt; ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenEncode : byte[] -&gt; string" Usage="System.Web.HttpServerUtility.UrlTokenEncode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="input">Das zu codierende Bytearray.</param>
        <summary>Codiert ein Bytearray in seine äquivalente Zeichenfolgendarstellung mit Base-64-Ziffern, die für die Übertragung in der URL geeignet ist.</summary>
        <returns>Die Zeichenfolge, die das codierte Token enthält, wenn die *Länge* des Bytearrays größer als eins ist, andernfalls eine leere Zeichenfolge („“).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> Methode konvertiert ein Bytearray in eine entsprechende Zeichen folgen Darstellung, die mit Basis-64-Ziffern codiert Das resultierende Zeichen folgen Token kann über die URL übertragen werden.  
  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>Gibt eine leere Zeichenfolge zurück, wenn der- `input` Parameter eine Länge von weniger als 1 hat.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert des <paramref name="input" />-Parameters ist <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.ToBase64String(System.Byte[])" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>
