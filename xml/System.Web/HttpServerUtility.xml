<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0b6477787c17199600536f8a4df06d52440d68c5" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66008071" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpServerUtility" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpServerUtility sealed" />
  <TypeSignature Language="F#" Value="type HttpServerUtility = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Hilfsmethoden für die Verarbeitung von Webanforderungen zur Verfügung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden und Eigenschaften der <xref:System.Web.HttpServerUtility> Klasse verfügbar gemacht werden, über das systeminterne <xref:System.Web.HttpContext.Server%2A> von ASP.NET bereitgestellte Objekt.  
  
   
  
## Examples  
 Ein Visual Studio Web-Websiteprojekt mit Quellcode ist zur Ergänzung dieses Themas verfügbar: [Herunterladen](https://go.microsoft.com/fwlink/?LinkId=192870).  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Web.HttpServerUtility.HtmlEncode%2A> Methode und die <xref:System.Web.HttpServerUtility.UrlEncode%2A> Methode der <xref:System.Web.HttpServerUtility> Klasse. Die <xref:System.Web.HttpServerUtility.HtmlEncode%2A> Methode trägt dazu bei, dass alle vom Benutzer bereitgestellte Zeichenfolge eingeben, wird als statischer Text in Browsern ausführbare Skript- oder HTML-Elementen gerendert werden. Die <xref:System.Web.HttpServerUtility.UrlEncode%2A> -Methode codiert die URLs, damit sie ordnungsgemäß im HTTP-Datenstrom übertragen werden.  
  
 [!code-aspx-csharp[System.Web.HttpServerUtility1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpServerUtility1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.HttpContext" />
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpServerUtility.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die vorhergehende Ausnahme.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel löscht die letzte Ausnahme, die ausgelöst wurde.  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.GetLastError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Serverinstanz eines COM-Objekts.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : string -&gt; obj" Usage="httpServerUtility.CreateObject progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Die Klasse oder der Typ des Objekts, von dem eine Instanz erstellt werden soll.</param>
        <summary>Erstellt eine Serverinstanz eines COM-Objekts, das durch den Programmbezeichner (ProgID) des Objekts gekennzeichnet ist.</summary>
        <returns>Das neue Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt ein Objekt mit der ProgID des Objekts.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Es konnte keine Instanz des Objekts erstellt werden.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : Type -&gt; obj" Usage="httpServerUtility.CreateObject type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Ein <see cref="T:System.Type" />, der das zu erstellende Objekt darstellt.</param>
        <summary>Erstellt eine Serverinstanz eines COM-Objekts, das durch den Objekttyp identifiziert wird.</summary>
        <returns>Das neue Objekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectFromClsid (clsid As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObjectFromClsid(System::String ^ clsid);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectFromClsid : string -&gt; obj" Usage="httpServerUtility.CreateObjectFromClsid clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Der Klassenbezeichner des Objekts, von dem eine Instanz erstellt werden soll.</param>
        <summary>Erstellt eine Serverinstanz eines COM-Objekts, das durch die Klassen-ID (Class Identifier, CLSID) des Objekts gekennzeichnet ist.</summary>
        <returns>Das neue Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A> Methode, um eine Serverinstanz eines COM-Objekts zu erstellen.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Es konnte keine Instanz des Objekts erstellt werden.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Execute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt den Handler für eine angegebene Ressource im Kontext der aktuellen Anforderung aus und gibt die Ausführung an die aufrufende Seite zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Execute : string -&gt; unit" Usage="httpServerUtility.Execute path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der auszuführende URL-Pfad.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpServerUtility.Execute%2A> Methode wird die Ausführung der ursprünglichen Seite fortgesetzt, nachdem die Ausführung der neuen Seite abgeschlossen wurde. Die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode bedingungslos überträgt die Ausführung an einen anderen Handler.  
  
 ASP.NET überprüft nicht, dass der aktuelle Benutzer autorisiert ist, die von Ressource Anzeigen der <xref:System.Web.HttpServerUtility.Execute%2A> Methode. Obwohl die Autorisierungs- und Authentifizierungsfunktionen Logik von ASP.NET ausgeführt wird, bevor die ursprüngliche Ressource-Handler aufgerufen wird, ruft ASP.NET direkt den Handler für erkennbar der <xref:System.Web.HttpServerUtility.Execute%2A> Methode und die Authentifizierung und Autorisierung Logik für das neue wird nicht erneut ausgeführt die Ressource. Wenn Ihrer Anwendung Sicherheitsrichtlinie für Clients, damit die entsprechenden Autorisierung zum Zugriff auf die Ressource erforderlich ist, sollte die Anwendung eine erneute Authentifizierung zu erzwingen oder bieten einen Mechanismus für die benutzerdefinierte Zugriffssteuerung.  
  
 Sie können eine erneute Authentifizierung erzwingen, indem Sie mit der <xref:System.Web.HttpResponse.Redirect%2A> -Methode anstelle der <xref:System.Web.HttpServerUtility.Execute%2A> Methode. <xref:System.Web.HttpResponse.Redirect%2A> führt eine clientseitige Umleitung in der der Browser die neue Ressource anfordert. Da diese Umleitung auf eine neue Anforderung, die das System ist, wird er alle der Authentifizierung und Autorisierung Logik, die der Sicherheitsrichtlinie von sowohl Internet Information Services (IIS) und ASP.NET unterzogen.  
  
 Sie können überprüfen, ob der Benutzer verfügt über die Berechtigung zum Anzeigen der Ressource durch die Aufnahme einer benutzerdefinierten Autorisierungs-Methode, die verwendet die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> -Methode auf, bevor die Anwendung ruft die <xref:System.Web.HttpServerUtility.Execute%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die ASPX‑Seite "Updateinfo.aspx" im aktuellen Verzeichnis. Nachdem die Updateinfo.aspx-Seite angezeigt wird, werden Ausführung des Programms zur Startseite zurück.  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Das aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.  
  
- oder - 
Fehler beim Ausführen des von <paramref name="path" /> angegebenen Handlers.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="path" /> ist kein virtueller Pfad.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * bool -&gt; unit" Usage="httpServerUtility.Execute (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der auszuführende URL-Pfad.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten, <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung aus und gibt an, ob die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung gelöscht werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die ASPX-Seite ausführen `Updateinfo.aspx` in der aktuellen Anforderung und das Beibehalten der <xref:System.Web.HttpRequest.QueryString%2A> und <xref:System.Web.HttpRequest.Form%2A> Sammlungen. Ausführung des Programms zurückgegeben wird, um die Startseite nach `Updateinfo.aspx` wird angezeigt.  
  
 [!code-csharp[HttpServerUtility.Execute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Das aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.  
  
- oder - 
Fehler beim Ausführen des von <paramref name="path" /> angegebenen Handlers.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="path" /> ist kein virtueller Pfad.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.Execute (path, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">Der auszuführende URL-Pfad.</param>
        <param name="writer">Der zum Aufzeichnen der Ausgabe zu verwendende <see cref="T:System.IO.TextWriter" />.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung aus. Ein <see cref="T:System.IO.TextWriter" /> zeichnet die Ausgabe des ausgeführten Handlers auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpServerUtility.Execute%2A> Methode weiterhin die ursprüngliche Anforderung, nach dem Abschluss der Ausführung des angegebenen virtuellen Pfads. Die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode bedingungslos überträgt die Ausführung an einen anderen Handler.  
  
 ASP.NET überprüft nicht, dass der aktuelle Benutzer autorisiert ist, die von Ressource Anzeigen der <xref:System.Web.HttpServerUtility.Execute%2A> Methode. Obwohl die Autorisierungs- und Authentifizierungsfunktionen Logik von ASP.NET ausgeführt wird, bevor die ursprüngliche Ressource-Handler aufgerufen wird, ruft ASP.NET direkt den Handler für erkennbar der <xref:System.Web.HttpServerUtility.Execute%2A> Methode und die Authentifizierung und Autorisierung Logik für das neue wird nicht erneut ausgeführt die Ressource. Wenn Ihrer Anwendung Sicherheitsrichtlinie für Clients, damit die entsprechenden Autorisierung zum Zugriff auf die Ressource erforderlich ist, sollte die Anwendung eine erneute Authentifizierung zu erzwingen oder bieten einen Mechanismus für die benutzerdefinierte Zugriffssteuerung.  
  
 Sie können eine erneute Authentifizierung erzwingen, indem Sie mit der <xref:System.Web.HttpResponse.Redirect%2A> -Methode anstelle der <xref:System.Web.HttpServerUtility.Execute%2A> Methode. <xref:System.Web.HttpResponse.Redirect%2A> führt eine clientseitige Umleitung in der der Browser die neue Ressource anfordert. Da diese Umleitung auf eine neue Anforderung, die das System ist, wird er alle der Authentifizierung und Autorisierung Logik, die der Sicherheitsrichtlinie von sowohl Internet Information Services (IIS) und ASP.NET unterzogen.  
  
 Sie können überprüfen, ob der Benutzer verfügt über die Berechtigung zum Anzeigen der Ressource durch die Aufnahme einer benutzerdefinierten Autorisierungs-Methode, die verwendet die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> -Methode auf, bevor die Anwendung ruft die <xref:System.Web.HttpServerUtility.Execute%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel führt die `Login.aspx` Seite, auf dem Server im aktuellen Verzeichnis und empfängt die Ausgabe der Seite über die <xref:System.IO.StringWriter> Objekt `writer`. Empfangen von HTML-Stream schreibt `writer` an den HTTP-Ausgabestream.  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Das aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.  
  
- oder - 
Fehler beim Ausführen des von <paramref name="path" /> angegebenen Handlers.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="path" /> ist kein virtueller Pfad.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (path, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der auszuführende URL-Pfad.</param>
        <param name="writer">Der zum Aufzeichnen der Ausgabe zu verwendende <see cref="T:System.IO.TextWriter" />.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten, <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung aus. Ein <see cref="T:System.IO.TextWriter" /> zeichnet die Ausgabe der Seite auf, und ein boolescher Parameter gibt an, ob die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung gelöscht werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpServerUtility.Execute%2A> Methode weiterhin die ursprüngliche Anforderung, nach dem Abschluss der Ausführung des angegebenen virtuellen Pfads. Die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode bedingungslos überträgt die Ausführung an einen anderen Handler.  
  
 ASP.NET überprüft nicht, dass der aktuelle Benutzer autorisiert ist, die von Ressource Anzeigen der <xref:System.Web.HttpServerUtility.Execute%2A> Methode. Obwohl die Autorisierungs- und Authentifizierungsfunktionen Logik von ASP.NET ausgeführt wird, bevor die ursprüngliche Ressource-Handler aufgerufen wird, ruft ASP.NET direkt den Handler für erkennbar der <xref:System.Web.HttpServerUtility.Execute%2A> Methode und die Authentifizierung und Autorisierung Logik für das neue wird nicht erneut ausgeführt die Ressource. Wenn Ihrer Anwendung Sicherheitsrichtlinie für Clients, damit die entsprechenden Autorisierung zum Zugriff auf die Ressource erforderlich ist, sollte die Anwendung eine erneute Authentifizierung zu erzwingen oder bieten einen Mechanismus für die benutzerdefinierte Zugriffssteuerung.  
  
 Sie können eine erneute Authentifizierung erzwingen, indem Sie mit der <xref:System.Web.HttpResponse.Redirect%2A> -Methode anstelle der <xref:System.Web.HttpServerUtility.Execute%2A> Methode. <xref:System.Web.HttpResponse.Redirect%2A> führt eine clientseitige Umleitung in der der Browser die neue Ressource anfordert. Da diese Umleitung auf eine neue Anforderung, die das System ist, wird er alle der Authentifizierung und Autorisierung Logik, die der Sicherheitsrichtlinie von sowohl Internet Information Services (IIS) und ASP.NET unterzogen.  
  
 Sie können überprüfen, ob der Benutzer verfügt über die Berechtigung zum Anzeigen der Ressource durch die Aufnahme einer benutzerdefinierten Autorisierungs-Methode, die verwendet die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> -Methode auf, bevor die Anwendung ruft die <xref:System.Web.HttpServerUtility.Execute%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel führt die `Login.aspx` Seite, auf dem Server im aktuellen Verzeichnis und empfängt die Ausgabe der Seite über die <xref:System.IO.StringWriter> Objekt `writer`. Empfangen von HTML-Stream schreibt `writer` an den HTTP-Ausgabestream. Den Inhalt der <xref:System.Web.HttpRequest.Form%2A> und <xref:System.Web.HttpRequest.QueryString%2A> Sammlungen werden beibehalten.  
  
 [!code-csharp[HttpServerUtility.Execute02#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der aktuelle <see cref="T:System.Web.HttpContext" /> ist ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic).  
  
- oder - 
 <paramref name="path" /> endet mit einem Punkt (.).  
  
- oder - 
Fehler beim Ausführen des von <paramref name="path" /> angegebenen Handlers.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist kein virtueller Pfad.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (handler As IHttpHandler, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Web::IHttpHandler ^ handler, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : System.Web.IHttpHandler * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (handler, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">Der HTTP-Handler, der den <see cref="T:System.Web.IHttpHandler" /> implementiert, an den die aktuelle Anforderung übertragen werden soll.</param>
        <param name="writer">Der zum Aufzeichnen der Ausgabe zu verwendende <see cref="T:System.IO.TextWriter" />.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten, <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Führt den Handler für den angegebenen virtuellen Pfad im Kontext der aktuellen Anforderung aus. Ein <see cref="T:System.IO.TextWriter" /> zeichnet die Ausgabe des ausgeführten Handlers auf, und ein boolescher Parameter gibt an, ob die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung gelöscht werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können benutzerdefinierte HTTP-Handler zum Verarbeiten von bestimmter, vordefinierten Typen von HTTP-Anforderungen in einer beliebigen Sprache, die mit der Common Language Specification (CLS) kompatibel ist, schreiben. Ausführbarer Code, der in der HTTP-handlerklassen anstelle von herkömmlichen ASP (auch bekannt als klassisches ASP)-Seiten oder ASP.NET-Seiten definiert ist, antwortet auf diese bestimmten Anforderungen. HTTP-Handler zu ermöglichen, für die Interaktion mit der Low-Level-Anforderung und Antwort-Dienste von einem Webserver, auf denen Internet Information Services (IIS) ausgeführt wird, und sie bieten ähnliche Funktionen ISAPI-Erweiterungen, aber mit ein einfacheres Programmiermodell.  
  
 ASP.NET überprüft nicht, der aktuelle Benutzer autorisiert ist, um die Ressource anzuzeigen, die von bereitgestellt wird, ob die <xref:System.Web.HttpServerUtility.Execute%2A> Methode. Obwohl ASP.NET Autorisierungs- und Authentifizierungsfunktionen Logik ausgeführt wird, bevor die ursprüngliche Ressource-Handler aufgerufen wird, ruft ASP.NET direkt den Handler, der angegebenen die <xref:System.Web.HttpServerUtility.Execute%2A> Methode und wird nicht erneut ausgeführt, Authentifizierung und Autorisierung Logik für die neue Ressource. Wenn die Sicherheitsrichtlinie für Ihre Anwendung die Clients, damit die entsprechenden Autorisierung für den Zugriff auf die Ressource erforderlich ist, sollte die Anwendung eine erneute Authentifizierung zu erzwingen oder bieten einen Mechanismus für die benutzerdefinierte Zugriffssteuerung.  
  
 Sie können eine erneute Authentifizierung erzwingen, indem Sie mit der <xref:System.Web.HttpResponse.Redirect%2A> -Methode anstelle der <xref:System.Web.HttpServerUtility.Execute%2A> Methode. Die <xref:System.Web.HttpResponse.Redirect%2A> führt eine clientseitige Umleitung in der der Browser die neue Ressource anfordert. Da diese Umleitung auf eine neue Anforderung, die das System ist, wird er alle der Authentifizierung und Autorisierung Logik, die der Sicherheitsrichtlinie für IIS und ASP.NET unterzogen.  
  
 Sie können überprüfen, ob der Benutzer verfügt über die Berechtigung zum Anzeigen der Ressource durch die Aufnahme einer benutzerdefinierten Autorisierungs-Methode, die verwendet die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> -Methode auf, bevor die Anwendung ruft die <xref:System.Web.HttpServerUtility.Execute%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Fehler beim Ausführen des von <paramref name="handler" /> angegebenen Handlers.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="handler" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastError () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ GetLastError();" />
      <MemberSignature Language="F#" Value="member this.GetLastError : unit -&gt; Exception" Usage="httpServerUtility.GetLastError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die vorhergehende Ausnahme zurück.</summary>
        <returns>Die zuletzt ausgelöste Ausnahme.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel gibt eine Beschreibung des letzten Fehler von der Anwendung in den HTTP-Ausgabestream. "No Errors" ausgegeben, wenn keine Fehler aufgetreten sind.  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.ClearError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodiert eine Zeichenfolge, die codiert wurde, um ungültige HTML-Zeichen zu entfernen.  
  
Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <see cref="T:System.Net.WebUtility" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string -&gt; string" Usage="httpServerUtility.HtmlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die zu decodierende HTML-Zeichenfolge.</param>
        <summary>Decodiert eine HTML-codierte Zeichenfolge und gibt die decodierte Zeichenfolge zurück.</summary>
        <returns>Der decodierte Text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-Codierung stellt sicher, dass Text ordnungsgemäß im Browser angezeigt wird, und vom Browser als HTML-Code nicht interpretiert. Angenommen, eine Textzeichenfolge eine kleiner als-Zeichen enthält (\<) oder größer als-Zeichen (>), würde der Browser als öffnende oder schließende Klammer eines HTML-Tags diese Zeichen interpretiert. Wenn die Zeichen HTML-codiert sind, werden sie in Zeichenfolgen konvertiert `&lt;` und `&gt;`, wodurch den Browser das kleiner-als-Zeichen und größer-als-Zeichen ordnungsgemäß an. <xref:System.Web.HttpServerUtility.HtmlDecode%2A> decodiert Text, der an den Server übertragen wurde.  
  
 Diese Methode ist eine bequeme Möglichkeit, Zugriff auf die <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> Methode zur Laufzeit aus einer ASP.NET-Anwendung. Diese Methode intern verwendet <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> um Zeichenfolgen zu decodieren.  
  
 In der CodeBehind-Datei für eine ASP.NET-Webseite auf eine Instanz des der <xref:System.Web.HttpServerUtility> Klasse über die `Server` Eigenschaft. Verwenden Sie in einer Klasse, die nicht in einer CodeBehind-Datei ist `HttpContext.Current.Server` Zugriff auf eine Instanz von der <xref:System.Web.HttpServerUtility> Klasse.  
  
 Verwenden Sie außerhalb einer Webanwendung, die <xref:System.Net.WebUtility> Klasse zum Codieren bzw. Decodieren von Werten.  
  
   
  
## Examples  
 Das folgende Beispiel enthält die Funktion `LoadDecodedFile`, die die Daten aus einer Datei decodiert und kopiert sie in einer Zeichenfolge.  
  
 [!code-aspx-csharp[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-aspx-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Die zu decodierende HTML-Zeichenfolge.</param>
        <param name="output">Der <see cref="T:System.IO.TextWriter" />-Ausgabestream, der die dekodierte Zeichenfolge enthält.</param>
        <summary>Decodiert eine HTML-codierte Zeichenfolge und sendet die Ausgabe an einen <see cref="T:System.IO.TextWriter" />-Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-Codierung stellt sicher, dass Text ordnungsgemäß im Browser angezeigt wird, und vom Browser als HTML-Code nicht interpretiert. Angenommen, eine Textzeichenfolge eine kleiner als-Zeichen enthält (\<) oder größer als-Zeichen (>), würde der Browser als öffnende oder schließende Klammer eines HTML-Tags diese Zeichen interpretiert. Wenn die Zeichen HTML-codiert sind, werden sie in Zeichenfolgen konvertiert `&lt;` und `&gt;`, wodurch den Browser das kleiner-als-Zeichen und größer-als-Zeichen ordnungsgemäß an.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> decodiert Text, der an den Server übertragen wurde.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> ist eine bequeme Möglichkeit, den Zugriff auf die <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> Methode zur Laufzeit aus einer ASP.NET-Anwendung. Intern <xref:System.Web.HttpServerUtility.HtmlDecode%2A> verwendet <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> um Zeichenfolgen zu decodieren.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird decodiert eine Zeichenfolge, die HTML-codierte für die Übertragung über HTTP wurde. Wird decodiert die angegebene Zeichenfolge mit dem Namen `EncodedString` enthält den Text "Dies ist eine &lt;Testzeichenfolge&gt;.", und kopiert sie in der Zeichenfolge, die mit dem Namen `DecodedString` als "Dies ist eine \<Testzeichenfolge >.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codiert eine Zeichenfolge, die in einem Browser angezeigt werden soll.  
  
Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <see cref="T:System.Net.WebUtility" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string -&gt; string" Usage="httpServerUtility.HtmlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die zu codierende Textzeichenfolge.</param>
        <summary>Codiert eine Zeichenfolge in HTML und gibt diese codiert zurück.</summary>
        <returns>Der HTML-codierte Text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-Codierung stellt sicher, dass Text ordnungsgemäß im Browser angezeigt wird, und vom Browser als HTML-Code nicht interpretiert. Angenommen, eine Textzeichenfolge eine kleiner als-Zeichen enthält (\<) oder größer als-Zeichen (>), würde der Browser als öffnende oder schließende Klammer eines HTML-Tags diese Zeichen interpretiert. Wenn die Zeichen HTML-codiert sind, werden sie in Zeichenfolgen konvertiert `&lt;` und `&gt;`, wodurch den Browser das kleiner-als-Zeichen und größer-als-Zeichen ordnungsgemäß an.  
  
 Diese Methode ist eine bequeme Möglichkeit, Zugriff auf die <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> Methode zur Laufzeit aus einer ASP.NET-Anwendung. Diese Methode intern verwendet <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> zum Codieren von Zeichenfolgen.  
  
 In der CodeBehind-Datei für eine ASP.NET-Webseite auf eine Instanz des der <xref:System.Web.HttpServerUtility> Klasse über die `Server` Eigenschaft. Verwenden Sie in einer Klasse, die nicht in einer CodeBehind-Datei ist `HttpContext.Current.Server` Zugriff auf eine Instanz von der <xref:System.Web.HttpServerUtility> Klasse.  
  
 Verwenden Sie außerhalb einer Webanwendung, die <xref:System.Net.WebUtility> Klasse zum Codieren bzw. Decodieren von Werten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie auf einen Wert HTML-Codierung potenziell unsicheren Code Fehlercodes. Der Code befindet sich in der CodeBehind-Datei für eine Webseite. Der zu codierende Wert ist in diesem Beispiel wird nur für das Beispiel vereinfacht, und zeigen dem Typ des Werts, dass Sie mit der HTML-Codierung möglicherweise hartcodiert. In der Regel würden Sie HTML-Codierung einen Wert, den Sie vom Benutzer oder die Anforderung erhalten haben. `Result` bezieht sich auf eine `Literal` Steuerelement.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 Das nächste Beispiel ist ähnlich wie im vorherigen Beispiel, außer es zeigt, wie in HTML codieren können einen Wert aus einer Klasse das ist nicht in der CodeBehind-Datei.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Die zu codierende Zeichenfolge.</param>
        <param name="output">Der <see cref="T:System.IO.TextWriter" />-Ausgabestream, der die kodierte Zeichenfolge enthält.</param>
        <summary>Codiert eine Zeichenfolge in HTML und sendet die Ausgabe an einen <see cref="T:System.IO.TextWriter" />-Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-Codierung wird sichergestellt, dass Text ordnungsgemäß im Browser nicht interpretiert wird, vom Browser als HTML angezeigt wird. Angenommen, eine Textzeichenfolge eine kleiner als-Zeichen enthält (\<) oder größer als-Zeichen (>), würde der Browser als öffnende oder schließende Klammer eines HTML-Tags diese Zeichen interpretiert. Ist die HTML-Codierung der beiden Zeichen `&lt;` und `&gt;`, wodurch den Browser das kleiner-als-Zeichen und größer-als-Zeichen ordnungsgemäß an.  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> ist eine bequeme Möglichkeit, den Zugriff auf die <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> Methode zur Laufzeit aus einer ASP.NET-Anwendung. Intern <xref:System.Web.HttpServerUtility.HtmlEncode%2A> verwendet <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> zum Codieren von Zeichenfolgen.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird codiert eine Zeichenfolge für die Übertragung von HTTP. Es wird die Zeichenfolge, die mit dem Namen `TestString`, enthält den Text "Dies ist eine \<Testzeichenfolge >.", und kopiert sie in der Zeichenfolge, die mit dem Namen `EncodedString` als "Dies ist eine &lt;Testzeichenfolge&gt;.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Web.HttpServerUtility.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Computernamen des Servers ab.</summary>
        <value>Der Name des lokalen Computers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel speichert den Namen des Servers Computer als eine String-Variable.  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der Computername kann nicht gefunden werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpServerUtility.MapPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der virtuelle Pfad zur Webanwendung.</param>
        <summary>Gibt den physischen Dateipfad zurück, der dem angegebenen virtuellen Pfad entspricht.</summary>
        <returns>Der physische Dateipfad auf dem Webserver, der <paramref name="path" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `path` ist `null`, <xref:System.Web.HttpServerUtility.MapPath%2A> Methode gibt den vollständigen physischen Pfad des Verzeichnisses, das die aktuelle Anforderung für den Pfad enthält. Der relative Pfad muss es sich nicht an eine vorhandene Datei oder Ordner für diese Methode einen Wert zurückgeben. Sie können nicht jedoch, einen Pfad außerhalb der Anwendung angeben.  
  
> [!IMPORTANT]
>  Die <xref:System.Web.HttpServerUtility.MapPath%2A> Methode enthält möglicherweise vertrauliche Informationen über die hostumgebung bereit. Der Rückgabewert sollte Benutzern nicht angezeigt werden.  
  
 Eine Anwendung, die sich auf befindet `C:\ExampleSites\TestMapPath` würden die folgenden Ergebnisse zurück:  
  
|Anfordern von|`path`|Zurückgegebener Wert|  
|------------------|------------|--------------------|  
|RootLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath|  
|RootLevelPage.aspx|"/DownOneLevel/DownLevelPage.aspx"|C:\ExampleSites\TestMapPath\DownOneLevel\DownLevelPage.aspx|  
|RootLevelPage.aspx|"/NotRealFolder"|C:\ExampleSites\TestMapPath\NotRealFolder|  
|RootLevelPage.aspx|"../OutsideApplication"|<xref:System.Web.HttpException>|  
|/DownOneLevel/DownLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath\DownOneLevel|  
|/DownOneLevel/DownLevelPage.aspx|"../RootLevelPage.aspx"|C:\ExampleSites\TestMapPath\RootLevelPage.aspx|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie ein relativer virtueller Pfad der physische Datei abgerufen wird. Der Code befindet sich im Code-Behind-Datei für eine Webseite, und verwendet die standardmäßige `Server` Objekt.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 Im nächste Beispiel ist ähnlich wie im vorherigen Beispiel, außer es wird gezeigt, wie einen physischen Pfad von innerhalb einer Klasse abrufen, die nicht in der CodeBehind-Datei ist.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Das aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.
        
- oder - 
<paramref name="path" /> ist ein physischer Pfad, es wurde aber ein virtueller Pfad erwartet.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScriptTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptTimeout : int with get, set" Usage="System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Timeoutwert der Anforderung (in Sekunden) ab oder legt diesen fest.</summary>
        <value>Die Timeoutwert-Einstellung für Anforderungen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> Eigenschaft kann in der Datei "Web.config" festgelegt werden, durch Festlegen der `executionTimeout` Attribut der [HttpRuntime](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) Element. Festlegen des Timeouts programmgesteuert mit der <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> -Eigenschaft Vorrang vor der Web.config-Einstellung.  
  
> [!NOTE]
>  Setzen Sie die `debug` Attribut der [HttpRuntime](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) Element `true` in der Datei "Web.config" der Wert des <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> ignoriert werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Timeout der Anforderung auf 60 Sekunden.  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Das aktuelle <see cref="T:System.Web.HttpContext" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Timeoutspanne ist <see langword="null" /> oder konnte nicht festgelegt werden.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transfer">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet die Ausführung der aktuellen Seite und startet die Ausführung einer neuen Seite für die aktuelle Anforderung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string -&gt; unit" Usage="httpServerUtility.Transfer path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <summary>Beendet für die aktuelle Anforderung die Ausführung der aktuellen Seite und startet die Ausführung einer neuen Seite unter Verwendung des angegebenen URL-Pfads für die Seite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Seite zu übertragen, sollte eine andere ASPX-Seite. Eine Übertragung an eine ASP- oder ASMX-Seite ist beispielsweise ungültig. Die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode behält die <xref:System.Web.HttpRequest.QueryString%2A> und <xref:System.Web.HttpRequest.Form%2A> Sammlungen.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> Aufrufe <xref:System.Web.HttpResponse.End%2A>, welche löst eine <xref:System.Threading.ThreadAbortException> Ausnahme nach Abschluss.  
  
 ASP.NET überprüft nicht, dass der aktuelle Benutzer autorisiert ist, die von Ressource Anzeigen der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Obwohl die Autorisierungs- und Authentifizierungsfunktionen Logik von ASP.NET ausgeführt wird, bevor die ursprüngliche Ressource-Handler aufgerufen wird, ruft ASP.NET direkt den Handler für erkennbar der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode und die Authentifizierung und Autorisierung Logik für das neue wird nicht erneut ausgeführt die Ressource. Wenn Ihrer Anwendung Sicherheitsrichtlinie für Clients, damit die entsprechenden Autorisierung zum Zugriff auf die Ressource erforderlich ist, sollte die Anwendung eine erneute Authentifizierung zu erzwingen oder bieten einen Mechanismus für die benutzerdefinierte Zugriffssteuerung.  
  
 Sie können eine erneute Authentifizierung erzwingen, indem Sie mit der <xref:System.Web.HttpResponse.Redirect%2A> -Methode anstelle der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Die <xref:System.Web.HttpResponse.Redirect%2A> -Methode führt eine clientseitige Umleitung in der der Browser die neue Ressource anfordert. Da diese Umleitung auf eine neue Anforderung, die das System ist, wird er alle der Authentifizierung und Autorisierung Logik, die der Sicherheitsrichtlinie von sowohl Internet Information Services (IIS) und ASP.NET unterzogen.  
  
 Sie können überprüfen, ob der Benutzer verfügt über die Berechtigung zum Anzeigen der Ressource durch die Aufnahme einer benutzerdefinierten Autorisierungs-Methode, die verwendet die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> -Methode auf, bevor die Anwendung ruft die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string * bool -&gt; unit" Usage="httpServerUtility.Transfer (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten, <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Beendet die Ausführung der aktuellen Seite und startet die Ausführung einer neuen Seite unter Verwendung des angegebenen URL-Pfads für die Seite. Gibt an, ob die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung gelöscht werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Seite zu übertragen, sollte eine andere ASPX-Seite. Eine Übertragung an eine ASP- oder ASMX-Seite ist beispielsweise ungültig.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> Aufrufe <xref:System.Web.HttpResponse.End%2A>, welche löst eine <xref:System.Threading.ThreadAbortException> Ausnahme nach Abschluss.  
  
 Setzen Sie die `preserveForm` Parameter `true`, die Zielseite wird in der Lage, den Ansichtszustand der vorherigen Seite mit Zugriff auf die <xref:System.Web.UI.Page.PreviousPage%2A> Eigenschaft.  
  
 Aus Sicherheitsgründen sollten Sie halten die `enableViewStateMac` -Attributsatz auf `true`. ASP.NET überprüft nicht, dass der aktuelle Benutzer autorisiert ist, die von Ressource Anzeigen der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Obwohl die Autorisierungs- und Authentifizierungsfunktionen Logik von ASP.NET ausgeführt wird, bevor die ursprüngliche Ressource-Handler aufgerufen wird, ruft ASP.NET direkt den Handler für erkennbar der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode und die Authentifizierung und Autorisierung Logik für das neue wird nicht erneut ausgeführt die Ressource. Wenn Ihrer Anwendung Sicherheitsrichtlinie für Clients, damit die entsprechenden Autorisierung zum Zugriff auf die Ressource erforderlich ist, sollte die Anwendung eine erneute Authentifizierung zu erzwingen oder bieten einen Mechanismus für die benutzerdefinierte Zugriffssteuerung.  
  
 Sie können eine erneute Authentifizierung erzwingen, indem Sie mit der <xref:System.Web.HttpResponse.Redirect%2A> -Methode anstelle der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Die <xref:System.Web.HttpResponse.Redirect%2A> -Methode führt eine clientseitige Umleitung in der der Browser die neue Ressource anfordert. Da diese Umleitung auf eine neue Anforderung, die das System ist, wird er alle der Authentifizierung und Autorisierung Logik, die der Sicherheitsrichtlinie von sowohl Internet Information Services (IIS) und ASP.NET unterzogen.  
  
 Sie können überprüfen, ob der Benutzer verfügt über die Berechtigung zum Anzeigen der Ressource durch die Aufnahme einer benutzerdefinierten Autorisierungs-Methode, die verwendet die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> -Methode auf, bevor die Anwendung ruft die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine neue Seite im selben Verzeichnis wie die aktuelle Seite.  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Die aktuelle Seitenanforderung ist ein Rückruf.</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (handler As IHttpHandler, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::Web::IHttpHandler ^ handler, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : System.Web.IHttpHandler * bool -&gt; unit" Usage="httpServerUtility.Transfer (handler, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">Der HTTP-Handler, der den <see cref="T:System.Web.IHttpHandler" /> implementiert, an den die aktuelle Anforderung übertragen werden soll.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten, <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Beendet die Ausführung der aktuellen Seite und beginnt die Ausführung einer neuen Anforderung mithilfe eines benutzerdefinierten HTTP-Handlers, der die <see cref="T:System.Web.IHttpHandler" />-Schnittstelle implementiert und angibt, ob die <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung und die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung gelöscht werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können benutzerdefinierte HTTP-Handler zum Verarbeiten von bestimmter, vordefinierten Typen von HTTP-Anforderungen in einer beliebigen Sprache, die mit der Common Language Specification (CLS) kompatibel ist, schreiben. Ausführbarer Code, der in der HTTP-handlerklassen anstelle von herkömmlichen ASP (auch bekannt als klassisches ASP)-Seiten oder ASP.NET-Seiten definiert ist, antwortet auf diese bestimmten Anforderungen. HTTP-Handler zu ermöglichen, für die Interaktion mit der Low-Level-Anforderung und Antwort-Dienste von einem Webserver, auf denen Internet Information Services (IIS) ausgeführt wird, und sie bieten ähnliche Funktionen ISAPI-Erweiterungen, aber mit ein einfacheres Programmiermodell.  
  
 Setzen Sie die `preserveForm` Parameter `true`, die Zielseite wird in der Lage, den Ansichtszustand der vorherigen Seite mit Zugriff auf die <xref:System.Web.UI.Page.PreviousPage%2A> Eigenschaft.  
  
 Aus Sicherheitsgründen sollten Sie halten die `enableViewStateMac` -Attributsatz auf `true`. ASP.NET überprüft nicht, dass der aktuelle Benutzer autorisiert ist, die von Ressource Anzeigen der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Obwohl die Autorisierungs- und Authentifizierungsfunktionen Logik von ASP.NET ausgeführt wird, bevor die ursprüngliche Ressource-Handler aufgerufen wird, ruft ASP.NET direkt den Handler für erkennbar die <xref:System.Web.HttpServerUtility.Transfer%2A> -Methode und wird nicht erneut ausgeführt, Authentifizierung und Autorisierung Logik für das neue die Ressource. Wenn die Sicherheitsrichtlinie für Ihre Anwendung die Clients, damit die entsprechenden Autorisierung zum Zugriff auf die Ressource erforderlich ist, sollte die Anwendung eine erneute Authentifizierung zu erzwingen oder bieten einen Mechanismus für die benutzerdefinierte Zugriffssteuerung.  
  
 Sie können eine erneute Authentifizierung erzwingen, indem Sie mit der <xref:System.Web.HttpResponse.Redirect%2A> -Methode anstelle der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Die <xref:System.Web.HttpResponse.Redirect%2A> -Methode führt eine clientseitige Umleitung in der der Browser die neue Ressource anfordert. Da diese Umleitung auf eine neue Anforderung, die das System ist, wird er alle der Authentifizierung und Autorisierung Logik, die der Sicherheitsrichtlinie für IIS und ASP.NET unterzogen.  
  
 Sie können überprüfen, ob der Benutzer verfügt über die Berechtigung zum Anzeigen der Ressource durch die Aufnahme einer benutzerdefinierten Autorisierungs-Methode, die verwendet die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> -Methode auf, bevor die Anwendung ruft die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Die aktuelle Seitenanforderung ist ein Rückruf.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt die angegebene URL asynchron aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> wurde in .NET Framework, Version 3.5 eingeführt. Zusammenfassende Informationen zu .NET Framework finden Sie unter [-Versionen und-Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string -&gt; unit" Usage="httpServerUtility.TransferRequest path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <summary>Führt die angegebene URL asynchron aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladung dieser Methode ruft die <xref:System.Web.HttpServerUtility.TransferRequest%2A> -Überladung mit der `preserveForm` Parametersatz zu `false`, die `method` Parametersatz zu `null`, die `headers` Parametersatz zu `null`, und die `preserveUser` Parametersatz zu `true`. Weitere Informationen finden Sie im Abschnitt "Hinweise" in <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Anforderung erfordert den integrierten Pipelinemodus von [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Der Server ist nicht verfügbar, um die Anforderung zu behandeln.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <summary>Führt die angegebene URL asynchron aus und behält die Parameter der Abfragezeichenfolge bei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ruft die <xref:System.Web.HttpServerUtility.TransferRequest%2A> -Überladung mit der `preserveForm` Parameter auf den Wert übergeben werden, die `method` Parametersatz zu `null`, `headers` Parametersatz zu `null`, und die `preserveUser` Parametersatz um `true`. Weitere Informationen finden Sie im Abschnitt "Hinweise" in <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> wird in .NET Framework, Version 3.5 eingeführt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Anforderung erfordert den integrierten Pipelinemodus von [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Der Server ist nicht verfügbar, um die Anforderung zu behandeln.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der URL-Pfad für die neue auszuführende Seite auf dem Server.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <param name="method">Die HTTP-Methode, die für die Ausführung der neuen Anforderung verwendet werden soll.</param>
        <param name="headers">Eine <see cref="T:System.Collections.Specialized.NameValueCollection" /> von Anforderungsheadern für die neue Anforderung.</param>
        <summary>Führt die angegebene URL mit der angegebenen HTTP-Methode und den angegebenen HTTP-Headern asynchron aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, bei der Ausführung mit den integrierten Pipelinemodus in [!INCLUDE[iisver](~/includes/iisver-md.md)] um die Verarbeitung von Anforderungen von einem Ressourcentyp in einen anderen übertragen werden, während der Ausführung der zielanforderung mit dem richtigen Anforderungskontext zu ermöglichen. Beispielsweise können Sie die <xref:System.Web.HttpServerUtility.TransferRequest%2A> Methode, um eine Anforderung für eine ASPX-Seite auf eine Anforderung für eine XML-Seite zu übertragen.  
  
 Die <xref:System.Web.HttpServerUtility.TransferRequest%2A> Methode nimmt eine asynchrone untergeordneten Ausführung der angegebenen URL mit den folgenden Bedingungen:  
  
-   Wenn die `path` Parameter gibt an, eine Abfragezeichenfolge, er wird als neue Abfragezeichenfolge verwendet. Wenn keine Abfragezeichenfolge enthalten ist, wird die Abfragezeichenfolge der Anforderung wiederverwendet werden.  
  
-   Wenn die `method` -Parameter angegeben wird, wird dieser verwendet. Ist dies `null`, die HTTP-Methode der ursprünglichen Anforderung verwendet werden.  
  
-   Wenn die `preserveForm` Parameter `true`, dem aktuellen Entity-Body der die Anforderung an die zielanforderung stehen. Dadurch können formularbereitstellungen und hochgeladen werden, um die übertragen werden.  
  
-   Wenn die Identität des Benutzers derzeit in der ursprünglichen Anforderung festgelegt ist, wird die Identität auf die neue Anforderung übertragen werden. Dies ermöglicht authentifizierte Anforderungen an das Ergebnis der Authentifizierung für die neue Anforderung erneut zu verwenden. Wenn Sie nicht möchten, dass den Benutzer übertragen werden, legen Sie den Benutzer auf `null` in der ursprünglichen Anforderung vor der Übertragung.  
  
-   Wenn die `headers` -Parameter angegeben wird, wird die neue Anforderung mit den angegebenen Headern ausgeführt. Dies kann verwendet werden, um die Anforderungsheader und Cookies für die neue Anforderung zu ändern oder ein spezieller Header, der angibt, in dem die ursprüngliche Anforderung empfangen wurde hinzugefügt.  
  
     Diese Methode ruft die <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29> methodenüberladung mit dem `preserveUser` Parametersatz zu `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Anforderung erfordert, dass [!INCLUDE[iisver](~/includes/iisver-md.md)] im integrierten Modus ausgeführt wird.</exception>
        <exception cref="T:System.Web.HttpException">Der Server ist nicht verfügbar, um die Anforderung zu behandeln.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection, preserveUser As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers, bool preserveUser);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers, preserveUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveUser" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad.</param>
        <param name="preserveForm"><see langword="true" />, um die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung beizubehalten; <see langword="false" />, um die <see cref="P:System.Web.HttpRequest.Form" />-Auflistung zu löschen.</param>
        <param name="method">Die HTTP-Methode für die neue Anforderung.</param>
        <param name="headers">Ein <see cref="T:System.Collections.Specialized.NameValueCollection" />-Objekt, das Anforderungsheader für die neue Anforderung enthält.</param>
        <param name="preserveUser"><see langword="true" />, um die Benutzeridentität zu erhalten; andernfalls <see langword="false" />. Die anderen Überladungen dieser Methode rufen diese Überladung mit diesem auf <see langword="true" /> gesetzten Parameter auf.</param>
        <summary>Nimmt eine asynchrone Ausführung der angegebenen URL mit der angegebenen HTTP-Methode, den angegebenen HTTP-Headern und dem angegebenen HTTP-Pfad vor und behält die Formwerte und Benutzeridentität optional bei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" in <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Anforderung erfordert den integrierten Pipelinemodus von [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Der Server ist nicht verfügbar, um die Anforderung zu behandeln.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist ungültig.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodiert eine Zeichenfolge, die für eine HTTP-Übertragung codiert und in einer URL an den Server gesendet wurde.  
  
Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <see cref="T:System.Net.WebUtility" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string -&gt; string" Usage="httpServerUtility.UrlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die zu decodierende Textzeichenfolge.</param>
        <summary>Decodiert eine URL-Zeichenfolge und gibt die decodierte Zeichenfolge zurück.</summary>
        <returns>Der decodierte Text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL-Codierung wird sichergestellt, dass alle Browser Text im URL-Zeichenfolgen ordnungsgemäß übertragen werden. (?) Zeichen wie z. B. eine Frage zu markieren, markieren kaufmännisches und-Zeichen (&), Schrägstrich (/) und Leerzeichen abgeschnitten oder von einigen Browsern beschädigt werden können. Daher müssen diese Zeichen codiert werden, `<a>` tags oder im Abfrage-Zeichenfolgen, in denen die Zeichenfolgen von einem Browser in einer Anforderungszeichenfolge erneut gesendet werden können.  
  
 Diese Methode ist eine bequeme Möglichkeit, Zugriff auf die <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> Methode zur Laufzeit aus einer ASP.NET-Anwendung. Diese Methode intern verwendet <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> um Zeichenfolgen zu decodieren.  
  
 In der CodeBehind-Datei für eine ASP.NET-Webseite auf eine Instanz des der <xref:System.Web.HttpServerUtility> Klasse über die `Server` Eigenschaft. Verwenden Sie in einer Klasse, die nicht in einer CodeBehind-Datei ist `HttpContext.Current.Server` Zugriff auf eine Instanz von der <xref:System.Web.HttpServerUtility> Klasse.  
  
 Verwenden Sie außerhalb einer Webanwendung, die <xref:System.Net.WebUtility> Klasse zum Codieren bzw. Decodieren von Werten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt wie URL-decodiert einen Wert, der aus der Abfragezeichenfolge abgerufen wird. Der Code befindet sich in der CodeBehind-Datei für eine Webseite. `ReturnPage` bezieht sich auf eine `HyperLink` Steuerelement.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 Das nächste Beispiel ist ähnlich wie im vorherigen Beispiel, außer es zeigt, wie URL-decodiert einen Wert aus einer Klasse das ist nicht in der CodeBehind-Datei.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Die zu decodierende HTML-Zeichenfolge.</param>
        <param name="output">Der <see cref="T:System.IO.TextWriter" />-Ausgabestream, der die dekodierte Zeichenfolge enthält.</param>
        <summary>Decodiert eine HTML-Zeichenfolge, die in einer URL empfangen wurde, und sendet die Ausgabe an einen <see cref="T:System.IO.TextWriter" />-Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL-Codierung wird sichergestellt, dass alle Browser Text im URL-Zeichenfolgen ordnungsgemäß übertragen werden. (?) Zeichen wie z. B. eine Frage zu markieren, markieren kaufmännisches und-Zeichen (&), Schrägstrich (/) und Leerzeichen abgeschnitten oder von einigen Browsern beschädigt werden können. Daher müssen diese Zeichen codiert werden, `<a>` tags oder im Abfrage-Zeichenfolgen, in denen die Zeichenfolgen von einem Browser in einer Anforderungszeichenfolge erneut gesendet werden können.  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A> ist eine bequeme Möglichkeit, den Zugriff auf die <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> Methode zur Laufzeit aus einer ASP.NET-Anwendung. Intern <xref:System.Web.HttpServerUtility.UrlDecode%2A> verwendet <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> um Zeichenfolgen zu decodieren.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Zeichenfolge, die mit dem Namen decodiert `EncodedString` (in einer URL empfangen) in die Zeichenfolge, die mit dem Namen `DecodedString`.  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codiert eine Zeichenfolge für eine zuverlässige HTTP-Übertragung vom Webserver an einen Client über die URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> ist eine bequeme Möglichkeit, den Zugriff auf die <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> Methode zur Laufzeit aus einer ASP.NET-Anwendung. Intern <xref:System.Web.HttpServerUtility.UrlEncode%2A> verwendet <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> zum Codieren von Zeichenfolgen.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string -&gt; string" Usage="httpServerUtility.UrlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Der als URL zu codierende Text.</param>
        <summary>Codiert eine Zeichenfolge als URL und gibt die codierte Zeichenfolge zurück.</summary>
        <returns>Der URL-codierte Text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL-Codierung wird sichergestellt, dass alle Browser Text im URL-Zeichenfolgen ordnungsgemäß übertragen werden. (?) Zeichen wie z. B. eine Frage zu markieren, markieren kaufmännisches und-Zeichen (&), Schrägstrich (/) und Leerzeichen abgeschnitten oder von einigen Browsern beschädigt werden können. Daher müssen diese Zeichen codiert werden, `<a>` tags oder im Abfrage-Zeichenfolgen, in denen die Zeichenfolgen von einem Browser in einer Anforderungszeichenfolge erneut gesendet werden können.  
  
 Diese Methode ist eine bequeme Möglichkeit, Zugriff auf die <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> Methode zur Laufzeit aus einer ASP.NET-Anwendung. Diese Methode intern verwendet <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> zum Codieren von Zeichenfolgen.  
  
 In der CodeBehind-Datei für eine ASP.NET-Webseite auf eine Instanz des der <xref:System.Web.HttpServerUtility> Klasse über die `Server` Eigenschaft. Verwenden Sie in einer Klasse, die nicht in einer CodeBehind-Datei ist `HttpContext.Current.Server` Zugriff auf eine Instanz von der <xref:System.Web.HttpServerUtility> Klasse.  
  
 Verwenden Sie außerhalb einer Webanwendung, die <xref:System.Net.WebUtility> Klasse zum Codieren bzw. Decodieren von Werten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt wie auf einen Wert URL-Codierung, die als Wert einer Abfragezeichenfolge als Link verwendet wird. Der Code befindet sich in der CodeBehind-Datei für eine Webseite. Der zu codierende Wert ist in diesem Beispiel wird nur für das Beispiel vereinfacht, und zeigen dem Typ des Werts, dass Sie mit der URL-Codierung möglicherweise hartcodiert. In der Regel würden Sie URL-Codierung einen Wert, den Sie vom Benutzer oder die Anforderung erhalten haben. `NextPage` bezieht sich auf eine `HyperLink` Steuerelement.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 Das nächste Beispiel ist ähnlich wie im vorherigen Beispiel, außer es zeigt, wie auf URL-Codierung eines Werts von innerhalb einer Klasse das ist nicht in der CodeBehind-Datei.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Die zu codierende Textzeichenfolge.</param>
        <param name="output">Der <see cref="T:System.IO.TextWriter" />-Ausgabestream, der die kodierte Zeichenfolge enthält.</param>
        <summary>Codiert eine Zeichenfolge als URL und sendet die Ausgabe an einen <see cref="T:System.IO.TextWriter" />-Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL-Codierung wird sichergestellt, dass alle Browser Text im URL-Zeichenfolgen ordnungsgemäß übertragen werden. (?) Zeichen wie z. B. eine Frage zu markieren, markieren kaufmännisches und-Zeichen (&), Schrägstrich (/) und Leerzeichen abgeschnitten oder von einigen Browsern beschädigt werden können. Daher müssen diese Zeichen codiert werden, `<a>` tags oder im Abfrage-Zeichenfolgen, in denen die Zeichenfolgen von einem Browser in einer Anforderungszeichenfolge erneut gesendet werden können.  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> ist eine bequeme Möglichkeit, den Zugriff auf die <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> Methode zur Laufzeit aus einer ASP.NET-Anwendung. Intern <xref:System.Web.HttpServerUtility.UrlEncode%2A> verwendet <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> zum Codieren von Zeichenfolgen.  
  
 Verwenden Sie zum Codieren oder Decodieren von Werten außerhalb einer Webanwendung die <xref:System.Net.WebUtility>-Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird codiert eine Zeichenfolge für die Übertragung von HTTP. Es wird die Zeichenfolge, die mit dem Namen `TestString`, enthält den Text "Dies ist eine \<Testzeichenfolge >.", und kopiert sie in der Zeichenfolge, die mit dem Namen `EncodedString` als "This + wird + a + % 3cTest + Zeichenfolge % 3e.".  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlPathEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlPathEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlPathEncode : string -&gt; string" Usage="httpServerUtility.UrlPathEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Der als URL zu codierende Text.</param>
        <summary>Nicht verwenden. Nur für die Browserkompatibilität vorgesehen. Verwenden Sie <see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />.</summary>
        <returns>Der URL-codierte Text.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenDecode (input As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ UrlTokenDecode(System::String ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenDecode : string -&gt; byte[]" Usage="System.Web.HttpServerUtility.UrlTokenDecode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="input">Das zu decodierende URL-Zeichenfolgentoken.</param>
        <summary>Decodiert ein URL-Zeichenfolgentoken in sein entsprechendes Bytearray mit Base-64-Ziffern.</summary>
        <returns>Das Bytearray, das das decodierte URL-Zeichenfolgentoken enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> -Methode konvertiert ein URL-Zeichenfolgentoken, das Binärdaten als base-64-Ziffern codiert, in die entsprechende Bytearraydarstellung. Verwenden der <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> Methode zum Decodieren von Token in der URL übertragen und codiert, indem die <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>.  
  
 Die <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> Methode gibt ein leeres Byte-Array zurück, wenn die `input` Parameter hat eine Länge von weniger als 1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert des <paramref name="input" />-Parameters ist <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenEncode (input As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UrlTokenEncode(cli::array &lt;System::Byte&gt; ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenEncode : byte[] -&gt; string" Usage="System.Web.HttpServerUtility.UrlTokenEncode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="input">Das zu codierende Bytearray.</param>
        <summary>Codiert ein Bytearray in seine äquivalente Zeichenfolgendarstellung mit Base-64-Ziffern, die für die Übertragung in der URL geeignet ist.</summary>
        <returns>Die Zeichenfolge, die das codierte Token enthält, wenn die *Länge* des Bytearrays größer als eins ist, andernfalls eine leere Zeichenfolge („“).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> Methode konvertiert ein Bytearray in eine entsprechende Zeichenfolgendarstellung mit base-64-Ziffern codiert. Das resultierende Zeichenfolgentoken, das kann in der URL übertragen werden.  
  
 Die <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> gibt eine leere Zeichenfolge zurück, wenn die `input` Parameter hat eine Länge von weniger als 1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert des <paramref name="input" />-Parameters ist <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.ToBase64String(System.Byte[])" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>