<Type Name="DefaultHttpHandler" FullName="System.Web.DefaultHttpHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5521ea3e40ff815bf51089ba7c923ed2b98372c8" /><Meta Name="ms.sourcegitcommit" Value="f9576bf8c61e3d46834aeeff50f858359f2a99ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/09/2020" /><Meta Name="ms.locfileid" Value="77105691" /></Metadata><TypeSignature Language="C#" Value="public class DefaultHttpHandler : System.Web.IHttpAsyncHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DefaultHttpHandler extends System.Object implements class System.Web.IHttpAsyncHandler, class System.Web.IHttpHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.DefaultHttpHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class DefaultHttpHandler&#xA;Implements IHttpAsyncHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class DefaultHttpHandler : System::Web::IHttpAsyncHandler" />
  <TypeSignature Language="F#" Value="type DefaultHttpHandler = class&#xA;    interface IHttpAsyncHandler&#xA;    interface IHttpHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.IHttpAsyncHandler</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.IHttpHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt die Eigenschaften und Methoden eines HTTP-Standardhandlers dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 Ein <xref:System.Web.DefaultHttpHandler>-Objekt fängt eingehende Anforderungen in der HTTP-Pipeline ab, wenn die Anforderungs Abfang Funktion über Internetinformationsdienste (IIS) 6,0 konfiguriert wurde und keine expliziten Bindungen auf die angeforderte Erweiterung angewendet wurden.

 Das Abfangen von Anforderungen kann über das in IIS 6,0 eingeführte Feature "Platzhalter Anwendungs Zuordnung" eingerichtet werden.

 Die <xref:System.Web.DefaultHttpHandler>-Klasse implementiert die <xref:System.Web.IHttpAsyncHandler>-Schnittstelle, um die asynchrone Anforderungs Verarbeitung bereitzustellen. Allgemeine Informationen zu HTTP-Handlern finden Sie unter [Übersicht über HTTP-Handler und HTTP-Module](https://docs.microsoft.com/previous-versions/aspnet/bb398986(v=vs.100)). Weitere Informationen finden Sie in den folgenden Bereichen:

-   Informationen zum Erstellen von asynchronen HTTP-Handlern finden Sie unter Exemplarische Vorgehensweise [: Erstellen eines asynchronen HTTP](https://docs.microsoft.com/previous-versions/aspnet/ms227433(v=vs.100))-Handlers.

-   Informationen zum Registrieren von HTTP-Handlern finden Sie unter Gewusst [wie: Registrieren von HTTP-Handlern](https://docs.microsoft.com/previous-versions/aspnet/46c5ddfy(v=vs.100)).

 Klassen können von der <xref:System.Web.DefaultHttpHandler>-Klasse abgeleitet werden, um die angepasste Verarbeitung von Anforderungen bereitzustellen. Ein asynchroner HTTP-Handler, der vom <xref:System.Web.DefaultHttpHandler> abgeleitet ist, kann die <xref:System.Web.DefaultHttpHandler.BeginProcessRequest%2A>-Methode überschreiben, um zu ändern, wie Anforderungen verarbeitet werden.

 Ein <xref:System.Web.DefaultHttpHandler> verwendet keine ASP.NET-Fehler. Vorhandener Inhalt, der IIS-Fehler oder einen benutzerdefinierten ISAPI-Fehler Mechanismus verwendet, würde unverändert funktionieren.



## Examples
 Im folgenden Codebeispiel wird veranschaulicht, wie ein angepasster HTTP-Handler durch Ableiten von der <xref:System.Web.DefaultHttpHandler>-Klasse implementiert wird.

 [!code-csharp[System.Web.DefaultHttpHandler#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.DefaultHttpHandler/CS/source.cs#1)]
 [!code-vb[System.Web.DefaultHttpHandler#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.DefaultHttpHandler/VB/source.vb#1)]

 ]]></format>
    </remarks>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/46c5ddfy(v=vs.100)">Gewusst wie: Registrieren von HTTP-Handlern</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms227433(v=vs.100)">Gewusst wie: Erstellen eines asynchronen HTTP-Handlers</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DefaultHttpHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.DefaultHttpHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DefaultHttpHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.DefaultHttpHandler" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginProcessRequest">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginProcessRequest (System.Web.HttpContext context, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.DefaultHttpHandler.BeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginProcessRequest (context As HttpContext, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginProcessRequest(System::Web::HttpContext ^ context, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginProcessRequest : System.Web.HttpContext * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginProcessRequest : System.Web.HttpContext * AsyncCallback * obj -&gt; IAsyncResult" Usage="defaultHttpHandler.BeginProcessRequest (context, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.IHttpAsyncHandler.BeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">Ein Objekt, das Verweise auf systeminterne Serverobjekte für HTTP-Anforderungen bereitstellt.</param>
        <param name="callback">Die Methode, die beim Abschluss des asynchronen Methodenaufrufs aufgerufen wird. Wenn <paramref name="callback" /> auf <see langword="null" /> festgelegt ist, wird der Delegat nicht aufgerufen.</param>
        <param name="state">Zustandsdaten, die zur Verarbeitung der Anforderung benötigt werden.</param>
        <summary>Initialisiert einen asynchronen Aufruf des HTTP-Handlers.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das Informationen über den Status des Prozesses enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn Sie einen HTTP-Handler für die asynchrone Verwendung erstellen, muss der Handler die asynchronen <xref:System.Web.DefaultHttpHandler.BeginProcessRequest%2A> und <xref:System.Web.DefaultHttpHandler.EndProcessRequest%2A> Methoden implementieren, die asynchron von ASP.NET aufgerufen werden.

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die Vorbedingungen für die Verarbeitung einer Anforderung sind fehlgeschlagen, und die angeforderte Datei verfügt entweder über das Suffix .asp, oder die Anforderung wurde über POST gesendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.DefaultHttpHandler.Context" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Context As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Context : System.Web.HttpContext" Usage="System.Web.DefaultHttpHandler.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Kontext ab, der dem aktuellen <see cref="T:System.Web.DefaultHttpHandler" />-Objekt zugeordnet ist.</summary>
        <value>Ein <see cref="T:System.Web.HttpContext" />-Objekt, das den aktuellen Kontext enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.DefaultHttpHandler.Context%2A>-Eigenschaft ermöglicht den Zugriff auf das aktuelle <xref:System.Web.HttpContext>-Objekt für abgeleitete Klassen. Ein <xref:System.Web.HttpContext>-Objekt ermöglicht den Zugriff auf die Eigenschaften der systeminternen <xref:System.Web.HttpApplication.Request%2A>, <xref:System.Web.HttpApplication.Response%2A>und <xref:System.Web.HttpApplication.Server%2A> für die Anforderung. Weitere Informationen zum Zugreifen auf Kontextinformationen finden Sie unter <xref:System.Web.HttpContext>.

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
      </Docs>
    </Member>
    <Member MemberName="EndProcessRequest">
      <MemberSignature Language="C#" Value="public virtual void EndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.DefaultHttpHandler.EndProcessRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndProcessRequest (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndProcessRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndProcessRequest : IAsyncResult -&gt; unit&#xA;override this.EndProcessRequest : IAsyncResult -&gt; unit" Usage="defaultHttpHandler.EndProcessRequest result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.IHttpAsyncHandler.EndProcessRequest(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ein Objekt, das Informationen zum Status des Prozesses enthält.</param>
        <summary>Stellt eine Methode zum Beenden für einen asynchronen Prozess bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Sie können die <xref:System.Web.DefaultHttpHandler.EndProcessRequest%2A>-Methode verwenden, um alle Ausnahmen auszulösen, die während des asynchronen Prozesses abgefangen werden.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteUrlHeaders">
      <MemberSignature Language="C#" Value="protected System.Collections.Specialized.NameValueCollection ExecuteUrlHeaders { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection ExecuteUrlHeaders" />
      <MemberSignature Language="DocId" Value="P:System.Web.DefaultHttpHandler.ExecuteUrlHeaders" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ExecuteUrlHeaders As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Specialized::NameValueCollection ^ ExecuteUrlHeaders { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecuteUrlHeaders : System.Collections.Specialized.NameValueCollection" Usage="System.Web.DefaultHttpHandler.ExecuteUrlHeaders" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung der Anforderungsheader und Anforderungswerte ab, die mit der Anforderung übertragen werden.</summary>
        <value>Eine <see cref="T:System.Collections.Specialized.NameValueCollection" />, die die Anforderungsheader und -werte enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.DefaultHttpHandler.ExecuteUrlHeaders%2A>-Eigenschaft gibt eine leere Auflistung zurück, es sei denn, Sie wird in einer Klasse aufgefüllt, die von der <xref:System.Web.DefaultHttpHandler>-Klasse abgeleitet ist. Die hinzugefügten Header werden an die Auflistung der Header in der Anforderung angehängt, bevor die Anforderung an Internetinformationsdienste (IIS) zurückgegeben wird.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReusable">
      <MemberSignature Language="C#" Value="public virtual bool IsReusable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReusable" />
      <MemberSignature Language="DocId" Value="P:System.Web.DefaultHttpHandler.IsReusable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReusable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReusable : bool" Usage="System.Web.DefaultHttpHandler.IsReusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.IHttpHandler.IsReusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, dass eine andere Anforderung die aktuelle Instanz der <see cref="T:System.Web.DefaultHttpHandler" />-Klasse verwenden kann.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Web.DefaultHttpHandler" /> wiederverwendet werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die <xref:System.Web.DefaultHttpHandler.IsReusable%2A>-Eigenschaft explizit auf `true` oder `false`festzulegen, überschreiben Sie die <xref:System.Web.DefaultHttpHandler.IsReusable%2A>-Eigenschaft.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.DefaultHttpHandler.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnExecuteUrlPreconditionFailure">
      <MemberSignature Language="C#" Value="public virtual void OnExecuteUrlPreconditionFailure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnExecuteUrlPreconditionFailure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.DefaultHttpHandler.OnExecuteUrlPreconditionFailure" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnExecuteUrlPreconditionFailure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnExecuteUrlPreconditionFailure();" />
      <MemberSignature Language="F#" Value="abstract member OnExecuteUrlPreconditionFailure : unit -&gt; unit&#xA;override this.OnExecuteUrlPreconditionFailure : unit -&gt; unit" Usage="defaultHttpHandler.OnExecuteUrlPreconditionFailure " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird aufgerufen, wenn aufgrund von Vorbedingungen das <see cref="T:System.Web.DefaultHttpHandler" />-Objekt eine Anforderung nicht verarbeitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Vorbedingungen werden vom Client in den Anforderungs Header Feldern angegeben und auf dem Webserver ausgewertet. Mithilfe von Vorbedingungen können Clients z. b. verhindern, dass eine angeforderte Methode (z. b. Get) nicht auf die gewünschte Ressource angewendet wird. Weitere Informationen finden Sie in Abschnitt 14, "Header Feld Definitionen" in der Spezifikation " [Hypertext Transfer Protocol--HTTP/1.1](https://go.microsoft.com/fwlink/?LinkID=73147) " auf der World Wide Web Consortium-Website (W3C).

 Die <xref:System.Web.DefaultHttpHandler.OnExecuteUrlPreconditionFailure%2A>-Methode wird aufgerufen, wenn Vorbedingungen das <xref:System.Web.DefaultHttpHandler> Objekt daran hindern, eine Anforderung zu verarbeiten. Eine abgeleitete Klasse kann die <xref:System.Web.DefaultHttpHandler.OnExecuteUrlPreconditionFailure%2A> Methode überschreiben, um eine Ausnahme auszulösen, wenn die Vorbedingungen fehlschlagen. Der <xref:System.Web.DefaultHttpHandler> löst keine Ausnahme in der <xref:System.Web.DefaultHttpHandler.OnExecuteUrlPreconditionFailure%2A>-Methode aus.

 Jede der folgenden Ursachen führt zu einem Fehler bei den Vorbedingungen:

-   Aufrufen von <xref:System.Web.HttpResponse.Write%2A?displayProperty=nameWithType>.

-   Aufrufen von <xref:System.Web.HttpResponse.AddHeader%2A?displayProperty=nameWithType>.

-   Aufrufen von <xref:System.Web.HttpResponse.Flush%2A?displayProperty=nameWithType>.

-   Ändern der Cache Richtlinie für die Antwort.

-   Hinzufügen eines <xref:System.IO.Stream> Objekts als Filter zur <xref:System.Web.HttpResponse.Filter%2A?displayProperty=nameWithType>-Eigenschaft.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverrideExecuteUrlPath">
      <MemberSignature Language="C#" Value="public virtual string OverrideExecuteUrlPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string OverrideExecuteUrlPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.DefaultHttpHandler.OverrideExecuteUrlPath" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OverrideExecuteUrlPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ OverrideExecuteUrlPath();" />
      <MemberSignature Language="F#" Value="abstract member OverrideExecuteUrlPath : unit -&gt; string&#xA;override this.OverrideExecuteUrlPath : unit -&gt; string" Usage="defaultHttpHandler.OverrideExecuteUrlPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überschreibt die Ziel-URL für die aktuelle Anforderung.</summary>
        <returns>Die überschriebene URL, die in der Anforderung verwendet werden soll, oder <see langword="null" />, wenn keine überschriebene URL bereitgestellt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.DefaultHttpHandler.OverrideExecuteUrlPath%2A>-Methode gibt `null` zurück, es sei denn, Sie wird in einer Klasse überschrieben, die von der <xref:System.Web.DefaultHttpHandler>-Klasse abgeleitet ist.

 Die <xref:System.Web.DefaultHttpHandler.OverrideExecuteUrlPath%2A>-Methode wird nur aufgerufen, wenn ASP.net im Arbeitsprozess-Isolations Modus auf IIS 6,0 ausgeführt wird und die Antwort nicht geändert wurde, bevor das <xref:System.Web.DefaultHttpHandler>-Objekt aufgerufen wurde. Die Antwort wird folgendermaßen geändert:

-   Aufrufen von <xref:System.Web.HttpResponse.Write%2A?displayProperty=nameWithType>.

-   Aufrufen von <xref:System.Web.HttpResponse.AddHeader%2A?displayProperty=nameWithType>.

-   Aufrufen von <xref:System.Web.HttpResponse.Flush%2A?displayProperty=nameWithType>.

-   Ändern der Cache Richtlinie für die Antwort.

-   Hinzufügen eines <xref:System.IO.Stream> Objekts als Filter zur <xref:System.Web.HttpResponse.Filter%2A?displayProperty=nameWithType>-Eigenschaft.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessRequest">
      <MemberSignature Language="C#" Value="public virtual void ProcessRequest (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessRequest(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.DefaultHttpHandler.ProcessRequest(System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ProcessRequest (context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessRequest(System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ProcessRequest : System.Web.HttpContext -&gt; unit&#xA;override this.ProcessRequest : System.Web.HttpContext -&gt; unit" Usage="defaultHttpHandler.ProcessRequest context" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.IHttpHandler.ProcessRequest(System.Web.HttpContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context">Ein Objekt, das Verweise auf systeminterne Serverobjekte für HTTP-Anforderungen bereitstellt.</param>
        <summary>Aktiviert zum Verarbeiten der HTTP-Webanforderungen ein <see cref="T:System.Web.DefaultHttpHandler" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.DefaultHttpHandler.ProcessRequest%2A>-Methode sollte nicht synchron aufgerufen werden. Klassen, die von der <xref:System.Web.DefaultHttpHandler>-Klasse abgeleitet werden, können den <xref:System.Web.DefaultHttpHandler.ProcessRequest%2A> überschreiben, um eine angepasste Anforderungs Verarbeitung bereitzustellen.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="M:System.Web.DefaultHttpHandler.ProcessRequest(System.Web.HttpContext)" /> wird synchron aufgerufen.</exception>
        <altmember cref="M:System.Web.IHttpHandler.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
  </Members>
</Type>
