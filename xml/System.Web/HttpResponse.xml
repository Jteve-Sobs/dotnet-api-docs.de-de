<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e5c35c3b043a89e523782cf7d7b7df0d7e814e43" /><Meta Name="ms.sourcegitcommit" Value="f9576bf8c61e3d46834aeeff50f858359f2a99ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/09/2020" /><Meta Name="ms.locfileid" Value="77105613" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <TypeSignature Language="F#" Value="type HttpResponse = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Kapselt HTTP-Antwortinformationen aus einem ASP.NET-Vorgang.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 Die Methoden und Eigenschaften der <xref:System.Web.HttpResponse>-Klasse werden über die <xref:System.Web.HttpApplication.Response%2A>-Eigenschaft der Klassen <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>und <xref:System.Web.UI.UserControl> verfügbar gemacht.

 Die folgenden Methoden der <xref:System.Web.HttpResponse>-Klasse werden nur in Post Back Szenarien und nicht in asynchronen Post Back Szenarien unterstützt:

-   <xref:System.Web.HttpResponse.BinaryWrite%2A>

-   <xref:System.Web.HttpResponse.Clear%2A>

-   <xref:System.Web.HttpResponse.ClearContent%2A>

-   <xref:System.Web.HttpResponse.ClearHeaders%2A>

-   <xref:System.Web.HttpResponse.Close%2A>

-   <xref:System.Web.HttpResponse.End%2A>

-   <xref:System.Web.HttpResponse.Flush%2A>

-   <xref:System.Web.HttpResponse.TransmitFile%2A>

-   <xref:System.Web.HttpResponse.Write%2A>

-   <xref:System.Web.HttpResponse.WriteFile%2A>

-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>

 Teil Seiten Aktualisierungen werden aktiviert, wenn Sie <xref:System.Web.UI.UpdatePanel> Steuerelemente verwenden, um die ausgewählten Bereiche einer Seite zu aktualisieren, anstatt die gesamte Seite mit einem Postback zu aktualisieren. Weitere Informationen finden Sie unter Übersicht über das [Update Panel-Steuer](https://docs.microsoft.com/previous-versions/aspnet/bb386454(v=vs.100)) Element und [Übersicht über das Seiten Rendering](https://docs.microsoft.com/previous-versions/aspnet/bb386573(v=vs.100)).



## Examples
 Im folgenden Beispiel werden drei überlappende Rechtecke gezeichnet, wenn die Seite angefordert wird. Der Code beginnt mit dem Festlegen der <xref:System.Web.HttpResponse.ContentType%2A>-Eigenschaft auf Image/JPEG, sodass die gesamte Seite als JPEG-Bild gerendert wird. Der Code ruft dann die <xref:System.Web.HttpResponse.Clear%2A>-Methode auf, um sicherzustellen, dass mit dieser Antwort kein überflüssiger Inhalt gesendet wird. Als nächstes legt der Code die <xref:System.Web.HttpResponse.BufferOutput%2A>-Eigenschaft auf "true" fest, damit die Seite vollständig verarbeitet wird, bevor Sie an den anfordernden Client gesendet wird. Anschließend werden zwei-Objekte erstellt, die zum Zeichnen der Rechtecke verwendet werden: eine <xref:System.Drawing.Bitmap> und ein <xref:System.Drawing.Graphics>-Objekt. Die auf der Seite erstellten Variablen werden als Koordinaten zum Zeichnen der Rechtecke und einer Zeichenfolge verwendet, die innerhalb des größten Rechtecks angezeigt wird.

 Wenn die drei Rechtecke und die darin angezeigte Zeichenfolge gezeichnet werden, wird der <xref:System.Drawing.Bitmap> im <xref:System.IO.Stream>-Objekt gespeichert, das der <xref:System.Web.HttpResponse.OutputStream%2A>-Eigenschaft zugeordnet ist, und sein Format wird auf JPEG festgelegt. Der Code Ruft die Methoden <xref:System.Drawing.Image.Dispose%2A> und <xref:System.Drawing.Graphics.Dispose%2A> auf, um die Ressourcen freizugeben, die von den beiden Zeichnungsobjekten verwendet werden. Schließlich ruft der Code die <xref:System.Web.HttpResponse.Flush%2A>-Methode auf, um die gepufferte Antwort an den anfordernden Client zu senden.

> [!NOTE]
>  Im Code wird auf das <xref:System.Web.HttpResponse> Objekt durch das Schlüsselwort `Response`verwiesen. `Response.Clear()` bezieht sich z. b. auf die <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType>-Methode. Die <xref:System.Web.UI.Page>-Klasse verfügt über eine Eigenschaft mit dem Namen <xref:System.Web.UI.Page.Response%2A>, die die aktuelle Instanz von <xref:System.Web.HttpResponse>verfügbar macht.

 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpResponse : System.IO.TextWriter -&gt; System.Web.HttpResponse" Usage="new System.Web.HttpResponse writer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Ein <see cref="T:System.IO.TextWriter" />-Objekt, das die benutzerdefinierte HTTP-Ausgabe aktiviert.</param>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Web.HttpResponse" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Dieses Element unterstützt die .NET Framework-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.

 Die Methoden und Eigenschaften der <xref:System.Web.HttpResponse>-Klasse werden über das systeminterne <xref:System.Web.HttpContext.Response%2A>-Objekt in ASP.net verfügbar gemacht.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberSignature Language="F#" Value="member this.AddCacheDependency : System.Web.Caching.CacheDependency[] -&gt; unit" Usage="httpResponse.AddCacheDependency dependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">Eine Datei, ein Cacheschlüssel oder eine <see cref="T:System.Web.Caching.CacheDependency" />, die der Liste mit Anwendungsabhängigkeiten hinzugefügt werden soll.</param>
        <summary>Ordnet der Antwort Cacheabhängigkeiten zu, sodass die Antwort für ungültig erklärt werden kann, wenn sie im Ausgabecache gespeichert ist und sich die angegebenen Abhängigkeiten ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpResponse.AddCacheDependency%2A>-Methode ermöglicht das Erstellen von Abhängigkeiten zwischen zwischengespeicherten Antworten und einem <xref:System.Web.Caching.CacheDependency>-Objekt.



## Examples
 Im folgenden Beispiel wird veranschaulicht, wie eine Cache Abhängigkeit mithilfe der <xref:System.Web.HttpResponse.AddCacheDependency%2A>-Methode und eines <xref:System.Web.Caching.CacheDependency>-Objekts erstellt wird.

 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="dependencies" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Methode wurde zu spät in der Cacheverarbeitungspipeline aufgerufen, nachdem die zwischengespeicherte Antwort bereits erstellt worden war.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/06bh14hk(v=vs.100)">Caching ASP.NET Seiten</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Macht die Gültigkeit einer zwischengespeicherten Antwort von anderen Elementen im Cache abhängig.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Die <see cref="T:System.Collections.ArrayList" /> mit den Schlüsseln der Elemente, von der die gegenwärtig zwischengespeicherte Antwort abhängt.</param>
        <summary>Macht die Gültigkeit einer zwischengespeicherten Antwort von anderen Elementen im Cache abhängig.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn die Elemente, auf die im `cacheKeys`-Parameter verwiesen wird, aus dem Cache entfernt werden, ist die zwischengespeicherte Antwort des aktuellen Elements ungültig.



## Examples
 Im folgenden Beispiel wird veranschaulicht, wie eine ASP.NET Seite verwendet wird, die im Cache ausgegeben wird. Der Code für die Seite erstellt ein <xref:System.Collections.ArrayList> Objekt Schlüssel, die Elementen zugeordnet sind, die im <xref:System.Web.Caching.Cache>-Objekt gespeichert sind. Als nächstes übergibt der Code den <xref:System.Collections.ArrayList> als Parameter in einem aufzurufenden <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> Methode. Dadurch ist die Ausgabe zwischengespeicherten Antworten ungültig, wenn eine der im <xref:System.Collections.ArrayList> angegebenen Dateien geändert wird.

 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/06bh14hk(v=vs.100)">Caching ASP.NET Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : string[] -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Ein Array von Elementschlüsseln, von denen die zwischengespeicherte Antwort abhängt.</param>
        <summary>Macht die Gültigkeit eines zwischengespeicherten Elements von einem anderen Element im Cache abhängig.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn eine der `cacheKey`s aus dem Cache entfernt wird, ist die zwischengespeicherte Antwort des aktuellen Elements ungültig.

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/06bh14hk(v=vs.100)">Caching ASP.NET Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependency : string -&gt; unit" Usage="httpResponse.AddCacheItemDependency cacheKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">Der Schlüssel des Elements, von dem die zwischengespeicherte Antwort abhängt.</param>
        <summary>Macht die Gültigkeit einer zwischengespeicherten Antwort von einem anderen Element im Cache abhängig.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn das Element, das dem `cacheKey`-Parameter entspricht, aus dem Cache entfernt wird, ist die zwischengespeicherte Antwort des aktuellen Elements ungültig.



## Examples
 Das folgende Beispiel ist ein ASP.NET-Benutzer Steuerelement, das als Ausgabe zwischengespeichert wird. Der Code für das-Steuerelement ruft die <xref:System.Web.HttpResponse.AddCacheItemDependency%2A>-Methode mit dem Schlüssel eines Elements auf, das im <xref:System.Web.Caching.Cache> Objekt gespeichert ist, das als sein-Parameter übergeben wird. Wenn das Element nicht im Cache vorhanden ist, wird die im Ausgabe Cache gespeicherte Antwort des Steuer Elements für ungültig erklärt. Dies bedeutet, dass bei der nachfolgenden Anforderung eine neue Version der Antwort des Steuer Elements dem Ausgabe Cache hinzugefügt wird.

 Als nächstes überprüft der Code, ob ein Element, das einem `bookData` Schlüssel zugeordnet ist, im `Cache` Objekt gespeichert wird, und zeigt eine von zwei Textzeilen an, die vom Ergebnis abhängig sind. Anschließend legt der Code die <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A>-Eigenschaft eines <xref:System.Web.UI.WebControls.DataGrid> Steuer Elements mit dem Namen `dgBooks`mit einem aufzurufenden benutzerdefinierten `GetBookData`-Methode der `DataHelper` Klasse fest und füllt den <xref:System.Web.UI.WebControls.DataGrid> mit der <xref:System.Web.UI.Control.DataBind%2A>-Methode auf.

 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/06bh14hk(v=vs.100)">Caching ASP.NET Seiten</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt der Auflistung der Dateinamen, von denen die aktuelle Antwort abhängt, eine Gruppe von Dateinamen hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">Die hinzuzufügende Dateiauflistung.</param>
        <summary>Fügt der Auflistung der Dateinamen, von denen die aktuelle Antwort abhängt, eine Gruppe von Dateinamen hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird eine ASP.NET-Seite dargestellt, die im Cache ausgegeben wird. Der Code für die Seite erstellt eine <xref:System.Collections.ArrayList> von Dateipfaden und übergibt dann die <xref:System.Collections.ArrayList> als Parameter in einem Aufrufen der <xref:System.Web.HttpResponse.AddFileDependencies%2A>-Methode. Dadurch wird die Ausgabe zwischengespeicherten Antworten ungültig, wenn eine der im <xref:System.Collections.ArrayList> angegebenen Dateien geändert wird.

 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/06bh14hk(v=vs.100)">Caching ASP.NET Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : string[] -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filenames">Ein hinzuzufügendes Array von Dateien.</param>
        <summary>Fügt einer Auflistung von Dateinamen, von denen die aktuelle Antwort abhängt, ein Array von Dateinamen hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird ein Array von Dateinamen zur Abhängigkeits Liste <xref:System.Web.HttpResponse.AddFileDependencies%2A> Datei hinzugefügt. Wenn sich die Dateien ändern, wird die zwischengespeicherte Antwort für ungültig erklärt.

 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/06bh14hk(v=vs.100)">Caching ASP.NET Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependency : string -&gt; unit" Usage="httpResponse.AddFileDependency filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Der Name der hinzuzufügenden Datei.</param>
        <summary>Fügt der Auflistung der Dateinamen, von denen die aktuelle Antwort abhängt, einen einzelnen Dateinamen hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn Sie die <xref:System.Web.HttpResponse.AddFileDependency%2A>-Methode zum Hinzufügen einer Datei Abhängigkeit verwenden, müssen Sie den Ausgabe Cache auch Programm gesteuert oder deklarativ angeben. Verwenden Sie z. b. die [@ OutputCache](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/hdxfb6cy(v=vs.100)) -Direktive, um das Ausgabe Caching deklarativ anzugeben. Weitere Informationen finden Sie unter Gewusst [wie: Zwischenspeichern der Seiten Ausgabe mit Datei Abhängigkeiten](https://docs.microsoft.com/previous-versions/aspnet/67z4z916(v=vs.100)).



## Examples
 Im folgenden Beispiel wird gezeigt, wie Sie einen einzelnen Dateinamen zur Abhängigkeits Liste <xref:System.Web.HttpResponse.AddFileDependency%2A> Datei hinzufügen. Wenn sich die Datei ändert, wird die zwischengespeicherte Antwort für ungültig erklärt.

 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/06bh14hk(v=vs.100)">Caching ASP.NET Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des HTTP-Headers, dem <paramref name="value" /> hinzugefügt werden soll.</param>
        <param name="value">Die Zeichenfolge, die dem Header hinzugefügt werden soll.</param>
        <summary>Fügt dem Ausgabestream einen HTTP-Header hinzu. <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> wird bereitgestellt, um die Kompatibilität mit früheren Versionen von ASP zu gewährleisten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.AddHeader%2A> ist identisch mit <xref:System.Web.HttpResponse.AppendHeader%2A> und wird nur aus Gründen der Kompatibilität mit früheren Versionen von ASP bereitgestellt. Verwenden Sie ASP.net mit <xref:System.Web.HttpResponse.AppendHeader%2A>.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnSendingHeaders : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpResponse.AddOnSendingHeaders callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" Index="0" FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Die Rückrufmethode.</param>
        <summary>Registriert einen Rückruf, den die ASP.NET-Laufzeit unmittelbar vor dem Senden der Antwortheader für diese Anforderung aufruft.</summary>
        <returns>Ein <see cref="T:System.Web.ISubscriptionToken" />-Objekt, das ein Abonnement für das OnSendingHeaders-Pseudoereignis darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
>  Die addonsendingheaders-Methode wird nicht aufgerufen, wenn das Native Modul die Antwort zuerst leert.

 Das Pseudo Ereignis "onsendingheaders" unterscheidet sich vom "IHttpModule-Level"-Pipeline Ereignis insofern, als ob es sich um ein Abonnement pro Anforderung anstelle eines anwendungsbezogenen Abonnements handelt. Die Absicht besteht darin, dass der Rückruf den Antwortstatus Code ändern kann oder ein Antwort Cookie oder einen Header festlegen kann. Weitere Verwendungs Hinweise und Einschränkungen:

-   Diese Methode ist nur wirksam, wenn IIS in der integrierten Pipeline Modus-Pipeline ausgeführt wird und nur, wenn noch keine Antwortheader für die aktuelle Anforderung gesendet wurden.

-   Die ASP.NET-Laufzeit garantiert nichts über den Thread, für den der Rückruf aufgerufen wird. Beispielsweise kann der Rückruf synchron in einem Hintergrund Thread aufgerufen werden, wenn eine Hintergrund Leerung ausgeführt wird. Es ist nicht garantiert, dass <xref:System.Web.HttpContext.Current%2A> in einem solchen Thread verfügbar ist.

-   Der Rückruf darf keine Methode aufzurufen, die den Antwort Entitäts Text bearbeitet oder eine Leerung bewirkt. Der Rückruf darf z. b. <xref:System.Web.HttpResponse.Redirect%2A>nicht aufzurufen, da diese Methode den Text der Antwort Entität bearbeiten kann.

-   Der Rückruf darf nur einen synchronen Code mit kurzer Laufzeit enthalten. Der Versuch, einen asynchronen Vorgang aufzurufen oder auf einen solchen Vorgang zu warten, kann zu einem Deadlock führen.

-   Der Rückruf darf keine Ausnahme auslösen. Andernfalls ist das Verhalten nicht definiert.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Das <see cref="T:System.Web.HttpCookie" />, das dem Ausgabestream hinzugefügt werden soll.</param>
        <summary>Fügt der systeminternen Cookieauflistung ein HTTP-Cookie hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird ein neues Cookie mit dem Namen `LastVisit`erstellt, der Wert des Cookies wird auf das aktuelle Datum und die aktuelle Uhrzeit festgelegt, und das Cookie wird an die aktuelle Cookie-Auflistung angefügt. Alle Cookies in der cookiesammlung werden mit dem HTTP-Ausgabestream an den Client im `Set-Cookie`-Header gesendet.

 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wird ein Cookie angefügt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des HTTP-Headers, der dem Ausgabestream hinzugefügt werden soll.</param>
        <param name="value">Die Zeichenfolge, die an den Header angefügt werden soll.</param>
        <summary>Fügt dem Ausgabestream einen HTTP-Header hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn Sie die <xref:System.Web.HttpResponse.AppendHeader%2A>-Methode verwenden, um Cache spezifische Header zu senden, und gleichzeitig das Cache-Objektmodell (<xref:System.Web.HttpResponse.Cache%2A>) verwenden, um die Cache Richtlinie festzulegen, werden möglicherweise HTTP-Antwortheader, die sich auf das Zwischenspeichern (`Cache-Control`, `Expires`, `Last-Modified`, `Pragma`und `Vary`) beziehen, bei Verwendung des Cache Objektmodells gelöscht. Dieses Verhalten ermöglicht ASP.net, die restriktivsten Einstellungen beizubehalten. Stellen Sie sich beispielsweise eine Seite vor, die Benutzer Steuerelemente enthält. Wenn diese Steuerelemente widersprüchliche Cache Richtlinien aufweisen, wird die restriktivste Cache Richtlinie verwendet. Wenn ein Benutzer Steuerelement den Header "`Cache-Control: Public`" festlegt und ein anderes Benutzer Steuerelement den restriktiveren Header "`Cache-Control: Private`" über Aufrufe von <xref:System.Web.HttpCachePolicy.SetCacheability%2A>festlegt, wird der "`Cache-Control: Private`"-Header mit der Antwort gesendet.

 Eine Liste der HTTP/1.1-Standard Header finden Sie in Abschnitt 14, "Header Feld Definitionen" in der Spezifikation " [Hypertext Transfer Protocol--HTTP/1.1](https://go.microsoft.com/fwlink/?LinkID=73147) " auf der World Wide Web Consortium-Website (W3C).



## Examples
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.AppendHeader%2A>-Methode aufgerufen, um dem an den anfordernden Client gesendeten <xref:System.Web.HttpResponse> Objekt einen benutzerdefinierten Header hinzuzufügen.

 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der Header wurde nach dem Senden der HTTP-Header hinzugefügt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberSignature Language="F#" Value="member this.AppendToLog : string -&gt; unit" Usage="httpResponse.AppendToLog param" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">Der Text, der der Protokolldatei hinzugefügt werden soll.</param>
        <summary>Fügt der IIS-Protokolldatei (Internetinformationsdienste) benutzerdefinierte Protokollinformationen hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Damit die angegebene Zeichenfolge in der Protokolldatei aufgezeichnet werden kann, müssen Sie zuerst die Option **URI-Abfrage** im Dialogfeld **Erweiterte Protokollierungs Eigenschaften** für den Standort aktivieren, für den Sie die Aktivität in IIS protokollieren möchten.

 Führen Sie die folgenden Schritte aus, um die erweiterte Protokollierung in IIS 6,0 anzupassen:

1.  Erweitern Sie im IIS-Manager den Knoten Lokaler Computer, erweitern Sie den Ordner Web oder FTP Sites, klicken Sie mit der rechten Maustaste auf die Web-oder FTP-Website, und klicken Sie dann auf **Eigenschaften**.

2.  Klicken Sie auf die Registerkarte **Web-oder FTP-Website** , und aktivieren Sie dann das Kontrollkästchen **Protokollierung aktivieren** (sofern nicht bereits ausgewählt).

3.  Klicken Sie im Feld **aktives Protokoll Format** auf das **Erweiterte W3C-Protokolldatei Format**.

4.  Klicken Sie auf **Eigenschaften**.

5.  Klicken Sie auf die Registerkarte **erweitert** , wählen Sie die Eigenschaften aus, die Sie protokollieren möchten, und klicken Sie dann auf **OK**.



## Examples
 Im folgenden Beispiel wird gezeigt, wie eine Zeichenfolge an das Protokoll angefügt wird.

 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=36829">Windows Server 2003-Produkt Hilfe</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.ApplyAppPathModifier : string -&gt; string" Usage="httpResponse.ApplyAppPathModifier virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Der virtuelle Pfad zu einer Ressource.</param>
        <summary>Fügt dem virtuellen Pfad eine Sitzungs-ID hinzu, wenn für die Sitzung ein <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" />-Sitzungszustand verwendet wird, und gibt den kombinierten Pfad zurück. Wenn der <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" />-Sitzungszustand nicht verwendet wird, gibt <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> den ursprünglichen virtuellen Pfad zurück.</summary>
        <returns>Der <paramref name="virtualPath" /> mit der eingefügten Sitzungs-ID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> wird nur mit cookischlosen Sitzungen verwendet, um absolute HREFs zu erstellen.



## Examples
 Im folgenden Beispiel wird eine Zeichen folgen Variable mit dem Namen `urlConverted`deklariert und auf das Ergebnis eines <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> Methoden Aufrufes festgelegt. Der Code übergibt dann den Wert der Variablen an die <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A>-Eigenschaft eines <xref:System.Web.UI.WebControls.HyperLink> Steuer Elements.

 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlush : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpResponse.BeginFlush (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Das Rückrufobjekt.</param>
        <param name="state">Antwortstatus.</param>
        <summary>Sendet die gesamte gegenwärtig gepufferte Antwort an den Client.</summary>
        <returns>Das asynchrone Ergebnisobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn das zugrunde liegende <xref:System.Web.HttpWorkerRequest>-Objekt asynchrone Leerungs Vorgänge unterstützt und diese Methode von einem asynchronen Modul Ereignis oder von einem asynchronen Handler aufgerufen wird, wird der Löschvorgang asynchron ausgeführt. Andernfalls wird der Leerungs Vorgang synchron ausgeführt. Asynchronous Flush wird für IIS 6,0 und höher unterstützt.

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die Antwort wurde bereits abgeschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.BinaryWrite : byte[] -&gt; unit" Usage="httpResponse.BinaryWrite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Die Bytes, die in den Ausgabestream geschrieben werden sollen.</param>
        <summary>Schreibt eine Zeichenfolge von Binärzeichen in den HTTP-Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird eine Textdatei in einen Puffer gelesen und der Puffer in den HTTP-Ausgabestream geschrieben.

 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Ausgabe gepuffert und nach der vollständigen Verarbeitung der Antwort gesendet werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Ausgabe an den Client gepuffert wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpResponse.Buffer%2A>-Eigenschaft ist zugunsten der <xref:System.Web.HttpResponse.BufferOutput%2A>-Eigenschaft veraltet und wird nur aus Gründen der Kompatibilität mit früheren Versionen von ASP bereitgestellt. Verwenden Sie ASP.net mit <xref:System.Web.HttpResponse.BufferOutput%2A>.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BufferOutput : bool with get, set" Usage="System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Ausgabe gepuffert und nach der vollständigen Verarbeitung der Seite gesendet werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Ausgabe an den Client gepuffert wird, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.ContentType%2A>-Eigenschaft für die Antwort auf Image/JPEG festgelegt, die <xref:System.Web.HttpResponse.Clear%2A>-Methode aufgerufen, um andere Inhalte zu entfernen, die möglicherweise an die Antwort angefügt sind. Anschließend wird die <xref:System.Web.HttpResponse.BufferOutput%2A>-Eigenschaft auf true festgelegt, sodass die gesamte Seite verarbeitet wird, bevor Inhalte an den anfordernden Client gesendet werden.

 Ein umfassendes Beispiel finden Sie in der <xref:System.Web.HttpResponse>-Klasse.

 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.HttpCachePolicy" Usage="System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Cachingrichtlinie für eine Webseite ab, d. h. Ablaufzeit, Datenschutzeinstellungen und Variationsklauseln.</summary>
        <value>Ein <see cref="T:System.Web.HttpCachePolicy" />-Objekt, das Informationen zur Cachingrichtlinie für die aktuelle Antwort enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel werden die Eigenschaften der aktuellen Cache Richtlinie in den HTTP-Ausgabestream geschrieben.

 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheControl : string with get, set" Usage="System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see langword="Cache-Control" />-HTTP-Header ab, der mit einem der <see cref="T:System.Web.HttpCacheability" />-Enumerationswerte übereinstimmt, oder legt diesen fest.</summary>
        <value>Eine Zeichenfolgendarstellung des <see cref="T:System.Web.HttpCacheability" />-Enumerationswerts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die Werte für `Private`, `Public`und `No-Cache` sind Zeichen folgen und müssen in Anführungszeichen ("") eingeschlossen werden. Wenn die <xref:System.Web.HttpResponse.CacheControl%2A>-Eigenschaft auf einen Wert festgelegt ist, der nicht mit einem der <xref:System.Web.HttpCacheability> Enumerationswerte identisch ist, wird eine <xref:System.ArgumentException> ausgelöst. Wenn die <xref:System.Web.HttpResponse.CacheControl%2A>-Eigenschaft nicht festgelegt ist, wird die Cache Fähigkeit der Antwort auf <xref:System.Web.HttpCacheability.NoCache>festgelegt.

 Die Eigenschaften `CacheControl`, <xref:System.Web.HttpResponse.Expires%2A>und <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> sind veraltet. Stattdessen sind die Methoden der <xref:System.Web.HttpCachePolicy>-Klasse über das systeminterne <xref:System.Web.HttpResponse.Cache%2A> Objekt verfügbar, um den Internetinformationsdienste (IIS)-Ausgabe Cache und die Client Caches zu steuern.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der festgelegte Zeichenfolgenwert stimmt nicht mit einem der <see cref="T:System.Web.HttpCacheability" />-Enumerationswerte überein.</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Charset : string with get, set" Usage="System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den HTTP-Zeichensatz des Ausgabestreams ab oder legt diesen fest.</summary>
        <value>Der HTTP-Zeichensatz des Ausgabestreams.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die `Charset`-Eigenschaft kann auf `null` festgelegt werden, um den HTTP-`Content-Type`-Header zu unterdrücken.



## Examples
 Im folgenden Beispiel wird überprüft, ob der Zeichensatz des Ausgabestreams Mitteleuropäisch (ISO) ist.

 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die <see langword="Charset" />-Eigenschaft wurde nach dem Senden von Headern festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="httpResponse.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Inhaltsausgaben aus dem Pufferstream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpResponse.Clear%2A>-Methode löscht keine Header Informationen.



## Examples
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.ContentType%2A>-Eigenschaft für die Antwort auf Image/JPEG festgelegt, die <xref:System.Web.HttpResponse.Clear%2A>-Methode aufgerufen, um andere Inhalte zu entfernen, die möglicherweise an die Antwort angefügt sind. Anschließend wird die <xref:System.Web.HttpResponse.BufferOutput%2A>-Eigenschaft auf true festgelegt, sodass die gesamte Seite verarbeitet wird, bevor Inhalte an den anfordernden Client gesendet werden.

 Ein umfassendes Beispiel finden Sie in der <xref:System.Web.HttpResponse>-Klasse.

 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="httpResponse.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Inhaltsausgaben aus dem Pufferstream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpResponse.ClearContent%2A>-Methode löscht keine Header Informationen.



## Examples
 Im folgenden Beispiel wird der gesamte Inhalt aus dem Pufferstream gelöscht.

 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberSignature Language="F#" Value="member this.ClearHeaders : unit -&gt; unit" Usage="httpResponse.ClearHeaders " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Header aus dem Pufferstream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.ClearHeaders%2A>-Methode aufgerufen, um sicherzustellen, dass keine Header mit der aktuellen Antwort gesendet werden. Dieses Verfahren kann besonders wichtig sein, wenn die ASP.net-Antwort ein Bild erzeugt, z. b. eine JPEG-Datei. In diesem Beispiel wird die <xref:System.Web.HttpResponse.ContentType%2A>-Eigenschaft auf Image/JPEG festgelegt.

 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die Header wurden nach dem Senden der HTTP-Header gelöscht.</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientDisconnectedToken : System.Threading.CancellationToken" Usage="System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Threading.CancellationToken" />-Objekt ab, das aktiviert wird, wenn der Client die Verbindung trennt.</summary>
        <value>Das Abbruchtoken.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese API ist Thread sicher. Es gibt jedoch einige Einschränkungen hinsichtlich der Verwendung des Abbruch Tokens. Eine falsche Verwendung kann zu Racebedingungen, Deadlocks oder anderem unerwartetem Verhalten führen. Beachten Sie die folgenden Richtlinien:

-   Stellen Sie sicher, dass diese API nicht außerhalb der Grenzen einer einzelnen Anforderung aufgerufen wird, da ASP.NET das Abbruch Token am Ende der Anforderung löscht. Es gibt keine Garantie, dass das Token jemals in den Zustand "abgebrochen" übergeht, bevor es verworfen wird. Wenn die Anforderung z. b. beendet wird, ohne dass der Client getrennt wurde, wird das Token verworfen, ohne dass es zuerst abgebrochen wurde.

-   Warten Sie nicht auf den <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>, da dadurch der Zweck einer asynchronen Benachrichtigung und Deadlocks verursacht werden.

-   Rufen Sie die <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> Überladungen, die den Rückruf für das ursprüngliche <xref:System.Threading.SynchronizationContext> Objekt aufrufen, nicht auf.

-   Verwenden Sie das <xref:System.Web.HttpContext>-Objekt oder andere nicht Thread sichere ASP.NET-Objekte nicht innerhalb des Rückrufs, der für die <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType>-Methode bereitgestellt wird. Der Rückruf kann gleichzeitig mit anderem ASP.net-oder Anwendungscode ausgeführt werden.

-   Halten Sie die Rückruf Methoden mit kurzer Laufzeit und ohne Blockierung.

-   Machen Sie alle Anstrengungen, um zu vermeiden, dass Ausnahmen innerhalb der Rückruf Methoden ausgelöst werden.

 Diese Eigenschaft wird nur in Internet Informationsdienste (IIS) 7,5 oder höher im integrierten Modus unterstützt. Wenn Sie die Anwendung ohne die richtige IIS-Version oder den richtigen Pipeline Modus aufrufen, wird eine <xref:System.PlatformNotSupportedException> ausgelöst. Verwenden Sie <xref:System.Web.HttpRuntime.IISVersion%2A>, um die IIS-Version zu ermitteln. Verwenden Sie <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>, um den Pipeline Modus zu bestimmen.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die Socketverbindung zu einem Client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode beendet die Verbindung mit dem Client auf abrupte Weise und ist nicht für die normale Verarbeitung von HTTP-Anforderungen vorgesehen. Die-Methode sendet ein Zurücksetzungs Paket an den Client, das dazu führen kann, dass Antwortdaten, die auf dem Server, dem Client oder irgendwo dazwischen gepuffert werden, gelöscht werden.

 In der Regel sollten Sie jedoch <xref:System.Web.HttpApplication.CompleteRequest%2A> aufrufen, wenn Sie zum <xref:System.Web.HttpApplication.EndRequest>-Ereignis springen und eine Antwort an den Client senden möchten.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den HTTP-Zeichensatz des Ausgabestreams ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Text.Encoding" />-Objekt, das Informationen über den Zeichensatz für die aktuelle Antwort enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Standard `ContentEncoding` können in einer ASP.NET-Konfigurationsdatei im Abschnitt [globalization-Element (ASP.NET Settings Schema)](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/hy4kkhe0(v=vs.100)) angegeben werden. Wenn <xref:System.Web.HttpResponse.ContentEncoding%2A> vom Client angegeben wird, werden die Standard Konfigurationseinstellungen überschrieben.



## Examples
 Im folgenden Beispiel wird eine lesbare Beschreibung der Zeichensatz Codierung in den Ausgabestream geschrieben.

 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Es wurde versucht, <see cref="P:System.Web.HttpResponse.ContentEncoding" /> auf <see langword="null" /> festzulegen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den HTTP-MIME-Typ des Ausgabestreams ab oder legt diesen fest.</summary>
        <value>Der HTTP-MIME-Typ des Ausgabestreams. Der Standardwert ist „<see langword="text/html" />“.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.ContentType%2A>-Eigenschaft für die Antwort auf Image/JPEG festgelegt, die <xref:System.Web.HttpResponse.Clear%2A>-Methode aufgerufen, um andere Inhalte zu entfernen, die möglicherweise an die Antwort angefügt sind. Anschließend wird die <xref:System.Web.HttpResponse.BufferOutput%2A>-Eigenschaft auf true festgelegt, sodass die gesamte Seite verarbeitet wird, bevor Inhalte an den anfordernden Client gesendet werden.

 Ein umfassendes Beispiel finden Sie in der <xref:System.Web.HttpResponse>-Klasse.

 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die <see cref="P:System.Web.HttpResponse.ContentType" />-Eigenschaft ist auf <see langword="null" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Cookieauflistung der Antwort ab.</summary>
        <value>Die Cookieauflistung der Antwort.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET enthält zwei systeminterne Cookie-Auflistungen. Die Auflistung, auf die über die <xref:System.Web.HttpRequest.Cookies%2A>-Auflistung von <xref:System.Web.HttpRequest> zugegriffen wird, enthält Cookies, die vom Client an den Server im `Cookie`-Header übertragen werden. Die Auflistung, auf die über die <xref:System.Web.HttpResponse.Cookies%2A> Auflistung von <xref:System.Web.HttpResponse> zugegriffen wird, enthält neue Cookies, die auf dem Server erstellt und im `Set-Cookie` Header an den Client übermittelt werden.

 Nachdem Sie mithilfe der <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> Auflistung ein Cookie hinzugefügt haben, ist das Cookie sofort in der <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> Auflistung verfügbar, auch wenn die Antwort nicht an den Client gesendet wurde.



## Examples
 Im folgenden Beispiel wird ein neues Cookie mit dem Namen `LastVisit`erstellt, der Wert des Cookies wird auf das aktuelle Datum und die aktuelle Uhrzeit festgelegt, und das Cookie wird der aktuellen Cookie-Auflistung hinzugefügt. Alle Cookies in der cookiesammlung werden mit dem HTTP-Ausgabestream an den Client im `Set-Cookie`-Header gesendet.

 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberSignature Language="F#" Value="member this.DisableKernelCache : unit -&gt; unit" Usage="httpResponse.DisableKernelCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deaktiviert die Kernelzwischenspeicherung für die aktuelle Antwort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn Kernel Caching nicht unterstützt wird, hat diese Methode keine Auswirkungen.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberSignature Language="F#" Value="member this.DisableUserCache : unit -&gt; unit" Usage="httpResponse.DisableUserCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deaktiviert IIS-Benutzermodus-Caching für diese Antwort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn das Zwischenspeichern des IIS-Benutzermodus nicht unterstützt wird, gibt diese Methode zurück, ohne eine Aktion auszuführen.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberSignature Language="F#" Value="member this.End : unit -&gt; unit" Usage="httpResponse.End " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sendet alle derzeit gepufferten Ausgaben an den Client, beendet die Ausführung der Seite und löst das <see cref="E:System.Web.HttpApplication.EndRequest" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird nur aus Gründen der Kompatibilität mit ASP bereitgestellt, d. h. aus Kompatibilitätsgründen mit der com-basierten webprogrammier Technologie, die ASP.net voransteht. Wenn Sie zum <xref:System.Web.HttpApplication.EndRequest> Ereignis springen und eine Antwort an den Client senden möchten, ist es in der Regel vorzuziehen, stattdessen <xref:System.Web.HttpApplication.CompleteRequest%2A> aufzurufen.

 Um das Verhalten der `End`-Methode in ASP zu imitieren, versucht diese Methode, eine <xref:System.Threading.ThreadAbortException>-Ausnahme zu. Wenn dieser Versuch erfolgreich ist, wird der aufrufende Thread abgebrochen, was die Leistung Ihrer Website beeinträchtigt. In diesem Fall wird nach dem Abrufen der <xref:System.Web.HttpResponse.End%2A>-Methode kein Code ausgeführt.

 Wenn die <xref:System.Web.HttpResponse.End%2A>-Methode nicht in der Lage ist, eine <xref:System.Threading.ThreadAbortException>aufzurichten, leert Sie stattdessen die Antwort Bytes an den Client. Dies erfolgt synchron, was auch die Leistung Ihrer Website beeinträchtigt.

 In beiden Fällen (unabhängig davon, ob eine <xref:System.Threading.ThreadAbortException> Ausnahme erfolgreich ausgelöst wurde) springt die Antwort Pipeline zum <xref:System.Web.HttpApplication.EndRequest>-Ereignis.

 Die <xref:System.Web.HttpApplication.CompleteRequest%2A>-Methode gibt keine Ausnahme aus, und Code, nachdem der <xref:System.Web.HttpApplication.CompleteRequest%2A> Methode aufgerufen wurde, kann ausgeführt werden. Wenn Sie beabsichtigen, die Ausführung des nachfolgenden Codes zu vermeiden, und wenn die Leistungs Einbuße <xref:System.Web.HttpResponse.End%2A> akzeptabel ist, können Sie <xref:System.Web.HttpResponse.End%2A> anstelle von <xref:System.Web.HttpApplication.CompleteRequest%2A>aufzurufen.

 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">Der Aufruf von <see cref="M:System.Web.HttpResponse.End" /> hat die aktuelle Anforderung beendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndFlush : IAsyncResult -&gt; unit" Usage="httpResponse.EndFlush asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das asynchrone Ergebnisobjekt.</param>
        <summary>Schließt eine asynchrone Leerung ab.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Asynchroner Löschvorgang wird nicht unterstützt und der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Asynchroner Löschvorgang wird nicht unterstützt, und der <paramref name="asyncResult" />-Parameter kann nicht in ein <c>FlushAsyncResult</c>-Objekt umgewandelt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Expires : int with get, set" Usage="System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Minuten ab, nach denen eine im Browser zwischengespeicherte Seite abläuft, oder legt diese fest. Wenn der Benutzer zur selben Seite zurückkehrt, bevor diese abgelaufen ist, wird die zwischengespeicherte Version angezeigt. <see cref="P:System.Web.HttpResponse.Expires" /> wird bereitgestellt, um die Kompatibilität mit früheren Versionen von ASP zu gewährleisten.</summary>
        <value>Die Anzahl von Minuten, nach denen die Seite abläuft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die Eigenschaften `Expires`, <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> und <xref:System.Web.HttpResponse.CacheControl%2A> sind zugunsten der Methoden der <xref:System.Web.HttpCachePolicy> Klasse veraltet, die durch das <xref:System.Web.HttpResponse.Cache%2A> intrinsische Objekt verfügbar sind, um den Internetinformationsdienste (IIS)-Ausgabe Cache und die Client Caches zu steuern.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ExpiresAbsolute : DateTime with get, set" Usage="System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das absolute Datum und die Uhrzeit ab, zu der die zwischengespeicherten Informationen aus dem Cache entfernt werden sollen, oder legt diese fest. <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> wird bereitgestellt, um die Kompatibilität mit früheren Versionen von ASP zu gewährleisten.</summary>
        <value>Das Datum und die Uhrzeit für das Ablaufen der Seite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die Eigenschaften `ExpiresAbsolute`, <xref:System.Web.HttpResponse.Expires%2A>und <xref:System.Web.HttpResponse.CacheControl%2A> sind zugunsten der Methoden der <xref:System.Web.HttpCachePolicy> Klasse veraltet, die durch das <xref:System.Web.HttpResponse.Cache%2A> intrinsische Objekt verfügbar sind, um den Internetinformationsdienste (IIS)-Ausgabe Cache und die Client Caches zu steuern.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Wrappingfilterobjekt ab, das den HTTP-Entitätstext vor der Übertragung ändern soll, oder legt dieses fest.</summary>
        <value>Das <see cref="T:System.IO.Stream" />-Objekt, das als Ausgabefilter verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn Sie ein `Stream` Objekt erstellen und die <xref:System.Web.HttpResponse.Filter%2A>-Eigenschaft auf das `Stream`-Objekt festlegen, übergibt die gesamte von <xref:System.Web.HttpResponse.Write%2A> gesendete HTTP-Ausgabe den Filter.



## Examples
 Das folgende Beispiel zeigt eine ASP.NET-Seite, die die <xref:System.Web.HttpResponse.Filter%2A>-Eigenschaft auf eine neue Instanz der `UpperCaseFilter`-Klasse festlegt, eine benutzerdefinierte <xref:System.IO.Stream> Klasse, die den gesamten Text konvertiert, der Sie an Großbuchstaben übergibt. Die Informationen zur Anforderung werden in einer Textdatei gespeichert, und dann wird die <xref:System.Web.HttpResponse.Filter%2A>-Eigenschaft festgelegt. Nachdem der Antwort Filter vorhanden ist, ruft der Code die <xref:System.Web.HttpRequest.MapPath%2A>-Methode auf, um den absoluten Pfad zu einer Textdatei mit dem Namen `TestFile.txt` zu erhalten, die als Quelle für den Inhalt der Antwort fungiert. Der Code erstellt dann ein neues <xref:System.IO.StreamReader> Objekt, um die Textdatei von Anfang bis Ende zu lesen, und ruft dann die <xref:System.Web.HttpResponse.Write%2A>-Methode auf, um den Inhalt der Datei auf der Seite anzuzeigen.

 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Filtern ist bei der Entität nicht zulässig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="httpResponse.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sendet die gesamte gegenwärtig gepufferte Ausgabe an den Client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Erzwingt, dass die gesamte aktuell gepufferte Ausgabe an den Client gesendet wird. Die <xref:System.Web.HttpResponse.Flush%2A>-Methode kann während der Anforderungs Verarbeitung mehrmals aufgerufen werden.



## Examples
 Im folgenden Beispiel wird die <xref:System.Drawing.Graphics.Save%2A>-Methode aufgerufen, um ein <xref:System.Drawing.Bitmap> Objekt in der <xref:System.Web.HttpResponse.OutputStream%2A>-Eigenschaft zu speichern und das Bild in das JPEG-Format zu konvertieren. Der Code ruft dann die `Dispose`-Methode für das <xref:System.Drawing.Bitmap>-Objekt und ein <xref:System.Drawing.Graphics>-Objekt auf und gibt die Ressourcen frei, die Sie verwendet haben. Anschließend wird die <xref:System.Web.HttpResponse.Flush%2A>-Methode aufgerufen, um den Inhalt der Antwort an den anfordernden Client zu senden.

 Ein umfassendes Beispiel finden Sie in der <xref:System.Web.HttpResponse>-Klasse.

 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der Antwort wird der Cache entleert.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpResponse.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sendet die gesamte gegenwärtig gepufferte Ausgabe asynchron an den Client.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Text.Encoding" />-Objekt ab, das die Codierung für den aktuellen Headerausgabestream darstellt, oder legt dieses fest.</summary>
        <value><see cref="T:System.Text.Encoding" /> mit Informationen zum Zeichensatz für den aktuellen Header.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Mit der <xref:System.Web.HttpResponse.HeaderEncoding%2A>-Eigenschaft können Sie das <xref:System.Text.Encoding>-Objekt in einem Antwortheader mit dem <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF7Encoding>oder <xref:System.Text.UTF8Encoding> Objekt deaktivieren oder ändern. Der Standard Codierungs Wert ist die <xref:System.Text.UTF8Encoding>-Klasse.

 Wenn Sie den Typ der <xref:System.Web.HttpResponse.HeaderEncoding%2A> Eigenschaft ändern, können Sie potenziell das Risiko bestimmter böswilliger Angriffe erhöhen oder dazu führen, dass sensible Daten über den Antwortheader gesendet werden. Header einschleusungs Angriffe können teilweise vermieden werden, indem die <xref:System.Web.HttpResponse.HeaderEncoding%2A>-Eigenschaft einer Antwort auf die Standardeinstellung belassen wird. Ein Angriff auf eine anfällige Anwendung könnte vertraute Daten als Teil eines Antwort Headers zurückgeben. Wenn die <xref:System.Web.HttpResponse.HeaderEncoding%2A> aufgrund einer Anforderung an Fortsetzungs Zeilen in einem Header deaktiviert ist oder wenn ein Header basierend auf dem Ergebnis nicht vertrauenswürdiger Daten erstellt wird, sollten die Header Daten vor dem Senden an den Antwortstream überprüft werden.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Codierungswert ist <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Der Codierungswert ist <see cref="P:System.Text.Encoding.Unicode" />.

Oder

Die Header wurden bereits gesendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung von Antwortheadern ab.</summary>
        <value>Eine <see cref="T:System.Collections.Specialized.NameValueCollection" /> von Antwortheadern.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpResponse.Headers%2A>-Eigenschaft wird nur mit dem [!INCLUDE[iisver](~/includes/iisver-md.md)] integrierten Pipeline Modus und mindestens dem .NET Framework 3,0 unterstützt. Wenn Sie versuchen, auf die <xref:System.Web.HttpResponse.Headers%2A>-Eigenschaft zuzugreifen, und eine der beiden Bedingungen nicht erfüllt ist, wird eine <xref:System.PlatformNotSupportedException> ausgelöst.

 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Der Vorgang erfordert den integrierten Pipelinemodus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und mindestens .NET Framework Version 3.0.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=86952">Aktualisieren von ASP.NET-Anwendungen auf IIS 7,0: Unterschiede zwischen dem integrierten IIS 7,0-Modus und dem klassischen Modus</related>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HeadersWritten : bool" Usage="System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Antwortheader geschrieben wurden.</summary>
        <value><see langword="true" />, wenn die Antwortheader geschrieben wurden, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClientConnected : bool" Usage="System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Client noch mit dem Server verbunden ist.</summary>
        <value><see langword="true" />, wenn der Client gegenwärtig mit dem Server verbunden ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpResponse.IsClientConnected%2A>-Eigenschaft gibt `false` zurück, wenn die folgenden Bedingungen zutreffen:

-   Die Verbindung mit dem Client wurde beendet. Dies kann vorkommen, wenn die <xref:System.Web.HttpResponse.Close%2A>-Methode aufgerufen wurde oder wenn der Client die Ausführung der Webseite beendet oder zu einer anderen Seite durchsucht hat.

-   Das <xref:System.Web.HttpWorkerRequest> Objekt, das die Anforderung verarbeitet, ist `null`, oder die <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> Methode gibt `false`zurück. Wenn ein benutzerdefiniertes <xref:System.Web.HttpWorkerRequest> Objekt die Anforderung verarbeitet, kann die <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType>-Methode basierend auf benutzerdefinierten Kriterien festgelegt werden. Beispielsweise kann die benutzerdefinierte Workeranforderung ein Timeout nach einem bestimmten Zeitraum erzwingen.



## Examples
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.IsClientConnected%2A>-Eigenschaft verwendet, um zu überprüfen, ob der Client, der die Seite anfordert, mit dem Server verbunden bleibt. Wenn <xref:System.Web.HttpResponse.IsClientConnected%2A> true ist, ruft der Code die <xref:System.Web.HttpResponse.Redirect%2A>-Methode auf, und der Client zeigt eine andere Seite an. Wenn <xref:System.Web.HttpResponse.IsClientConnected%2A> false ist, ruft der Code die <xref:System.Web.HttpResponse.End%2A>-Methode auf, und die gesamte Seiten Verarbeitung wird beendet.

 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequestBeingRedirected : bool" Usage="System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob der Client an eine neue Adresse weitergeleitet wird.</summary>
        <value><see langword="true" />, wenn der Wert des Antwortheaders der Adresse sich von der aktuellen Adresse unterscheidet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Verwenden Sie die <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A>-Eigenschaft mit der <xref:System.Web.HttpResponse.RedirectLocation%2A>-Eigenschaft, um zu testen und zu bestimmen, ob der absolute URI, der an den Client im http-`Location` Header übertragen wird, vom aktuellen URI abweicht und der neue beabsichtigte URI, der an übertragen wird, ist.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Output As TextWriter" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter" Usage="System.Web.HttpResponse.Output" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter with get, set" Usage="System.Web.HttpResponse.Output" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aktiviert die Ausgabe von Text an den ausgehenden HTTP-Antwortstream.</summary>
        <value>Ein <see cref="T:System.IO.TextWriter" />-Objekt, das benutzerdefinierte Ausgaben an den Client ermöglicht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Das folgende Beispiel ist eine ASP.NET Seite, die ein <xref:System.Web.UI.WebControls.TextBox> Steuerelement enthält, dessen <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>-Eigenschaft auf <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>festgelegt ist. Der Code der Seite verwendet den Text, den ein Benutzer im <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>eingibt, verwendet die <xref:System.Web.HttpServerUtility.HtmlEncode%2A>-Methode, um ihn zu codieren, und die <xref:System.Web.HttpResponse.Output%2A>-Eigenschaft, um die codierte Zeichenfolge auf der Seite anzuzeigen.

 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ermöglicht die binäre Ausgabe an den ausgehenden HTTP-Inhaltstext.</summary>
        <value>Ein E/A-<see cref="T:System.IO.Stream" />-Objekt, das den Rohdateninhalt des ausgehenden HTTP-Inhaltstexts darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Beginnend mit der .NET Framework Version 2,0, wenn Sie die <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>-Methode des e/a-Streams verwenden, der von der <xref:System.Web.HttpResponse.OutputStream%2A>-Eigenschaft zurückgegeben wird, werden möglicherweise die folgenden Ausnahmen ausgelöst:

-   <xref:System.ArgumentOutOfRangeException>, wenn der `offset`-oder `count`-Parameter negativ ist oder wenn die Länge des `buffer` Parameters abzüglich des `offset`-Parameters kleiner oder gleich 0 (null) ist.

-   <xref:System.ArgumentNullException>, wenn der `buffer` Parameter `null`ist.



## Examples
 Im folgenden Beispiel wird die <xref:System.Drawing.Image.Save%2A>-Methode aufgerufen, um ein <xref:System.Drawing.Bitmap> Objekt in der <xref:System.Web.HttpResponse.OutputStream%2A>-Eigenschaft zu speichern, und das Bild wird in das JPEG-Format konvertiert. Der Code ruft dann die verwerfen-Methode für das <xref:System.Drawing.Bitmap>-Objekt und ein <xref:System.Drawing.Graphics>-Objekt auf und gibt die Ressourcen frei, die Sie verwendet haben. Schließlich ruft der Code die <xref:System.Web.HttpResponse.Flush%2A>-Methode auf, um den Inhalt der Antwort an den anfordernden Client zu senden.

 Ein umfassendes Beispiel finden Sie in der <xref:System.Web.HttpResponse>-Klasse.

 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="OutputStream" /> ist nicht verfügbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Pics : string -&gt; unit" Usage="httpResponse.Pics value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die dem Header mit <see langword="PICS-Label" /> hinzugefügt werden soll.</param>
        <summary>Fügt einen HTTP-Header mit <see langword="PICS-Label" /> an den Ausgabestream an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die Plattform für die Internet Inhalts Auswahl (Fotos) ist ein World Wide Web Consortium (W3C)-Standard für die Inhalts Bezeichnung. Fotos ist im Wesentlichen eine Sprache zum Erstellen eines Bewertungssystems.

 Jeder Wert kann eine Bilder Bezeichnung sein. ASP.NET überprüft die Bezeichnung nicht. Die maximale Länge der Zeichenfolge beträgt 255 Zeichen. Weitere Informationen zu den Standard-und Syntax Informationen von Bildern finden Sie auf der [World Wide Web Consortium](https://go.microsoft.com/fwlink/?LinkID=37125) -Website.



## Examples
 Das folgende Beispiel zeigt eine ASP.NET-Seite, auf der ein Bild angezeigt wird. Der Seitencode Ruft die <xref:System.Web.HttpResponse.Pics%2A>-Methode auf, um den HTTP-`PICS-Label`-Header für die Antwort festzulegen. Die Zeichenfolge, die als Parameter an die <xref:System.Web.HttpResponse.Pics%2A>-Methode übergeben wird, stellt eine Bewertungs Bezeichnung dar, die von der ICRA-Website (Internet Content Rating Association) generiert wird.

 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stuft ein zugesichertes Objekt herauf.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string -&gt; unit" Usage="httpResponse.PushPromise path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Die URL der Pushanforderung. Dies sollte der virtuelle Pfad der relativen Ressource sein, die der Server auf den Client pushen soll.</param>
        <summary>Diese API dient zur Unterstützung von Anwendungen, die Pushzusagen an HTTP 2.0-Clients senden. Weitere Informationen zu HTTP 2-Serverpushvorgängen finden Sie unter <see href="https://http2.github.io/http2-spec/#PushResources">HTTP/2 Specification Section 8.2: Server Push</see>.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Pushpromise ist nicht deterministisch, und Anwendungen sollten keine Logik aufweisen, die von ihr abhängt. Der einzige Zweck ist der Leistungsvorteil in einigen Fällen. Es gibt viele Bedingungen (Protokoll und Implementierung), die dazu führen können, dass die pushanforderungen vollständig ignoriert werden. Die Annahme basiert auf "Fire-and-Forget".

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpResponse.PushPromise (path, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="2" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Die URL der Pushanforderung. Dies sollte der virtuelle Pfad der relativen Ressource sein, die der Server auf den Client pushen soll.</param>
        <param name="method">HTTP-Anforderungsmethode, die von der Pushanforderung verwendet wird.</param>
        <param name="headers">HTTP-Anforderungsheader, der von der Pushanforderung verwendet wird.</param>
        <summary>Diese API dient zur Unterstützung von Anwendungen, die Pushzusagen an HTTP 2.0-Clients senden. Weitere Informationen zu HTTP 2-Serverpushvorgängen finden Sie unter <see href="https://http2.github.io/http2-spec/#PushResources">HTTP/2 Specification Section 8.2: Server Push</see>.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Pushpromise ist nicht deterministisch, und Anwendungen sollten keine Logik aufweisen, die von ihr abhängt. Der einzige Zweck ist der Leistungsvorteil in einigen Fällen. Es gibt viele Bedingungen (Protokoll und Implementierung), die dazu führen können, dass die pushanforderungen vollständig ignoriert werden. Die Annahme basiert auf "Fire-and-Forget".

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Leitet einen Client zu einer neuen URL um.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Der Zielort. Dies kann ein zur Anwendung relativer virtueller Pfad sein.</param>
        <summary>Leitet eine Anforderung an eine neue URL um und gibt die neue URL an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das Aufrufen von <xref:System.Web.HttpResponse.Redirect%2A> entspricht dem Aufrufen von <xref:System.Web.HttpResponse.Redirect%2A>, wobei der zweite Parameter auf `true`festgelegt ist.

 <xref:System.Web.HttpResponse.Redirect%2A> ruft <xref:System.Web.HttpResponse.End%2A> auf, der nach Abschluss eine <xref:System.Threading.ThreadAbortException> Ausnahme auslöst. Diese Ausnahme wirkt sich nachteilig auf die Leistung der Webanwendung aus. Daher wird empfohlen, anstelle dieser Überladung die <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> Überladung zu verwenden und `false` für den `endResponse`-Parameter zu übergeben und dann die <xref:System.Web.HttpApplication.CompleteRequest%2A>-Methode aufzurufen. Weitere Informationen finden Sie unter der Methode <xref:System.Web.HttpResponse.End%2A>.

> [!NOTE]
>  Nur für Mobile Seiten: Wenn Ihre Anwendung auf cookielosen Sitzungen basiert oder Anforderungen von mobilen Geräten empfangen kann, für die cookielose Sitzungen erforderlich sind, kann die Verwendung einer Tilde (\~) in einem Pfad dazu führen, dass eine neue Sitzung erstellt und möglicherweise Sitzungsdaten verloren gehen. Um eine Eigenschaft auf einem mobilen Steuerelement mit einem Pfad wie "\~/Path" festzulegen, lösen Sie den Pfad mithilfe <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "\~/Path", bevor Sie ihn der Eigenschaft zuweisen.

 ASP.NET führt die Umleitung durch die Rückgabe des HTTP-Statuscodes 302 aus. Eine alternative Möglichkeit zum Übertragen der Steuerung an eine andere Seite ist die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Die <xref:System.Web.HttpServerUtility.Transfer%2A>-Methode ist in der Regel effizienter, da Sie keinen Roundtrip zum Client auslöst. Weitere Informationen finden Sie unter Gewusst [wie: Umleiten von Benutzern an eine andere Seite](https://docs.microsoft.com/previous-versions/aspnet/540y83hx(v=vs.100)).



## Examples
 Im folgenden Beispiel wird eine unbedingte Umleitung zu einer anderen Website erzwungen.

 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wird eine Umleitung versucht.</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string * bool -&gt; unit" Usage="httpResponse.Redirect (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Der Zielspeicherort.</param>
        <param name="endResponse">Gibt an, ob die Ausführung der aktuellen Seite beendet werden soll.</param>
        <summary>Leitet einen Client zu einer neuen URL um. Gibt die neue URL an und meldet, ob die Ausführung der aktuellen Seite beendet werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Eine absolute URL (z. b. `http://www.contoso.com/default.aspx`) oder eine relative URL (z. b. default. aspx) kann für den Ziel Speicherort angegeben werden, einige Browser lehnen jedoch möglicherweise eine relative URL ab.

 Wenn Sie diese Methode in einem Seiten Handler verwenden, um eine Anforderung für eine Seite zu beenden und eine neue Anforderung für eine andere Seite zu starten, legen Sie `endResponse` auf `false` fest, und wenden Sie dann die <xref:System.Web.HttpApplication.CompleteRequest%2A>-Methode an. Wenn Sie `true` für den `endResponse`-Parameter angeben, ruft diese Methode die <xref:System.Web.HttpResponse.End%2A>-Methode für die ursprüngliche Anforderung auf, die eine <xref:System.Threading.ThreadAbortException> Ausnahme auslöst, wenn Sie abgeschlossen wird. Diese Ausnahme wirkt sich nachteilig auf die Leistung der Webanwendung aus. aus diesem Grund empfiehlt es sich, `false` für den `endResponse`-Parameter zu übergeben. Weitere Informationen finden Sie unter der Methode <xref:System.Web.HttpResponse.End%2A>.

> [!NOTE]
>  Wenn Ihre Anwendung auf mobilen Seiten von cookielosen Sitzungen abhängig ist oder Anforderungen von mobilen Geräten empfangen werden können, für die cookielose Sitzungen erforderlich sind, kann bei Verwendung einer Tilde (\~) in einem Pfad eine neue Sitzung erstellt werden, und Sitzungsdaten können verloren gehen. Um eine Eigenschaft auf einem mobilen Steuerelement mit einem Pfad wie "\~/Path" festzulegen, lösen Sie den Pfad mithilfe <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "\~/Path", bevor Sie ihn der Eigenschaft zuweisen.

 ASP.NET führt die Umleitung durch die Rückgabe des HTTP-Statuscodes 302 aus. Eine alternative Möglichkeit zum Übertragen der Steuerung an eine andere Seite ist die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Die <xref:System.Web.HttpServerUtility.Transfer%2A>-Methode ist in der Regel effizienter, da Sie keinen Roundtrip zum Client auslöst. Weitere Informationen finden Sie unter Gewusst [wie: Umleiten von Benutzern an eine andere Seite](https://docs.microsoft.com/previous-versions/aspnet/540y83hx(v=vs.100)).



## Examples
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.IsClientConnected%2A>-Eigenschaft verwendet, um zu überprüfen, ob der Client, der die Seite anfordert, mit dem Server verbunden bleibt. Wenn <xref:System.Web.HttpResponse.IsClientConnected%2A> true ist, ruft der Code die <xref:System.Web.HttpResponse.Redirect%2A>-Methode auf, und der Client zeigt eine andere Seite an. Wenn <xref:System.Web.HttpResponse.IsClientConnected%2A> false ist, ruft der Code die <xref:System.Web.HttpResponse.End%2A>-Methode auf, und die gesamte Seiten Verarbeitung wird beendet.

 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> enthält ein Zeilenumbruchzeichen.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wird eine Umleitung versucht.</exception>
        <exception cref="T:System.ApplicationException">Die Seitenanforderung ist das Ergebnis eines Rückrufs.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des HTTP-<see langword="Location" />-Headers ab oder legt diesen fest.</summary>
        <value>Der absolute URI, der im <see langword="Location" />-HTTP-Header an den Client übermittelt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird gezeigt, wie diese Eigenschaft verwendet wird, um die Umleitungs-URL anzugeben, wenn Sie eine permanente Umleitung mithilfe des HTTP 301-Antwort Codes codieren.

```csharp
Response.StatusCode = 301;
Response.Status = "301 Moved Permanently";
Response.RedirectLocation = "http://www.newurl.com ";
Response.End();
```

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die HTTP-Header wurden bereits geschrieben.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine permanente Umleitung von einer angeforderten URL zu einer angegebenen URL aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string -&gt; unit" Usage="httpResponse.RedirectPermanent url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="url">Der Speicherort, an den die Anforderung umgeleitet wird.</param>
        <summary>Führt eine permanente Umleitung von der angeforderten URL zur angegebenen URL aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29>-Methoden Überladung stellt den HTTP-Statuscode 301 in der Antwort bereit und enthält die URL, an die die Anforderung umgeleitet werden soll. Der HTTP-Statuscode 301 ist ein Standard Code in einer HTTP-Antwort. Es zeigt an, dass eine permanente Umleitung vorhanden ist, und stellt den Umleitungs Speicherort bereit.

 Wenn Sie die <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> Methoden Überladung aufrufen, wird die Antwort beendet.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> schließt ein Zeilenumbruchzeichen (<c>\n</c>) ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string * bool -&gt; unit" Usage="httpResponse.RedirectPermanent (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="endResponse" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="url">Der Speicherort, an den die Anforderung umgeleitet wird.</param>
        <param name="endResponse"><see langword="true" />, um die Antwort zu beenden, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</param>
        <summary>Führt eine permanente Umleitung von der angeforderten URL zur angegebenen URL aus und stellt die Option zum Abschließen der Antwort bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29>-Methoden Überladung stellt den HTTP-Statuscode 301 in der Antwort bereit und enthält die URL, an die die Anforderung umgeleitet werden soll. Diese Methoden Überladung bietet auch die Option, anzugeben, ob die Antwort beendet oder nach der Umleitung abgeschlossen werden soll. Der HTTP-Statuscode 301 ist ein Standard Code in einer HTTP-Antwort. Es zeigt an, dass eine permanente Umleitung vorhanden ist, und stellt den Umleitungs Speicherort bereit.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> schließt ein Zeilenumbruchzeichen (<c>\n</c>) ein.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Leitet eine Anforderung mit Routenparameterwerten, einem Routennamen oder beiden Angaben an eine neue URL um.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : obj -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Leitet eine Anforderung mit Routenparameterwerten an eine neue URL um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>-Methode, wobei der zweite Parameter auf `false`festgelegt ist.

 Mit dieser Methode wird das Objekt, das in `routeValues` übergeben wird, mithilfe des <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>-Konstruktors an ein <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> Objekt konvertiert. Die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>-Methode wird dann aufgerufen, um die URL zu bestimmen.

 ASP.NET führt die Umleitung durch die Rückgabe des HTTP-Statuscodes 302 aus.



## Examples
 Im folgenden Beispiel wird gezeigt, wie diese Methode aufgerufen wird, um eine Umleitung zu einer Route mit Parametern namens `productid` und `category`durchzusetzen.

```vb
Response.RedirectToRoute(
  New With {.productid = "1", .category = "widgets"})
```

```csharp
Response.RedirectToRoute(
  new { productid = "1", category = "widgets" });
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string -&gt; unit" Usage="httpResponse.RedirectToRoute routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <summary>Leitet eine Anforderung mit einem Routennamen an eine neue URL um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>-Methode, wobei der zweite Parameter auf `false`festgelegt ist.

 Mit dieser Methode wird der Routen Name, der in `routeName` weitergegeben wird, mithilfe der <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>-Methode in eine URL konvertiert.

 ASP.NET führt die Umleitung durch die Rückgabe des HTTP-Statuscodes 302 aus.



## Examples
 Im folgenden Beispiel wird gezeigt, wie diese Methode aufgerufen wird, um eine Umleitung an eine Route mit dem Namen "`Products`" zu leiten.

```vb
Response.RedirectToRoute("Products")
```

```csharp
Response.RedirectToRoute("Products");
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Leitet eine Anforderung mit Routenparameterwerten an eine neue URL um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>-Methode, wobei der zweite Parameter auf `false`festgelegt ist.

 Diese Methode ruft die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>-Methode auf, um die URL zu bestimmen.

 ASP.NET führt die Umleitung durch die Rückgabe des HTTP-Statuscodes 302 aus.



## Examples
 Im folgenden Beispiel wird gezeigt, wie diese Methode aufgerufen wird, um eine Umleitung zu einer Route mit Parametern namens `productid` und `category`durchzusetzen.

```vb
Response.RedirectToRoute(
  new RouteValueDictionary {productId="1", category="widgets"})
```

```csharp
Response.RedirectToRoute(
  (new RouteValueDictionary {productId="1", category="widgets"});
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Leitet eine Anforderung mit Routenparameterwerten und einem Routennamen an eine neue URL um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>-Methode, wobei der zweite Parameter auf `false`festgelegt ist.

 Mit dieser Methode wird das Objekt, das in `routeValues` übergeben wird, mithilfe des <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>-Konstruktors an ein <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> Objekt konvertiert. Die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>-Methode wird dann aufgerufen, um die URL zu bestimmen.

 ASP.NET führt die Umleitung durch die Rückgabe des HTTP-Statuscodes 302 aus.



## Examples
 Im folgenden Beispiel wird gezeigt, wie diese Methode aufgerufen wird, um zu einer Route mit dem Namen `Product` umzuleiten, die über Parameter verfügt, die `productid` und `category`benannt sind.

```vb
Response.RedirectToRoute("Product",
  New With {.productid = "1", .category = "widgets"})
```

```csharp
Response.RedirectToRoute("Product",
  new { productid = "1", category = "widgets" });
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Leitet eine Anforderung mit Routenparameterwerten und einem Routennamen an eine neue URL um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>-Methode, wobei der zweite Parameter auf `false`festgelegt ist.

 Die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>-Methode wird aufgerufen, um die URL zu bestimmen.

 ASP.NET führt die Umleitung durch die Rückgabe des HTTP-Statuscodes 302 aus.



## Examples
 Im folgenden Beispiel wird gezeigt, wie diese Methode aufgerufen wird, um zu einer Route mit dem Namen `Product` umzuleiten, die über Parameter verfügt, die `productid` und `category`benannt sind.

```vb
Response.RedirectToRoute("Product",
  new RouteValueDictionary {productId="1", category="widgets"})
```

```csharp
Response.RedirectToRoute("Product",
  (new RouteValueDictionary {productId="1", category="widgets"});
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine permanente Umleitung von einer angeforderten URL an eine neue URL mit Routenparameterwerten, einem Routennamen oder beiden Angaben aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Führt eine permanente Umleitung von einer angeforderten URL an eine neue URL mit Routenparameterwerten aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29>-Methode, wobei der zweite Parameter auf `false`festgelegt ist.

 Mit dieser Methode wird das Objekt, das in `routeValues` übergeben wird, mithilfe des <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>-Konstruktors an ein <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> Objekt konvertiert. Die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>-Methode wird dann aufgerufen, um die URL zu bestimmen.

 ASP.NET führt die Umleitung durch die Rückgabe des HTTP-Statuscodes 301 aus.



## Examples
 Im folgenden Beispiel wird gezeigt, wie diese Methode aufgerufen wird, um eine Umleitung zu einer Route mit Parametern namens `productid` und `category`durchzusetzen.

```vb
Response.RedirectToRoutePermanent(
  New With {.productid = "1", .category = "widgets"})
```

```csharp
Response.RedirectToRoutePermanent(
  new { productid = "1", category = "widgets" });
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <summary>Führt eine permanente Umleitung von einer angeforderten URL an eine neue URL mit einem Routennamen aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29>-Methode, wobei der zweite Parameter auf `false`festgelegt ist.

 Mit dieser Methode wird der Routen Name, der in `routeName` weitergegeben wird, mithilfe der <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>-Methode in eine URL konvertiert.

 ASP.NET führt die Umleitung durch die Rückgabe des HTTP-Statuscodes 301 aus.



## Examples
 Im folgenden Beispiel wird gezeigt, wie diese Methode aufgerufen wird, um eine Umleitung an eine Route mit dem Namen "`Products`" zu leiten.

```vb
Response.RedirectToRoutePermanent("Products")
```

```csharp
Response.RedirectToRoutePermanent("Products");
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Führt eine permanente Umleitung von einer angeforderten URL an eine neue URL mit Routenparameterwerten aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>-Methode, wobei der zweite Parameter auf `false`festgelegt ist.

 Diese Methode ruft die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>-Methode auf, um die URL zu bestimmen.

 ASP.NET führt die Umleitung durch die Rückgabe des HTTP-Statuscodes 301 aus.



## Examples
 Im folgenden Beispiel wird gezeigt, wie diese Methode aufgerufen wird, um eine Umleitung zu einer Route mit Parametern namens `productid` und `category`durchzusetzen.

```vb
Response.RedirectToRoutePermanent(
  new RouteValueDictionary {productId="1", category="widgets"})
```

```csharp
Response.RedirectToRoutePermanent(
  new RouteValueDictionary {productId="1", category="widgets"});
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Führt mit den Routenparameterwerten und dem Namen der Route, die der neuen URL entsprechen, eine permanente Umleitung von einer angeforderten URL an eine neue URL aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.HttpResponse.RedirectPermanent%2A>-Methode, wobei der zweite Parameter auf `false`festgelegt ist.

 Mit dieser Methode wird das Objekt, das in `routeValues` übergeben wird, mithilfe des <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>-Konstruktors an ein <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> Objekt konvertiert. Die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>-Methode wird dann aufgerufen, um die URL zu bestimmen.

 ASP.NET führt die Umleitung durch die Rückgabe des HTTP-Statuscodes 301 aus.



## Examples
 Im folgenden Beispiel wird gezeigt, wie diese Methode aufgerufen wird, um zu einer Route mit dem Namen `Product` umzuleiten, die über Parameter verfügt, die `productid` und `category`benannt sind.

```vb
Response.RedirectToRoutePermanent("Product",
  New With {.productid = "1", .category = "widgets"})
```

```csharp
Response.RedirectToRoutePermanent("Product",
  new { productid = "1", category = "widgets" });
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Führt eine permanente Umleitung von einer angeforderten URL an eine neue URL mit Routenparameterwerten und einem Routennamen aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>-Methode, wobei der zweite Parameter auf `false`festgelegt ist.

 Diese Methode ruft die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>-Methode auf, um die URL zu bestimmen.

 ASP.NET führt die Umleitung durch die Rückgabe des HTTP-Statuscodes 301 aus.



## Examples
 Im folgenden Beispiel wird gezeigt, wie diese Methode aufgerufen wird, um zu einer Route mit dem Namen `Product` umzuleiten, die über Parameter verfügt, die `productid` und `category`benannt sind.

```vb
Response.RedirectToRoutePermanent("Product",
  new RouteValueDictionary {productId="1", category="widgets"})
```

```csharp
Response.RedirectToRoutePermanent("Product",
  new RouteValueDictionary {productId="1", category="widgets"});
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt mit dem Ausgabecache-Standardanbieter zwischengespeicherte Elemente aus dem Ausgabecache.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der virtuelle absolute Pfad für die Elemente, die aus dem Cache entfernt wurden.</param>
        <summary>Entfernt alle zwischengespeicherten Elemente aus dem Cache, die dem standardmäßigen Ausgabecacheanbieter zugeordnet sind. Dies ist eine statische Methode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Aufrufen Sie diese Methode, um Ausgabe Cache Elemente zu entfernen, die dem standardmäßigen Ausgabe Cache Anbieter zugeordnet sind. Aufrufen der <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A>-Methode, um Ausgabe Cache Elemente zu entfernen, die mit benutzerdefinierten Ausgabe Cache Anbietern verknüpft sind, die in der Website Konfigurationsdatei angegeben sind.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist kein absoluter virtueller Pfad.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string * string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem (path, providerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="providerName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der virtuelle absolute Pfad der Elemente, die aus dem Cache entfernt werden.</param>
        <param name="providerName">Der Anbieter, mit dem die Ausgabecacheartefakte entfernt werden, die dem angegebenen Pfad zugeordnet sind.</param>
        <summary>Verwendet den angegebenen Ausgabecacheanbieter, um alle Ausgabecacheelemente zu entfernen, die dem angegebenen Pfad zugeordnet sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Aufrufen Sie diese Methode, um Ausgabe Cache Elemente zu entfernen, die den benutzerdefinierten Ausgabe Cache Anbietern zugeordnet sind, die in der Website Konfigurationsdatei angegeben sind. Um Ausgabe Cache Elemente zu entfernen, die dem standardmäßigen Ausgabe Cache Anbieter zugeordnet sind, müssen Sie die <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29>-Methoden Überladung aufrufen.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist ein ungültiger Pfad.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Das in der Auflistung zu aktualisierende Cookie.</param>
        <summary>Da die <b>HttpResponse.SetCookie</b>-Methode nur für die interne Verwendung vorgesehen ist, sollten Sie sie nicht in Ihrem Code aufrufen. Rufen Sie stattdessen wie im folgenden Beispiel gezeigt die <b>HttpResponse.Cookies.Set</b>-Methode auf.<br /> Aktualisiert ein vorhandenes Cookie in der Cookieauflistung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird der Wert eines vorhandenen Cookies aktualisiert.

 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Es wurde versucht, nach dem Senden der HTTP-Header das Cookie festzulegen.</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Status : string with get, set" Usage="System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die <see langword="Status" />-Zeile fest, die an den Client zurückgegeben wird.</summary>
        <value>Durch das Festlegen des Statuscodes wird in einer Zeichenfolge der Status der HTTP-Ausgabe beschrieben, die an den Client zurückgegeben werden soll. Der Standardwert ist 200 (OK).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.Status%2A> ist zugunsten <xref:System.Web.HttpResponse.StatusDescription%2A> veraltet und wird nur aus Gründen der Kompatibilität mit früheren Versionen von ASP bereitgestellt. Verwenden Sie bei ASP.NET stattdessen <xref:System.Web.HttpResponse.StatusDescription%2A>.

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der Status wurde auf einen ungültigen Statuscode festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den HTTP-Statuscode der an den Client zurückgegebenen Ausgabe ab oder legt diesen fest.</summary>
        <value>Eine ganze Zahl, die den Status der an den Client zurückgegebenen HTTP-Ausgabe darstellt. Der Standardwert ist 200 (OK). Eine Auflistung gültiger Statuscodes finden Sie unter <see href="/windows/win32/winhttp/http-status-codes">HTTP-Statuscodes</see>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird der Statuscode des Ausgabestreams überprüft. Wenn der Statuscode nicht gleich 200 ist, wird zusätzlicher Code ausgeführt.

 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see cref="P:System.Web.HttpResponse.StatusCode" /> wurde nach dem Senden der HTTP-Header festgelegt.</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die HTTP-Statuszeichenfolge der an den Client zurückgegebenen Ausgabe ab oder legt diese fest.</summary>
        <value>Eine Zeichenfolge, die den Status der an den Client zurückgegebenen HTTP-Ausgabe beschreibt. Der Standardwert ist „OK“. Eine Auflistung gültiger Statuscodes finden Sie unter <see href="/windows/win32/winhttp/http-status-codes">HTTP-Statuscodes</see>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird die Status Zeichenfolge des Ausgabestreams überprüft. Wenn der Status nicht gleich "OK" ist, wird zusätzlicher Code ausgeführt.

 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="StatusDescription" /> wurde nach dem Senden der HTTP-Header festgelegt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge des ausgewählten Werts ist größer als 512.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SubStatusCode : int with get, set" Usage="System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den Statuscode der Antwort qualifiziert, oder legt diesen fest.</summary>
        <value>Ein Ganzzahlwert, der den [!INCLUDE[iisver](~/includes/iisver-md.md)]-Substatuscode darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpResponse.SubStatusCode%2A>-Eigenschaft wird nur für den integrierten Pipeline Modus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und zumindest für die .NET Framework Version 3,0 unterstützt. Wenn Sie die <xref:System.Web.HttpResponse.SubStatusCode%2A>-Eigenschaft festlegen, wird der Status [!INCLUDE[iisver](~/includes/iisver-md.md)] protokolliert, wenn die Ablauf Verfolgung für fehlgeschlagene Anforderungen konfiguriert ist. Unabhängig davon, ob die Ablauf Verfolgung konfiguriert ist, wird der Code nie als Teil der letzten Antwort auf die Anforderung gesendet. Weitere Informationen finden Sie unter beheben fehlerhafter [Anforderungen mithilfe der Ablauf Verfolgung für Anforderungs Fehler in IIS 7,0](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1).



## Examples
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.SubStatusCode%2A>-Eigenschaft in einem Ereignishandler für die <xref:System.Web.HttpApplication> Instanz des <xref:System.Web.HttpApplication.PostAuthenticateRequest> Ereignisses festgelegt. Platzieren Sie die Codedatei im Ordner "App_Code" Ihrer Webanwendung, und konfigurieren Sie die Datei "Web. config", um das Modul zu registrieren. Weitere Informationen finden Sie unter Exemplarische Vorgehensweise [: Erstellen und Registrieren eines benutzerdefinierten HTTP-Moduls](https://docs.microsoft.com/previous-versions/aspnet/ms227673(v=vs.100)).

 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Der Vorgang erfordert den integrierten Pipelinemodus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und mindestens .NET Framework Version 3.0.</exception>
        <exception cref="T:System.Web.HttpException">Der Statuscode wird festgelegt, nachdem alle HTTP-Header gesendet wurden.</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAsyncFlush : bool" Usage="System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Verbindung asynchrone Leerungsvorgänge unterstützt.</summary>
        <value><see langword="true" />, wenn die Verbindung asynchrone Leerungsvorgänge unterstützt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Eigenschaft gibt den Wert der <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType>-Eigenschaft zurück.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressContent : bool with get, set" Usage="System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob HTTP-Inhalt an den Client gesendet werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, um die Ausgabe zu unterdrücken, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird überprüft, ob die <xref:System.Web.HttpRequest.IsSecureConnection%2A>-Eigenschaft auf false festgelegt ist. Wenn dies der Fall ist, wird die <xref:System.Web.HttpResponse.SuppressContent%2A>-Eigenschaft auf true festgelegt, um zu verhindern, dass die Antwort gesendet wird.

 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressDefaultCacheControlHeader : bool with get, set" Usage="System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der standardmäßige <c>Cache Control: private</c>-Header für die aktuelle HTTP-Antwort unterdrückt werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, um das standardmäßige Cache Steuerelement zu unterdrücken <c>: privater</c> Header für die aktuelle HTTP-Antwort. Andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Standardmäßig sendet ASP.net einen `Cache-Control: private`-Antwortheader, es sei denn, eine explizite Cache Richtlinie wurde für diese Antwort angegeben. Diese Eigenschaft ermöglicht das Unterdrücken dieses Standardantwort Headers auf Anforderungs Basis. Der Header kann für die gesamte Anwendung weiterhin unterdrückt werden, indem <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> im [httpRuntime-Element (ASP.NET Settings Schema)](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/e1f13641(v=vs.100)) oder im [OutputCache-Element für Caching (ASP.NET Settings Schema)](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms228124(v=vs.100))festgelegt wird.

 Gehen Sie beim unterdrücken der Standard `Cache-Control: private` Kopfzeile vorsichtig vor, da Proxys und andere Vermittler Antworten möglicherweise ohne diesen Header als Cache fähig behandeln. Diese Behandlung kann zu unbeabsichtigtem Zwischenspeichern vertraulicher Informationen führen. Weitere Informationen finden Sie [unter RFC 2616, Sek. 13,4](https://tools.ietf.org/html/rfc2616) .

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressFormsAuthenticationRedirect : bool with get, set" Usage="System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob die Umleitung der Formularauthentifizierung zur Anmeldeseite unterdrückt werden soll.</summary>
        <value><see langword="true" />, wenn die Umleitung der Formularauthentifizierung unterdrückt werden soll, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Standardmäßig werden von der Formular Authentifizierung HTTP 401-Statuscodes in 302 konvertiert, um zur Anmeldeseite umzuleiten. Dies eignet sich nicht für bestimmte Fehlerklassen, z. b. wenn die Authentifizierung erfolgreich ist, die Autorisierung jedoch fehlschlägt oder wenn es sich bei der aktuellen Anforderung um eine AJAX-oder eine Service Request Web Diese Eigenschaft bietet eine Möglichkeit, das Umleitungs Verhalten zu unterdrücken und den ursprünglichen Statuscode an den Client zu senden.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt die angegebene Datei direkt in einen HTTP-Antwort-Ausgabestream, ohne dass sie im Arbeitsspeicher gepuffert wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string -&gt; unit" Usage="httpResponse.TransmitFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Der Name der Datei, die in die HTTP-Ausgabe geschrieben werden soll.</param>
        <summary>Schreibt die angegebene Datei direkt in einen HTTP-Antwort-Ausgabestream, ohne dass sie im Arbeitsspeicher gepuffert wird.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="filename" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.TransmitFile (filename, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="offset" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filename">Der Name der Datei, die in die HTTP-Ausgabe geschrieben werden soll.</param>
        <param name="offset">Die Position in der Datei, ab der die HTTP-Ausgabe geschrieben wird.</param>
        <param name="length">Die Anzahl der zu übertragenden Bytes.</param>
        <summary>Schreibt den angegebenen Teil einer Datei direkt in einen HTTP-Antwort-Ausgabestream, ohne dass diese im Arbeitsspeicher gepuffert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn Sie 0 als `offset`-Parameter und-1 als `length` Parameter angeben, wird die gesamte Datei gesendet.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="offset" />-Parameter ist kleiner als 0 (null).

Oder

Der <paramref name="length" />-Parameter ist kleiner als -1.

Oder

Der <paramref name="length" />-Parameter gibt eine Anzahl von Bytes an, die größer ist, als die Anzahl der Bytes in der Datei abzüglich des Offsets.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Out-of-Process-Arbeitsanforderung wird nicht unterstützt.

Oder

Die Antwort verwendet kein <see cref="T:System.Web.HttpWriter" />-Objekt.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="offset" />-Parameter ist kleiner als 0 (null) oder größer als die Dateigröße.

Oder

Der <paramref name="length" />-Parameter ist kleiner als -1 oder größer als der Wert des <paramref name="offset" />-Parameters plus Dateigröße.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrySkipIisCustomErrors : bool with get, set" Usage="System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob benutzerdefinierte [!INCLUDE[iisver](~/includes/iisver-md.md)]-Fehler deaktiviert sind, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn benutzerdefinierte IIS-Fehler deaktiviert werden sollen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A>-Eigenschaft wird nur verwendet, wenn Ihre Anwendung in IIS 7,0 und höher gehostet wird. Bei der Ausführung im klassischen Modus ist der Standardwert der <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A>-Eigenschaft `true`. Bei Ausführung im integrierten Modus ist der Standardwert der <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A>-Eigenschaft `false`.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Informationen in einen Ausgabestream für HTTP-Antworten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberSignature Language="F#" Value="member this.Write : char -&gt; unit" Usage="httpResponse.Write ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">Das Zeichen, das in den HTTP-Ausgabestream geschrieben werden soll.</param>
        <summary>Schreibt ein Zeichen in einen Ausgabestream für HTTP-Antworten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird eine Reihe von Konstanten erstellt, die mithilfe der Write-Methode auf eine ASP.NET Seite geschrieben werden. Der Code ruft diese Version der Write-Methode auf, um einzelne Zeichen Konstanten auf die Seite zu schreiben.

 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Write : obj -&gt; unit" Usage="httpResponse.Write obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das <see cref="T:System.Object" />, das in einen HTTP-Ausgabestream geschrieben werden soll.</param>
        <summary>Schreibt ein <see cref="T:System.Object" /> in einen HTTP-Antwortstream.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="httpResponse.Write s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge, die in den HTTP-Ausgabestream geschrieben werden soll.</param>
        <summary>Schreibt eine Zeichenfolge in einen Ausgabestream für HTTP-Antworten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Dynamisch generierte HTML-Seiten können zu Sicherheitsrisiken führen, wenn die von Webclients empfangene Eingaben nicht überprüft werden, wenn Sie von einem Client empfangen oder an einen Client zurückgesendet werden. Böswillige Skripts, die in Eingaben eingebettet sind, die an eine Website gesendet und später auf einen Client zurückgeschrieben werden, können aus einer vertrauenswürdigen Quelle stammen. Dieses Sicherheitsrisiko wird als Site übergreifender Skript Angriff bezeichnet. Sie sollten immer die Daten überprüfen, die von einem Client empfangen werden, wenn er von Ihrem Standort an Client Browser übertragen wird.

 Wenn Sie alle Daten, die als Eingabe empfangen wurden, als HTML-Code schreiben, sollten Sie ihn mit einer Technik wie <xref:System.Web.HttpServerUtility.HtmlEncode%2A> oder <xref:System.Web.HttpServerUtility.UrlEncode%2A> codieren, um zu verhindern, dass böswillige Skripts ausgeführt werden. Dieses Verfahren ist nützlich für Daten, die nicht überprüft wurden, als Sie empfangen wurden.

 Wenn Sie Daten codieren oder filtern, müssen Sie einen Zeichensatz für Ihre Webseiten angeben, damit der Filter beliebige Byte Sequenzen identifizieren und entfernen kann, die nicht zu diesem Satz gehören (z. b. nicht-alphanumerische Sequenzen) und potenziell schädliches Skript in haben.

 Weitere Informationen zu Site übergreifenden Skript Angriffen finden Sie auf der [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?LinkID=37115) -Website im Artikel Q252985 "Vorgehensweise beim verhindern von Sicherheitsproblemen mit Standort übergreifender Skripterstellung".



## Examples
 Im folgenden Beispiel wird der Name des Clients wieder an den Browser des Clients zurückgeben. Die <xref:System.Web.HttpServerUtility.HtmlEncode%2A>-Methode entfernt alle bösartigen Skripts und ungültigen Zeichen, die möglicherweise im `UserName` Eingabefeld übermittelt wurden.

 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="httpResponse.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Das zu schreibende Zeichenarray.</param>
        <param name="index">Die Position im Zeichenarray, an der mit dem Schreiben begonnen wird.</param>
        <param name="count">Die Anzahl der ab dem <paramref name="index" /> zu schreibenden Zeichen.</param>
        <summary>Schreibt ein Zeichenarray in einen Ausgabestream für HTTP-Antworten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird eine Reihe von Konstanten erstellt, die mithilfe der Write-Methode auf eine ASP.NET Seite geschrieben werden. Der Code ruft diese Version der Write-Methode auf, um einzelne Zeichen Konstanten auf die Seite zu schreiben.

 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt die angegebene Datei direkt in einen Ausgabestream für HTTP-Antworten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string -&gt; unit" Usage="httpResponse.WriteFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Der Name der Datei, die in die HTTP-Ausgabe geschrieben werden soll.</param>
        <summary>Schreibt den Inhalt der angegebenen Datei als Dateiblock direkt in einen HTTP-Antwort-Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn diese Methode mit großen Dateien verwendet wird, löst der Aufruf der-Methode möglicherweise eine Ausnahme aus. Die Größe der Datei, die mit dieser Methode verwendet werden kann, hängt von der Hardwarekonfiguration des Webservers ab. Weitere Informationen finden Sie auf der [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) -Website im Artikel 812406, "PRB: Response. Beschreib tefile kann keine große Datei herunterladen".



## Examples
 Im folgenden Beispiel wird der gesamte Inhalt einer Textdatei mit dem Namen `Login.txt` (die literalen HTML-Text und Eingabe Steuerelemente enthalten kann) direkt in den Ausgabestream geschrieben.

 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="filename" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * bool -&gt; unit" Usage="httpResponse.WriteFile (filename, readIntoMemory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Der Name der Datei, die in einen Speicherblock geschrieben werden soll.</param>
        <param name="readIntoMemory">Gibt an, ob die Datei in einen Speicherblock geschrieben wird.</param>
        <summary>Schreibt den Inhalt der angegebenen Datei als Speicherblock direkt in einen HTTP-Antwort-Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn diese Methode mit großen Dateien verwendet wird, löst der Aufruf der-Methode möglicherweise eine Ausnahme aus. Die Größe der Datei, die mit dieser Methode verwendet werden kann, hängt von der Hardwarekonfiguration des Webservers ab. Weitere Informationen finden Sie auf der [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) -Website im Artikel 812406, "PRB: Response. Beschreib tefile kann keine große Datei herunterladen".



## Examples
 Im folgenden Beispiel wird eine Datei in den Arbeitsspeicher geschrieben.

 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="filename" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : nativeint * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (fileHandle, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">Das Dateihandle der Datei, die in den HTTP-Ausgabestream geschrieben werden soll.</param>
        <param name="offset">Die Byteposition in der Datei, an der der Schreibvorgang beginnt.</param>
        <param name="size">Die Anzahl der Bytes, die in den Ausgabestream geschrieben werden sollen.</param>
        <summary>Schreibt die angegebene Datei direkt in einen Ausgabestream für HTTP-Antworten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn diese Methode mit großen Dateien verwendet wird, löst der Aufruf der-Methode möglicherweise eine Ausnahme aus. Die Größe der Datei, die mit dieser Methode verwendet werden kann, hängt von der Hardwarekonfiguration des Webservers ab. Weitere Informationen finden Sie auf der [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) -Website im Artikel 812406, "PRB: Response. Beschreib tefile kann keine große Datei herunterladen".



## Examples
 Im folgenden Beispiel wird der gesamte Inhalt einer Textdatei mit dem Namen `Login.txt` (die literalen HTML-Text und Eingabe Steuerelemente enthalten kann) direkt in den Ausgabestream geschrieben.

 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileHandler" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Web.HttpException"><paramref name="offset" /> ist kleiner als 0.

Oder

 <paramref name="size" /> ist größer als die Dateigröße minus <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (filename, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Der Name der Datei, die in den HTTP-Ausgabestream geschrieben werden soll.</param>
        <param name="offset">Die Byteposition in der Datei, an der der Schreibvorgang beginnt.</param>
        <param name="size">Die Anzahl der Bytes, die in den Ausgabestream geschrieben werden sollen.</param>
        <summary>Schreibt die angegebene Datei direkt in einen Ausgabestream für HTTP-Antworten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn diese Methode mit großen Dateien verwendet wird, löst der Aufruf der-Methode möglicherweise eine Ausnahme aus. Die Größe der Datei, die mit dieser Methode verwendet werden kann, hängt von der Hardwarekonfiguration des Webservers ab. Weitere Informationen finden Sie auf der [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) -Website im Artikel 812406, "PRB: Response. Beschreib tefile kann keine große Datei herunterladen".



## Examples
 Im folgenden Beispiel wird der gesamte Inhalt einer Textdatei mit dem Namen `Login.txt` (die möglicherweise Literaltext und HTML-Eingabe Steuerelemente enthält) direkt in den Ausgabestream geschrieben.

 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="offset" /> ist kleiner als 0.

Oder

 <paramref name="size" /> ist größer als die Dateigröße minus <paramref name="offset" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="filename" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.WriteSubstitution : System.Web.HttpResponseSubstitutionCallback -&gt; unit" Usage="httpResponse.WriteSubstitution callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Die Methode, das Benutzersteuerelement oder das Objekt, die bzw. das ersetzt werden soll.</param>
        <summary>Ermöglicht das Einfügen von Antwortersetzungsblöcken in die Antwort, wodurch das dynamische Generieren von angegebenen Antwortbereichen für Antworten im Ausgabecache ermöglicht wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Sie können die <xref:System.Web.HttpResponse.WriteSubstitution%2A>-Methode für die Ersetzung nach dem Cache in ihren Ausgabe zwischengespeicherten Seiten verwenden. Durch die Übergabe eines <xref:System.Web.HttpContext> Objekts an eine Rückruf Methode mit einer vorgeschriebenen <xref:System.Web.HttpResponseSubstitutionCallback> Signatur können Sie die Ausgabe zwischengespeicherten Inhalten an jedem beliebigen Speicherort im Seitencache ersetzen. Rufen Sie zum Initiieren der Ersetzung die <xref:System.Web.HttpResponse.WriteSubstitution%2A>-Methode auf, und übergeben Sie dabei die Rückruf Methode, die Thread sicher sein muss und eine der folgenden sein kann:

-   Eine statische Methode auf der Seite des Containers oder des Benutzer Steuer Elements.

-   Eine statische Methode oder Instanzmethode für ein anderes beliebiges Objekt.

 Bei der ersten Anforderung der Seite ruft der <xref:System.Web.HttpResponse.WriteSubstitution%2A> den <xref:System.Web.HttpResponseSubstitutionCallback> Delegaten auf, um die Ausgabe zu entwickeln. Anschließend wird der Antwort ein Ersetzungs Puffer hinzugefügt, der den Delegaten beibehält, bei zukünftigen Anforderungen aufzurufen. Schließlich wird die Client seitige Zwischenspeicherung von öffentlich zu Server beeinträchtigt, sodass zukünftige Anforderungen an die Seite den Delegaten erneut aufrufen können, indem Sie auf dem Client nicht zwischenspeichern.

> [!NOTE]
>  Die Post-Cache-Ersetzung wird für ein zwischengespeichertes Benutzer Steuerelement nicht unterstützt, bei dem die Ausgabe Zwischenspeicherung auf der Benutzer Steuerelement Ebene Dies wird auch als FragmentCaching bezeichnet. Weitere Informationen finden Sie unter zwischen [Speichern von Teilen einer ASP.NET-Seite](https://docs.microsoft.com/previous-versions/aspnet/h30h475z(v=vs.100)).

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Ziel des <paramref name="callback" />-Parameters ist vom Typ <see cref="T:System.Web.UI.Control" />.</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/w9s3a17d(v=vs.100)">Festlegen der cacheability einer Seite</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/h30h475z(v=vs.100)">Zwischenspeichern von Teilen einer ASP.NET-Seite</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms227429(v=vs.100)">Dynamisches Aktualisieren von Teilen einer zwischengespeicherten Seite</related>
      </Docs>
    </Member>
  </Members>
</Type>
