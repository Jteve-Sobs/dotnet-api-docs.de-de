<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a0025463cb29af85b3274bba24f2c4c4c61b3837" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51889071" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <TypeSignature Language="F#" Value="type HttpResponse = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Kapselt HTTP-Antwortinformationen aus einem ASP.NET-Vorgang.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden und Eigenschaften der <xref:System.Web.HttpResponse> Klasse verfügbar gemacht werden, über die <xref:System.Web.HttpApplication.Response%2A> Eigenschaft der <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, und <xref:System.Web.UI.UserControl> Klassen.  
  
 Die folgenden Methoden der der <xref:System.Web.HttpResponse> Klasse werden nur in der post-Back-Szenarien unterstützt, und Sichern Sie nicht in asynchronen Szenarien:  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 Teilaktualisierungen von Seiten aktiviert sind, bei der Verwendung <xref:System.Web.UI.UpdatePanel> Steuerelemente zum Aktualisieren der ausgewählten Bereiche einer Seite statt die gesamte Seite aktualisieren, mit einer POST-Anforderung zurück. Weitere Informationen finden Sie unter [Übersicht über das UpdatePanel-Steuerelement](https://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a) und [Partial-Page Rendering Overview](https://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49).  
  
   
  
## Examples  
 Im folgende Beispiel werden drei überlappende Rechtecke gezeichnet, wenn die Seite angefordert wird. Der Code beginnt mit der Festlegung der <xref:System.Web.HttpResponse.ContentType%2A> Image/Jpeg, Eigenschaft, damit die gesamte Seite als ein JPEG-Bild gerendert wird. Der Code ruft dann die <xref:System.Web.HttpResponse.Clear%2A> Methode, um sicherzustellen, dass keine überflüssige Inhalte mit dieser Antwort gesendet werden. Als Nächstes mit dem Code wird die <xref:System.Web.HttpResponse.BufferOutput%2A> Eigenschaft auf "true", damit die Seite vollständig verarbeitet wird, bevor sie an den anfordernden Client gesendet wird. Zwei Objekte verwendet, um die Rechtecke gezeichnet werden erstellt: ein <xref:System.Drawing.Bitmap> und <xref:System.Drawing.Graphics> Objekt. Die Variablen, die auf der Seite erstellt dienen als Koordinaten zum Zeichnen der Rechtecke und eine Zeichenfolge, die das größte Rechteck angezeigt wird.  
  
 Beim Zeichnen von drei Rechtecke und die Zeichenfolge, die darin enthaltenen angezeigt werden, die <xref:System.Drawing.Bitmap> gespeichert der <xref:System.IO.Stream> -Objekt, das zugeordnet ist die <xref:System.Web.HttpResponse.OutputStream%2A> -Eigenschaft und das Format auf JPEG eingestellt festgelegt ist. Der Code Ruft die <xref:System.Drawing.Image.Dispose%2A> und <xref:System.Drawing.Graphics.Dispose%2A> Methoden, die von den zwei Objekte verwendeten Ressourcen freizugeben. Abschließend ruft der Code die <xref:System.Web.HttpResponse.Flush%2A> Methode, um die gepufferte Antwort an den anfordernden Client zu senden.  
  
> [!NOTE]
>  Im Code die <xref:System.Web.HttpResponse> Objekt verweist auf das Schlüsselwort `Response`. Z. B. `Response.Clear()` bezieht sich auf die <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType> Methode. Die <xref:System.Web.UI.Page> -Klasse verfügt über eine Eigenschaft mit dem Namen <xref:System.Web.UI.Page.Response%2A> , verfügbar macht, die aktuelle Instanz von <xref:System.Web.HttpResponse>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpResponse : System.IO.TextWriter -&gt; System.Web.HttpResponse" Usage="new System.Web.HttpResponse writer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Ein <see cref="T:System.IO.TextWriter" />-Objekt, das die benutzerdefinierte HTTP-Ausgabe aktiviert.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.HttpResponse" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member unterstützt die .NET Framework-Infrastruktur und ist nicht für die direkte Verwendung in Code vorgesehen.  
  
 Die Methoden und Eigenschaften der <xref:System.Web.HttpResponse> Klasse verfügbar gemacht werden, über das systeminterne <xref:System.Web.HttpContext.Response%2A> Objekts in ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberSignature Language="F#" Value="member this.AddCacheDependency : System.Web.Caching.CacheDependency[] -&gt; unit" Usage="httpResponse.AddCacheDependency dependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">Eine Datei, ein Cacheschlüssel oder eine <see cref="T:System.Web.Caching.CacheDependency" />, die der Liste mit Anwendungsabhängigkeiten hinzugefügt werden soll.</param>
        <summary>Ordnet der Antwort Cacheabhängigkeiten zu, sodass die Antwort für ungültig erklärt werden kann, wenn sie im Ausgabecache gespeichert ist und sich die angegebenen Abhängigkeiten ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpResponse.AddCacheDependency%2A> Methode können Sie Abhängigkeiten zwischen zwischengespeicherten Antworten erstellt werden und ein <xref:System.Web.Caching.CacheDependency> Objekt.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie erstellen Sie eine Cacheabhängigkeit mithilfe der <xref:System.Web.HttpResponse.AddCacheDependency%2A> Methode und eine <xref:System.Web.Caching.CacheDependency> Objekt.  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="dependencies" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Methode wurde zu spät in der Cacheverarbeitungspipeline aufgerufen, nachdem die zwischengespeicherte Antwort bereits erstellt worden war.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Zwischenspeichern von ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Macht die Gültigkeit einer zwischengespeicherten Antwort von anderen Elementen im Cache abhängig.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Die <see cref="T:System.Collections.ArrayList" /> mit den Schlüsseln der Elemente, von der die gegenwärtig zwischengespeicherte Antwort abhängt.</param>
        <summary>Macht die Gültigkeit einer zwischengespeicherten Antwort von anderen Elementen im Cache abhängig.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Elemente bezeichnet, die in der `cacheKeys` Parameter aus dem Cache entfernt werden, die zwischengespeicherte Antwort des aktuellen Elements ist ungültig.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht eine ASP.NET-Seite zu verwenden, die Ausgabe zwischengespeichert wird. Der Code für die Seite erstellt eine <xref:System.Collections.ArrayList> Objekt der Schlüssel, die Elementen zugeordnet sind, die in gespeichert werden die <xref:System.Web.Caching.Cache> Objekt. Als Nächstes übergibt der Code die <xref:System.Collections.ArrayList> als Parameter in einem Aufruf der <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> Methode. Dadurch wird im Ausgabecache zwischengespeicherte Antwort nicht gültig ist, wenn eine der Dateien in die <xref:System.Collections.ArrayList> ändern.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Zwischenspeichern von ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : string[] -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Ein Array von Elementschlüsseln, von denen die zwischengespeicherte Antwort abhängt.</param>
        <summary>Macht die Gültigkeit eines zwischengespeicherten Elements von einem anderen Element im Cache abhängig.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eines der `cacheKey`s werden aus dem Cache entfernt, die zwischengespeicherte Antwort des aktuellen Elements ist ungültig.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Zwischenspeichern von ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependency : string -&gt; unit" Usage="httpResponse.AddCacheItemDependency cacheKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">Der Schlüssel des Elements, von dem die zwischengespeicherte Antwort abhängt.</param>
        <summary>Macht die Gültigkeit einer zwischengespeicherten Antwort von einem anderen Element im Cache abhängig.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Element, das entspricht der `cacheKey` Parameter aus dem Cache entfernt wird, die zwischengespeicherte Antwort des aktuellen Elements ist ungültig.  
  
   
  
## Examples  
 Im folgende Beispiel wird ein ASP.NET-Benutzersteuerelement, die Ausgabe zwischengespeichert wird. Der Code für das Steuerelement ruft die <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> Methode mit dem Schlüssel des im gespeicherten Elements der <xref:System.Web.Caching.Cache> -Objekt als Parameter übergeben. Wenn das Element nicht im Cache vorhanden ist, wird die Antwort des Steuerelements, die sich im Ausgabecache gespeichert wurde ungültig. Dies bedeutet, dass in der nachfolgenden Anforderung der Ausgabecache eine neue Version der Antwort des Steuerelements hinzugefügt werden.  
  
 Als Nächstes der Code überprüft, ob ein Element zugeordnet eine `bookData` Schlüssel befindet sich in der `Cache` -Objekt und zeigt einen der beiden Textzeilen, die abhängig vom Ergebnis. Klicken Sie dann im Code wird die <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> Eigenschaft eine <xref:System.Web.UI.WebControls.DataGrid> -Steuerelement, das heißt `dgBooks`, durch einen Aufruf an einen benutzerdefinierten `DataHelper` -Klasse zu freigegeben `GetBookData` -Methode, und füllt die <xref:System.Web.UI.WebControls.DataGrid> mit der <xref:System.Web.UI.Control.DataBind%2A> Methode.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Zwischenspeichern von ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt der Auflistung der Dateinamen, von denen die aktuelle Antwort abhängt, eine Gruppe von Dateinamen hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">Die hinzuzufügende Dateiauflistung.</param>
        <summary>Fügt der Auflistung der Dateinamen, von denen die aktuelle Antwort abhängt, eine Gruppe von Dateinamen hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird eine ASP.NET-Seite, die Ausgabe zwischengespeichert wird. Der Code für die Seite erstellt eine <xref:System.Collections.ArrayList> von Dateipfaden und übergibt dann die <xref:System.Collections.ArrayList> als Parameter in einem Aufruf der <xref:System.Web.HttpResponse.AddFileDependencies%2A> Methode. Dadurch wird die Ausgabe zwischengespeicherte Antwort Ungültiger If alle Dateien im angegebenen die <xref:System.Collections.ArrayList> Änderungen.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Zwischenspeichern von ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : string[] -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="filenames">Ein hinzuzufügendes Array von Dateien.</param>
        <summary>Fügt einer Auflistung von Dateinamen, von denen die aktuelle Antwort abhängt, ein Array von Dateinamen hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird ein Array von Dateinamen, die die <xref:System.Web.HttpResponse.AddFileDependencies%2A> Dateiliste für Abhängigkeiten. Wenn die Dateien geändert wird, wird die zwischengespeicherte Antwort für ungültig erklärt.  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Zwischenspeichern von ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependency : string -&gt; unit" Usage="httpResponse.AddFileDependency filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Der Name der hinzuzufügenden Datei.</param>
        <summary>Fügt der Auflistung der Dateinamen, von denen die aktuelle Antwort abhängt, einen einzelnen Dateinamen hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Verwendung der <xref:System.Web.HttpResponse.AddFileDependency%2A> Methode, um eine dateiabhängigkeit, die hinzuzufügen. Sie müssen auch die Zwischenspeicherung der Ausgabe programmgesteuert oder deklarativ angeben. Z. B. um deklarative Zwischenspeichern der Ausgabe anzugeben, verwenden Sie die Direktive an. Weitere Informationen finden Sie unter [Vorgehensweise: Ausgabe des Cache-Seite mit Abhängigkeiten](https://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie einen einzelnen Dateinamen zum Hinzufügen der <xref:System.Web.HttpResponse.AddFileDependency%2A> Dateiliste für Abhängigkeiten. Wenn die Datei geändert wird, wird die zwischengespeicherte Antwort für ungültig erklärt.  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Zwischenspeichern von ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des HTTP-Headers, dem <c>value</c> hinzugefügt werden soll.</param>
        <param name="value">Die Zeichenfolge, die dem Header hinzugefügt werden soll.</param>
        <summary>Fügt dem Ausgabestream einen HTTP-Header hinzu. <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> wird bereitgestellt, um die Kompatibilität mit früheren Versionen von ASP zu gewährleisten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> entspricht dem <xref:System.Web.HttpResponse.AppendHeader%2A> und dient nur zur Kompatibilität mit früheren Versionen von ASP zu gewährleisten. Verwenden Sie ASP.NET <xref:System.Web.HttpResponse.AppendHeader%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnSendingHeaders : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpResponse.AddOnSendingHeaders callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Die Rückrufmethode.</param>
        <summary>[Wird nur in .NET Framework 4.5.2 und neueren Versionen unterstützt] 
Registriert einen Rückruf, den die ASP.NET-Laufzeit unmittelbar vor dem Senden der Antwortheader für diese Anforderung aufruft.</summary>
        <returns>Ein <see cref="T:System.Web.ISubscriptionToken" />-Objekt, das ein Abonnement für das OnSendingHeaders-Pseudoereignis darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Die AddOnSendingHeaders-Methode wird nicht aufgerufen, wenn das systemeigene Modul die Antwort zunächst leert.  
  
 Die pseudoereignis OnSendingHeaders verwendet wird, unterscheidet das Pipeline-Ereignis auf Serverebene "IHttpModule" darin, dass es sich um ein Abonnement pro Anwendung, anstatt ein Abonnement pro Anforderung ist. Die Absicht ist, dass der Rückruf Statuscode der Antwort ändern darf oder kann ein Antwortcookie oder Header festgelegt. Weitere Hinweise zur Verwendung und Einschränkungen:  
  
-   Diese Methode gilt nur, wenn IIS in der Pipeline der integrierten Pipeline-Modus ausgeführt wird und nur dann, wenn Header für die Antwort noch für die aktuelle Anforderung gesendet wurden noch nicht zur Verfügung.  
  
-   Die ASP.NET-Laufzeit garantiert nichts über den Thread nicht, die auf der Rückruf aufgerufen wird. Der Rückruf kann z. B. synchron in einem Hintergrundthread aufgerufen werden, wenn ein Wegschreiben im Hintergrund ausgeführt wird. <xref:System.Web.HttpContext.Current%2A> ist nicht unbedingt in einem derartigen Thread verfügbar sein.  
  
-   Der Rückruf muss keine Methode, die den Entitätstext der Antwort bearbeitet oder, aufrufen Dies führt zu einer leeren. Der Rückruf muss z. B. nicht aufrufen <xref:System.Web.HttpResponse.Redirect%2A>, wie diese Methode den Entitätstext der Antwort bearbeiten kann.  
  
-   Der Rückruf muss nur ein kurzer synchronen Code enthalten. Es wird versucht, einen asynchronen Vorgang aufrufen, oder warten auf solcher Vorgang kann zu einem Deadlock führen.  
  
-   Der Rückruf muss keine Ausnahme ausgelöst; Andernfalls ist die Verhalten nicht definiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Das <see cref="T:System.Web.HttpCookie" />, das dem Ausgabestream hinzugefügt werden soll.</param>
        <summary>Fügt der systeminternen Cookieauflistung ein HTTP-Cookie hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt ein neues Cookie mit dem Namen `LastVisit`, wird der Wert des Cookies auf das aktuelle Datum und die Uhrzeit und das Cookie an der aktuellen Auflistung angefügt. Alle Cookies in der cookieauflistung an den Client gesendet werden die `Set-Cookie` Header mit dem HTTP-Ausgabestream.  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wird ein Cookie angefügt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des HTTP-Headers, der dem Ausgabestream hinzugefügt werden soll.</param>
        <param name="value">Die Zeichenfolge, die an den Header angefügt werden soll.</param>
        <summary>Fügt dem Ausgabestream einen HTTP-Header hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Verwendung der <xref:System.Web.HttpResponse.AppendHeader%2A> Methode cachespezifischen-Header senden und gleichzeitig das Cache-Objektmodell verwenden (<xref:System.Web.HttpResponse.Cache%2A>) die Cacherichtlinie, HTTP-Antwortheader festlegen, die Sie Zwischenspeichern betreffen (`Cache-Control`, `Expires`, `Last-Modified`, `Pragma`, und `Vary`) kann gelöscht werden, wenn das Cache-Objektmodell verwendet wird. Dieses Verhalten ermöglicht es ASP.NET, die restriktivsten Einstellungen zu verwalten. Betrachten Sie beispielsweise eine Seite, die Benutzersteuerelemente enthält. Wenn die Steuerelemente in Konflikt stehende Cacherichtlinien haben, wird die restriktivste Cacherichtlinie verwendet werden. Wenn Sie den Header festlegt, ein Benutzersteuerelement "`Cache-Control: Public`"und ein anderes Benutzersteuerelement legt fest, den restriktiveren Header"`Cache-Control: Private`" über Aufrufe von <xref:System.Web.HttpCachePolicy.SetCacheability%2A>, die "`Cache-Control: Private`" Header wird mit der Antwort gesendet werden.  
  
 Eine Liste der HTTP/1.1-Standardheader, finden Sie unter im Abschnitt 14, "-Header von Feld-Definitionen", in der [Hypertext Transfer Protocol – HTTP/1.1-](https://go.microsoft.com/fwlink/?LinkID=73147) Spezifikation auf der Website des World Wide Web Consortium (W3C).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.AppendHeader%2A> Methode, um einen benutzerdefinierten Header zum Hinzufügen der <xref:System.Web.HttpResponse> Objekt an den anfordernden Client gesendet.  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der Header wurde nach dem Senden der HTTP-Header hinzugefügt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberSignature Language="F#" Value="member this.AppendToLog : string -&gt; unit" Usage="httpResponse.AppendToLog param" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">Der Text, der der Protokolldatei hinzugefügt werden soll.</param>
        <summary>Fügt der IIS-Protokolldatei (Internetinformationsdienste) benutzerdefinierte Protokollinformationen hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Damit wird für die angegebene Zeichenfolge in der Protokolldatei aufgezeichnet werden, zunächst müssen Sie aktivieren die **URI-Abfrage** Möglichkeit, die **Erweiterte Protokollierungseigenschaften** im Dialogfeld für die Website, die Aktivitäten in IIS protokolliert werden sollen. .  
  
 Um erweiterte Protokollierung in IIS 6.0 anzupassen, gehen Sie folgendermaßen vor:  
  
1.  Im IIS-Manager, erweitern Sie im lokalen Computerknoten, erweitern Sie den Ordner Web- oder FTP-Sites, mit der rechten Maustaste in der Web- oder FTP-Website und klicken Sie dann auf **Eigenschaften**.  
  
2.  Klicken Sie auf die **Web- oder FTP-Site** Registerkarte, und wählen Sie dann die **Aktivieren der Protokollierung** Kontrollkästchen (wenn es nicht bereits ausgewählt ist).  
  
3.  In der **Aktives Protokollformat** auf **erweiterten W3C-Protokolldateiformat**.  
  
4.  Klicken Sie auf **Eigenschaften**.  
  
5.  Klicken Sie auf die **erweitert** Registerkarte, wählen Sie die Eigenschaften, die Sie verwenden möchten, melden Sie sich, und klicken Sie dann auf **OK**.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie eine Zeichenfolge in das Protokoll angefügt wird.  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=36829">Windows Server 2003-Produkthilfe</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.ApplyAppPathModifier : string -&gt; string" Usage="httpResponse.ApplyAppPathModifier virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Der virtuelle Pfad zu einer Ressource.</param>
        <summary>Fügt dem virtuellen Pfad eine Sitzungs-ID hinzu, wenn für die Sitzung ein <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" />-Sitzungszustand verwendet wird, und gibt den kombinierten Pfad zurück. Wenn der <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" />-Sitzungszustand nicht verwendet wird, gibt <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> den ursprünglichen virtuellen Pfad zurück.</summary>
        <returns>Der <paramref name="virtualPath" /> mit der eingefügten Sitzungs-ID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> wird nur mit Sitzungen ohne Cookies verwendet, um absolute Suchen nach HREFs zu erstellen.  
  
   
  
## Examples  
 Das folgende Beispiel deklariert eine String-Variable, die mit dem Namen `urlConverted`, und legt es auf das Ergebnis einer <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> Methodenaufruf. Der Code übergibt dann den Wert der Variablen auf einen <xref:System.Web.UI.WebControls.HyperLink> des Steuerelements <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> Eigenschaft.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlush : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpResponse.BeginFlush (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Das Rückrufobjekt.</param>
        <param name="state">Antwortstatus.</param>
        <summary>Sendet die gesamte gegenwärtig gepufferte Antwort an den Client.</summary>
        <returns>Das asynchrone Ergebnisobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zugrunde liegende <xref:System.Web.HttpWorkerRequest> Objekt unterstützt asynchrone leerungsvorgänge und diese Methode wird aufgerufen, ein asynchrones Modulereignis oder ein asynchroner Handler, der Löschvorgang asynchron ausgeführt. Andernfalls wird die Leerung synchron ausgeführt. Asynchroner Löschvorgang wird für IIS 6.0 und höher unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die Antwort wurde bereits abgeschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.BinaryWrite : byte[] -&gt; unit" Usage="httpResponse.BinaryWrite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Die Bytes, die in den Ausgabestream geschrieben werden sollen.</param>
        <summary>Schreibt eine Zeichenfolge von Binärzeichen in den HTTP-Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel liest eine Textdatei in einen Puffer und den Puffer in den HTTP-Ausgabestream schreibt.  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Ausgabe gepuffert und nach der vollständigen Verarbeitung der Antwort gesendet werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die Ausgabe an den Client gepuffert wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpResponse.Buffer%2A> Eigenschaft ist veraltet, zugunsten des der <xref:System.Web.HttpResponse.BufferOutput%2A> Eigenschaft und wird nur bereitgestellt, um Kompatibilität mit früheren Versionen von ASP zu gewährleisten. Verwenden Sie ASP.NET <xref:System.Web.HttpResponse.BufferOutput%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BufferOutput : bool with get, set" Usage="System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Ausgabe gepuffert und nach der vollständigen Verarbeitung der Seite gesendet werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die Ausgabe an den Client gepuffert wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.ContentType%2A> -Eigenschaft für die Antwort auf Image/Jpeg, ruft der <xref:System.Web.HttpResponse.Clear%2A> Methode, um anderen Inhalt zu entfernen, die mit der Antwort verbunden sein, und legt dann die <xref:System.Web.HttpResponse.BufferOutput%2A> Eigenschaft auf "true", damit die gesamte Seite stehen verarbeitet, bevor Sie Inhalt an den anfordernden Client gesendet wird.  
  
 Ein vollständiges Beispiel finden Sie unter den <xref:System.Web.HttpResponse> Klasse.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.HttpCachePolicy" Usage="System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Cachingrichtlinie für eine Webseite ab, d. h. Ablaufzeit, Datenschutzeinstellungen und Variationsklauseln.</summary>
        <value>Ein <see cref="T:System.Web.HttpCachePolicy" />-Objekt, das Informationen zur Cachingrichtlinie für die aktuelle Antwort enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel schreibt die Eigenschaften des die aktuelle Cacherichtlinie in den HTTP-Ausgabestream.  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheControl : string with get, set" Usage="System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see langword="Cache-Control" />-HTTP-Header ab, der mit einem der <see cref="T:System.Web.HttpCacheability" />-Enumerationswerte übereinstimmt, oder legt diesen fest.</summary>
        <value>Eine Zeichenfolgendarstellung des <see cref="T:System.Web.HttpCacheability" />-Enumerationswerts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Werte für `Private`, `Public`, und `No-Cache` sind Zeichenfolgen und muss in Anführungszeichen eingeschlossen werden (""). Wenn die <xref:System.Web.HttpResponse.CacheControl%2A> -Eigenschaftensatz auf einen Wert, der nicht mit einer der übereinstimmt der <xref:System.Web.HttpCacheability> -Enumerationswerte fest, wird eine <xref:System.ArgumentException> ausgelöst. Wenn die <xref:System.Web.HttpResponse.CacheControl%2A> Eigenschaft nicht festgelegt ist, die cachefähigkeit von der Antwort nastaven NA hodnotu <xref:System.Web.HttpCacheability.NoCache>.  
  
 Die `CacheControl`, <xref:System.Web.HttpResponse.Expires%2A>, und <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> Eigenschaften sind veraltet. Stattdessen die Methoden der <xref:System.Web.HttpCachePolicy> Klasse stehen über die <xref:System.Web.HttpResponse.Cache%2A> systeminternes Objekt zum Steuern von Internet Information Services (IIS) ausgeben, Cache und Clientcaches.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der festgelegte Zeichenfolgenwert stimmt nicht mit einem der <see cref="T:System.Web.HttpCacheability" />-Enumerationswerte überein.</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Charset : string with get, set" Usage="System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den HTTP-Zeichensatz des Ausgabestreams ab oder legt diesen fest.</summary>
        <value>Der HTTP-Zeichensatz des Ausgabestreams.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Charset` Eigenschaft kann festgelegt werden, um `null` unterdrückt werden, die HTTP `Content-Type` Header.  
  
   
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob der Zeichensatz des Ausgabestreams Mitteleuropäisch (ISO).  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die <see langword="Charset" />-Eigenschaft wurde nach dem Senden von Headern festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="httpResponse.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Inhaltsausgaben aus dem Pufferstream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpResponse.Clear%2A> Methode Headerinformationen nicht gelöscht.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.ContentType%2A> -Eigenschaft für die Antwort auf Image/Jpeg, ruft der <xref:System.Web.HttpResponse.Clear%2A> Methode, um anderen Inhalt zu entfernen, die mit der Antwort verbunden sein, und legt dann die <xref:System.Web.HttpResponse.BufferOutput%2A> Eigenschaft auf "true", damit Sie auf der Seite abgeschlossen werden verarbeitet, bevor Sie Inhalt an den anfordernden Client gesendet wird.  
  
 Ein vollständiges Beispiel finden Sie unter den <xref:System.Web.HttpResponse> Klasse.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="httpResponse.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Inhaltsausgaben aus dem Pufferstream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpResponse.ClearContent%2A> Methode Headerinformationen nicht gelöscht.  
  
   
  
## Examples  
 Das folgende Beispiel löscht den gesamten Inhalt aus dem Pufferstream.  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberSignature Language="F#" Value="member this.ClearHeaders : unit -&gt; unit" Usage="httpResponse.ClearHeaders " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Header aus dem Pufferstream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.ClearHeaders%2A> Methode, um sicherzustellen, dass keine Header mit der aktuellen Antwort gesendet werden. Diese Technik kann besonders wichtig, wenn die Antwort von ASP.NET ein Bild, z. B. eine JPEG-Datei generiert werden. In diesem Beispiel die <xref:System.Web.HttpResponse.ContentType%2A> -Eigenschaftensatz auf Image/Jpeg.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die Header wurden nach dem Senden der HTTP-Header gelöscht.</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientDisconnectedToken : System.Threading.CancellationToken" Usage="System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Threading.CancellationToken" />-Objekt ab, das aktiviert wird, wenn der Client die Verbindung trennt.</summary>
        <value>Das Abbruchtoken.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese API ist threadsicher. Es gibt jedoch einige Einschränkungen auf wie das Abbruchtoken, das verwendet werden soll. Es eine nicht ordnungsgemäße Verwendung kann zu Racebedingungen, Deadlocks oder anderen unerwarteten Verhalten führen. Beachten Beachten Sie die folgenden Richtlinien:  
  
-   Stellen Sie sicher, dass Sie nicht außerhalb der Grenzen einer einzelnen Anforderung, die API aufrufen, da ASP.NET, der das Abbruchtoken, das am Ende der Anforderung verworfen werden. Es gibt keine Garantie, die das Token immer in einem abgebrochenen Zustand übergehen, bevor er verworfen wird. Wenn Sie ohne den Client getrennt, dass die Anforderung abgeschlossen ist, wird z. B. das Token verworfen, ohne dass zuerst abgebrochen wurde.  
  
-   Sollten Sie nicht warten auf die <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>, wie dies den Zweck der eine asynchrone Benachrichtigung verfehlt und kann zu Deadlocks kommen.  
  
-   Rufen Sie nicht die <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> Überladungen, die den Rückruf im ursprünglichen Aufrufen <xref:System.Threading.SynchronizationContext> Objekt.  
  
-   Verwenden Sie nicht die <xref:System.Web.HttpContext> Objekt oder anderen nicht threadsichere ASP.NET systeminternen Objekten innerhalb des Rückrufs bereitgestellt, um die <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> Methode. Der Rückruf kann gleichzeitig mit anderen ASP.NET ausgeführt werden oder Code der Anwendung.  
  
-   Halten Sie die Rückrufmethoden kurzer Ausführungszeit und nicht blockierend.  
  
-   Stellen Sie die höchste anstrengungen, um zu vermeiden, Auslösen von Ausnahmen von in die Rückrufmethoden.  
  
 Diese Eigenschaft wird nur in Internet Information Service (IIS) 7.5 oder höher im integrierten Modus unterstützt. Wenn Sie es ohne den richtigen IIS-Version oder die Pipelineversion-Modus Aufrufen einer <xref:System.PlatformNotSupportedException> ausgelöst. Um die IIS-Version zu ermitteln, verwenden Sie <xref:System.Web.HttpRuntime.IISVersion%2A>. Verwenden Sie zum Bestimmen des Pipelinemodus <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die Socketverbindung zu einem Client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird die Verbindung an den Client in einer abrupten Weise beendet und ist nicht für normale Verarbeitung von HTTP-Anforderung bestimmt. Die Methode sendet ein Zurücksetzungspaket an den Client, der Antwortdaten, die gepuffert werden auf dem Server, den Client oder irgendwo dazwischen zu löschenden verursachen kann.  
  
 Allerdings in der Regel sollte rufen Sie <xref:System.Web.HttpApplication.CompleteRequest%2A> stattdessen sollten Sie springen die <xref:System.Web.HttpApplication.EndRequest> Ereignis und eine Antwort an den Client senden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den HTTP-Zeichensatz des Ausgabestreams ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Text.Encoding" />-Objekt, das Informationen über den Zeichensatz für die aktuelle Antwort enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standard `ContentEncoding` kann angegeben werden, in einer ASP.NET-Konfigurationsdatei in die [Globalization-Element ((ASP.NET Einstellungsschema)](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) Abschnitt. Wenn <xref:System.Web.HttpResponse.ContentEncoding%2A> wird vom Client angegeben, werden die standardkonfigurationseinstellungen außer Kraft gesetzt.  
  
   
  
## Examples  
 Im folgende Beispiel schreibt eine lesbare Beschreibung der die zeichensatzcodierung fest in den Ausgabestream.  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Es wurde versucht, <see cref="P:System.Web.HttpResponse.ContentEncoding" /> auf <see langword="null" /> festzulegen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den HTTP-MIME-Typ des Ausgabestreams ab oder legt diesen fest.</summary>
        <value>Der HTTP-MIME-Typ des Ausgabestreams. Der Standardwert ist „<see langword="text/html" />“.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.ContentType%2A> -Eigenschaft für die Antwort auf Image/Jpeg, ruft der <xref:System.Web.HttpResponse.Clear%2A> Methode, um anderen Inhalt zu entfernen, die mit der Antwort verbunden sein, und legt dann die <xref:System.Web.HttpResponse.BufferOutput%2A> Eigenschaft auf "true", damit Sie auf der Seite abgeschlossen werden verarbeitet, bevor Sie Inhalt an den anfordernden Client gesendet wird.  
  
 Ein vollständiges Beispiel finden Sie unter den <xref:System.Web.HttpResponse> Klasse.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die <see cref="P:System.Web.HttpResponse.ContentType" />-Eigenschaft ist auf <see langword="null" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Cookieauflistung der Antwort ab.</summary>
        <value>Die Cookieauflistung der Antwort.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET umfasst zwei systeminterne Cookie-Auflistungen. Die Auflistung erfolgt über die <xref:System.Web.HttpRequest.Cookies%2A> Auflistung von <xref:System.Web.HttpRequest> enthält Cookies vom Client an den Server im übertragen die `Cookie` Header. Die Auflistung erfolgt über die <xref:System.Web.HttpResponse.Cookies%2A> Auflistung von <xref:System.Web.HttpResponse> enthält neue Cookies auf dem Server erstellt und an den Client übertragen die `Set-Cookie` Header.  
  
 Nach dem Hinzufügen eines Cookies mithilfe der <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> -Auflistung, der das Cookie ist sofort verfügbar ist, in der <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> -Auflistung, selbst wenn die Antwort nicht an den Client gesendet wurden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues Cookie mit dem Namen `LastVisit`, wird der Wert des Cookies auf das aktuelle Datum und die Uhrzeit und der aktuellen Auflistung der Cookies hinzugefügt. Alle Cookies in der cookieauflistung an den Client gesendet werden die `Set-Cookie` Header mit dem HTTP-Ausgabestream.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberSignature Language="F#" Value="member this.DisableKernelCache : unit -&gt; unit" Usage="httpResponse.DisableKernelCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deaktiviert die Kernelzwischenspeicherung für die aktuelle Antwort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Kernelzwischenspeicherung nicht unterstützt wird, hat diese Methode keine Auswirkungen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberSignature Language="F#" Value="member this.DisableUserCache : unit -&gt; unit" Usage="httpResponse.DisableUserCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deaktiviert IIS-Benutzermodus-Caching für diese Antwort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn IIS-Benutzermodus-caching nicht unterstützt wird, gibt diese Methode zurück, ohne dass eine Aktion ausgeführt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberSignature Language="F#" Value="member this.End : unit -&gt; unit" Usage="httpResponse.End " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sendet alle derzeit gepufferten Ausgaben an den Client, beendet die Ausführung der Seite und löst das <see cref="E:System.Web.HttpApplication.EndRequest" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird nur für Kompatibilität mit ASP bereitgestellt, d. h. für die Kompatibilität mit COM-basierten Webprogrammierung-Technologie, die ASP.NET vorangestellt. Wenn Sie springen möchten die <xref:System.Web.HttpApplication.EndRequest> Ereignis und eine Antwort an den Client senden, es empfiehlt sich in der Regel Aufrufen <xref:System.Web.HttpApplication.CompleteRequest%2A> stattdessen.  
  
 Zum imitieren des Verhaltens der der `End` -Methode in ASP, versucht diese Methode zum Auslösen einer <xref:System.Threading.ThreadAbortException> Ausnahme. Wenn dieser Versuch erfolgreich ist, wird der aufrufende Thread die nachteilig auf die Leistung Ihrer Website wird abgebrochen. In diesem Fall kein Code nach dem Aufruf der <xref:System.Web.HttpResponse.End%2A> Methode ausgeführt wird.  
  
 Wenn die <xref:System.Web.HttpResponse.End%2A> Methode kann nicht zum Auslösen einer <xref:System.Threading.ThreadAbortException>, leert sie stattdessen die Antwortbytes an den Client. Dies wird synchron, was auch negativ auf die Leistung Ihrer Website auswirken kann.  
  
 In beiden Fällen (unabhängig davon, ob eine <xref:System.Threading.ThreadAbortException> erfolgreich ausgelöst wird), der Antwortpipeline zu den <xref:System.Web.HttpApplication.EndRequest> Ereignis.  
  
 Die <xref:System.Web.HttpApplication.CompleteRequest%2A> Methode ohne eine Ausnahme ausgelöst werden, und nach dem Aufruf von code die <xref:System.Web.HttpApplication.CompleteRequest%2A> Methode ausgeführt werden kann. Wenn Sie beabsichtigen, die Ausführung der nachfolgende Code zu vermeiden, und wenn die Leistungseinbußen durch <xref:System.Web.HttpResponse.End%2A> akzeptabel ist, rufen Sie <xref:System.Web.HttpResponse.End%2A> anstelle von <xref:System.Web.HttpApplication.CompleteRequest%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">Der Aufruf von <see cref="M:System.Web.HttpResponse.End" /> hat die aktuelle Anforderung beendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndFlush : IAsyncResult -&gt; unit" Usage="httpResponse.EndFlush asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das asynchrone Ergebnisobjekt.</param>
        <summary>Schließt eine asynchrone Leerung ab.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Asynchroner Löschvorgang wird nicht unterstützt und der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Asynchroner Löschvorgang wird nicht unterstützt, und der <paramref name="asyncResult" />-Parameter kann nicht in ein <c>FlushAsyncResult</c>-Objekt umgewandelt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Expires : int with get, set" Usage="System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Minuten ab, nach denen eine im Browser zwischengespeicherte Seite abläuft, oder legt diese fest. Wenn der Benutzer zur selben Seite zurückkehrt, bevor diese abgelaufen ist, wird die zwischengespeicherte Version angezeigt. <see cref="P:System.Web.HttpResponse.Expires" /> wird bereitgestellt, um die Kompatibilität mit früheren Versionen von ASP zu gewährleisten.</summary>
        <value>Die Anzahl von Minuten, nach denen die Seite abläuft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Expires`, <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> und <xref:System.Web.HttpResponse.CacheControl%2A> Eigenschaften sind veraltet, und die Methoden der <xref:System.Web.HttpCachePolicy> Klasse, die über die <xref:System.Web.HttpResponse.Cache%2A> systeminternes Objekt zum Steuern von Internet Information Services (IIS)-Ausgabecache und Client-caches.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ExpiresAbsolute : DateTime with get, set" Usage="System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das absolute Datum und die Uhrzeit ab, zu der die zwischengespeicherten Informationen aus dem Cache entfernt werden sollen, oder legt diese fest. <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> wird bereitgestellt, um die Kompatibilität mit früheren Versionen von ASP zu gewährleisten.</summary>
        <value>Das Datum und die Uhrzeit für das Ablaufen der Seite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ExpiresAbsolute`, <xref:System.Web.HttpResponse.Expires%2A>, und <xref:System.Web.HttpResponse.CacheControl%2A> Eigenschaften sind veraltet, und die Methoden der <xref:System.Web.HttpCachePolicy> Klasse, die über die <xref:System.Web.HttpResponse.Cache%2A> systeminternes Objekt zum Steuern von Internet Information Services (IIS)-Ausgabecache und Client-caches.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Wrappingfilterobjekt ab, das den HTTP--Einheitstextkörper vor der Übertragung ändern soll, oder legt dieses fest.</summary>
        <value>Das <see cref="T:System.IO.Stream" />-Objekt, das als Ausgabefilter verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Erstellung einer `Stream` Objekt, und legen die <xref:System.Web.HttpResponse.Filter%2A> Eigenschaft, um die `Stream` alle HTTP-Objekt, Ausgabe, die per <xref:System.Web.HttpResponse.Write%2A> durch den Filter übergibt.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine ASP.NET-Seite, der festlegt der <xref:System.Web.HttpResponse.Filter%2A> Eigenschaft, um eine neue Instanz der dem `UpperCaseFilter` Klasse, eine benutzerdefinierte <xref:System.IO.Stream> -Klasse, die sämtlichen Text konvertiert, die in Großbuchstaben durchlaufen. Die Informationen über die Anforderung wird gespeichert, in eine Textdatei, und klicken Sie dann die <xref:System.Web.HttpResponse.Filter%2A> festgelegt wird. Nach dem Antwortfilter vorhanden ist, ruft der Code die <xref:System.Web.HttpRequest.MapPath%2A> -Methode zum Abrufen des absoluten Pfads in eine Textdatei mit dem Namen `TestFile.txt` , dient als Quelle für den Inhalt der Antwort. Der Code erstellt dann eine neue <xref:System.IO.StreamReader> Objekt zum Lesen der Textdatei von Anfang bis Ende, und ruft dann die <xref:System.Web.HttpResponse.Write%2A> Methode, um den Inhalt der Datei auf der Seite anzuzeigen.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Filtern ist bei der Entität nicht zulässig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="httpResponse.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sendet die gesamte gegenwärtig gepufferte Ausgabe an den Client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der zwischengespeicherten erzwingt, dass die Ausgabe an den Client gesendet werden. Die <xref:System.Web.HttpResponse.Flush%2A> Methode kann mehrmals aufgerufen werden, während der anforderungsverarbeitung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Drawing.Graphics.Save%2A> Methode zum Speichern einer <xref:System.Drawing.Bitmap> -Objekt an die <xref:System.Web.HttpResponse.OutputStream%2A> -Eigenschaft und konvertiert das Bild in das JPEG-format. Der Code ruft dann die `Dispose` Methode für die <xref:System.Drawing.Bitmap> Objekt und ein <xref:System.Drawing.Graphics> Objekts, die Freigabe der Ressourcen, die sie verwendet haben. Es ruft dann die <xref:System.Web.HttpResponse.Flush%2A> Methode, um den Inhalt der Antwort an den anfordernden Client zu senden.  
  
 Ein vollständiges Beispiel finden Sie unter den <xref:System.Web.HttpResponse> Klasse.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der Antwort wird der Cache entleert.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpResponse.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sendet die gesamte gegenwärtig gepufferte Ausgabe asynchron an den Client.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Text.Encoding" />-Objekt ab, das die Codierung für den aktuellen Headerausgabestream darstellt, oder legt dieses fest.</summary>
        <value>
          <see cref="T:System.Text.Encoding" /> mit Informationen zum Zeichensatz für den aktuellen Header.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpResponse.HeaderEncoding%2A> Eigenschaft können Sie die Möglichkeit, zu deaktivieren oder Ändern der <xref:System.Text.Encoding> Objekt für einen Antwortheader mithilfe der <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF7Encoding>, oder <xref:System.Text.UTF8Encoding> Objekt. Der Standardwert für die Verschlüsselung ist die <xref:System.Text.UTF8Encoding> Klasse.  
  
 Durch Ändern des Typs der <xref:System.Web.HttpResponse.HeaderEncoding%2A> -Eigenschaft, Sie können möglicherweise erhöhen das Risiko von bestimmten Angriffen oder Ursache sensible Daten über den Antwortheader gesendet werden. Header Injection-Angriffen können vermieden werden, teilweise durch eine verlassen die <xref:System.Web.HttpResponse.HeaderEncoding%2A> Eigenschaft einer Antwort auf die Standardeinstellung. Ein Angriff gegen die betroffene Anwendung kann als Teil eines Antwortheaders enthaltene Daten zurückgegeben werden. Wenn die <xref:System.Web.HttpResponse.HeaderEncoding%2A> aufgrund einer Anforderung deaktiviert ist, für die Fortsetzung Zeilen in einem Header oder Header abhängig vom Ergebnis nicht vertrauenswürdiger Daten erstellt wird, die Daten im Anforderungsheader überprüft werden, sollten vor dem Senden an den Antwortstream.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Codierungswert ist <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Der Codierungswert ist <see cref="P:System.Text.Encoding.Unicode" />.  
  
\- oder – 
Die Header wurden bereits gesendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung von Antwortheadern ab.</summary>
        <value>Eine <see cref="T:System.Collections.Specialized.NameValueCollection" /> von Antwortheadern.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpResponse.Headers%2A> Eigenschaft wird nur unterstützt, mit der [!INCLUDE[iisver](~/includes/iisver-md.md)] integrierten Pipelinemodus und mindestens .NET Framework 3.0. Wenn Sie versuchen, Zugriff auf die <xref:System.Web.HttpResponse.Headers%2A> -Eigenschaft und eine der folgenden zwei Bedingungen nicht erfüllt sind, eine <xref:System.PlatformNotSupportedException> ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Der Vorgang erfordert den integrierten Pipelinemodus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und mindestens .NET Framework Version 3.0.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=86952">Aktualisieren von ASP.NET-Anwendungen auf IIS 7.0: Unterschiede zwischen den integrierten Modus von IIS 7.0 und klassischen Modus</related>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HeadersWritten : bool" Usage="System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Wird nur in .NET Framework 4.5.2 und neueren Versionen unterstützt] 
Ruft einen Wert ab, der angibt, ob die Antwortheader geschrieben wurden.</summary>
        <value>
          <see langword="true" />, wenn die Antwortheader geschrieben wurden, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClientConnected : bool" Usage="System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Client noch mit dem Server verbunden ist.</summary>
        <value>
          <see langword="true" />, wenn der Client gegenwärtig mit dem Server verbunden ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpResponse.IsClientConnected%2A> -Eigenschaft gibt `false` Wenn folgenden Bedingungen erfüllt sind:  
  
-   Die Verbindung an den Client wurde beendet. Dies kann auftreten, wenn die <xref:System.Web.HttpResponse.Close%2A> Methode wurde aufgerufen, oder wenn der Client beendet die Ausführung der Webseite oder zu einer anderen Seite.  
  
-   Die <xref:System.Web.HttpWorkerRequest> Objekt, das die Abfrage verarbeitet wird, ist `null` oder <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> Methodenrückgabe `false`. Wenn eine benutzerdefinierte <xref:System.Web.HttpWorkerRequest> Objekt verarbeitet die Anforderung, und klicken Sie dann die <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> Methode kann festgelegt werden basierend auf benutzerdefinierten Kriterien. Beispielsweise kann die benutzerdefinierten workertarifs-Anforderung einen Timeout nach einiger Zeit erzwingen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.IsClientConnected%2A> Eigenschaft zu überprüfen, ob der Client, der die Seite anfordert, wird mit dem Server verbunden bleibt. Wenn <xref:System.Web.HttpResponse.IsClientConnected%2A> true ist, ruft der Code die <xref:System.Web.HttpResponse.Redirect%2A> -Methode, und der Client eine andere Seite angezeigt wird. Wenn <xref:System.Web.HttpResponse.IsClientConnected%2A> ist "false", und der Code ruft dann die <xref:System.Web.HttpResponse.End%2A> -Methode und die gesamte seitenverarbeitung wird beendet.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequestBeingRedirected : bool" Usage="System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob der Client an eine neue Adresse weitergeleitet wird.</summary>
        <value>
          <see langword="true" />, wenn der Wert des Antwortheaders der Adresse sich von der aktuellen Adresse unterscheidet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> Eigenschaft mit dem die <xref:System.Web.HttpResponse.RedirectLocation%2A> Eigenschaft, und bestimmen Sie, ob der absolute URI, an den Client in der HTTP-Übertragung `Location` Header unterscheidet sich von der aktuellen URI und was den neuen gewünschten URI, der übertragen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter with get, set" Usage="System.Web.HttpResponse.Output" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aktiviert die Ausgabe von Text an den ausgehenden HTTP-Antwortstream.</summary>
        <value>Ein <see cref="T:System.IO.TextWriter" />-Objekt, das benutzerdefinierte Ausgaben an den Client ermöglicht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird eine ASP.NET-Seite, die enthält eine <xref:System.Web.UI.WebControls.TextBox> -Steuerelement mit der <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> -Eigenschaftensatz auf <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>. Der Code der Seite wird den Text, der ein Benutzer in ein die <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>, verwendet der <xref:System.Web.HttpServerUtility.HtmlEncode%2A> Methode, um HTML zu codieren, und die <xref:System.Web.HttpResponse.Output%2A> Eigenschaft, um die codierte Zeichenfolge auf der Seite anzuzeigen.  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ermöglicht die binäre Ausgabe an den ausgehenden HTTP-Inhaltstext.</summary>
        <value>Ein E/A-<see cref="T:System.IO.Stream" />-Objekt, das den Rohdateninhalt des ausgehenden HTTP-Inhaltstexts darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ab .NET Framework, Version 2.0, bei der Verwendung der <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> -Methode der zurückgegebenen von e/a-Datenstrom der <xref:System.Web.HttpResponse.OutputStream%2A> -Eigenschaft, die folgenden Ausnahmen ausgelöst werden können:  
  
-   <xref:System.ArgumentOutOfRangeException>, wenn die `offset` oder `count` -Parameter ist negativ oder, wenn die `buffer` des Parameters-Länge minus der `offset` -Parameter ist kleiner als oder gleich 0 (null).  
  
-   <xref:System.ArgumentNullException>, wenn die `buffer` Parameter `null`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Drawing.Image.Save%2A> Methode zum Speichern einer <xref:System.Drawing.Bitmap> -Objekt an die <xref:System.Web.HttpResponse.OutputStream%2A> -Eigenschaft, und das Bild im JPEG-Format konvertiert. Der Code ruft dann die Dispose-Methode für die <xref:System.Drawing.Bitmap> Objekt und ein <xref:System.Drawing.Graphics> Objekts, die Freigabe der Ressourcen, die sie verwendet haben. Abschließend ruft der Code die <xref:System.Web.HttpResponse.Flush%2A> Methode, um den Inhalt der Antwort an den anfordernden Client zu senden.  
  
 Ein vollständiges Beispiel finden Sie unter den <xref:System.Web.HttpResponse> Klasse.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="OutputStream" /> ist nicht verfügbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Pics : string -&gt; unit" Usage="httpResponse.Pics value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die dem Header mit <see langword="PICS-Label" /> hinzugefügt werden soll.</param>
        <summary>Fügt einen HTTP-Header mit <see langword="PICS-Label" /> an den Ausgabestream an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plattform für das Internet Content Selection (PICS) ist eine World Wide Web Consortium (W3C)-Standard für die Bezeichnung von Inhalten. PICS ist im Wesentlichen eine Sprache für die Erstellung einer Bewertungen.  
  
 Jeder Wert kann eine PICS-Bezeichnung sein. ASP.NET überprüft nicht die Bezeichnung. Die maximale Länge der Zeichenfolge beträgt 255 Zeichen. Weitere Informationen zur Syntax und PICS-Standards finden Sie unter den [World Wide Web Consortium](https://go.microsoft.com/fwlink/?LinkID=37125) Website.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine ASP.NET-Seite, die ein Bild anzeigt. Die Seite Code Ruft die <xref:System.Web.HttpResponse.Pics%2A> Methode zum Festlegen von HTTP `PICS-Label` Header für die Antwort. Die Zeichenfolge, die als Parameter übergeben, wird die <xref:System.Web.HttpResponse.Pics%2A> Methode darstellt, einen Klassifikationsbezeichner, die von der Website der Internet Content Bewertung Association (ICRA).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stuft ein zugesichertes Objekt herauf.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string -&gt; unit" Usage="httpResponse.PushPromise path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die URL der Pushanforderung. Dies sollte der virtuelle Pfad der relativen Ressource sein, die der Server auf den Client pushen soll.</param>
        <summary>Diese API dient zur Unterstützung von Anwendungen, die Pushzusagen an HTTP 2.0-Clients senden. Weitere Informationen zu HTTP 2-Serverpushvorgängen finden Sie unter <see href="https://http2.github.io/http2-spec/#PushResources">HTTP/2 Specification Section 8.2: Server Push</see>.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pushpromise(String) ist nicht deterministisch, und Anwendungen sollte keine Logik, die von ihr abhängig ist. Sein einzige Zweck ist die Leistungsvorteile in einigen Fällen. Es gibt viele Bedingungen (Protokoll und Implementierung), die verursachen können, um die pushanforderungen vollständig zu ignorieren. Der Annahme basieren auf Fire-and-forget.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpResponse.PushPromise (path, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">Die URL der Pushanforderung. Dies sollte der virtuelle Pfad der relativen Ressource sein, die der Server auf den Client pushen soll.</param>
        <param name="method">HTTP-Anforderungsmethode, die von der Pushanforderung verwendet wird.</param>
        <param name="headers">HTTP-Anforderungsheader, der von der Pushanforderung verwendet wird.</param>
        <summary>Diese API dient zur Unterstützung von Anwendungen, die Pushzusagen an HTTP 2.0-Clients senden. Weitere Informationen zu HTTP 2-Serverpushvorgängen finden Sie unter <see href="https://http2.github.io/http2-spec/#PushResources">HTTP/2 Specification Section 8.2: Server Push</see>.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pushpromise(String) ist nicht deterministisch, und Anwendungen sollte keine Logik, die von ihr abhängig ist. Sein einzige Zweck ist die Leistungsvorteile in einigen Fällen. Es gibt viele Bedingungen (Protokoll und Implementierung), die verursachen können, um die pushanforderungen vollständig zu ignorieren. Der Annahme basieren auf Fire-and-forget.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Leitet einen Client zu einer neuen URL um.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Der Zielort. Dies kann ein zur Anwendung relativer virtueller Pfad sein.</param>
        <summary>Leitet eine Anforderung an eine neue URL um und gibt die neue URL an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Web.HttpResponse.Redirect%2A> entspricht dem Aufruf <xref:System.Web.HttpResponse.Redirect%2A> mit den zweiten Parameter auf `true`.  
  
 <xref:System.Web.HttpResponse.Redirect%2A> Aufrufe <xref:System.Web.HttpResponse.End%2A> welche löst eine <xref:System.Threading.ThreadAbortException> Ausnahme nach Abschluss. Diese Ausnahme hat sich nachteilig auf die Leistung der Webanwendung. Daher wird empfohlen, anstelle diese Überladung, die Sie verwenden die <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> überladen, und übergeben Sie `false` für die `endResponse` -Parameter, und rufen Sie dann die <xref:System.Web.HttpApplication.CompleteRequest%2A> Methode. Weitere Informationen finden Sie unter der Methode <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Für mobile Seiten nur wenn Ihre Anwendung für Sitzungen ohne Cookies verwendet, oder Anforderungen von mobilen Geräten, die Sitzungen ohne Cookies, erfordern möglicherweise kann mit einer Tilde (~) in einem Pfad führen Erstellen einer neuen Sitzung und Sitzungsdaten verloren gehen. Zum Festlegen einer Eigenschaft eines mobilen Steuerelements mit einem Pfad wie z. B. "~ / Pfad", lösen Sie den Pfad mit <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "~ / Pfad" vor der-Eigenschaft zuweisen.  
  
 ASP.NET führt die Umleitung von einer HTTP-Statuscode 302 zurückgeben. Eine alternative Möglichkeit zum Übertragen von Steuerelement zu einer anderen Seite ist die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode ist in der Regel effizienter, da sie nicht über einen Roundtrip an dem Client führt. Weitere Informationen finden Sie unter [Vorgehensweise: Benutzer zu einer anderen Seite umleiten](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine nicht bedingte Umleitung an eine andere Website an.  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wird eine Umleitung versucht.</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string * bool -&gt; unit" Usage="httpResponse.Redirect (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Der Zielspeicherort.</param>
        <param name="endResponse">Gibt an, ob die Ausführung der aktuellen Seite beendet werden soll.</param>
        <summary>Leitet einen Client zu einer neuen URL um. Gibt die neue URL an und meldet, ob die Ausführung der aktuellen Seite beendet werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine absolute URL (z. B. http://www.contoso.com/default.aspx) oder eine relative URL (z. B. "default.aspx") kann als Ziel angegeben werden, aber einige Browser möglicherweise eine relative URL abgelehnt.  
  
 Bei Verwendung dieser Methode in einem Seite-Ereignishandler eine Anforderung beendet wird, für eine Seite, und starten Sie eine neue Anforderung für eine andere Seite festgelegt `endResponse` zu `false` und rufen Sie dann die <xref:System.Web.HttpApplication.CompleteRequest%2A> Methode. Bei Angabe von `true` für die `endResponse` Parameter, um diese Methode ruft die <xref:System.Web.HttpResponse.End%2A> -Methode für die ursprüngliche Anforderung, die auslöst, ein <xref:System.Threading.ThreadAbortException> Ausnahme aus, wenn der Vorgang abgeschlossen ist. Diese Ausnahme hat sich nachteilig auf die Leistung der Webanwendung, weshalb übergeben `false` für die `endResponse` Parameter wird empfohlen. Weitere Informationen finden Sie unter der Methode <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Für mobile Seiten Wenn Ihre Anwendung für Sitzungen ohne Cookies verwendet, oder Anforderungen von mobilen Geräten, die Sitzungen ohne Cookies, erfordern möglicherweise kann mit einer Tilde (~) in einem Pfad eine neue Sitzung erstellt und möglicherweise Daten zu verlieren. Zum Festlegen einer Eigenschaft eines mobilen Steuerelements mit einem Pfad wie z. B. "~ / Pfad", lösen Sie den Pfad mit <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "~ / Pfad" vor der-Eigenschaft zuweisen.  
  
 ASP.NET führt die Umleitung von einer HTTP-Statuscode 302 zurückgeben. Eine alternative Möglichkeit zum Übertragen von Steuerelement zu einer anderen Seite ist die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode ist in der Regel effizienter, da sie nicht über einen Roundtrip an dem Client führt. Weitere Informationen finden Sie unter [Vorgehensweise: Benutzer zu einer anderen Seite umleiten](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.IsClientConnected%2A> Eigenschaft zu überprüfen, ob der Client, der die Seite anfordert, wird mit dem Server verbunden bleibt. Wenn <xref:System.Web.HttpResponse.IsClientConnected%2A> true ist, ruft der Code die <xref:System.Web.HttpResponse.Redirect%2A> -Methode, und der Client eine andere Seite angezeigt wird. Wenn <xref:System.Web.HttpResponse.IsClientConnected%2A> ist "false", und der Code ruft dann die <xref:System.Web.HttpResponse.End%2A> -Methode und die gesamte seitenverarbeitung wird beendet.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> enthält ein Zeilenumbruchzeichen.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wird eine Umleitung versucht.</exception>
        <exception cref="T:System.ApplicationException">Die Seitenanforderung ist das Ergebnis eines Rückrufs.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des HTTP-<see langword="Location" />-Headers ab oder legt diesen fest.</summary>
        <value>Der absolute URI, der im <see langword="Location" />-HTTP-Header an den Client übermittelt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie diese Eigenschaft verwenden, um die umleitungs-URL angeben, wenn Sie eine permanente Umleitung mit den Antwortcode 301 für HTTP-code.  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die HTTP-Header wurden bereits geschrieben.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine permanente Umleitung von einer angeforderten URL zu einer angegebenen URL aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string -&gt; unit" Usage="httpResponse.RedirectPermanent url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Der Speicherort, an den die Anforderung umgeleitet wird.</param>
        <summary>Führt eine permanente Umleitung von der angeforderten URL zur angegebenen URL aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> methodenüberladung enthält 301 HTTP-Statuscode in der Antwort sowie die URL, um die Anforderung umgeleitet. Eine HTTP-Statuscode 301 ist ein standard-Code in einer HTTP-Antwort. Er gibt an, dass eine permanente Umleitung vorhanden ist, und die Redirect-Speicherort bietet.  
  
 Aufrufen der <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> -methodenüberladung, beendet die Antwort.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> schließt ein Zeilenumbruchzeichen (<c>\n</c>) ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string * bool -&gt; unit" Usage="httpResponse.RedirectPermanent (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Der Speicherort, an den die Anforderung umgeleitet wird.</param>
        <param name="endResponse">
          <see langword="true" />, um die Antwort zu beenden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</param>
        <summary>Führt eine permanente Umleitung von der angeforderten URL zur angegebenen URL aus und stellt die Option zum Abschließen der Antwort bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> methodenüberladung enthält 301 HTTP-Statuscode in der Antwort sowie die URL, um die Anforderung umgeleitet. Diese methodenüberladung bietet auch die Option zur Angabe, ob Sie beendet oder zum Abschließen der Antwort, nachdem die Umleitung durchgeführt wurde. Eine HTTP-Statuscode 301 ist ein standard-Code in einer HTTP-Antwort. Er gibt an, dass eine permanente Umleitung vorhanden ist, und die Redirect-Speicherort bietet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> schließt ein Zeilenumbruchzeichen (<c>\n</c>) ein.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Leitet eine Anforderung mit Routenparameterwerten, einem Routennamen oder beiden Angaben an eine neue URL um.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : obj -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Leitet eine Anforderung mit Routenparameterwerten an eine neue URL um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für die Codierung der Einfachheit halber bereitgestellt. Dies ist äquivalent zum Aufrufen der <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> -Methode mit den zweiten Parameter auf `false`.  
  
 Diese Methode konvertiert das Objekt, das übergeben wird `routeValues` zu einem <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> -Objekt unter Verwendung der <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> Konstruktor. Die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Methode wird aufgerufen, um die URL zu ermitteln.  
  
 ASP.NET führt die Umleitung von einer HTTP-Statuscode 302 zurückgeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Aufrufen von dieser Methode für eine Route umgeleitet wird, die über Parameter verfügt, die mit dem Namen sind `productid` und `category`.  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string -&gt; unit" Usage="httpResponse.RedirectToRoute routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <summary>Leitet eine Anforderung mit einem Routennamen an eine neue URL um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für die Codierung der Einfachheit halber bereitgestellt. Dies ist äquivalent zum Aufrufen der <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> -Methode mit den zweiten Parameter auf `false`.  
  
 Diese Methode konvertiert den Namen der Route, die übergeben werden `routeName` an eine URL mit der <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Methode.  
  
 ASP.NET führt die Umleitung von einer HTTP-Statuscode 302 zurückgeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie diese Methode, um zu einer Route umzuleiten, mit dem Namen aufrufen `Products`.  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Leitet eine Anforderung mit Routenparameterwerten an eine neue URL um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für die Codierung der Einfachheit halber bereitgestellt. Dies ist äquivalent zum Aufrufen der <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> -Methode mit den zweiten Parameter auf `false`.  
  
 Diese Methode ruft die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Methode, um die URL zu ermitteln.  
  
 ASP.NET führt die Umleitung von einer HTTP-Statuscode 302 zurückgeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Aufrufen von dieser Methode für eine Route umgeleitet wird, die über Parameter verfügt, die mit dem Namen sind `productid` und `category`.  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Leitet eine Anforderung mit Routenparameterwerten und einem Routennamen an eine neue URL um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für die Codierung der Einfachheit halber bereitgestellt. Dies ist äquivalent zum Aufrufen der <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> -Methode mit den zweiten Parameter auf `false`.  
  
 Diese Methode konvertiert das Objekt, das übergeben wird `routeValues` zu einem <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> -Objekt unter Verwendung der <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> Konstruktor. Die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Methode wird aufgerufen, um die URL zu ermitteln.  
  
 ASP.NET führt die Umleitung von einer HTTP-Statuscode 302 zurückgeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie diese Methode, um zu einer Route umzuleiten, mit dem Namen aufrufen `Product` und dessen Parameter mit dem Namen `productid` und `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Leitet eine Anforderung mit Routenparameterwerten und einem Routennamen an eine neue URL um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für die Codierung der Einfachheit halber bereitgestellt. Dies ist äquivalent zum Aufrufen der <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> -Methode mit den zweiten Parameter auf `false`.  
  
 Die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> aufgerufen, um die URL zu ermitteln.  
  
 ASP.NET führt die Umleitung von einer HTTP-Statuscode 302 zurückgeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie diese Methode, um zu einer Route umzuleiten, mit dem Namen aufrufen `Product` und dessen Parameter mit dem Namen `productid` und `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine permanente Umleitung von einer angeforderten URL an eine neue URL mit Routenparameterwerten, einem Routennamen oder beiden Angaben aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Führt eine permanente Umleitung von einer angeforderten URL an eine neue URL mit Routenparameterwerten aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für die Codierung der Einfachheit halber bereitgestellt. Dies ist äquivalent zum Aufrufen der <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> -Methode mit den zweiten Parameter auf `false`.  
  
 Diese Methode konvertiert das Objekt, das übergeben wird `routeValues` zu einem <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> -Objekt unter Verwendung der <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> Konstruktor. Die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Methode wird aufgerufen, um die URL zu ermitteln.  
  
 ASP.NET führt die Umleitung von 301 HTTP-Statuscode zurückgeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Aufrufen von dieser Methode für eine Route umgeleitet wird, die über Parameter verfügt, die mit dem Namen sind `productid` und `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <summary>Führt eine permanente Umleitung von einer angeforderten URL an eine neue URL mit einem Routennamen aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für die Codierung der Einfachheit halber bereitgestellt. Dies ist äquivalent zum Aufrufen der <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> -Methode mit den zweiten Parameter auf `false`.  
  
 Diese Methode konvertiert den Namen der Route, die übergeben werden `routeName` an eine URL mit der <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Methode.  
  
 ASP.NET führt die Umleitung von 301 HTTP-Statuscode zurückgeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie diese Methode, um zu einer Route umzuleiten, mit dem Namen aufrufen `Products`.  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Führt eine permanente Umleitung von einer angeforderten URL an eine neue URL mit Routenparameterwerten aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für die Codierung der Einfachheit halber bereitgestellt. Dies ist äquivalent zum Aufrufen der <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> -Methode mit den zweiten Parameter auf `false`.  
  
 Diese Methode ruft die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Methode, um die URL zu ermitteln.  
  
 ASP.NET führt die Umleitung von 301 HTTP-Statuscode zurückgeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Aufrufen von dieser Methode für eine Route umgeleitet wird, die über Parameter verfügt, die mit dem Namen sind `productid` und `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Führt mit den Routenparameterwerten und dem Namen der Route, die der neuen URL entsprechen, eine permanente Umleitung von einer angeforderten URL an eine neue URL aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für die Codierung der Einfachheit halber bereitgestellt. Dies ist äquivalent zum Aufrufen der <xref:System.Web.HttpResponse.RedirectPermanent%2A> -Methode mit den zweiten Parameter auf `false`.  
  
 Diese Methode konvertiert das Objekt, das übergeben wird `routeValues` zu einem <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> -Objekt unter Verwendung der <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> Konstruktor. Die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Methode wird aufgerufen, um die URL zu ermitteln.  
  
 ASP.NET führt die Umleitung von 301 HTTP-Statuscode zurückgeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie diese Methode, um zu einer Route umzuleiten, mit dem Namen aufrufen `Product` und dessen Parameter mit dem Namen `productid` und `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <param name="routeValues">Die Routenparameterwerte.</param>
        <summary>Führt eine permanente Umleitung von einer angeforderten URL an eine neue URL mit Routenparameterwerten und einem Routennamen aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für die Codierung der Einfachheit halber bereitgestellt. Dies ist äquivalent zum Aufrufen der <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> -Methode mit den zweiten Parameter auf `false`.  
  
 Diese Methode ruft die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Methode, um die URL zu ermitteln.  
  
 ASP.NET führt die Umleitung von 301 HTTP-Statuscode zurückgeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie diese Methode, um zu einer Route umzuleiten, mit dem Namen aufrufen `Product` und dessen Parameter mit dem Namen `productid` und `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Den angegebenen Routenparametern entspricht keine Route.</exception>
        <exception cref="T:System.Web.HttpException">Nach dem Senden der HTTP-Header wurde eine Umleitung versucht.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt mit dem Ausgabecache-Standardanbieter zwischengespeicherte Elemente aus dem Ausgabecache.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der virtuelle absolute Pfad für die Elemente, die aus dem Cache entfernt wurden.</param>
        <summary>Entfernt alle zwischengespeicherten Elemente aus dem Cache, die dem standardmäßigen Ausgabecacheanbieter zugeordnet sind. Dies ist eine statische Methode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode, um Ausgabecacheelemente zu entfernen, die dem standardmäßigen Ausgabecacheanbieter zugeordnet sind. Rufen Sie die <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A> Methode, um Ausgabecacheelemente zu entfernen, die benutzerdefinierten Ausgabecacheanbieter zugeordnet sind, die in der Konfigurationsdatei für die Website angegeben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist kein absoluter virtueller Pfad.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string * string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem (path, providerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="providerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der virtuelle absolute Pfad der Elemente, die aus dem Cache entfernt werden.</param>
        <param name="providerName">Der Anbieter, mit dem die Ausgabecacheartefakte entfernt werden, die dem angegebenen Pfad zugeordnet sind.</param>
        <summary>Verwendet den angegebenen Ausgabecacheanbieter, um alle Ausgabecacheelemente zu entfernen, die dem angegebenen Pfad zugeordnet sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode, um Ausgabecacheelemente zu entfernen, die die benutzerdefinierten Ausgabecacheanbieter zugeordnet sind, die in der Konfigurationsdatei für die Website angegeben werden. Um Ausgabecacheelemente zu entfernen, die dem standardmäßigen Ausgabecacheanbieter zugeordnet sind, rufen die <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist ein ungültiger Pfad.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Das in der Auflistung zu aktualisierende Cookie.</param>
        <summary>Da die <b>HttpResponse.SetCookie</b>-Methode nur für die interne Verwendung vorgesehen ist, sollten Sie sie nicht in Ihrem Code aufrufen. Rufen Sie stattdessen wie im folgenden Beispiel gezeigt die <b>HttpResponse.Cookies.Set</b>-Methode auf.<br /> Aktualisiert ein vorhandenes Cookie in der Cookieauflistung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel aktualisiert den Wert eines vorhandenen Cookies.  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Es wurde versucht, nach dem Senden der HTTP-Header das Cookie festzulegen.</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Status : string with get, set" Usage="System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die <see langword="Status" />-Zeile fest, die an den Client zurückgegeben wird.</summary>
        <value>Durch das Festlegen des Statuscodes wird in einer Zeichenfolge der Status der HTTP-Ausgabe beschrieben, die an den Client zurückgegeben werden soll. Der Standardwert ist 200 (OK).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> ist veraltet zugunsten des <xref:System.Web.HttpResponse.StatusDescription%2A> und dient nur zur Kompatibilität mit früheren Versionen von ASP zu gewährleisten. Verwenden Sie ASP.NET <xref:System.Web.HttpResponse.StatusDescription%2A> stattdessen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der Status wurde auf einen ungültigen Statuscode festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den HTTP-Statuscode der an den Client zurückgegebenen Ausgabe ab oder legt diesen fest.</summary>
        <value>Eine ganze Zahl, die den Status der an den Client zurückgegebenen HTTP-Ausgabe darstellt. Der Standardwert ist 200 (OK). Eine Auflistung gültiger Statuscodes finden Sie [Http-Statuscodes](https://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel überprüft den Statuscode, der den Ausgabestream. Wenn der Statuscode nicht gleich 200 ist, wird zusätzlicher Code ausgeführt.  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.HttpResponse.StatusCode" /> wurde nach dem Senden der HTTP-Header festgelegt.</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die HTTP-Statuszeichenfolge der an den Client zurückgegebenen Ausgabe ab oder legt diese fest.</summary>
        <value>Eine Zeichenfolge, die den Status der an den Client zurückgegebenen HTTP-Ausgabe beschreibt. Der Standardwert ist „OK“. Eine Auflistung gültiger Statuscodes finden Sie [Http-Statuscodes](https://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel überprüft die Statuszeichenfolge des ausgabedatenstroms. Wenn der Status auf "OK" nicht entspricht, ist zusätzlicher Code ausgeführt.  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="StatusDescription" /> wurde nach dem Senden der HTTP-Header festgelegt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge des ausgewählten Werts ist größer als 512.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SubStatusCode : int with get, set" Usage="System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den Statuscode der Antwort qualifiziert, oder legt diesen fest.</summary>
        <value>Ein Ganzzahlwert, der den [!INCLUDE[iisver](~/includes/iisver-md.md)]-Substatuscode darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpResponse.SubStatusCode%2A> Eigenschaft wird nur unterstützt, mit den integrierten Pipelinemodus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und mindestens .NET Framework, Version 3.0. Beim Festlegen der <xref:System.Web.HttpResponse.SubStatusCode%2A> -Eigenschaft, die der Status wird auf protokolliert [!INCLUDE[iisver](~/includes/iisver-md.md)] Wenn Anforderungsfehler konfiguriert ist. Unabhängig von, ob die Ablaufverfolgung konfiguriert ist, wird der Code niemals als Teil der endgültige Antwort auf die Anforderung gesendet. Weitere Informationen finden Sie unter [Problembehandlung für Fehler bei Anforderungen mithilfe von Failed Request Tracing in IIS 7.0](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Web.HttpResponse.SubStatusCode%2A> Eigenschaft in einem Ereignishandler für die <xref:System.Web.HttpApplication> Instanz die <xref:System.Web.HttpApplication.PostAuthenticateRequest> Ereignis. Legen Sie die Codedatei im Ordner "App_Code" Ihrer Webanwendung, und konfigurieren Sie die Datei "Web.config", um das Modul zu registrieren. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Erstellen und Registrieren eines benutzerdefinierten HTTP-Moduls](https://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453).  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Der Vorgang erfordert den integrierten Pipelinemodus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und mindestens .NET Framework Version 3.0.</exception>
        <exception cref="T:System.Web.HttpException">Der Statuscode wird festgelegt, nachdem alle HTTP-Header gesendet wurden.</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAsyncFlush : bool" Usage="System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Verbindung asynchrone Leerungsvorgänge unterstützt.</summary>
        <value>
          <see langword="true" />, wenn die Verbindung asynchrone Leerungsvorgänge unterstützt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert zurück. die <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressContent : bool with get, set" Usage="System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob HTTP-Inhalt an den Client gesendet werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, um die Ausgabe zu unterdrücken, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob die <xref:System.Web.HttpRequest.IsSecureConnection%2A> Eigenschaft auf "false" festgelegt ist. Wenn es sich handelt, die <xref:System.Web.HttpResponse.SuppressContent%2A> -Eigenschaftensatz auf "true", beenden Sie die Antwort gesendet werden.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressDefaultCacheControlHeader : bool with get, set" Usage="System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Wird nur in .NET Framework 4.5.2 und neueren Versionen unterstützt] 
Ruft einen Wert ab, der angibt, ob der standardmäßige <c>Cache Control: private</c>-Header für die aktuelle HTTP-Antwort unterdrückt werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" /> auf der Standard-Header <c>Cache Control: private</c> -Header für die aktuelle HTTP-Antwort, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig sendet ASP.NET eine `Cache-Control: private` -Header der Antwort, wenn eine explizite Cacherichtlinie für diese Antwort angegeben wurde. Diese Eigenschaft ermöglicht das unterdrücken dieser Standard-Antwortheader auf Grundlage individueller Anforderungen. Der Header kann weiterhin für die gesamte Anwendung unterdrückt werden, durch Festlegen von <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> in [HttpRuntime-Element ((ASP.NET Einstellungsschema)](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) oder [OutputCache-Element für caching ((ASP.NET Einstellungsschema)](https://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 Seien Sie vorsichtig beim standardmäßig unterdrückt `Cache-Control: private` Header, die als Proxys oder andere Vermittler können behandeln Antworten ohne diesen Header als zwischenspeicherbar standardmäßig. Diese Behandlung kann zu den unbeabsichtigtem Zwischenspeichern des vertraulicher Informationen führen. Finden Sie unter [RFC 2616, SEC 13.4](http://tools.ietf.org/html/rfc2616) für Weitere Informationen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressFormsAuthenticationRedirect : bool with get, set" Usage="System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob die Umleitung der Formularauthentifizierung zur Anmeldeseite unterdrückt werden soll.</summary>
        <value>
          <see langword="true" />, wenn die Umleitung der Formularauthentifizierung unterdrückt werden soll, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig konvertiert Formularauthentifizierung HTTP 401-Statuscodes in 302 aus, um zur Anmeldeseite umgeleitet. Dies ist nicht geeignet für bestimmte Klassen von Fehlern, z. B. bei erfolgreicher Authentifizierung, die Autorisierung jedoch fehlschlägt, oder wenn die aktuelle Anforderung ist eine dienstanforderung AJAX oder eine Webanwendung. Diese Eigenschaft bietet eine Möglichkeit zum Unterdrücken der umleitungs-Verhalten und den ursprünglichen Statuscode an den Client gesendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt die angegebene Datei direkt in einen HTTP-Antwort-Ausgabestream, ohne dass sie im Arbeitsspeicher gepuffert wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string -&gt; unit" Usage="httpResponse.TransmitFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Der Name der Datei, die in die HTTP-Ausgabe geschrieben werden soll.</param>
        <summary>Schreibt die angegebene Datei direkt in einen HTTP-Antwort-Ausgabestream, ohne dass sie im Arbeitsspeicher gepuffert wird.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="filename" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.TransmitFile (filename, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Der Name der Datei, die in die HTTP-Ausgabe geschrieben werden soll.</param>
        <param name="offset">Die Position in der Datei, ab der die HTTP-Ausgabe geschrieben wird.</param>
        <param name="length">Die Anzahl der zu übertragenden Bytes.</param>
        <summary>Schreibt den angegebenen Teil einer Datei direkt in einen HTTP-Antwort-Ausgabestream, ohne dass diese im Arbeitsspeicher gepuffert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Angabe von 0 als die `offset` Parameter und-1 als die `length` Parameter, die ganze Datei gesendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="offset" />-Parameter ist kleiner als 0 (null).  
  
\- oder – 
Der <paramref name="length" />-Parameter ist kleiner als -1.  
  
\- oder – 
Der <paramref name="length" />-Parameter gibt eine Anzahl von Bytes an, die größer ist, als die Anzahl der Bytes in der Datei abzüglich des Offsets.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Out-of-Process-Arbeitsanforderung wird nicht unterstützt.  
  
\- oder – 
Die Antwort verwendet kein <see cref="T:System.Web.HttpWriter" />-Objekt.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="offset" />-Parameter ist kleiner als 0 (null) oder größer als die Dateigröße.  
  
\- oder – 
Der <paramref name="length" />-Parameter ist kleiner als -1 oder größer als der Wert des <paramref name="offset" />-Parameters plus Dateigröße.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrySkipIisCustomErrors : bool with get, set" Usage="System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob benutzerdefinierte [!INCLUDE[iisver](~/includes/iisver-md.md)]-Fehler deaktiviert sind, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn benutzerdefinierte IIS-Fehler deaktiviert werden sollen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> Eigenschaft wird nur verwendet, wenn Ihre Anwendung in IIS 7.0 gehostet wird. Bei der Ausführung im klassischen Modus in IIS 7.0 die <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> ist der Standardwert der Eigenschaft `true`. Bei der Ausführung im integrierten Modus der <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> ist der Standardwert der Eigenschaft `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Informationen in einen Ausgabestream für HTTP-Antworten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberSignature Language="F#" Value="member this.Write : char -&gt; unit" Usage="httpResponse.Write ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">Das Zeichen, das in den HTTP-Ausgabestream geschrieben werden soll.</param>
        <summary>Schreibt ein Zeichen in einen Ausgabestream für HTTP-Antworten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine Reihe von Konstanten, die in eine ASP.NET-Seite mithilfe der Write-Methode geschrieben werden. Der Code ruft diese Version von der Write-Methode, um einzelne Zeichenkonstanten Datenseite zu schreiben.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Write : obj -&gt; unit" Usage="httpResponse.Write obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das <see cref="T:System.Object" />, das in einen HTTP-Ausgabestream geschrieben werden soll.</param>
        <summary>Schreibt ein <see cref="T:System.Object" /> in einen HTTP-Antwortstream.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="httpResponse.Write s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge, die in den HTTP-Ausgabestream geschrieben werden soll.</param>
        <summary>Schreibt eine Zeichenfolge in einen Ausgabestream für HTTP-Antworten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dynamisch generierte HTML-Seiten können Sicherheitsrisiken verursachen, wenn von Webclients empfangene Eingabe nicht überprüft wird, wenn er von einem Client empfangen wurde oder sie an den Client übertragen werden. Schädliches Skript, das in der Eingabe an eine Website gesendet und später zurückgeschrieben auf einem Client eingebettet ist angezeigt werden kann, die von einer vertrauenswürdigen Quelle stammen sein. Dieses Sicherheitsrisiko wird als Cross-Site scripting-Angriff bezeichnet. Sie sollten immer Daten überprüfen, die von einem Client empfangen wird, wenn diese von Ihrem Standort Clientbrowsern übermittelt werden.  
  
 Darüber hinaus Sie als HTML-Daten schreiben, die als Eingabe empfangen wurde, Sie sollten codieren sie z. B. mit einer Technik <xref:System.Web.HttpServerUtility.HtmlEncode%2A> oder <xref:System.Web.HttpServerUtility.UrlEncode%2A> um zu verhindern, dass ein böswilliges Skript ausführen. Dieses Verfahren ist nützlich für Daten, die nicht überprüft wurde, wenn sie empfangen wurde.  
  
 Wenn Sie codieren oder Daten zu filtern, müssen Sie angeben einen Zeichensatz für Ihre Webseiten so, dass der Filter kann erkennen und entfernen alle Bytefolgen, die nicht gehören, die festlegen (z. B. nicht alphanumerische Sequenzen) und möglicherweise schädlichen Skripts, die in eingebettet Diese.  
  
 Weitere Informationen zu Cross-Site scripting-Angriffe, finden Sie unter "How to zu verhindern, dass Cross-Site Scripting Security Issues" im Artikel Q252985 auf die [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?LinkID=37115) Website.  
  
   
  
## Examples  
 Das folgende Beispiel gibt den Namen des Clients zurück an die im Browser des Clients. Die <xref:System.Web.HttpServerUtility.HtmlEncode%2A> -Methode entfernt alle schädliches Skript und ungültige Zeichen, die in übermittelt wurden möglicherweise die `UserName` Eingabefeld ein.  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="httpResponse.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Das zu schreibende Zeichenarray.</param>
        <param name="index">Die Position im Zeichenarray, an der mit dem Schreiben begonnen wird.</param>
        <param name="count">Die Anzahl der ab dem <c>index</c> zu schreibenden Zeichen.</param>
        <summary>Schreibt ein Zeichenarray in einen Ausgabestream für HTTP-Antworten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine Reihe von Konstanten, die in eine ASP.NET-Seite mithilfe der Write-Methode geschrieben werden. Der Code ruft diese Version von der Write-Methode, um einzelne Zeichenkonstanten Datenseite zu schreiben.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt die angegebene Datei direkt in einen Ausgabestream für HTTP-Antworten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string -&gt; unit" Usage="httpResponse.WriteFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Der Name der Datei, die in die HTTP-Ausgabe geschrieben werden soll.</param>
        <summary>Schreibt den Inhalt der angegebenen Datei als Dateiblock direkt in einen HTTP-Antwort-Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode mit großen Dateien verwendet wird, kann durch Aufrufen der Methode eine Ausnahme auslösen. Die Größe der Datei, die mit dieser Methode verwendet werden kann, hängt von der Hardwarekonfiguration des Webservers. Weitere Informationen finden Sie im Artikel 812406 "PRB: Response.WriteFile kann nicht herunterladen einer großen Datei" auf die [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) Website.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt den gesamten Inhalt einer Textdatei mit dem Namen `Login.txt` (die möglicherweise Literale Steuerelementen für die HTML-Text und Eingabe enthalten) direkt in den Ausgabestream.  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="filename" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * bool -&gt; unit" Usage="httpResponse.WriteFile (filename, readIntoMemory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Der Name der Datei, die in einen Speicherblock geschrieben werden soll.</param>
        <param name="readIntoMemory">Gibt an, ob die Datei in einen Speicherblock geschrieben wird.</param>
        <summary>Schreibt den Inhalt der angegebenen Datei als Speicherblock direkt in einen HTTP-Antwort-Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode mit großen Dateien verwendet wird, kann durch Aufrufen der Methode eine Ausnahme auslösen. Die Größe der Datei, die mit dieser Methode verwendet werden kann, hängt von der Hardwarekonfiguration des Webservers. Weitere Informationen finden Sie im Artikel 812406 "PRB: Response.WriteFile kann nicht herunterladen einer großen Datei" auf die [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) Website.  
  
   
  
## Examples  
 Im folgenden Beispiel werden eine Datei in den Speicher geschrieben.  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="filename" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : nativeint * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (fileHandle, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">Das Dateihandle der Datei, die in den HTTP-Ausgabestream geschrieben werden soll.</param>
        <param name="offset">Die Byteposition in der Datei, an der der Schreibvorgang beginnt.</param>
        <param name="size">Die Anzahl der Bytes, die in den Ausgabestream geschrieben werden sollen.</param>
        <summary>Schreibt die angegebene Datei direkt in einen Ausgabestream für HTTP-Antworten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode mit großen Dateien verwendet wird, kann durch Aufrufen der Methode eine Ausnahme auslösen. Die Größe der Datei, die mit dieser Methode verwendet werden kann, hängt von der Hardwarekonfiguration des Webservers. Weitere Informationen finden Sie im Artikel 812406 "PRB: Response.WriteFile kann nicht herunterladen einer großen Datei" auf die [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) Website.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt den gesamten Inhalt einer Textdatei mit dem Namen `Login.txt` (die möglicherweise Literale Steuerelementen für die HTML-Text und Eingabe enthalten) direkt in den Ausgabestream.  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileHandler" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> ist kleiner als 0.  
  
\- oder – 
 <paramref name="size" /> ist größer als die Dateigröße minus <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (filename, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Der Name der Datei, die in den HTTP-Ausgabestream geschrieben werden soll.</param>
        <param name="offset">Die Byteposition in der Datei, an der der Schreibvorgang beginnt.</param>
        <param name="size">Die Anzahl der Bytes, die in den Ausgabestream geschrieben werden sollen.</param>
        <summary>Schreibt die angegebene Datei direkt in einen Ausgabestream für HTTP-Antworten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode mit großen Dateien verwendet wird, kann durch Aufrufen der Methode eine Ausnahme auslösen. Die Größe der Datei, die mit dieser Methode verwendet werden kann, hängt von der Hardwarekonfiguration des Webservers. Weitere Informationen finden Sie im Artikel 812406 "PRB: Response.WriteFile kann nicht herunterladen einer großen Datei" auf die [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) Website.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt den gesamten Inhalt einer Textdatei mit dem Namen `Login.txt` (die literalen Text und HTML enthalten möglicherweise Eingabesteuerelemente) direkt in den Ausgabestream.  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> ist kleiner als 0.  
  
\- oder – 
 <paramref name="size" /> ist größer als die Dateigröße minus <paramref name="offset" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="filename" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.WriteSubstitution : System.Web.HttpResponseSubstitutionCallback -&gt; unit" Usage="httpResponse.WriteSubstitution callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Die Methode, das Benutzersteuerelement oder das Objekt, die bzw. das ersetzt werden soll.</param>
        <summary>Ermöglicht das Einfügen von Antwortersetzungsblöcken in die Antwort, wodurch das dynamische Generieren von angegebenen Antwortbereichen für Antworten im Ausgabecache ermöglicht wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Web.HttpResponse.WriteSubstitution%2A> Methode für die Ersetzung in Ihren ausgabezwischengespeicherte Seiten nach dem Zwischenspeichern. Durch Übergeben einer <xref:System.Web.HttpContext> Objekt, das eine Rückrufmethode mit einer vorgeschriebenen <xref:System.Web.HttpResponseSubstitutionCallback> Signatur können Sie Ausgabecache ersetzen Inhalt im Seitencache an beliebigen. Um die Ersetzung zu initiieren, rufen die <xref:System.Web.HttpResponse.WriteSubstitution%2A> -Methode, und übergeben sie die Callback-Methode, die muss threadsicher sein und kann eine der folgenden sein:  
  
-   Eine statische Methode auf der Seite oder des Containersteuerelements.  
  
-   Eine statische oder Instanzmethode auf ein anderes beliebiges Objekt.  
  
 Bei der ersten Anforderung auf der Seite die <xref:System.Web.HttpResponse.WriteSubstitution%2A> Aufrufe der <xref:System.Web.HttpResponseSubstitutionCallback> Delegat, der die Ausgabe zu erzeugen. Anschließend, wird einen Ersatz-Puffer an die Antwort, die der Delegat, der bei zukünftigen Anforderungen aufgerufen werden beibehalten. Schließlich wird die clientseitige-cachefähigkeit von öffentlich, nur für den Server, schützen zukünftigen Anforderungen an die Seite erneut aufrufen des Delegaten, durch die keine Zwischenspeicherung auf dem Client beeinträchtigt.  
  
> [!NOTE]
>  Ersetzung nach dem Zwischenspeichern ist nicht für eine zwischengespeicherte Benutzersteuerelement unterstützt, in denen Zwischenspeicherung der Ausgabe auf Benutzerebene Steuerelement angewendet wird. Dies wird auch als Fragment-caching bezeichnet. Weitere Informationen finden Sie unter [Zwischenspeichern von Teilen einer ASP.NET-Seite](https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Ziel des <paramref name="callback" />-Parameters ist vom Typ <see cref="T:System.Web.UI.Control" />.</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
        <related type="Article" href="https://msdn.microsoft.com/library/d5fbd79f-972d-4557-9a39-f90684b3dcd3">Festlegen der Cachefähigkeit einer Seite</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e">Zwischenspeichern von Teilen einer ASP.NET-Seite</related>
        <related type="Article" href="https://msdn.microsoft.com/library/09c9bd9a-0d68-4a5c-aa6f-1b461c208795">Teile einer zwischengespeicherten Seite dynamisch aktualisieren</related>
      </Docs>
    </Member>
  </Members>
</Type>