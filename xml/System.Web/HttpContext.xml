<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="19824f9c0268fdfd07cbc29dc41746e8950c4d80" /><Meta Name="ms.sourcegitcommit" Value="a8ff98b48bda124cfcb2605f5da9b21bc6dcd791" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/14/2020" /><Meta Name="ms.locfileid" Value="77245954" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContext = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Kapselt alle HTTP-spezifischen Informationen über eine einzelne HTTP-Anforderung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 Klassen, die die <xref:System.Web.IHttpModule>-und <xref:System.Web.IHttpHandler>-Schnittstellen erben, werden als Verweis auf ein <xref:System.Web.HttpContext>-Objekt für die aktuelle HTTP-Anforderung bereitgestellt. Das-Objekt bietet Zugriff auf die systeminternen Eigenschaften <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A>und <xref:System.Web.HttpContext.Server%2A> für die Anforderung.

> [!IMPORTANT]
> Dieses Objekt ist bereit für Garbage Collection, wenn die <xref:System.Web.HttpRequest> abgeschlossen ist. Die Verwendung nach Abschluss der Anforderung kann zu nicht definiertem Verhalten führen, wie z. b. einem <xref:System.NullReferenceException>.
>
> Dieses Objekt ist nur in dem von ASP.net kontrollierten Thread verfügbar. Die Verwendung in Hintergrundthreads kann zu undefiniertem Verhalten führen.

## Examples
 Im folgenden Beispiel wird veranschaulicht, wie Sie auf Eigenschaften des <xref:System.Web.HttpContext> Objekts zugreifen und diese anzeigen. Auf den Kontext der aktuellen HTTP-Anforderung wird mithilfe der <xref:System.Web.UI.Page.Context%2A>-Eigenschaft des <xref:System.Web.UI.Page>-Objekts zugegriffen.

 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]

 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=196730">Eine Frage des Kontexts</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Web.HttpContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpWorkerRequest -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext wr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">Das <see cref="T:System.Web.HttpWorkerRequest" />-Objekt für die aktuelle HTTP-Anforderung.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.HttpContext" />-Klasse mit dem angegebenen Arbeitsanforderungsobjekt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpRequest * System.Web.HttpResponse -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext (request, response)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">Das <see cref="T:System.Web.HttpRequest" />-Objekt für die aktuelle HTTP-Anforderung.</param>
        <param name="response">Das <see cref="T:System.Web.HttpResponse" />-Objekt für die aktuelle HTTP-Anforderung.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.HttpContext" />-Klasse mit den angegebenen Anforderungs- und Antwortobjekten.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Akzeptiert eine <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> Anforderung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContext.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="userFunc">Die Benutzerfunktion.</param>
        <summary>Akzeptiert eine <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> Anforderung unter Verwendung der angegebenen Benutzerfunktion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das Aufrufen dieser Methode entspricht dem Aufrufen der <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A>-Methoden Überladung und der Übergabe `null` für den `options`-Parameter.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="userFunc" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Anforderung ist keine <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Anforderung.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContext.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="userFunc">Die Benutzerfunktion.</param>
        <param name="options">Das Options-Objekt.</param>
        <summary>Akzeptiert eine <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> Anforderung mit dem angegebenen Benutzerfunktions- und Optionenobjekt.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="userFunc" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Anforderung ist keine <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Anforderung.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="member this.AddError : Exception -&gt; unit" Usage="httpContext.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">Das <see cref="T:System.Exception" />-Objekt, das der Auflistung der Ausnahmen hinzugefügt werden soll.</param>
        <summary>Fügt der Auflistung der Ausnahmen für die aktuelle HTTP-Anforderung eine Ausnahme hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnRequestCompleted : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContext.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Das HTTP-Kontextobjekt.</param>
        <summary>Löst ein virtuelles Ereignis aus, das eintritt, wenn der HTTP-Teil der Anforderung beendet wird.</summary>
        <returns>Das Abonnementtoken.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Dieses Ereignis tritt auf, bevor die <xref:System.Web.WebSockets.AspNetWebSocket> Verbindung beginnt.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="callback" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Array von Fehlern ab, die beim Verarbeiten einer HTTP-Anforderung angesammelt wurden.</summary>
        <value>Ein Array von <see cref="T:System.Exception" />-Objekten für die aktuelle HTTP-Anforderung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt diesen fest, der angibt, ob asynchrone Vorgänge während Teilen der ASP.NET-Anfragenverarbeitung erlaubt sind, wenn sie nicht erwartet werden.</summary>
        <value><see langword="false" /> wenn ASP.NET eine Ausnahme auslöst, wenn die asynchrone API zu einem Zeitpunkt verwendet wird, an dem dies nicht erwartet wird; anderenfalls <see langword="true" />. Standardwert: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn dieses Flag nicht auf `true`festgelegt ist, löst ASP.net eine Ausnahme aus, wenn es erkennt, dass die Anwendung die Async-API missbraucht. Dies kann vorkommen, wenn Sie versuchen, eine asynchrone Methode während eines Teils der Anforderungs Verarbeitungs Pipeline aufzurufen, bei der asynchrone Vorgänge nicht erwartet werden, oder wenn noch eine ausstehende asynchrone Arbeit vorhanden ist, wenn ein asynchrones Modul oder Handler den Abschluss signalisiert. Dieses Verhalten ist als Sicherheitsnetz gedacht, damit Sie sich frühzeitig informieren können, wenn Sie asynchronen Code schreiben, der nicht zu den erwarteten Mustern passt und möglicherweise negative Nebeneffekte hat.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpApplicationState" />-Objekt für die aktuelle HTTP-Anforderung ab.</summary>
        <value>Das <see cref="T:System.Web.HttpApplicationState" />-Objekt für die aktuelle HTTP-Anforderung.

Verwenden Sie <see cref="T:System.Web.HttpApplication" />, um das <see cref="P:System.Web.HttpContext.ApplicationInstance" />-Objekt für die aktuelle HTTP-Anforderung abzurufen. (In ASP.NET wird als Eigenschaftenname <see langword="ApplicationInstance" /> anstelle von <see langword="Application" /> verwendet, um auf die aktuelle <see cref="T:System.Web.HttpApplication" />-Instanz zu verweisen, um Verwechslungen zwischen ASP.NET und klassischem ASP zu verhindern. Im klassischem ASP verweist <see langword="Application" /> auf das globale Anwendungszustands-Wörterbuch.)</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpApplication" /> -Objekt für die aktuelle HTTP-Anforderung ab oder legt dieses fest.</summary>
        <value>Das <see cref="T:System.Web.HttpApplication" />-Objekt für die aktuelle HTTP-Anforderung.

In ASP.NET wird als Eigenschaftenname <see langword="ApplicationInstance" /> anstelle von <see langword="Application" /> verwendet, um auf die aktuelle <see cref="T:System.Web.HttpApplication" />-Instanz zu verweisen, um Verwechslungen zwischen ASP.NET und klassischem ASP zu verhindern. Im klassischem ASP verweist <see langword="Application" /> auf das globale Anwendungszustands-Wörterbuch.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Die Webanwendung wird unter IIS 7.0 im integrierten Modus ausgeführt, und es wurde versucht, den Eigenschaftswert von einem Wert ungleich NULL in <see langword="null" /> zu ändern.</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab oder legt ein Objekt fest, das die Flags enthält, die den asynchronen Vorablademodus betreffen.</summary>
        <value>Ein Objekt, das Flags enthält, die den Modus des asynchronen Vorabladenmodus betreffen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Beim ersten Zugriff auf diese Eigenschaft wird das Objekt, das Flags für den asynchronen vorab Lade Modus enthält, aus der <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> Einstellung in der Konfigurationsdatei geladen.

 Obwohl diese Eigenschaft programmgesteuert festgelegt werden kann, wirkt sich die Änderung des Eigenschaftswerts nur aus, wenn die Eigenschaft vom `ExecuteRequestHandler`-Schritt der ASP.NET-Anforderungspipeline festgelegt ist.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.Caching.Cache" /> -Objekt für die aktuelle Anwendungsdomäne ab.</summary>
        <value>Der <see cref="T:System.Web.Caching.Cache" /> für die aktuelle Anwendungsdomäne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Es gibt eine Instanz der <xref:System.Web.Caching.Cache>-Klasse pro Anwendungsdomäne. Folglich ist das <xref:System.Web.Caching.Cache> Objekt, das von der <xref:System.Web.HttpContext.Cache%2A>-Eigenschaft zurückgegeben wird, das <xref:System.Web.Caching.Cache>-Objekt für alle Anforderungen in der Anwendungsdomäne.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpContext.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Fehler für die aktuelle HTTP-Anforderung.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.HttpContext with get, set" Usage="System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpContext" /> -Objekt für die aktuelle HTTP-Anforderung ab oder legt dieses fest.</summary>
        <value>Die <see cref="T:System.Web.HttpContext" />-Instanz für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Eigenschaft ist eine statische Eigenschaft der <xref:System.Web.HttpContext>-Klasse. Die-Eigenschaft speichert die <xref:System.Web.HttpContext>-Instanz, die auf die aktuelle Anforderung angewendet wird. Bei den Eigenschaften dieser Instanz handelt es sich um die nicht statischen Eigenschaften der <xref:System.Web.HttpContext>-Klasse.

 Sie können auch die <xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType>-Eigenschaft verwenden, um auf das <xref:System.Web.HttpContext>-Objekt für die aktuelle HTTP-Anforderung zuzugreifen.



## Examples
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpContext.Current%2A>-Eigenschaft verwendet, um auf die Methoden <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> und <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> und die <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType>-Eigenschaft zuzugreifen. In diesem Beispiel werden drei benutzerdefinierte Ausnahmen mithilfe der <xref:System.Web.HttpContext.AddError%2A>-Methode erstellt und die <xref:System.Web.HttpContext.AllErrors%2A>-Eigenschaft verwendet, um diese Ausnahmen in ein Array zu laden. Anschließend wird das Array in die enthaltende Seite geschrieben, und die <xref:System.Web.HttpContext.ClearError%2A>-Methode wird verwendet, um alle Fehler aus der <xref:System.Web.UI.Page.Context%2A>-Eigenschaft zu löschen.

```csharp
protected void Page_Load(object sender, EventArgs e)
{
    HttpContext context = HttpContext.Current;
    Response.Write("<p>HttpContext.Current Example:</p>");

    // Add three custom exceptions.
    context.AddError(new Exception("New Exception #1"));
    context.AddError(new Exception("New Exception #2"));
    context.AddError(new Exception("New Exception #3"));

    // Capture all the new Exceptions in an array.
    Exception[] errs = context.AllErrors;

    foreach (Exception ex in errs)
    {
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");
    }

    // Clear the exceptions so ASP.NET won't handle them.
    context.ClearError();
}
```

```vb
Protected Sub Page_Load(sender As Object, e As EventArgs)
Dim context As HttpContext = HttpContext.Current
Response.Write("<p>HttpContext.Current Example:</p>")

' Add three custom exceptions.
context.AddError(New Exception("New Exception #1"))
context.AddError(New Exception("New Exception #2"))
context.AddError(New Exception("New Exception #3"))

' Capture all the new Exceptions in an array.
Dim errs As Exception() = context.AllErrors

For Each ex As Exception In errs
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")
Next

' Clear the exceptions so ASP.NET won't handle them.
context.ClearError()
End Sub

```

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.IHttpHandler" />-Objekt ab, das den derzeit ausführenden Handler darstellt.</summary>
        <value>Ein <see cref="T:System.Web.IHttpHandler" />-Objekt, das den derzeit ausführenden Handler darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der aktuell ausgeführte Handler, auf den von der <xref:System.Web.HttpContext.CurrentHandler%2A>-Eigenschaft verwiesen wird, kann sich von dem Handler unterscheiden, auf den von der <xref:System.Web.HttpContext.Handler%2A>-Eigenschaft verwiesen wird. Dies kann vorkommen, wenn ein anderer Handler angefordert wurde, indem die <xref:System.Web.HttpServerUtility.Execute%2A>-Methode oder die <xref:System.Web.HttpServerUtility.Transfer%2A>-Methode verwendet wird. Wenn die Verarbeitung durch den aktuell ausgeführten Handler abgeschlossen ist, wird der zuvor festgelegte Handler wieder hergestellt.

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb398986(v=vs.100)">Übersicht über HTTP-Handler und HTTP-Module</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Web.RequestNotification" /> -Wert ab, der das <see cref="T:System.Web.HttpApplication" /> -Ereignis angibt, das derzeit verarbeitet wird.</summary>
        <value>Einer der <see cref="T:System.Web.RequestNotification" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.CurrentNotification%2A>-Eigenschaft erfordert den integrierten Pipeline Modus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und mindestens die .NET Framework Version 3,0. Wenn verfügbar, gibt die-Eigenschaft einen <xref:System.Web.RequestNotification> Wert zurück. Der Wert der <xref:System.Web.HttpContext.CurrentNotification%2A>-Eigenschaft gibt an, welches Ereignis in der <xref:System.Web.HttpApplication> Instanz die Anforderung zurzeit verarbeitet.

 Die <xref:System.Web.HttpContext.CurrentNotification%2A>-Eigenschaft ist nicht für die Festlegung vorgesehen. Stattdessen wird Sie durch [!INCLUDE[iisver](~/includes/iisver-md.md)] während der Verarbeitung der Anforderung in der ASP.NET-Pipeline festgelegt. Wenn Sie die <xref:System.Web.HttpContext.CurrentNotification%2A>-Eigenschaft festlegen, führt dies zu einem Kompilierungsfehler.

 <xref:System.Web.HttpContext.CurrentNotification%2A> wird in .NET Framework Version 3,5 eingeführt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).



## Examples
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Web.HttpContext.CurrentNotification%2A>-Eigenschaft verwendet wird, um zu bestimmen, welches Ereignis des <xref:System.Web.HttpApplication> Objekts, das die aktuelle Anforderung verarbeitet, verarbeitet wird. Im Beispiel verarbeitet der Ereignishandler mehrere Ereignisse des <xref:System.Web.HttpApplication> Objekts, und die <xref:System.Web.HttpContext.CurrentNotification%2A>-Eigenschaft bestimmt, welcher Code für jedes behandelte Ereignis aufgerufen wird.

 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Dieser Vorgang erfordert den integrierten Pipelinemodus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und .NET Framework 3.0 oder höher.</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="member this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContext.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target">Das Objekt, dessen <see cref="M:System.IDisposable.Dispose" />-Methode aufgerufen werden muss, wenn der <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Verbindungsteil der Anforderung abgeschlossen ist.</param>
        <summary>Aktiviert die <see cref="M:System.IDisposable.Dispose" />-Methode eines Objekts, wenn der <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Verbindungsteil der Anforderung abgeschlossen ist.</summary>
        <returns>Das Abonnementtoken.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.IDisposable.Dispose%2A>-Methode des Zielobjekts wird aufgerufen, nachdem der http-Teil der Anforderung und die <xref:System.Web.WebSockets.AspNetWebSocket> Verbindung beendet wurden. Das <xref:System.Web.HttpContext>-Objekt ist für die Überprüfung nicht verfügbar.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ggf. den ersten Fehler ab, der beim Verarbeiten einer HTTP-Anforderung aufgezeichnet wurde.</summary>
        <value>Die erste <see cref="T:System.Exception" /> für den aktuellen HTTP-Anforderungs-/Antwortprozess; andernfalls <see langword="null" />, wenn während der Verarbeitung der HTTP-Anforderung keine Fehler angesammelt wurden. Der Standardwert lautet <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetAppConfig : string -&gt; obj" Usage="System.Web.HttpContext.GetAppConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Das Anwendungskonfigurationstag, für das Informationen angefordert werden.</param>
        <summary>Gibt die angeforderten Konfigurationsinformationen für die aktuelle Anwendung zurück.</summary>
        <returns>Ein Objekt, das Konfigurationsinformationen enthält. (Wandeln Sie den zurückgegebenen Konfigurationsabschnitt vor der Verwendung in den zutreffenden Konfigurationstyp um.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.GetAppConfig%2A>-Methode ist veraltet. Verwenden Sie die <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A>-Methode der <xref:System.Web.Configuration.WebConfigurationManager>-Klasse, um Konfigurationsinformationen für die aktuelle Anwendung zu erhalten.

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetConfig : string -&gt; obj" Usage="httpContext.GetConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Das Konfigurationstag, für das Informationen angefordert werden.</param>
        <summary>Gibt die angeforderten Konfigurationsinformationen für die aktuelle HTTP-Anforderung zurück.</summary>
        <returns>Das angegebene <see cref="T:System.Configuration.ConfigurationSection" />-Objekt, <see langword="null" />, falls der Abschnitt nicht vorhanden ist, oder ein internes Objekt, falls der Zugriff auf den Abschnitt zur Laufzeit nicht möglich ist. (Wandeln Sie das zurückgegebene Objekt vor der Verwendung in den zutreffenden Konfigurationstyp um.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.GetConfig%2A>-Methode ist veraltet. Verwenden Sie die <xref:System.Web.HttpContext.GetSection%2A>-Methode, um Konfigurationsinformationen für die aktuelle HTTP-Anforderung zu erhalten.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine Ressource auf Anwendungsebene ab.</summary>
        <related type="Article" href="~/docs/framework/resources/index.md">Ressourcen in Anwendungen</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET-Website Layout</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="classKey">Eine Zeichenfolge, die die <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" />-Eigenschaft des angeforderten Ressourcenobjekts darstellt.</param>
        <param name="resourceKey">Eine Zeichenfolge, die die <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />-Eigenschaft des angeforderten Ressourcenobjekts darstellt.</param>
        <summary>Ruft auf der Grundlage der angegebenen <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" />-Eigenschaft und <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />-Eigenschaft ein Ressourcenobjekt auf Anwendungsebene ab.</summary>
        <returns>Ein <see cref="T:System.Object" />-Objekt, das das angeforderte Ressourcenobjekt auf Anwendungsebene darstellt; andernfalls NULL, wenn ein Ressourcenobjekt nicht gefunden wird oder wenn ein Ressourcenobjekt gefunden wird, es jedoch nicht über die angeforderte Eigenschaft verfügt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.GetGlobalResourceObject%2A>-Methode gibt eine globale Ressource zurück, indem Sie die Kultur verwendet, die in der <xref:System.Globalization.CultureInfo.CurrentUICulture%2A>-Eigenschaft angegeben ist.

> [!NOTE]
>  In einigen Bearbeitungs Umgebungen, wie z. b. [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)], löst der Editor möglicherweise eine Entwurfszeit <xref:System.Resources.MissingManifestResourceException> Ausnahme aus, wenn Sie einen Punkt (.) im globalen Ressourcen Schlüsselnamen verwenden. Dies wirkt sich jedoch nicht auf die Fähigkeit aus, die Datei zu bearbeiten oder zu speichern, und Sie können den Fehler ignorieren.

 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Ein Ressourcenobjekt mit dem angegebenen <paramref name="classKey" />-Parameter wurde nicht gefunden.

Oder

Die Hauptassembly enthält keine Ressourcen für die neutrale Kultur. Diese Ressourcen sind jedoch erforderlich, da die entsprechende Satellitenassembly nicht vorhanden ist.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="~/docs/framework/resources/index.md">Ressourcen in Anwendungen</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET-Website Layout</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="classKey">Eine Zeichenfolge, die die <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" />-Eigenschaft des angeforderten Ressourcenobjekts darstellt.</param>
        <param name="resourceKey">Eine Zeichenfolge, die die <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />-Eigenschaft des angeforderten Ressourcenobjekts darstellt.</param>
        <param name="culture">Eine Zeichenfolge, die das <see cref="T:System.Globalization.CultureInfo" /> -Objekt der angeforderten Ressource darstellt.</param>
        <summary>Ruft auf der Grundlage der angegebenen <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> -Eigenschaft und <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> -Eigenschaft sowie des angegebenen <see cref="T:System.Globalization.CultureInfo" /> -Objekts ein Ressourcenobjekt auf Anwendungsebene ab.</summary>
        <returns>Ein <see cref="T:System.Object" />-Objekt, das das angeforderte Ressourcenobjekt auf Anwendungsebene darstellt, das für die angegebene Kultur lokalisiert wird; andernfalls <see langword="null" />, wenn ein Ressourcenobjekt nicht gefunden wird oder wenn ein Ressourcenobjekt gefunden wird, es jedoch nicht über die angeforderte Eigenschaft verfügt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das <xref:System.Globalization.CultureInfo>-Objekt stellt die Kultur dar, für die die Ressource lokalisiert wurde. Wenn die Ressource für diese Kultur nicht lokalisiert ist, wird bei der Suche ein Fall Backprozess zum Auffinden einer entsprechenden Ressource befolgt. Weitere Informationen finden Sie unter [Verpacken und Bereitstellen von Ressourcen](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).

> [!NOTE]
>  In einigen Bearbeitungs Umgebungen, wie z. b. Visual Web Developer, löst der Editor möglicherweise eine Entwurfszeit <xref:System.Resources.MissingManifestResourceException> Ausnahme aus, wenn Sie einen Punkt (.) im globalen Ressourcen Schlüsselnamen verwenden. Dies wirkt sich jedoch nicht auf die Fähigkeit aus, die Datei zu bearbeiten oder zu speichern, und Sie können den Fehler ignorieren.

 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Ein Ressourcenobjekt, dessen angegebener <paramref name="classKey" />-Parameter nicht gefunden wurde.

Oder

Die Hauptassembly enthält keine Ressourcen für die neutrale Kultur. Diese Ressourcen sind jedoch erforderlich, da die entsprechende Satellitenassembly nicht vorhanden ist.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="~/docs/framework/resources/index.md">Ressourcen in Anwendungen</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine Ressource auf Seitenebene ab.</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="~/docs/framework/resources/index.md">Ressourcen in Anwendungen</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET-Website Layout</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Die <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" />-Eigenschaft für das lokale Ressourcenobjekt.</param>
        <param name="resourceKey">Eine Zeichenfolge, die die <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />-Eigenschaft des angeforderten Ressourcenobjekts darstellt.</param>
        <summary>Ruft auf der Grundlage der angegebenen <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> -Eigenschaft und <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> -Eigenschaft ein Ressourcenobjekt auf Seitenebene ab.</summary>
        <returns>Ein <see cref="T:System.Object" />, das das angeforderte Ressourcenobjekt auf Seitenebene darstellt; andernfalls <see langword="null" />, wenn ein übereinstimmendes Ressourcenobjekt, jedoch kein <paramref name="resourceKey" />-Parameter gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.GetLocalResourceObject%2A>-Methode gibt eine lokale Ressource mit der Kultur zurück, die in der <xref:System.Globalization.CultureInfo.CurrentUICulture%2A>-Eigenschaft angegeben ist.

 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Ein Ressourcenobjekt im angegebenen <paramref name="virtualPath" />-Parameter wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene <paramref name="virtualPath" />-Parameter ist nicht im Stammverzeichnis der aktuellen Anwendung enthalten.</exception>
        <exception cref="T:System.InvalidOperationException">Die Ressourcenklasse für die Seite wurde nicht gefunden.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="~/docs/framework/resources/index.md">Ressourcen in Anwendungen</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET-Website Layout</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms227982(v=vs.100)">Gewusst wie: Programm gesteuertes Abrufen von Ressourcen Werten</related>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Die <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" />-Eigenschaft für das lokale Ressourcenobjekt.</param>
        <param name="resourceKey">Eine Zeichenfolge, die die <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />-Eigenschaft des angeforderten Ressourcenobjekts darstellt.</param>
        <param name="culture">Eine Zeichenfolge, die das <see cref="T:System.Globalization.CultureInfo" /> -Objekt des angeforderten Ressourcenobjekts darstellt.</param>
        <summary>Ruft auf der Grundlage der angegebenen <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" />-Eigenschaft und <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />-Eigenschaft sowie des angegebenen <see cref="T:System.Globalization.CultureInfo" />-Objekts ein Ressourcenobjekt auf Seitenebene ab.</summary>
        <returns>Ein <see cref="T:System.Object" />, das das angeforderte lokale Ressourcenobjekt darstellt, das für die angegebene Kultur lokalisiert wird; andernfalls <see langword="null" />, wenn ein übereinstimmendes Ressourcenobjekt, jedoch kein <paramref name="resourceKey" />-Parameter gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn die Ressource für diese Kultur nicht lokalisiert ist, wird bei der Suche ein Fall Backprozess zum Auffinden einer entsprechenden Ressource befolgt. Weitere Informationen finden Sie unter [Verpacken und Bereitstellen von Ressourcen](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).

 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Ein Ressourcenobjekt im angegebenen <paramref name="virtualPath" />-Parameter wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene <paramref name="virtualPath" />-Parameter ist nicht im Stammverzeichnis der aktuellen Anwendung enthalten.</exception>
        <exception cref="T:System.InvalidOperationException">Die Ressourcenklasse für die Seite wurde nicht gefunden.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="~/docs/framework/resources/index.md">Ressourcen in Anwendungen</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET-Website Layout</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms227982(v=vs.100)">Gewusst wie: Programm gesteuertes Abrufen von Ressourcen Werten</related>
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="member this.GetSection : string -&gt; obj" Usage="httpContext.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sectionName">Der Pfad des Konfigurationsabschnitts (im XPath-Format) und der Name des Konfigurationselements.</param>
        <summary>Ruft einen angegebenen Konfigurationsabschnitt für die Standardkonfiguration der aktuellen Anwendung ab.</summary>
        <returns>Das angegebene <see cref="T:System.Configuration.ConfigurationSection" />-Objekt, <see langword="null" />, falls der Abschnitt nicht vorhanden ist, oder ein internes Objekt, falls der Zugriff auf den Abschnitt zur Laufzeit nicht möglich ist.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das für die Verarbeitung der HTTP-Anforderung verantwortliche <see cref="T:System.Web.IHttpHandler" />-Objekt ab oder legt dieses fest.</summary>
        <value>Ein für die Verarbeitung der HTTP-Anforderung verantwortliches <see cref="T:System.Web.IHttpHandler" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.Handler%2A>-Eigenschaft enthält einen Verweis auf den Handler, der die HTTP-Anforderung verarbeitet. Der-Handler kann mit dem [httpHandlers](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bya7fh0a(v=vs.100)) -Element oder mithilfe eines benutzerdefinierten Handlers angegeben werden, der im Benutzercode definiert ist. Weitere Informationen zu Handlern finden Sie unter [Übersicht über HTTP-Handler und HTTP-Module](https://docs.microsoft.com/previous-versions/aspnet/bb398986(v=vs.100)).

 Der Verweis auf die <xref:System.Web.HttpContext.Handler%2A>-Eigenschaft bleibt unverändert, auch nachdem die aktuelle Seite durch eine serverseitige Methode geändert wurde, wie z. b. die <xref:System.Web.HttpServerUtility.Execute%2A>-Methode oder die <xref:System.Web.HttpServerUtility.Transfer%2A>-Methode.

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb398986(v=vs.100)">Übersicht über HTTP-Handler und HTTP-Module</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für die aktuelle HTTP-Anforderung benutzerdefinierte Fehler aktiviert sind.</summary>
        <value><see langword="true" />, wenn benutzerdefinierte Fehler aktiviert sind, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob sich die aktuelle HTTP-Anforderung im Debugmodus befindet.</summary>
        <value><see langword="true" />, wenn sich die Anforderung im Debugmodus befindet, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der der aktuelle Verarbeitungspunkt in der ASP.NET-Pipeline ist, gleich nachdem ein <see cref="T:System.Web.HttpApplication" />-Ereignis die Verarbeitung beendet hat.</summary>
        <value><see langword="true" />, wenn benutzerdefinierte Fehler aktiviert sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.IsPostNotification%2A>-Eigenschaft wird nur mit dem integrierten Modus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und zumindest dem .NET Framework 3,0 unterstützt. Wenn verfügbar, gibt die-Eigenschaft einen booleschen Wert zurück, der angibt, ob ein Ereignis im <xref:System.Web.HttpApplication> Objekt die Verarbeitung abgeschlossen hat.

 Die <xref:System.Web.HttpContext.IsPostNotification%2A>-Eigenschaft ist nicht für die Festlegung vorgesehen. Stattdessen wird Sie durch [!INCLUDE[iisver](~/includes/iisver-md.md)] der ASP.NET-Laufzeit für jede Benachrichtigung bereitgestellt. Wenn Sie die <xref:System.Web.HttpContext.IsPostNotification%2A>-Eigenschaft festlegen, führt dies zu einem Kompilierungsfehler.

 In Szenarien, in denen mehrere Ereignisse des <xref:System.Web.HttpApplication> Objekts von einem Ereignishandler behandelt werden, können Sie die <xref:System.Web.HttpContext.IsPostNotification%2A>-Eigenschaft in Kombination mit der <xref:System.Web.RequestNotification>-Enumeration verwenden, um genau zu bestimmen, an welcher Stelle im Anwendungslebenszyklus die aktuelle Anforderung liegt.

 <xref:System.Web.HttpContext.IsPostNotification%2A> wird in .NET Framework Version 3,5 eingeführt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).



## Examples
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Web.HttpContext.IsPostNotification%2A>-Eigenschaft verwendet wird, um zu bestimmen, wann ein Ereignis des <xref:System.Web.HttpApplication>-Objekts die Verarbeitung aller zugeordneten Ereignishandler abgeschlossen hat. Der benutzerdefinierte Ereignishandler in diesem Beispiel verarbeitet mehrere Ereignisse des <xref:System.Web.HttpApplication> Objekts, und die <xref:System.Web.HttpContext.IsPostNotification%2A>-Eigenschaft wird verwendet, um zu bestimmen, welcher Code aufgerufen wird, nachdem ein bestimmtes Ereignis behandelt wurde.

 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Dieser Vorgang erfordert den integrierten Pipelinemodus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und .NET Framework 3.0 oder höher.</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob es sich bei der Anforderung um eine <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Anforderung handelt.</summary>
        <value><see langword="true" />, wenn es sich bei der Anforderung um eine <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Anforderung handelt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode gibt `true` zurück, wenn die Anforderung den ersten <xref:System.Web.WebSockets.AspNetWebSocket> Handshake enthält und das `WebSocket`-Modul von IIS aktiv ist.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Verbindung von einer HTTP-Verbindung zu einer <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Verbindung aktualisiert wird.</summary>
        <value><see langword="true" />, wenn die Verbindung aktualisiert wird, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Schlüssel-/Wert-Auflistung ab, die während einer HTTP-Anforderung zum Organisieren und Freigeben von Daten zwischen einer <see cref="T:System.Web.IHttpModule" />-Schnittstelle und einer <see cref="T:System.Web.IHttpHandler" />-Schnittstelle verwendet werden kann.</summary>
        <value>Eine <see cref="T:System.Collections.IDictionary" />-Schlüssel-/Wert-Auflistung, über die mithilfe eines angegebenen Schlüssels auf einen einzelnen Wert in der Auflistung zugegriffen werden kann.</value>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/previous-versions/dotnet/articles/ms972109(v=msdn.10)">Eine Frage des Kontexts</related>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf die Instanz für Seiteninstrumentationsdienste für diese Anforderung ab.</summary>
        <value>Die Seiteninstrumentierungs-Dienstinstanz für diese Anforderung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.IHttpHandler" />-Objekt für den übergeordneten Handler ab.</summary>
        <value>Eine <see cref="T:System.Web.IHttpHandler" />-Instanz oder <see langword="null" />, wenn kein vorheriger Handler gefunden wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.PreviousHandler%2A>-Eigenschaft entspricht dem letzten Handler vor dem Ausführen der aktuellen Anforderung.

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb398986(v=vs.100)">Übersicht über HTTP-Handler und HTTP-Module</related>
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.Profile.ProfileBase" />-Objekt für das aktuelle Benutzerprofil ab.</summary>
        <value>Ein <see cref="T:System.Web.Profile.ProfileBase" />-Objekt, wenn die Konfigurationsdatei der Anwendung eine Definition der Eigenschaften des Profils enthält, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Eine <xref:System.Web.HttpContext.Profile%2A>-Eigenschaft wird für die persistente Speicherung strukturierter Daten mithilfe einer typsicheren API verwendet. Wenn auf eine <xref:System.Web.HttpContext.Profile%2A> Eigenschaft zugegriffen wird, aber kein Wert vorhanden ist, wird eine leere Instanz zurückgegeben. `null` wird nicht zurückgegeben.

 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContext.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">Das Objekt, das die Anforderung verarbeiten soll.</param>
        <summary>Ermöglicht es Ihnen, einen Handler für die Anforderung anzugeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn Sie `handler` auf `null`festlegen, wird der Standard Handler verwendet, um die Anforderung zu verarbeiten. Sie können `handler` entweder auf einen asynchronen Handler oder einen synchronen Handler festlegen. Der Handler muss die <xref:System.Web.IHttpHandler>-Schnittstelle implementieren.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />-Methode wurde nach dem <see cref="E:System.Web.HttpApplication.MapRequestHandler" />-Ereignis aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpRequest" />-Objekt für die aktuelle HTTP-Anforderung ab.</summary>
        <value>Das <see cref="T:System.Web.HttpRequest" />-Objekt für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.Request%2A>-Eigenschaft ermöglicht programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Web.HttpRequest>-Klasse. Da ASP.NET Seiten einen Standard Verweis auf den <xref:System.Web>-Namespace enthalten (der die <xref:System.Web.HttpContext>-Klasse enthält), können Sie auf eine ASPX-Seite auf die Member von <xref:System.Web.HttpRequest> verweisen, ohne den voll qualifizierten Klassen Verweis zum <xref:System.Web.HttpContext>zu verwenden. Beispielsweise können Sie `Request.Browser` verwenden, um die Funktionen des Client Browsers zu erhalten. Wenn Sie jedoch die Member von <xref:System.Web.HttpRequest> aus einem ASP.NET-Code Behind-Modul verwenden möchten, müssen Sie einen Verweis auf den <xref:System.Web>-Namespace im Modul und einen voll qualifizierten Verweis auf den aktuell aktiven Anforderungs-/Antwortkontext und die Klasse in <xref:System.Web> einschließen, die Sie verwenden möchten. Beispielsweise müssen Sie auf einer Code Behind-Seite den voll qualifizierten Namen `HttpContext.Current.Request.Browser`angeben.

> [!NOTE]
>  ASP.NET löst eine Ausnahme aus, wenn Sie versuchen, diese Eigenschaft zu verwenden, wenn das <xref:System.Web.HttpRequest> Objekt nicht verfügbar ist. Dies gilt z. b. für die Application_Start-Methode der Global. asax-Datei oder in einer Methode, die von der Application_Start-Methode aufgerufen wird. Zu diesem Zeitpunkt wurde noch keine HTTP-Anforderung erstellt.

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die Webanwendung wird unter IIS 7 im integrierten Modus ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpResponse" />-Objekt für die aktuelle HTTP-Antwort ab.</summary>
        <value>Das <see cref="T:System.Web.HttpResponse" />-Objekt für die aktuelle HTTP-Antwort.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.Response%2A>-Eigenschaft ermöglicht programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Web.HttpResponse>-Klasse. Da ASP.NET Seiten einen Standard Verweis auf den <xref:System.Web>-Namespace enthalten (der die <xref:System.Web.HttpContext>-Klasse enthält), können Sie auf eine ASPX-Seite auf die Member von <xref:System.Web.HttpContext> verweisen, ohne den voll qualifizierten Klassen Verweis zum <xref:System.Web.HttpContext>zu verwenden. Beispielsweise können Sie `Response.Write("some output")` verwenden, um die Ausgabe in einen HTTP-Ausgabestream zu schreiben. Wenn Sie jedoch die Member von <xref:System.Web.HttpResponse> aus einem ASP.NET-Code Behind-Modul verwenden möchten, müssen Sie einen Verweis auf den <xref:System.Web>-Namespace im Modul und einen voll qualifizierten Verweis auf den aktuell aktiven Anforderungs-/Antwortkontext und die Klasse in <xref:System.Web> einschließen, die Sie verwenden möchten. Beispielsweise müssen Sie auf einer Code Behind-Seite den voll qualifizierten Namen `HttpContext.Current.Response.Write("some output")`angeben.

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die Webanwendung wird unter IIS 7 im integrierten Modus ausgeführt.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Leitet die Anforderung einer Ressource an einen anderen als den durch die angeforderte URL angegebenen Pfad um. <see cref="Overload:System.Web.HttpContext.RewritePath" /> wird im Sitzungszustand ohne Cookies verwendet, um Sitzungs-IDs aus URLs zu entfernen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string -&gt; unit" Usage="httpContext.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der interne Pfad für das erneute Schreiben.</param>
        <summary>Ändert die URL mit dem angegebenen Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Mit der <xref:System.Web.HttpContext.RewritePath%28System.String%29>-Methode wird eine Anforderung für eine Ressource an einen anderen Pfad umgeleitet als den, der von der angeforderten URL angegeben wird. Wenn Sie den virtuellen Pfad zurücksetzen müssen, damit Anforderungen vom Client für Server Ressourcen ordnungsgemäß aufgelöst werden, verwenden Sie die Überladung dieser Methode, die den `rebaseClientPath`-Parameter annimmt, und legen Sie den-Parameter auf `false`fest.

 Das Umschreiben von URLs ist nützlich, wenn Sie die Seiten in Ihrer Webanwendung umstrukturieren möchten, und Sie möchten sicherstellen, dass Personen, die über Lesezeichen verfügen, diese auch nach dem Verschieben von Seiten verwenden können. Durch das Umschreiben von URLs können Sie Anforderungen transparent an den neuen Seiten Speicherort weiterleiten.

 Wenn Sie für einen Standort die Verwendung von URLs aktivieren möchten, die benutzerfreundlicher und für suchmaschinenoptimiert sind, ist die Verwendung des ASP.NET-Routings robuster. Weitere Informationen finden Sie unter [ASP.NET Routing](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)).



## Examples
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Web.HttpContext.RewritePath%2A>-Methode verwendet wird, um einer Website das reagieren auf URLs zu ermöglichen, die nicht die Dateistruktur auf der Website widerspiegeln. Der erste Codeblock ist eine ASP.NET-Webseite mit dem Namen reschreitepath. aspx. Hierfür ist eine Abfrage Zeichenfolge erforderlich. Wenn der Name der Website website1 ist, wird im Browser im URL-`http://localhost/WebSite1/RewritePath.aspx?page=1` "Seite 1" angezeigt. Der Codeblock, der der Webseite folgt, ist der `Application_BeginRequest` Ereignishandler in der Datei Global. asax. Dieser Code fängt Anforderungen für URLs ab, wie z. b. `http://localhost/WebSite1/page1`, und konvertiert sie in das Formular, das für Rewrite Path. aspx erforderlich ist, bevor Sie verarbeitet werden. Daher ruft die URL `http://localhost/WebSite1/page1` reschreitepath. aspx mit dem Abfrage Zeichen folgen Parameter auf, der im Browser "Seite 1" anzeigt. Wenn eine URL wie `http://localhost/WebSite1/page1` empfangen wird, wird eine Überladung von <xref:System.Web.HttpContext.RewritePath%2A> aufgerufen, mit der Sie einen Wert für die <xref:System.Web.HttpRequest.PathInfo%2A>-Eigenschaft sowie einen Abfrage Zeichen folgen Parameter bereitstellen können.

 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]

 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Der <paramref name="path" />-Parameter ist nicht im Stammverzeichnis der aktuellen Anwendung enthalten.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd329551(v=vs.140)">Exemplarische Vorgehensweise: Verwenden des ASP.NET-Routings in einer Web Forms Anwendung</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * bool -&gt; unit" Usage="httpContext.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der interne Pfad für das erneute Schreiben.</param>
        <param name="rebaseClientPath"><see langword="true" />, um den virtuellen Pfad zurückzusetzen, <see langword="false" />, um den virtuellen Pfad unverändert zu lassen.</param>
        <summary>Ändert die URL mit dem angegebenen Pfad und einem booleschen Wert, der angibt, ob der virtuelle Pfad für die Serverressource geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType>-Methode wird von der <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType>-Methode aufgerufen, wobei der `rebaseClientPath`-Parameter auf `true`festgelegt ist. Um sicherzustellen, dass der virtuelle Pfad, der zum Erstellen von Pfaden zu Ressourcen verwendet wird, nicht geändert wird, legen Sie den `rebaseClientPath`-Parameter auf `false`fest. Ein häufiges Szenario, bei dem Sie `rebaseClientPath` auf `false` festlegen möchten, ist, wenn Sie die URL neu schreiben müssen, und Sie Designs verwenden und die URL an eine Ressource umleiten, die sich in einem anderen Ordner als die angeforderte Ressource befindet.

 Das Umschreiben von URLs ist nützlich, wenn Sie die Seiten in Ihrer Webanwendung umstrukturieren möchten, und Sie möchten sicherstellen, dass Personen, die über Lesezeichen verfügen, diese auch nach dem Verschieben von Seiten verwenden können. Durch das Umschreiben von URLs können Sie Anforderungen transparent an den neuen Seiten Speicherort weiterleiten.

 Wenn Sie für einen Standort die Verwendung von URLs aktivieren möchten, die benutzerfreundlicher und für suchmaschinenoptimiert sind, ist die Verwendung des ASP.NET-Routings robuster. Weitere Informationen finden Sie unter [ASP.NET Routing](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)).



## Examples
 Ein Codebeispiel finden Sie in der <xref:System.Web.HttpContext.RewritePath%28System.String%29>-Methoden Überladung.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Der <paramref name="path" />-Parameter ist nicht im Stammverzeichnis der aktuellen Anwendung enthalten.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd329551(v=vs.140)">Exemplarische Vorgehensweise: Verwenden des ASP.NET-Routings in einer Web Forms Anwendung</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">Der interne Pfad für das erneute Schreiben.</param>
        <param name="pathInfo">Zusätzliche Pfadinformationen für eine Ressource. Weitere Informationen finden Sie unter <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Die Abfragezeichenfolge der Anforderung.</param>
        <summary>Ändert die URL unter Verwendung des angegebenen Pfads, der Pfadinformationen und der Informationen über die Abfragezeichenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Mit der <xref:System.Web.HttpContext.RewritePath%2A>-Methode wird eine Anforderung einer Ressource an eine andere Ressource umgeleitet, ohne die URL zu ändern.

 Der `filePath`-Parameter enthält nicht den `pathInfo` Parameter Inhalt. Für den URL-`http://www.microsoft.com/virdir/page.html/tail`ist der `filePath` Parameter `http://www.microsoft.com/virdir/page.html`, und der `pathInfo` Parameter ist "tail".

 Das Umschreiben von URLs ist nützlich, wenn Sie die Seiten in Ihrer Webanwendung umstrukturieren möchten, und Sie möchten sicherstellen, dass Personen, die über Lesezeichen verfügen, diese auch nach dem Verschieben von Seiten verwenden können. Durch das Umschreiben von URLs können Sie Anforderungen transparent an den neuen Seiten Speicherort weiterleiten.

 Wenn Sie für einen Standort die Verwendung von URLs aktivieren möchten, die benutzerfreundlicher und für suchmaschinenoptimiert sind, ist die Verwendung des ASP.NET-Routings robuster. Weitere Informationen finden Sie unter [ASP.NET Routing](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)).



## Examples
 Ein Codebeispiel, einschließlich eines Beispiels für diese Methoden Überladung, finden Sie in der <xref:System.Web.HttpContext.RewritePath%28System.String%29>-Methoden Überladung.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist nicht im Stammverzeichnis der aktuellen Anwendung enthalten.</exception>
        <exception cref="T:System.Web.HttpException">Der <paramref name="filePath" />-Parameter ist nicht im Stammverzeichnis der aktuellen Anwendung enthalten.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd329551(v=vs.140)">Exemplarische Vorgehensweise: Verwenden des ASP.NET-Routings in einer Web Forms Anwendung</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="pathInfo" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="queryString" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filePath">Der virtuelle Pfad für die Ressource zur Verarbeitung der Anforderung.</param>
        <param name="pathInfo">Zusätzliche Pfadinformationen für die URL-Umleitung. Weitere Informationen finden Sie unter <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Die Abfragezeichenfolge der Anforderung für die URL-Umleitung.</param>
        <param name="setClientFilePath"><see langword="true" />, um den Dateipfad für Clientressourcen auf den Wert des <paramref name="filePath" />-Parameters festzulegen, andernfalls <see langword="false" />.</param>
        <summary>Ändert die URL mit dem angegebenen virtuellen Pfad, den angegebenen Pfadinformationen, den angegebenen Zeichenfolgeninformationen und einem booleschen Wert, der angibt, ob der Pfad mit dem Clientdateipfad neu geschrieben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der `filePath`-Parameter enthält nicht den Inhalt des `pathInfo`-Parameters. Für den URL-`http://www.microsoft.com/virdir/page.html/tail`ist der `filePath` Parameter `http://www.microsoft.com/virdir/page.html`, und der `pathInfo` Parameter ist "tail".

 Um sicherzustellen, dass der virtuelle Pfad, der zum Erstellen von Pfaden zu Ressourcen verwendet wird, nicht geändert wird, legen Sie den `setClientFilePath`-Parameter auf `false`fest. Ein häufiges Szenario, bei dem Sie `setClientFilePath` auf `false` festlegen möchten, ist, wenn Sie die URL neu schreiben müssen, und Sie Designs verwenden und die URL an eine Ressource umleiten, die sich in einem anderen Ordner als die angeforderte Ressource befindet.

 Das Umschreiben von URLs ist nützlich, wenn Sie die Seiten in Ihrer Webanwendung umstrukturieren möchten, und Sie möchten sicherstellen, dass Personen, die über Lesezeichen verfügen, diese auch nach dem Verschieben von Seiten verwenden können. Durch das Umschreiben von URLs können Sie Anforderungen transparent an den neuen Seiten Speicherort weiterleiten.

 Wenn Sie für einen Standort die Verwendung von URLs aktivieren möchten, die benutzerfreundlicher und für suchmaschinenoptimiert sind, ist die Verwendung des ASP.NET-Routings robuster. Weitere Informationen finden Sie unter [ASP.NET Routing](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)).



## Examples
 Ein Codebeispiel finden Sie in der <xref:System.Web.HttpContext.RewritePath%28System.String%29>-Methoden Überladung.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist nicht im Stammverzeichnis der aktuellen Anwendung enthalten.</exception>
        <exception cref="T:System.Web.HttpException">Der <paramref name="filePath" />-Parameter ist nicht im Stammverzeichnis der aktuellen Anwendung enthalten.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd329551(v=vs.140)">Exemplarische Vorgehensweise: Verwenden des ASP.NET-Routings in einer Web Forms Anwendung</related>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpServerUtility" />-Objekt ab, das die bei der Verarbeitung von Webanforderungen verwendeten Methoden bereitstellt.</summary>
        <value>Das <see cref="T:System.Web.HttpServerUtility" />-Objekt für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.Server%2A>-Eigenschaft ermöglicht programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Web.HttpServerUtility>-Klasse. Da ASP.NET Seiten einen Standard Verweis auf den <xref:System.Web>-Namespace enthalten (der die <xref:System.Web.HttpContext>-Klasse enthält), können Sie auf eine ASPX-Seite auf die Member von <xref:System.Web.HttpContext> verweisen, ohne den voll qualifizierten Klassen Verweis zum <xref:System.Web.HttpContext>zu verwenden. Beispielsweise können Sie `Server.CreateObject("MyCOMComponent")` verwenden, um eine Instanz eines COM-Objekts auf dem Server zu erstellen. Wenn Sie jedoch die Member von <xref:System.Web.HttpServerUtility> aus einem ASP.NET-Code Behind-Modul verwenden möchten, müssen Sie einen Verweis auf den <xref:System.Web>-Namespace im Modul und einen voll qualifizierten Verweis auf den aktuell aktiven Anforderungs-/Antwortkontext und die Klasse in <xref:System.Web> einschließen, die Sie verwenden möchten. Beispielsweise müssen Sie auf einer Code Behind-Seite den voll qualifizierten Namen `HttpContext.Current.Server.CreateObject("MyCOMComponent")`angeben.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.SessionState.HttpSessionState" />-Objekt für die aktuelle HTTP-Anforderung ab.</summary>
        <value>Das <see cref="T:System.Web.SessionState.HttpSessionState" />-Objekt für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.Session%2A>-Eigenschaft ermöglicht programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Web.SessionState.HttpSessionState>-Klasse.

 Um den Sitzungszustand zu verwenden, müssen Sie ihn aktivieren. Informationen zum Aktivieren des Sitzungs Zustands finden Sie unter **Konfigurieren des Sitzungs** Zustands in [ASP.NET Session State Overview](https://docs.microsoft.com/previous-versions/aspnet/ms178581(v=vs.100)).

 Informationen zum Speichern von Werten im Sitzungszustand finden Sie unter Gewusst [wie: Speichern von Werten im Sitzungszustand](https://docs.microsoft.com/previous-versions/aspnet/6ad7zeeb(v=vs.100)). Weitere Informationen zum Lesen von Werten aus dem Sitzungszustand finden Sie unter Gewusst [wie: Lesen von Werten aus dem Sitzungszustand](https://docs.microsoft.com/previous-versions/aspnet/03sekbw5(v=vs.100)).



## Examples
 In den folgenden Beispielen wird gezeigt, wie Werte im Sitzungszustand gespeichert werden und wie Werte aus dem Sitzungszustand gelesen werden.

 Voraussetzungen für diese Beispiele sind:

-   Eine ASP.NET-Anwendung, für die der Sitzungszustand aktiviert ist.

-   Eine Web Forms Page-Klasse, die Zugriff auf die <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType>-Eigenschaft hat, oder eine beliebige Klasse, die Zugriff auf die <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType>-Eigenschaft hat.

```csharp
string firstName = "Jeff";
string lastName = "Smith";
string city = "Seattle";

// Save to session state in a Web Forms page class.
Session["FirstName"] = firstName;
Session["LastName"] = lastName;
Session["City"] = city;

// Read from session state in a Web Forms page class.
firstName = (string)(Session["FirstName"]);
lastName = (string)(Session["LastName"]);
city = (string)(Session["City"]);

// Outside of Web Forms page class, use HttpContext.Current.
HttpContext context = HttpContext.Current;
context.Session["FirstName"] = firstName;
firstName = (string)(context.Session["FirstName"]);

```

```vb
Dim firstName As String = "Jeff"
Dim lastName As String = "Smith"
Dim city As String = "Seattle"

' Save to session state in a Web Forms page class.
Session("FirstName") = firstName
Session("LastName") = lastName
Session("City") = city

' Read from session state in a Web Forms page class.
firstName = DirectCast(Session("FirstName"), String)
lastName = DirectCast(Session("LastName"), String)
city = DirectCast(Session("City"), String)

' Outside of Web Forms page class, use HttpContext.Current.
Dim context As HttpContext = HttpContext.Current
context.Session("FirstName") = firstName
firstName = DirectCast(context.Session("FirstName"), String)

```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="member this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContext.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">Einer der Enumerationswerte, der angibt, welcher Typ des Sitzungszustandsverhaltens erforderlich ist.</param>
        <summary>Legt den Typ des Sitzungszustandsverhaltens fest, der zur Unterstützung von HTTP-Anforderungen erforderlich ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 In der ASP.NET-Standard Implementierung gibt ein HTTP-Anforderungs Handler an, ob der Sitzungszustand durch Implementieren der <xref:System.Web.SessionState.IRequiresSessionState>-Schnittstelle oder der <xref:System.Web.SessionState.IReadOnlySessionState> Schnittstelle erforderlich ist. Mit der <xref:System.Web.HttpContext.SetSessionStateBehavior%2A>-Methode und der <xref:System.Web.SessionState.SessionStateBehavior>-Enumeration können Sie weitere Details dazu angeben, welche Art von Sitzungs Zustands Unterstützung erforderlich ist, um eine Anforderung zu verarbeiten. Weitere Informationen finden Sie unter der <xref:System.Web.SessionState.SessionStateBehavior>-Enumeration.

 Die <xref:System.Web.HttpContext.SetSessionStateBehavior%2A>-Methode muss vor dem <xref:System.Web.HttpApplication.AcquireRequestState> Pipeline-Ereignis aufgerufen werden. Bei aufrufen, die während oder nach diesem Ereignis auftreten, wird eine <xref:System.InvalidOperationException> Ausnahme ausgelöst.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Methode wurde nach dem Auslösen des <see cref="E:System.Web.HttpApplication.AcquireRequestState" />-Ereignisses aufgerufen.</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Web.Security.UrlAuthorizationModule" />-Objekt die Autorisierungsprüfung für die aktuelle Anforderung überspringen soll, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Web.Security.UrlAuthorizationModule" />-Objekt die Autorisierungsprüfung überspringen soll, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.SkipAuthorization%2A>-Eigenschaft ist für die Erweiterte Verwendung durch Authentifizierungs Module vorgesehen, die zu einer Seite umgeleitet werden müssen, die anonyme Verbindungen zulässt. Das Formular Authentifizierungs Modul und das Passport-Authentifizierungs Modul legen beim Umleiten an eine konfigurierte Anmeldeseite <xref:System.Web.HttpContext.SkipAuthorization%2A> fest. Für das Festlegen von <xref:System.Web.HttpContext.SkipAuthorization%2A> muss das `ControlPrincipal`-Flag festgelegt werden. Weitere Informationen zum `ControlPrincipal`-Flag finden Sie unter <xref:System.Security.Permissions.SecurityPermissionFlag>.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">Ein <see cref="T:System.Web.HttpContext" />-Diensttyp, auf den der Dienstanbieter festgelegt wird.</param>
        <summary>Gibt ein Objekt für den aktuellen Diensttyp zurück.</summary>
        <returns>Ein <see cref="T:System.Web.HttpContext" />-Dienst, andernfalls <see langword="null" />, wenn kein Dienst gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode ist nützlich, um Zugriff auf das zugrunde liegende <xref:System.Web.HttpWorkerRequest>-Objekt zu erhalten.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt diesen fest, der angibt, ob die ASP.NET-Laufzeit die <see cref="M:System.Threading.Thread.Abort" /> in der Zeichenfolge aufrufen sollte, welche diese Anforderung bedient, wenn die Zeit für diese Anforderung überschritten wird.</summary>
        <value><see langword="true" />, wenn <see cref="M:System.Threading.Thread.Abort" /> aufgerufen wird, wenn das Timeout des Thread erreicht wird; andernfalls <see langword="false" />. Der Standardwert lautet <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 In Handlern und Modulen, die die <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType>-Eigenschaft verwenden, um kooperativen Abbruch zu implementieren, können Sie das <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> Verhalten deaktivieren, das ASP.NET standardmäßig durchführt, wenn ein Timeout für eine Anforderung eintritt. Wenn diese Eigenschaft auf `false` festgelegt wird, können Sie sicherstellen, dass Abbruch-und cleanuproutinen ausgeführt werden, ohne von ASP.net unterbrochen zu werden.

 Wenn Sie diese Eigenschaft auf `false`festlegen, zeigt ASP.net bei einem Timeout nicht automatisch die Fehlerseite "Timeout bei der Anforderung" an. Die Anwendung ist dafür verantwortlich, den Antwort Inhalt entsprechend festzulegen.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Ausgangstimestamp der aktuellen HTTP-Anforderung ab.</summary>
        <value>Der Timestamp der aktuellen HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der von der <xref:System.Web.HttpContext.Timestamp%2A>-Eigenschaft zurückgegebene Zeitstempel ist die Ortszeit des Servers und wird während der Instanziierung des <xref:System.Web.HttpContext> Objekts festgelegt. Die Ortszeit ist gleich der UTC-Zeit zuzüglich des UTC-Offsets.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.TraceContext" />-Objekt für die aktuelle HTTP-Antwort ab.</summary>
        <value>Das <see cref="T:System.Web.TraceContext" />-Objekt für die aktuelle HTTP-Antwort.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Sicherheitsinformationen für die aktuelle HTTP-Anforderung ab, oder legt diese fest.</summary>
        <value>Sicherheitsinformationen für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.HttpContext.User%2A>-Eigenschaft ermöglicht programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Security.Principal.IPrincipal>-Schnittstelle.

 Da ASP.NET Seiten einen Standard Verweis auf den <xref:System.Web>-Namespace enthalten (der die <xref:System.Web.HttpContext>-Klasse enthält), können Sie auf eine ASPX-Seite auf die Member von <xref:System.Web.HttpContext> verweisen, ohne den voll qualifizierten Klassen Verweis zum <xref:System.Web.HttpContext>zu verwenden. Beispielsweise können Sie `User.Identity.Name` verwenden, um den Namen des Benutzers zu erhalten, in dessen Auftrag der aktuelle Prozess ausgeführt wird. Wenn Sie jedoch die Member von <xref:System.Security.Principal.IPrincipal> aus einem ASP.NET-Code Behind-Modul verwenden möchten, müssen Sie einen Verweis auf den <xref:System.Web>-Namespace im Modul und einen voll qualifizierten Verweis auf den aktuell aktiven Anforderungs-/Antwortkontext und die Klasse in <xref:System.Web> einschließen, die Sie verwenden möchten. Beispielsweise müssen Sie auf einer Code Behind-Seite den voll qualifizierten Namen `HttpContext.Current.User.Identity.Name`angeben.



## Examples
 Im folgenden Beispiel wird gezeigt, wie Sie über die <xref:System.Web.HttpContext.User%2A>-Eigenschaft auf die Eigenschaften des aktuellen Benutzers zugreifen. Diese Eigenschaften werden verwendet, um den Titel der Webseite festzulegen.

 Wenn die Anwendung die Windows-Authentifizierung verwendet, enthält der Benutzername die Domäne. Der Seitentitel wäre z. b. "Startseite für Domäne \ Benutzername".

 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]

 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions/using-oauth-providers-with-mvc">Verwenden von OAuth-Anbietern mit MVC 4</related>
        <related type="ExternalDocumentation" href="/aspnet/web-forms/overview/getting-started/getting-started-with-aspnet-45-web-forms/checkout-and-payment-with-paypal">Ersten Einstieg in ASP.NET 4,5 Web Forms-Checkout und Zahlung mit PayPal</related>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions-1/nerddinner/secure-applications-using-authentication-and-authorization">Nerddinner-sichere Anwendungen mithilfe von Authentifizierung und Autorisierung</related>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das ausgehandelte Protokoll ab, das vom Server an den Client für eine <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> Verbindung gesendet wurde.</summary>
        <value>Das ausgehandelte Protokoll.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die sortierte Liste von Protokollen ab, die vom Client angefordert werden.</summary>
        <value>Die angeforderten Protokolle oder <see langword="null" />, wenn dies keine <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Anforderung ist oder wenn keine Liste vorhanden ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
