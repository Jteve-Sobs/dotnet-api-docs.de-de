<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fc6d4cecf3d1280676ea2a57d97ca8507ab41492" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53390588" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContext = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Kapselt alle HTTP-spezifischen Informationen über eine einzelne HTTP-Anforderung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klassen, erben die <xref:System.Web.IHttpModule> und <xref:System.Web.IHttpHandler> Schnittstellen finden Sie einen Verweis auf ein <xref:System.Web.HttpContext> Objekt für die aktuelle HTTP-Anforderung. Das Objekt bietet Zugriff auf die systeminternen <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A>, und <xref:System.Web.HttpContext.Server%2A> Eigenschaften für die Anforderung.  
  
> [!IMPORTANT] 
> Dieses Objekt ist bereit für die Garbagecollection bei der <xref:System.Web.HttpRequest> abgeschlossen ist. Die Verwendung nach Abschluss der Anforderung kann zu nicht definiertem Verhalten führen, z. B. eine <xref:System.NullReferenceException>.
>
> Dieses Objekt ist nur verfügbar, in dem Thread, der von ASP.NET gesteuert. Verwendung in Hintergrundthreads kann zu nicht definiertem Verhalten führen.

## Examples  
 Das folgende Beispiel zeigt das Zugreifen auf und Anzeigen der Eigenschaften der <xref:System.Web.HttpContext> Objekt. Der Kontext der aktuellen HTTP-Anforderung erfolgt über die <xref:System.Web.UI.Page.Context%2A> Eigenschaft der <xref:System.Web.UI.Page> Objekt.  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=196730">Eine Frage des Kontexts</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.HttpContext" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpWorkerRequest -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext wr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">Das <see cref="T:System.Web.HttpWorkerRequest" />-Objekt für die aktuelle HTTP-Anforderung.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.HttpContext" />-Klasse mit dem angegebenen Arbeitsanforderungsobjekt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpRequest * System.Web.HttpResponse -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext (request, response)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">Das <see cref="T:System.Web.HttpRequest" />-Objekt für die aktuelle HTTP-Anforderung.</param>
        <param name="response">Das <see cref="T:System.Web.HttpResponse" />-Objekt für die aktuelle HTTP-Anforderung.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.HttpContext" />-Klasse mit den angegebenen Anforderungs- und Antwortobjekten.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Akzeptiert eine <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> Anforderung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContext.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="userFunc">Die Benutzerfunktion.</param>
        <summary>Akzeptiert eine <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> Anforderung unter Verwendung der angegebenen Benutzerfunktion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode entspricht dem Aufrufen der <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> -methodenüberladung, und übergeben `null` für die `options` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="userFunc" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Anforderung ist keine <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Anforderung.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContext.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" />
      </Parameters>
      <Docs>
        <param name="userFunc">Die Benutzerfunktion.</param>
        <param name="options">Das Options-Objekt.</param>
        <summary>Akzeptiert eine <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Anforderung mit dem angegebenen Benutzerfunktions- und Options-Objekt.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="userFunc" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Anforderung ist keine <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Anforderung.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="member this.AddError : Exception -&gt; unit" Usage="httpContext.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">Das <see cref="T:System.Exception" />-Objekt, das der Auflistung der Ausnahmen hinzugefügt werden soll.</param>
        <summary>Fügt der Auflistung der Ausnahmen für die aktuelle HTTP-Anforderung eine Ausnahme hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnRequestCompleted : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContext.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Das HTTP-Kontextobjekt.</param>
        <summary>Löst ein virtuelles Ereignis aus, das eintritt, wenn der HTTP-Teil der Anforderung beendet wird.</summary>
        <returns>Das Abonnementtoken.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, bevor Sie die <xref:System.Web.WebSockets.AspNetWebSocket> Verbindung beginnt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="callback" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Array von Fehlern ab, die beim Verarbeiten einer HTTP-Anforderung angesammelt wurden.</summary>
        <value>Ein Array von <see cref="T:System.Exception" />-Objekten für die aktuelle HTTP-Anforderung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt diesen fest, der angibt, ob asynchrone Vorgänge während Teilen der ASP.NET-Anfragenverarbeitung erlaubt sind, wenn sie nicht erwartet werden.</summary>
        <value><see langword="false" /> wenn ASP.NET eine Ausnahme auslöst, wenn die asynchrone API zu einem Zeitpunkt verwendet wird, an dem dies nicht erwartet wird; anderenfalls <see langword="true" />. Der Standardwert ist <see langword="false" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Flag nicht, um festgelegt ist `true`, ASP.NET wird eine Ausnahme ausgelöst, wenn er erkennt, dass die Anwendung, die die asynchrone API missbraucht. Dies kann auftreten, wenn Sie versuchen, eine asynchrone Methode aufzurufen, während ein Teil der anforderungsverarbeitungs-Pipeline, in dem asynchrone Vorgänge nicht erwartet werden, oder wenn immer noch ausstehender asynchroner Arbeit vorhanden ist, wenn ein asynchrones Modul bzw. den Handler für den Abschluss signalisiert. Dieses Verhalten dient als Sicherheitsnetz, damit Sie am Anfang benachrichtigt, wenn Sie asynchronen Code, der nicht passt Muster erwartet und möglicherweise negative Nebeneffekte schreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpApplicationState" />-Objekt für die aktuelle HTTP-Anforderung ab.</summary>
        <value>Das <see cref="T:System.Web.HttpApplicationState" />-Objekt für die aktuelle HTTP-Anforderung.  
  
Verwenden Sie <see cref="T:System.Web.HttpApplication" />, um das <see cref="P:System.Web.HttpContext.ApplicationInstance" />-Objekt für die aktuelle HTTP-Anforderung abzurufen. (In ASP.NET wird als Eigenschaftenname <see langword="ApplicationInstance" /> anstelle von <see langword="Application" /> verwendet, um auf die aktuelle <see cref="T:System.Web.HttpApplication" />-Instanz zu verweisen, um Verwechslungen zwischen ASP.NET und klassischem ASP zu verhindern. Im klassischem ASP verweist <see langword="Application" /> auf das globale Anwendungszustands-Wörterbuch.)</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpApplication" />-Objekt für die aktuelle HTTP-Anforderung ab oder legt dieses fest.</summary>
        <value>Das <see cref="T:System.Web.HttpApplication" />-Objekt für die aktuelle HTTP-Anforderung.  
  
In ASP.NET wird als Eigenschaftenname <see langword="ApplicationInstance" /> anstelle von <see langword="Application" /> verwendet, um auf die aktuelle <see cref="T:System.Web.HttpApplication" />-Instanz zu verweisen, um Verwechslungen zwischen ASP.NET und klassischem ASP zu verhindern. Im klassischem ASP verweist <see langword="Application" /> auf das globale Anwendungszustands-Wörterbuch.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Die Webanwendung wird unter IIS 7.0 im integrierten Modus ausgeführt, und es wurde versucht, den Eigenschaftswert von einem Wert ungleich NULL in <see langword="null" /> zu ändern.</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab oder legt ein Objekt fest, das die Flags enthält, die den asynchronen Vorablademodus betreffen.</summary>
        <value>Ein Objekt, das Flags enthält, die den Modus des asynchronen Vorabladenmodus betreffen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim ersten Zugriff auf diese Eigenschaft wird das Objekt, das Flags für den asynchronen vorablademodus enthält wird geladen, aus der <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> in der Konfigurationsdatei festlegen.  
  
 Obwohl diese Eigenschaft programmgesteuert festgelegt werden kann, wirkt sich die Änderung des Eigenschaftswerts nur aus, wenn die Eigenschaft vom `ExecuteRequestHandler`-Schritt der ASP.NET-Anforderungspipeline festgelegt ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.Caching.Cache" />-Objekt für die aktuelle Anwendungsdomäne ab.</summary>
        <value>Der <see cref="T:System.Web.Caching.Cache" /> für die aktuelle Anwendungsdomäne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt eine Instanz von der <xref:System.Web.Caching.Cache> Klasse pro Anwendungsdomäne. Daher die <xref:System.Web.Caching.Cache> von zurückgegebene Objekt der <xref:System.Web.HttpContext.Cache%2A> -Eigenschaft ist die <xref:System.Web.Caching.Cache> Objekt für alle Anforderungen in der Anwendungsdomäne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpContext.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Fehler für die aktuelle HTTP-Anforderung.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.HttpContext with get, set" Usage="System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpContext" />-Objekt für die aktuelle HTTP-Anforderung ab oder legt dieses fest.</summary>
        <value>Die <see cref="T:System.Web.HttpContext" />-Instanz für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist eine statische Eigenschaft von der <xref:System.Web.HttpContext> Klasse. Der Eigenschaftenspeicher die <xref:System.Web.HttpContext> -Instanz, die auf die aktuelle Anforderung angewendet wird. Die Eigenschaften dieser Instanz sind, die nicht statische Eigenschaften der <xref:System.Web.HttpContext> Klasse.  
  
 Können Sie auch die <xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType> Eigenschaft, die Zugriff auf die <xref:System.Web.HttpContext> Objekt für die aktuelle HTTP-Anforderung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpContext.Current%2A> Eigenschaft, die Zugriff auf die <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> und <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> Methoden und die <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> Eigenschaft. Das Beispiel erstellt drei benutzerdefinierte Ausnahmen, die mit der <xref:System.Web.HttpContext.AddError%2A> -Methode und verwendet die <xref:System.Web.HttpContext.AllErrors%2A> Eigenschaft, um diese Ausnahmen in ein Array zu laden. Anschließend wird das Array in der entsprechenden Seite und verwendet die <xref:System.Web.HttpContext.ClearError%2A> -Methode löschen alle Fehler aus der <xref:System.Web.UI.Page.Context%2A> Eigenschaft.  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.IHttpHandler" />-Objekt ab, das den derzeit ausführenden Handler darstellt.</summary>
        <value>Ein <see cref="T:System.Web.IHttpHandler" />-Objekt, das den derzeit ausführenden Handler darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der aktuell ausgeführten Handler, der vom verwiesen wird die <xref:System.Web.HttpContext.CurrentHandler%2A> Eigenschaft möglicherweise anders als der Handler, der vom verwiesen wird die <xref:System.Web.HttpContext.Handler%2A> Eigenschaft. Dies kann auftreten, wenn ein anderer Handler, mithilfe angefordert wurde der <xref:System.Web.HttpServerUtility.Execute%2A> Methode oder der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Wenn der derzeit ausführende Handler die Verarbeitung abgeschlossen ist, wird der Handler für zuvor ermittelten wiederhergestellt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">HTTP-Handler und HTTP-Module (Übersicht)</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Web.RequestNotification" />-Wert ab, der das <see cref="T:System.Web.HttpApplication" />-Ereignis angibt, das derzeit verarbeitet wird.</summary>
        <value>Einer der <see cref="T:System.Web.RequestNotification" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.CurrentNotification%2A> Eigenschaft erfordert den integrierten Pipelinemodus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und mindestens .NET Framework, Version 3.0. Sofern verfügbar, die Eigenschaft gibt eine <xref:System.Web.RequestNotification> Wert. Der Wert des der <xref:System.Web.HttpContext.CurrentNotification%2A> Eigenschaft gibt an, welches Ereignis in der <xref:System.Web.HttpApplication> Instanz derzeit die Anforderung verarbeitet.  
  
 Die <xref:System.Web.HttpContext.CurrentNotification%2A> Eigenschaft sollte nicht festgelegt werden. Sie wird stattdessen durch festgelegt [!INCLUDE[iisver](~/includes/iisver-md.md)] während der Verarbeitung der Anforderung in der ASP.NET-Pipeline. Festlegen der <xref:System.Web.HttpContext.CurrentNotification%2A> Eigenschaft führt zu einem Kompilierungsfehler.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> wird in .NET Framework, Version 3.5 eingeführt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Web.HttpContext.CurrentNotification%2A> Eigenschaft, um zu bestimmen, welches Ereignis von der <xref:System.Web.HttpApplication> -Objekt, das die aktuelle Anforderung behandelt wird verarbeitet. Im Beispiel verarbeitet der Ereignishandler mehrere Ereignisse des der <xref:System.Web.HttpApplication> -Objekt, und die <xref:System.Web.HttpContext.CurrentNotification%2A> Eigenschaft bestimmt, welcher Code aufgerufen wird, für jedes Ereignis behandelt wird.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Dieser Vorgang erfordert den integrierten Pipelinemodus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und .NET Framework 3.0 oder höher.</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="member this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContext.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" />
      </Parameters>
      <Docs>
        <param name="target">Das Objekt, dessen <see cref="M:System.IDisposable.Dispose" />-Methode aufgerufen werden muss, wenn der <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Verbindungsteil der Anforderung abgeschlossen ist.</param>
        <summary>Aktiviert die <see cref="M:System.IDisposable.Dispose" />-Methode eines Objekts, wenn der <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Verbindungsteil der Anforderung abgeschlossen ist.</summary>
        <returns>Das Abonnementtoken.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IDisposable.Dispose%2A> Methode das Zielobjekt wird aufgerufen, nachdem sowohl die HTTP-Teil der Anforderung und die <xref:System.Web.WebSockets.AspNetWebSocket> Verbindung beendet. Die <xref:System.Web.HttpContext> Objekt ist nicht verfügbar für die Überprüfung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ggf. den ersten Fehler ab, der beim Verarbeiten einer HTTP-Anforderung aufgezeichnet wurde.</summary>
        <value>Die erste <see cref="T:System.Exception" /> für den aktuellen HTTP-Anforderungs-/Antwortprozess; andernfalls <see langword="null" />, wenn während der Verarbeitung der HTTP-Anforderung keine Fehler angesammelt wurden. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetAppConfig : string -&gt; obj" Usage="System.Web.HttpContext.GetAppConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Das Anwendungskonfigurationstag, für das Informationen angefordert werden.</param>
        <summary>Gibt die angeforderten Konfigurationsinformationen für die aktuelle Anwendung zurück.</summary>
        <returns>Ein Objekt, das Konfigurationsinformationen enthält. (Wandeln Sie den zurückgegebenen Konfigurationsabschnitt vor der Verwendung in den zutreffenden Konfigurationstyp um.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.GetAppConfig%2A>-Methode ist veraltet. Verwenden der <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> Methode der <xref:System.Web.Configuration.WebConfigurationManager> Klasse zum Abrufen der Konfigurationsinformationen für die aktuelle Anwendung.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetConfig : string -&gt; obj" Usage="httpContext.GetConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Das Konfigurationstag, für das Informationen angefordert werden.</param>
        <summary>Gibt die angeforderten Konfigurationsinformationen für die aktuelle HTTP-Anforderung zurück.</summary>
        <returns>Das angegebene <see cref="T:System.Configuration.ConfigurationSection" />-Objekt, <see langword="null" />, falls der Abschnitt nicht vorhanden ist, oder ein internes Objekt, falls der Zugriff auf den Abschnitt zur Laufzeit nicht möglich ist. (Wandeln Sie das zurückgegebene Objekt vor der Verwendung in den zutreffenden Konfigurationstyp um.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.GetConfig%2A>-Methode ist veraltet. Verwenden der <xref:System.Web.HttpContext.GetSection%2A> -Methode zum Abrufen der Konfigurationsinformationen für die aktuelle HTTP-Anforderung.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine Ressource auf Anwendungsebene ab.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ressourcen in Anwendungen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET Web Sitelayout</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classKey">Eine Zeichenfolge, die die <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" />-Eigenschaft des angeforderten Ressourcenobjekts darstellt.</param>
        <param name="resourceKey">Eine Zeichenfolge, die die <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />-Eigenschaft des angeforderten Ressourcenobjekts darstellt.</param>
        <summary>Ruft auf der Grundlage der angegebenen <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" />-Eigenschaft und <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />-Eigenschaft ein Ressourcenobjekt auf Anwendungsebene ab.</summary>
        <returns>Ein <see cref="T:System.Object" />-Objekt, das das angeforderte Ressourcenobjekt auf Anwendungsebene darstellt; andernfalls NULL, wenn ein Ressourcenobjekt nicht gefunden wird oder wenn ein Ressourcenobjekt gefunden wird, es jedoch nicht über die angeforderte Eigenschaft verfügt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.GetGlobalResourceObject%2A> Methode gibt eine globale Ressource, mit der Kultur, die im angegebenen die <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> Eigenschaft.  
  
> [!NOTE]
>  Bearbeiten Sie in einigen Umgebungen, wie z. B. [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)], Editor löst möglicherweise eine Entwurfszeit- <xref:System.Resources.MissingManifestResourceException> -Ausnahme aus, wenn Sie in der globalen Ressource-Key-Name einen Punkt (.) verwenden. Allerdings Dies hat keine Auswirkungen auf Ihre Fähigkeit, bearbeiten oder speichern Sie die Datei, und Sie können den Fehler ignorieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Ein Ressourcenobjekt mit dem angegebenen <paramref name="classKey" />-Parameter wurde nicht gefunden.  
  
- oder -  
Die Hauptassembly enthält keine Ressourcen für die neutrale Kultur. Diese Ressourcen sind jedoch erforderlich, da die entsprechende Satellitenassembly nicht vorhanden ist.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ressourcen in Anwendungen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET Web Sitelayout</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="classKey">Eine Zeichenfolge, die die <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" />-Eigenschaft des angeforderten Ressourcenobjekts darstellt.</param>
        <param name="resourceKey">Eine Zeichenfolge, die die <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />-Eigenschaft des angeforderten Ressourcenobjekts darstellt.</param>
        <param name="culture">Eine Zeichenfolge, die das <see cref="T:System.Globalization.CultureInfo" />-Objekt der angeforderten Ressource darstellt.</param>
        <summary>Ruft auf der Grundlage der angegebenen <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" />-Eigenschaft und <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />-Eigenschaft sowie des angegebenen <see cref="T:System.Globalization.CultureInfo" />-Objekts ein Ressourcenobjekt auf Anwendungsebene ab.</summary>
        <returns>Ein <see cref="T:System.Object" />-Objekt, das das angeforderte Ressourcenobjekt auf Anwendungsebene darstellt, das für die angegebene Kultur lokalisiert wird; andernfalls <see langword="null" />, wenn ein Ressourcenobjekt nicht gefunden wird oder wenn ein Ressourcenobjekt gefunden wird, es jedoch nicht über die angeforderte Eigenschaft verfügt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Globalization.CultureInfo> Objekt darstellt, das die Kultur für die die Ressource lokalisiert wurde. Wenn die Ressource nicht für diese Kultur lokalisiert ist, wird die Suche nach einem Fallbackprozess einer geeigneten Ressource folgen. Weitere Informationen finden Sie unter [Verpacken und Bereitstellen von Ressourcen](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
> [!NOTE]
>  Der Editor kann in einigen Umgebungen bearbeiten wie z. B. Visual Web Developer eine Entwurfszeit-auslösen <xref:System.Resources.MissingManifestResourceException> -Ausnahme aus, wenn Sie in der globalen Ressource-Key-Name einen Punkt (.) verwenden. Allerdings Dies hat keine Auswirkungen auf Ihre Fähigkeit, bearbeiten oder speichern Sie die Datei, und Sie können den Fehler ignorieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Ein Ressourcenobjekt, dessen angegebener <paramref name="classKey" />-Parameter nicht gefunden wurde.  
  
- oder -  
Die Hauptassembly enthält keine Ressourcen für die neutrale Kultur. Diese Ressourcen sind jedoch erforderlich, da die entsprechende Satellitenassembly nicht vorhanden ist.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ressourcen in Anwendungen</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine Ressource auf Seitenebene ab.</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ressourcen in Anwendungen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET Web Sitelayout</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Die <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" />-Eigenschaft für das lokale Ressourcenobjekt.</param>
        <param name="resourceKey">Eine Zeichenfolge, die die <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />-Eigenschaft des angeforderten Ressourcenobjekts darstellt.</param>
        <summary>Ruft auf der Grundlage der angegebenen <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" />-Eigenschaft und <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />-Eigenschaft ein Ressourcenobjekt auf Seitenebene ab.</summary>
        <returns>Ein <see cref="T:System.Object" />, das das angeforderte Ressourcenobjekt auf Seitenebene darstellt; andernfalls <see langword="null" />, wenn ein übereinstimmendes Ressourcenobjekt, jedoch kein <paramref name="resourceKey" />-Parameter gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.GetLocalResourceObject%2A> Methode gibt eine lokale Ressource mit der Kultur, die im angegebenen die <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Ein Ressourcenobjekt im angegebenen <paramref name="virtualPath" />-Parameter wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene <paramref name="virtualPath" />-Parameter ist nicht im Stammverzeichnis der aktuellen Anwendung enthalten.</exception>
        <exception cref="T:System.InvalidOperationException">Die Ressourcenklasse für die Seite wurde nicht gefunden.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ressourcen in Anwendungen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET Web Sitelayout</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">Vorgehensweise: Programmgesteuertes Abrufen von Ressourcenwerten</related>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Die <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" />-Eigenschaft für das lokale Ressourcenobjekt.</param>
        <param name="resourceKey">Eine Zeichenfolge, die die <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />-Eigenschaft des angeforderten Ressourcenobjekts darstellt.</param>
        <param name="culture">Eine Zeichenfolge, die das <see cref="T:System.Globalization.CultureInfo" />-Objekt des angeforderten Ressourcenobjekts darstellt.</param>
        <summary>Ruft auf der Grundlage der angegebenen <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" />-Eigenschaft und <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />-Eigenschaft sowie des angegebenen <see cref="T:System.Globalization.CultureInfo" />-Objekts ein Ressourcenobjekt auf Seitenebene ab.</summary>
        <returns>Ein <see cref="T:System.Object" />, das das angeforderte lokale Ressourcenobjekt darstellt, das für die angegebene Kultur lokalisiert wird; andernfalls <see langword="null" />, wenn ein übereinstimmendes Ressourcenobjekt, jedoch kein <paramref name="resourceKey" />-Parameter gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Ressource nicht für diese Kultur lokalisiert ist, wird die Suche nach einem Fallbackprozess einer geeigneten Ressource folgen. Weitere Informationen finden Sie unter [Verpacken und Bereitstellen von Ressourcen](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Ein Ressourcenobjekt im angegebenen <paramref name="virtualPath" />-Parameter wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene <paramref name="virtualPath" />-Parameter ist nicht im Stammverzeichnis der aktuellen Anwendung enthalten.</exception>
        <exception cref="T:System.InvalidOperationException">Die Ressourcenklasse für die Seite wurde nicht gefunden.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ressourcen in Anwendungen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET Web Sitelayout</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">Vorgehensweise: Programmgesteuertes Abrufen von Ressourcenwerten</related>
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="member this.GetSection : string -&gt; obj" Usage="httpContext.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">Der Pfad des Konfigurationsabschnitts (im XPath-Format) und der Name des Konfigurationselements.</param>
        <summary>Ruft einen angegebenen Konfigurationsabschnitt für die Standardkonfiguration der aktuellen Anwendung ab.</summary>
        <returns>Das angegebene <see cref="T:System.Configuration.ConfigurationSection" />-Objekt, <see langword="null" />, falls der Abschnitt nicht vorhanden ist, oder ein internes Objekt, falls der Zugriff auf den Abschnitt zur Laufzeit nicht möglich ist.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das für die Verarbeitung der HTTP-Anforderung verantwortliche <see cref="T:System.Web.IHttpHandler" />-Objekt ab oder legt dieses fest.</summary>
        <value>Ein für die Verarbeitung der HTTP-Anforderung verantwortliches <see cref="T:System.Web.IHttpHandler" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.Handler%2A> Eigenschaft enthält einen Verweis auf den Handler, die HTTP-Anforderung verarbeitet. Der Handler kann angegeben werden, mithilfe des Elements, oder einen benutzerdefinierten Handler im Benutzercode definiert. Weitere Informationen zu Ereignishandlern finden Sie unter [HTTP-Handler und Überblick über die HTTP-Module](https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b).  
  
 Der Verweis auf die <xref:System.Web.HttpContext.Handler%2A> Eigenschaft bleibt gleich auch nach die aktuelle Seite von einer serverseitigen Methode, wie z. B. geändert wurde der <xref:System.Web.HttpServerUtility.Execute%2A> Methode oder der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">HTTP-Handler und HTTP-Module (Übersicht)</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für die aktuelle HTTP-Anforderung benutzerdefinierte Fehler aktiviert sind.</summary>
        <value><see langword="true" />, wenn benutzerdefinierte Fehler aktiviert sind, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob sich die aktuelle HTTP-Anforderung im Debugmodus befindet.</summary>
        <value><see langword="true" />, wenn sich die Anforderung im Debugmodus befindet, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der der aktuelle Verarbeitungspunkt in der ASP.NET-Pipeline ist, gleich nachdem ein <see cref="T:System.Web.HttpApplication" />-Ereignis die Verarbeitung beendet hat.</summary>
        <value><see langword="true" />, wenn benutzerdefinierte Fehler aktiviert sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.IsPostNotification%2A> Eigenschaft wird nur unterstützt, mit dem integrierten Modus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und mindestens .NET Framework 3.0. Sofern dieses verfügbar ist, gibt die Eigenschaft einen booleschen Wert, der angibt, ob ein Ereignis in der <xref:System.Web.HttpApplication> Objekt wurde beendet.  
  
 Die <xref:System.Web.HttpContext.IsPostNotification%2A> Eigenschaft sollte nicht festgelegt werden. Stattdessen wird es von bereitgestellt [!INCLUDE[iisver](~/includes/iisver-md.md)] an die ASP.NET-Laufzeitumgebung für jede Benachrichtigung. Festlegen der <xref:System.Web.HttpContext.IsPostNotification%2A> Eigenschaft führt zu einem Kompilierungsfehler.  
  
 In Szenarien, in denen mehrere Ereignisse des der <xref:System.Web.HttpApplication> Objekt von einem Ereignishandler behandelt werden, können Sie mit der <xref:System.Web.HttpContext.IsPostNotification%2A> Eigenschaft in Kombination mit der <xref:System.Web.RequestNotification> Enumeration um genau zu bestimmen, an welcher Stelle in den Lebenszyklus der Anwendung die aktuelle die Anforderung ist.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> wird in .NET Framework, Version 3.5 eingeführt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Web.HttpContext.IsPostNotification%2A> Eigenschaft, um zu bestimmen, wenn ein Ereignis von der <xref:System.Web.HttpApplication> Objekt hat die Verarbeitung aller zugehörigen Ereignishandler abgeschlossen. In diesem Beispiel wird der benutzerdefinierte Ereignishandler verarbeitet mehrere Ereignisse des der <xref:System.Web.HttpApplication> -Objekt, und die <xref:System.Web.HttpContext.IsPostNotification%2A> Eigenschaft wird verwendet, um zu bestimmen, welcher Code aufgerufen wird, nachdem ein bestimmtes Ereignis behandelt wird.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Dieser Vorgang erfordert den integrierten Pipelinemodus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und .NET Framework 3.0 oder höher.</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob es sich bei der Anforderung um eine <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Anforderung handelt.</summary>
        <value><see langword="true" />, wenn es sich bei der Anforderung um eine <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Anforderung handelt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `true` , wenn die Anforderung mit den ersten enthält <xref:System.Web.WebSockets.AspNetWebSocket> Handshake und die `WebSocket` -Modul von IIS ist aktiv.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Verbindung von einer HTTP-Verbindung zu einer <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Verbindung aktualisiert wird.</summary>
        <value><see langword="true" />, wenn die Verbindung aktualisiert wird, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Schlüssel-/Wert-Auflistung ab, die während einer HTTP-Anforderung zum Organisieren und Freigeben von Daten zwischen einer <see cref="T:System.Web.IHttpModule" />-Schnittstelle und einer <see cref="T:System.Web.IHttpHandler" />-Schnittstelle verwendet werden kann.</summary>
        <value>Eine <see cref="T:System.Collections.IDictionary" />-Schlüssel-/Wert-Auflistung, über die mithilfe eines angegebenen Schlüssels auf einen einzelnen Wert in der Auflistung zugegriffen werden kann.</value>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms972109.aspx">Eine Frage des Kontexts</related>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf die Instanz für Seiteninstrumentierungsdienste für diese Anforderung ab.</summary>
        <value>Die Seiteninstrumentierungs-Dienstinstanz für diese Anforderung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.IHttpHandler" />-Objekt für den übergeordneten Handler ab.</summary>
        <value>Eine <see cref="T:System.Web.IHttpHandler" />-Instanz oder <see langword="null" />, wenn kein vorheriger Handler gefunden wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.PreviousHandler%2A> Eigenschaft entspricht dem letzten Ereignishandler, bevor die aktuelle Anforderung ausgeführt wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">HTTP-Handler und HTTP-Module (Übersicht)</related>
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.Profile.ProfileBase" />-Objekt für das aktuelle Benutzerprofil ab.</summary>
        <value>Ein <see cref="T:System.Web.Profile.ProfileBase" />-Objekt, wenn die Konfigurationsdatei der Anwendung eine Definition der Eigenschaften des Profils enthält, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Web.HttpContext.Profile%2A> Eigenschaft wird für die dauerhafte Speicherung von strukturierten Daten mit einer typsicheren API verwendet. Wenn eine <xref:System.Web.HttpContext.Profile%2A> -Eigenschaft zugegriffen wird, aber kein Wert vorhanden ist, wird eine leere Instanz zurückgegeben. `null` wird nicht zurückgegeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContext.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
      </Parameters>
      <Docs>
        <param name="handler">Das Objekt, das die Anforderung verarbeiten soll.</param>
        <summary>Ermöglicht es Ihnen, einen Handler für die Anforderung anzugeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Setzen Sie `handler` zu `null`, der Standard-Handler wird verwendet, um die Anforderung zu verarbeiten. Sie können festlegen, `handler` entweder ein asynchroner Handler oder ein synchroner Handler. Der Handler muss implementieren die <xref:System.Web.IHttpHandler> Schnittstelle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />-Methode wurde nach dem <see cref="E:System.Web.HttpApplication.MapRequestHandler" />-Ereignis aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpRequest" />-Objekt für die aktuelle HTTP-Anforderung ab.</summary>
        <value>Das <see cref="T:System.Web.HttpRequest" />-Objekt für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.Request%2A> Eigenschaft ermöglicht den programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Web.HttpRequest> Klasse. Da ASP.NET-Seiten ein standardverweises auf enthalten die <xref:System.Web> Namespace (enthält die <xref:System.Web.HttpContext> Klasse), können Sie auf die Member verweisen <xref:System.Web.HttpRequest> auf eine ASPX-Seite ohne Verwendung des vollqualifizierten Verweises auf <xref:System.Web.HttpContext>. Beispielsweise können Sie `Request.Browser` um die Funktionen des Clientbrowsers abzurufen. Allerdings sollten Sie die Elemente der <xref:System.Web.HttpRequest> aus einem ASP.NET Code-Behind-Modul, müssen Sie enthalten einen Verweis auf die <xref:System.Web> -Namespace in das Modul und einen vollqualifizierten Verweis auf beide den derzeit aktiven Anforderung/Antwort-Kontext und die -Klasse im <xref:System.Web> , die Sie verwenden möchten. Z. B. in einer CodeBehind-Seite Geben Sie den voll gekennzeichneten Namen `HttpContext.Current.Request.Browser`.  
  
> [!NOTE]
>  ASP.NET wird eine Ausnahme ausgelöst, wenn Sie versuchen, diese Eigenschaft verwenden, wenn die <xref:System.Web.HttpRequest> Objekt ist nicht verfügbar. Beispielsweise ist dies wäre "true" in der Application_Start-Methode der Datei Global.asax oder in einer Methode, die von der Methode "Application_Start" aufgerufen wird. Zu diesem Zeitpunkt wurde noch keine HTTP-Anforderung erstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die Webanwendung wird unter IIS 7 im integrierten Modus ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpResponse" />-Objekt für die aktuelle HTTP-Antwort ab.</summary>
        <value>Das <see cref="T:System.Web.HttpResponse" />-Objekt für die aktuelle HTTP-Antwort.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.Response%2A> Eigenschaft ermöglicht den programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Web.HttpResponse> Klasse. Da ASP.NET-Seiten ein standardverweises auf enthalten die <xref:System.Web> Namespace (enthält die <xref:System.Web.HttpContext> Klasse), können Sie auf die Member verweisen <xref:System.Web.HttpContext> auf eine ASPX-Seite ohne Verwendung des vollqualifizierten Verweises auf <xref:System.Web.HttpContext>. Beispielsweise können Sie `Response.Write("some output")` Ausgabe in einen HTTP-Ausgabestream zu schreiben. Allerdings sollten Sie die Elemente der <xref:System.Web.HttpResponse> aus einem ASP.NET Code-Behind-Modul, müssen Sie enthalten einen Verweis auf die <xref:System.Web> -Namespace in das Modul und ein vollqualifizierter Verweis auf den derzeit aktiven Anforderung/Antwort-Kontext und die Klasse in <xref:System.Web> , die Sie verwenden möchten. Z. B. in einer CodeBehind-Seite Geben Sie den voll gekennzeichneten Namen `HttpContext.Current.Response.Write("some output")`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die Webanwendung wird unter IIS 7 im integrierten Modus ausgeführt.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Leitet die Anforderung einer Ressource an einen anderen als den durch die angeforderte URL angegebenen Pfad um. <see cref="Overload:System.Web.HttpContext.RewritePath" /> wird im Sitzungszustand ohne Cookies verwendet, um Sitzungs-IDs aus URLs zu entfernen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string -&gt; unit" Usage="httpContext.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der interne Pfad für das erneute Schreiben.</param>
        <summary>Ändert die URL mit dem angegebenen Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.RewritePath%28System.String%29> Methode leitet eine Anforderung für eine Ressource auf einen anderen Pfad als die, die von der angeforderten URL angegeben ist. Wenn Sie den virtuellen Pfad zurück, sodass Anforderungen vom Client für Serverressourcen ordnungsgemäß aufgelöst werden müssen, verwenden Sie die Überladung dieser Methode, die akzeptiert die `rebaseClientPath` Parameter und Festlegen des Parameters auf `false`.  
  
 URL-Umschreibung ist nützlich, wenn die Seiten in Ihrer Webanwendung umstrukturieren möchten, und Sie möchten, um sicherzustellen, dass Personen, die alten URLs, ein Lesezeichen erstellt haben diese aber weiterhin verwenden können, nachdem Sie die Seiten verschoben haben. URL-Umschreibung, können Sie transparent Weiterleiten von Anforderungen an den neuen Speicherort für die Seite.  
  
 Wenn Sie eine Site mit URLs, die Benutzerfreundlicher sind, und sind optimiert für Suchmaschinen aktivieren möchten, ist eine robustere Alternative ASP.NET-Routing verwenden. Weitere Informationen finden Sie unter [ASP.NET-Routing](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Web.HttpContext.RewritePath%2A> Methode zum Aktivieren einer Website auf URLs reagieren, die nicht die Dateistruktur in der Website widerspiegeln. Der erste Codeblock wird eine ASP.NET-Webseite mit dem Namen RewritePath.aspx. Es ist eine Abfragezeichenfolge erforderlich. Wenn der Name Ihrer Website WebSite1, die URL ist `http://localhost/WebSite1/RewritePath.aspx?page=1` "Seite 1" im Browser angezeigt. Der Codeblock, der auf der Webseite folgt wird den `Application_BeginRequest` -Ereignishandler in der Datei "Global.asax". Dieser Code fängt Anforderungen für URLs wie z. B. `http://localhost/WebSite1/page1` und konvertiert diese in das Formular, das für die RewritePath.aspx erforderlich ist, bevor sie verarbeitet werden. Aus diesem Grund die URL `http://localhost/WebSite1/page1` RewritePath.aspx aufruft, mit dem Abfragezeichenfolgen-Parameter, der "Seite 1" im Browser angezeigt wird. Wenn eine URL wie z. B. `http://localhost/WebSite1/page1` empfangen wird, eine Überladung der <xref:System.Web.HttpContext.RewritePath%2A> wird aufgerufen, mit der Sie einen Wert für die <xref:System.Web.HttpRequest.PathInfo%2A> Eigenschaft als auch eine Abfrage ein Zeichenfolgenparameter.  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Der <paramref name="path" />-Parameter befindet sich nicht im Stammverzeichnis der aktuellen Anwendung.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET-Routing</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Exemplarische Vorgehensweise: Verwenden von ASP.NET-ROUTING in einer Web Forms-Anwendung</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * bool -&gt; unit" Usage="httpContext.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der interne Pfad für das erneute Schreiben.</param>
        <param name="rebaseClientPath"><see langword="true" />, um den virtuellen Pfad zurückzusetzen, <see langword="false" />, um den virtuellen Pfad unverändert zu lassen.</param>
        <summary>Ändert die URL mit dem angegebenen Pfad und einem booleschen Wert, der angibt, ob der virtuelle Pfad für die Serverressource geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> Methode wird aufgerufen, indem die <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType> -Methode mit dem `rebaseClientPath` Parametersatz zu `true`. Um sicherzustellen, dass der virtuelle Pfad, der zum Erstellen von Pfaden zu Ressourcen verwendet wird, nicht geändert wird, legen die `rebaseClientPath` Parameter `false`. Ein häufiges Szenario, in denen Sie festlegen möchten `rebaseClientPath` zu `false` müssen Sie das Umschreiben der URL, und Sie werden unter Verwendung von Designs und Umleitung der URL an eine Ressource in einem anderen Ordner als die angeforderte Ressource ist.  
  
 URL-Umschreibung ist nützlich, wenn die Seiten in Ihrer Webanwendung umstrukturieren möchten, und Sie möchten, um sicherzustellen, dass Personen, die alten URLs, ein Lesezeichen erstellt haben diese aber weiterhin verwenden können, nachdem Sie die Seiten verschoben haben. URL-Umschreibung, können Sie transparent Weiterleiten von Anforderungen an den neuen Speicherort für die Seite.  
  
 Wenn Sie eine Site mit URLs, die Benutzerfreundlicher sind, und sind optimiert für Suchmaschinen aktivieren möchten, ist eine robustere Alternative ASP.NET-Routing verwenden. Weitere Informationen finden Sie unter [ASP.NET-Routing](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter den <xref:System.Web.HttpContext.RewritePath%28System.String%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Der <paramref name="path" />-Parameter befindet sich nicht im Stammverzeichnis der aktuellen Anwendung.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET-Routing</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Exemplarische Vorgehensweise: Verwenden von ASP.NET-ROUTING in einer Web Forms-Anwendung</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">Der interne Pfad für das erneute Schreiben.</param>
        <param name="pathInfo">Zusätzliche Pfadinformationen für eine Ressource. Weitere Informationen finden Sie unter <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Die Abfragezeichenfolge der Anforderung.</param>
        <summary>Ändert die URL unter Verwendung des angegebenen Pfads, der Pfadinformationen und der Informationen über die Abfragezeichenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.RewritePath%2A> Methode leitet eine Anforderung für eine Ressource auf eine andere Ressource, ohne die URL zu ändern.  
  
 Die `filePath` Parameter enthält keinen der `pathInfo` Parameter-Inhalt. Für die URL http://www.microsoft.com/virdir/page.html/tail, `filePath` Parameter http://www.microsoft.com/virdir/page.html, und die `pathInfo` -Parameter ist Ende.  
  
 URL-Umschreibung ist nützlich, wenn die Seiten in Ihrer Webanwendung umstrukturieren möchten, und Sie möchten, um sicherzustellen, dass Personen, die alten URLs, ein Lesezeichen erstellt haben diese aber weiterhin verwenden können, nachdem Sie die Seiten verschoben haben. URL-Umschreibung, können Sie transparent Weiterleiten von Anforderungen an den neuen Speicherort für die Seite.  
  
 Wenn Sie eine Site mit URLs, die Benutzerfreundlicher sind, und sind optimiert für Suchmaschinen aktivieren möchten, ist eine robustere Alternative ASP.NET-Routing verwenden. Weitere Informationen finden Sie unter [ASP.NET-Routing](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Ein Codebeispiel, einschließlich eines Beispiels für die Überladung dieser Methode finden Sie unter den <xref:System.Web.HttpContext.RewritePath%28System.String%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter befindet sich nicht im Stammverzeichnis der aktuellen Anwendung.</exception>
        <exception cref="T:System.Web.HttpException">Der <paramref name="filePath" />-Parameter befindet sich nicht im Stammverzeichnis der aktuellen Anwendung.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET-Routing</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Exemplarische Vorgehensweise: Verwenden von ASP.NET-ROUTING in einer Web Forms-Anwendung</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filePath">Der virtuelle Pfad für die Ressource zur Verarbeitung der Anforderung.</param>
        <param name="pathInfo">Zusätzliche Pfadinformationen für die URL-Umleitung. Weitere Informationen finden Sie unter <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Die Abfragezeichenfolge der Anforderung für die URL-Umleitung.</param>
        <param name="setClientFilePath"><see langword="true" />, um den Dateipfad für Clientressourcen auf den Wert des <paramref name="filePath" />-Parameters festzulegen, andernfalls <see langword="false" />.</param>
        <summary>Ändert die URL mit dem angegebenen virtuellen Pfad, den angegebenen Pfadinformationen, den angegebenen Zeichenfolgeninformationen und einem booleschen Wert, der angibt, ob der Pfad mit dem Clientdateipfad neu geschrieben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `filePath` Parameter umfasst nicht den Inhalt der `pathInfo` Parameter. Für die URL http://www.microsoft.com/virdir/page.html/tail, `filePath` Parameter http://www.microsoft.com/virdir/page.html, und die `pathInfo` -Parameter ist Ende.  
  
 Um sicherzustellen, dass der virtuelle Pfad, der zum Erstellen von Pfaden zu Ressourcen verwendet wird, nicht geändert wird, legen die `setClientFilePath` Parameter `false`. Ein häufiges Szenario, in denen Sie festlegen möchten `setClientFilePath` zu `false` müssen Sie das Umschreiben der URL, und Sie werden unter Verwendung von Designs und Umleitung der URL an eine Ressource in einem anderen Ordner als die angeforderte Ressource ist.  
  
 URL-Umschreibung ist nützlich, wenn die Seiten in Ihrer Webanwendung umstrukturieren möchten, und Sie möchten, um sicherzustellen, dass Personen, die alten URLs, ein Lesezeichen erstellt haben diese aber weiterhin verwenden können, nachdem Sie die Seiten verschoben haben. URL-Umschreibung, können Sie transparent Weiterleiten von Anforderungen an den neuen Speicherort für die Seite.  
  
 Wenn Sie eine Site mit URLs, die Benutzerfreundlicher sind, und sind optimiert für Suchmaschinen aktivieren möchten, ist eine robustere Alternative ASP.NET-Routing verwenden. Weitere Informationen finden Sie unter [ASP.NET-Routing](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter den <xref:System.Web.HttpContext.RewritePath%28System.String%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter befindet sich nicht im Stammverzeichnis der aktuellen Anwendung.</exception>
        <exception cref="T:System.Web.HttpException">Der <paramref name="filePath" />-Parameter befindet sich nicht im Stammverzeichnis der aktuellen Anwendung.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET-Routing</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Exemplarische Vorgehensweise: Verwenden von ASP.NET-ROUTING in einer Web Forms-Anwendung</related>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpServerUtility" />-Objekt ab, das die bei der Verarbeitung von Webanforderungen verwendeten Methoden bereitstellt.</summary>
        <value>Das <see cref="T:System.Web.HttpServerUtility" />-Objekt für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.Server%2A> Eigenschaft ermöglicht den programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Web.HttpServerUtility> Klasse. Da ASP.NET-Seiten ein standardverweises auf enthalten die <xref:System.Web> Namespace (enthält die <xref:System.Web.HttpContext> Klasse), können Sie auf die Member verweisen <xref:System.Web.HttpContext> auf eine ASPX-Seite ohne Verwendung des vollqualifizierten Verweises auf <xref:System.Web.HttpContext>. Beispielsweise können Sie `Server.CreateObject("MyCOMComponent")` eine Instanz eines COM-Objekts auf dem Server zu erstellen. Allerdings sollten Sie die Elemente der <xref:System.Web.HttpServerUtility> aus einem ASP.NET Code-Behind-Modul, müssen Sie enthalten einen Verweis auf die <xref:System.Web> -Namespace in das Modul und einen vollqualifizierten Verweis auf beide den derzeit aktiven Anforderung/Antwort-Kontext und die -Klasse im <xref:System.Web> , die Sie verwenden möchten. Z. B. in einer CodeBehind-Seite Geben Sie den voll gekennzeichneten Namen `HttpContext.Current.Server.CreateObject("MyCOMComponent")`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.SessionState.HttpSessionState" />-Objekt für die aktuelle HTTP-Anforderung ab.</summary>
        <value>Das <see cref="T:System.Web.SessionState.HttpSessionState" />-Objekt für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.Session%2A> Eigenschaft ermöglicht den programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Web.SessionState.HttpSessionState> Klasse.  
  
 Um den Sitzungszustand zu verwenden, um ihn zu aktivieren. Informationen dazu, wie Sie den Sitzungszustand aktivieren, finden Sie unter **Sitzungszustand konfigurieren** in [ASP.NET Session State Overview](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
 Informationen dazu, wie Sie die Werte im Sitzungsstatus zu speichern, finden Sie unter [Vorgehensweise: Speichern Sie die Werte im Sitzungsstatus](https://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165). Weitere Informationen zum Lesen von Werten aus dem Sitzungszustand, finden Sie unter [Vorgehensweise: Lesen die Werte aus dem Sitzungszustand](https://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5).  
  
   
  
## Examples  
 Die folgenden Beispiele zeigen, wie Werte im Sitzungszustand gespeichert und zum Lesen von Werten aus dem Sitzungszustand.  
  
 Diese Beispiele erfordern Folgendes:  
  
-   Eine ASP.NET-Anwendung, die Sitzungsstatus aktiviert wurde.  
  
-   Eine Web Forms-Seite-Klasse, die Zugriff auf die <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType> Eigenschaft oder in einer Klasse, die Zugriff auf die <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> Eigenschaft.  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="member this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContext.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">Einer der Enumerationswerte, der angibt, welcher Typ des Sitzungszustandsverhaltens erforderlich ist.</param>
        <summary>Legt den Typ des Sitzungszustandsverhaltens fest, der zur Unterstützung von HTTP-Anforderungen erforderlich ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Standardimplementierung von ASP.NET ein HTTP-Anforderungshandler gibt an, ob der Sitzungszustand durch die Implementierung benötigt der <xref:System.Web.SessionState.IRequiresSessionState> Schnittstelle oder die <xref:System.Web.SessionState.IReadOnlySessionState> Schnittstelle. Die <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> Methode und die <xref:System.Web.SessionState.SessionStateBehavior> Enumeration können Sie weitere Details zu welcher Typ podpory stavu zur Bearbeitung einer Anforderung benötigt wird. Weitere Informationen finden Sie unter der <xref:System.Web.SessionState.SessionStateBehavior>-Enumeration.  
  
 Die <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> Methode muss aufgerufen werden, bevor die <xref:System.Web.HttpApplication.AcquireRequestState> Pipelineereignis. Bewirkt, dass Aufrufe, die auftreten, während oder nach diesem Ereignis eine <xref:System.InvalidOperationException> Ausnahme.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Methode wurde nach dem Auslösen des <see cref="E:System.Web.HttpApplication.AcquireRequestState" />-Ereignisses aufgerufen.</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Web.Security.UrlAuthorizationModule" />-Objekt die Autorisierungsprüfung für die aktuelle Anforderung überspringen soll, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Web.Security.UrlAuthorizationModule" />-Objekt die Autorisierungsprüfung überspringen soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.SkipAuthorization%2A> Eigenschaft sollte für die erweiterte Verwendung von Authentifizierungsmodule, die auf einer Seite umleiten, die anonyme Verbindungen zulässt. Das Modul zur Formularauthentifizierung und Modul für die Passport-Authentifizierung, beide festgelegt <xref:System.Web.HttpContext.SkipAuthorization%2A> beim Umleiten zu einer konfigurierten Anmeldeseite. Festlegen von <xref:System.Web.HttpContext.SkipAuthorization%2A> erfordert die `ControlPrincipal` Flag festgelegt sein. Informationen zu den `ControlPrincipal` kennzeichnen, finden Sie unter <xref:System.Security.Permissions.SecurityPermissionFlag>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">Ein <see cref="T:System.Web.HttpContext" />-Diensttyp, auf den der Dienstanbieter festgelegt wird.</param>
        <summary>Gibt ein Objekt für den aktuellen Diensttyp zurück.</summary>
        <returns>Ein <see cref="T:System.Web.HttpContext" />-Dienst, andernfalls <see langword="null" />, wenn kein Dienst gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode eignet sich für den Zugriff auf die zugrunde liegende <xref:System.Web.HttpWorkerRequest> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt diesen fest, der angibt, ob die ASP.NET-Laufzeit die <see cref="M:System.Threading.Thread.Abort" /> in der Zeichenfolge aufrufen sollte, welche diese Anforderung bedient, wenn die Zeit für diese Anforderung überschritten wird.</summary>
        <value><see langword="true" />, wenn <see cref="M:System.Threading.Thread.Abort" /> aufgerufen wird, wenn das Timeout des Thread erreicht wird; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Handler und Module, die verwendet werden die <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> Eigenschaft, um einen kooperativen Abbruch, implementieren Sie deaktivieren möchten die <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> Verhalten, das standardmäßig ASP.NET ausgeführt werden soll, wenn eine Anforderung ein auftritt Timeout. Wenn diese Eigenschaft auf `false` können Sie sicherstellen, dass die Routinen für Abbruch und Bereinigung ausgeführt werden, ohne die von ASP.NET unterbrochen wird.  
  
 Wenn Sie diese Eigenschaft auf `false`, ASP.NET nicht zeigt automatisch eine Fehlerseite "Timeout für Anforderung" ein Timeout auftritt. Die Anwendung ist zuständig für das den Inhalt der Antwort entsprechend festlegen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Ausgangstimestamp der aktuellen HTTP-Anforderung ab.</summary>
        <value>Der Timestamp der aktuellen HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von zurückgegebene Zeitstempel der <xref:System.Web.HttpContext.Timestamp%2A> Eigenschaft ist die lokale Zeit des Servers und wird festgelegt, während der Instanziierung des der <xref:System.Web.HttpContext> Objekt. Die lokale Zeit entspricht der UTC-Zeit plus der UTC-Offset.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.TraceContext" />-Objekt für die aktuelle HTTP-Antwort ab.</summary>
        <value>Das <see cref="T:System.Web.TraceContext" />-Objekt für die aktuelle HTTP-Antwort.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Sicherheitsinformationen für die aktuelle HTTP-Anforderung ab, oder legt diese fest.</summary>
        <value>Sicherheitsinformationen für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.User%2A> Eigenschaft ermöglicht den programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Security.Principal.IPrincipal> Schnittstelle.  
  
 Da ASP.NET-Seiten ein standardverweises auf enthalten die <xref:System.Web> Namespace (enthält die <xref:System.Web.HttpContext> Klasse), können Sie auf die Member verweisen <xref:System.Web.HttpContext> auf eine ASPX-Seite ohne Verwendung des vollqualifizierten Verweises auf <xref:System.Web.HttpContext>. Beispielsweise können Sie `User.Identity.Name` um dem Namen des Benutzers abzurufen, in dessen Namen des aktuellen Prozesses ausgeführt werden. Allerdings sollten Sie die Elemente der <xref:System.Security.Principal.IPrincipal> aus einem ASP.NET Code-Behind-Modul, müssen Sie enthalten einen Verweis auf die <xref:System.Web> -Namespace in das Modul und einen vollqualifizierten Verweis auf beide den derzeit aktiven Anforderung/Antwort-Kontext und die -Klasse im <xref:System.Web> , die Sie verwenden möchten. Z. B. in einer CodeBehind-Seite Geben Sie den voll gekennzeichneten Namen `HttpContext.Current.User.Identity.Name`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie den Zugriff auf Eigenschaften des aktuellen Benutzers über die <xref:System.Web.HttpContext.User%2A> Eigenschaft. Diese Eigenschaften werden verwendet, um den Titel der Webseite festzulegen.  
  
 Wenn die Anwendung Windows-Authentifizierung verwendet wird, enthält der Benutzername die Domäne an. Beispielsweise wäre die Titel der Seite "Für" Domäne\Benutzername "Startseite".  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions/using-oauth-providers-with-mvc">Verwenden von OAuth-Anbietern mit MVC 4</related>
        <related type="ExternalDocumentation" href="/aspnet/web-forms/overview/getting-started/getting-started-with-aspnet-45-web-forms/checkout-and-payment-with-paypal">Erste Schritte mit ASP.NET 4.5 Web Forms - Bezahlvorgang und Zahlung mit PayPal</related>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions-1/nerddinner/secure-applications-using-authentication-and-authorization">NerdDinner – sicherer Anwendungen mit Authentifizierung und Autorisierung</related>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das ausgehandelte Protokoll ab, das vom Server an den Client für eine <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> Verbindung gesendet wurde.</summary>
        <value>Das ausgehandelte Protokoll.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die sortierte Liste von Protokollen ab, die vom Client angefordert werden.</summary>
        <value>Die angeforderten Protokolle oder <see langword="null" />, wenn dies keine <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Anforderung ist oder wenn keine Liste vorhanden ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>