<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="571c854e5bea1aa3323080495177f0636cdef671" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37586937" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContext = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Encapsulates all HTTP-specific information about an individual HTTP request.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klassen, erben die <xref:System.Web.IHttpModule> und <xref:System.Web.IHttpHandler> Schnittstellen finden Sie einen Verweis auf ein <xref:System.Web.HttpContext> Objekt für die aktuelle HTTP-Anforderung. Das Objekt bietet Zugriff auf die systeminternen <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A>, und <xref:System.Web.HttpContext.Server%2A> Eigenschaften für die Anforderung.  
  
> [!IMPORTANT] 
> Dieses Objekt ist bereit für die Garbagecollection bei der <xref:System.Web.HttpRequest> abgeschlossen ist. Die Verwendung nach Abschluss der Anforderung kann zu nicht definiertem Verhalten führen, z. B. eine <xref:System.NullReferenceException>.
>
> Dieses Objekt ist nur verfügbar, in dem Thread, der von ASP.NET gesteuert. Verwendung in Hintergrundthreads kann zu nicht definiertem Verhalten führen.

## Examples  
 Steht ein Visual Studio Web-Websiteprojekt mit Quellcode zur Ergänzung dieses Themas: [herunterladen](http://go.microsoft.com/fwlink/?LinkId=192422).  
  
 Das folgende Beispiel zeigt das Zugreifen auf und Anzeigen der Eigenschaften der <xref:System.Web.HttpContext> Objekt. Der Kontext der aktuellen HTTP-Anforderung erfolgt über die <xref:System.Web.UI.Page.Context%2A> Eigenschaft der <xref:System.Web.UI.Page> Objekt.  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Web.HttpContext" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpWorkerRequest -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext wr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">The <see cref="T:System.Web.HttpWorkerRequest" /> object for the current HTTP request.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Web.HttpContext" /> class that uses the specified worker-request object.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpRequest * System.Web.HttpResponse -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext (request, response)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">The <see cref="T:System.Web.HttpRequest" /> object for the current HTTP request.</param>
        <param name="response">The <see cref="T:System.Web.HttpResponse" /> object for the current HTTP request.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Web.HttpContext" /> class by using the specified request and response objects.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Accepts an <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> request.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContext.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="userFunc">The user function.</param>
        <summary>Accepts an <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> request using the specified user function.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode entspricht dem Aufrufen der <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> -methodenüberladung, und übergeben `null` für die `options` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="userFunc" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The request is not an <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> request.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContext.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" />
      </Parameters>
      <Docs>
        <param name="userFunc">The user function.</param>
        <param name="options">The options object.</param>
        <summary>Accepts an <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> request using the specified user function and options object.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="userFunc" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The request is not an <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> request.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="member this.AddError : Exception -&gt; unit" Usage="httpContext.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">The <see cref="T:System.Exception" /> to add to the exception collection.</param>
        <summary>Adds an exception to the exception collection for the current HTTP request.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnRequestCompleted : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContext.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">The HTTP context object.</param>
        <summary>Raises a virtual event that occurs when the HTTP part of the request is ending.</summary>
        <returns>The subscription token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, bevor Sie die <xref:System.Web.WebSockets.AspNetWebSocket> Verbindung beginnt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="callback" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an array of errors accumulated while processing an HTTP request.</summary>
        <value>Ein Array von <see cref="T:System.Exception" />-Objekten für die aktuelle HTTP-Anforderung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether asynchronous operations are allowed during parts of ASP.NET request processing when they are not expected.</summary>
        <value>
          <see langword="false" /> wenn ASP.NET eine Ausnahme auslöst, wenn die asynchrone API zu einem Zeitpunkt verwendet wird, an dem dies nicht erwartet wird; anderenfalls <see langword="true" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Flag nicht, um festgelegt ist `true`, ASP.NET wird eine Ausnahme ausgelöst, wenn er erkennt, dass die Anwendung, die die asynchrone API missbraucht. Dies kann auftreten, wenn Sie versuchen, eine asynchrone Methode aufzurufen, während ein Teil der anforderungsverarbeitungs-Pipeline, in dem asynchrone Vorgänge nicht erwartet werden, oder wenn immer noch ausstehender asynchroner Arbeit vorhanden ist, wenn ein asynchrones Modul bzw. den Handler für den Abschluss signalisiert. Dieses Verhalten dient als Sicherheitsnetz, damit Sie am Anfang benachrichtigt, wenn Sie asynchronen Code, der nicht passt Muster erwartet und möglicherweise negative Nebeneffekte schreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Web.HttpApplicationState" /> object for the current HTTP request.</summary>
        <value>Das <see cref="T:System.Web.HttpApplicationState" />-Objekt für die aktuelle HTTP-Anforderung.  Verwenden Sie <see cref="T:System.Web.HttpApplication" />, um das <see cref="P:System.Web.HttpContext.ApplicationInstance" />-Objekt für die aktuelle HTTP-Anforderung abzurufen. (In ASP.NET wird als Eigenschaftenname <see langword="ApplicationInstance" /> anstelle von <see langword="Application" /> verwendet, um auf die aktuelle <see cref="T:System.Web.HttpApplication" />-Instanz zu verweisen, um Verwechslungen zwischen ASP.NET und klassischem ASP zu verhindern. Im klassischem ASP verweist <see langword="Application" /> auf das globale Anwendungszustands-Wörterbuch.)</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Web.HttpApplication" /> object for the current HTTP request.</summary>
        <value>Das <see cref="T:System.Web.HttpApplication" />-Objekt für die aktuelle HTTP-Anforderung.  In ASP.NET wird als Eigenschaftenname <see langword="ApplicationInstance" /> anstelle von <see langword="Application" /> verwendet, um auf die aktuelle <see cref="T:System.Web.HttpApplication" />-Instanz zu verweisen, um Verwechslungen zwischen ASP.NET und klassischem ASP zu verhindern. Im klassischem ASP verweist <see langword="Application" /> auf das globale Anwendungszustands-Wörterbuch.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">The Web application is running under IIS 7.0 in Integrated mode, and an attempt was made to change the property value from a non-null value to <see langword="null" />.</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an object that contains flags that pertain to asynchronous preload mode.</summary>
        <value>Ein Objekt, das Flags enthält, die den Modus des asynchronen Vorabladenmodus betreffen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim ersten Zugriff auf diese Eigenschaft wird das Objekt, das Flags für den asynchronen vorablademodus enthält wird geladen, aus der <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> in der Konfigurationsdatei festlegen.  
  
 Auch wenn diese Eigenschaft programmgesteuert festgelegt werden kann, ändern den Wert der Eigenschaft nur hat Auswirkungen, wenn die Eigenschaft festgelegt ist, bevor Sie die `ExecuteRequestHandler` Schritt in der ASP.NET-Pipeline für die Anforderung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Web.Caching.Cache" /> object for the current application domain.</summary>
        <value>Der <see cref="T:System.Web.Caching.Cache" /> für die aktuelle Anwendungsdomäne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt eine Instanz von der <xref:System.Web.Caching.Cache> Klasse pro Anwendungsdomäne. Daher die <xref:System.Web.Caching.Cache> von zurückgegebene Objekt der <xref:System.Web.HttpContext.Cache%2A> -Eigenschaft ist die <xref:System.Web.Caching.Cache> Objekt für alle Anforderungen in der Anwendungsdomäne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpContext.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears all errors for the current HTTP request.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.HttpContext with get, set" Usage="System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Web.HttpContext" /> object for the current HTTP request.</summary>
        <value>Die <see cref="T:System.Web.HttpContext" />-Instanz für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist eine statische Eigenschaft von der <xref:System.Web.HttpContext> Klasse. Der Eigenschaftenspeicher die <xref:System.Web.HttpContext> -Instanz, die auf die aktuelle Anforderung angewendet wird. Die Eigenschaften dieser Instanz sind, die nicht statische Eigenschaften der <xref:System.Web.HttpContext> Klasse.  
  
 Können Sie auch die <xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType> Eigenschaft, die Zugriff auf die <xref:System.Web.HttpContext> Objekt für die aktuelle HTTP-Anforderung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpContext.Current%2A> Eigenschaft, die Zugriff auf die <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> und <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> Methoden und die <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> Eigenschaft. Das Beispiel erstellt drei benutzerdefinierte Ausnahmen, die mit der <xref:System.Web.HttpContext.AddError%2A> -Methode und verwendet die <xref:System.Web.HttpContext.AllErrors%2A> Eigenschaft, um diese Ausnahmen in ein Array zu laden. Anschließend wird das Array in der entsprechenden Seite und verwendet die <xref:System.Web.HttpContext.ClearError%2A> -Methode löschen alle Fehler aus der <xref:System.Web.UI.Page.Context%2A> Eigenschaft.  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Web.IHttpHandler" /> object that represents the currently executing handler.</summary>
        <value>Ein <see cref="T:System.Web.IHttpHandler" />-Objekt, das den derzeit ausführenden Handler darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der aktuell ausgeführten Handler, der vom verwiesen wird die <xref:System.Web.HttpContext.CurrentHandler%2A> Eigenschaft möglicherweise anders als der Handler, der vom verwiesen wird die <xref:System.Web.HttpContext.Handler%2A> Eigenschaft. Dies kann auftreten, wenn ein anderer Handler, mithilfe angefordert wurde der <xref:System.Web.HttpServerUtility.Execute%2A> Methode oder der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode. Wenn der derzeit ausführende Handler die Verarbeitung abgeschlossen ist, wird der Handler für zuvor ermittelten wiederhergestellt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Web.RequestNotification" /> value that indicates the current <see cref="T:System.Web.HttpApplication" /> event that is processing.</summary>
        <value>Einer der <see cref="T:System.Web.RequestNotification" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.CurrentNotification%2A> Eigenschaft erfordert den integrierten Pipelinemodus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und mindestens .NET Framework, Version 3.0. Sofern verfügbar, die Eigenschaft gibt eine <xref:System.Web.RequestNotification> Wert. Der Wert des der <xref:System.Web.HttpContext.CurrentNotification%2A> Eigenschaft gibt an, welches Ereignis in der <xref:System.Web.HttpApplication> Instanz derzeit die Anforderung verarbeitet.  
  
 Die <xref:System.Web.HttpContext.CurrentNotification%2A> Eigenschaft sollte nicht festgelegt werden. Sie wird stattdessen durch festgelegt [!INCLUDE[iisver](~/includes/iisver-md.md)] während der Verarbeitung der Anforderung in der ASP.NET-Pipeline. Festlegen der <xref:System.Web.HttpContext.CurrentNotification%2A> Eigenschaft führt zu einem Kompilierungsfehler.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> wird in .NET Framework, Version 3.5 eingeführt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Web.HttpContext.CurrentNotification%2A> Eigenschaft, um zu bestimmen, welches Ereignis von der <xref:System.Web.HttpApplication> -Objekt, das die aktuelle Anforderung behandelt wird verarbeitet. Im Beispiel verarbeitet der Ereignishandler mehrere Ereignisse des der <xref:System.Web.HttpApplication> -Objekt, und die <xref:System.Web.HttpContext.CurrentNotification%2A> Eigenschaft bestimmt, welcher Code aufgerufen wird, für jedes Ereignis behandelt wird.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The operation requires integrated pipeline mode in [!INCLUDE[iisver](~/includes/iisver-md.md)] and at least the .NET Framework version 3.0.</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="member this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContext.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" />
      </Parameters>
      <Docs>
        <param name="target">The object whose <see cref="M:System.IDisposable.Dispose" /> method must be called when the <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> connection part of the request is completed.</param>
        <summary>Enables an object's <see cref="M:System.IDisposable.Dispose" /> method to be called when the <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> connection part of this request is completed.</summary>
        <returns>The subscription token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IDisposable.Dispose%2A> Methode das Zielobjekt wird aufgerufen, nachdem sowohl die HTTP-Teil der Anforderung und die <xref:System.Web.WebSockets.AspNetWebSocket> Verbindung beendet. Die <xref:System.Web.HttpContext> Objekt ist nicht verfügbar für die Überprüfung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the first error (if any) accumulated during HTTP request processing.</summary>
        <value>Die erste <see cref="T:System.Exception" /> für den aktuellen HTTP-Anforderungs-/Antwortprozess; andernfalls <see langword="null" />, wenn während der Verarbeitung der HTTP-Anforderung keine Fehler angesammelt wurden. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetAppConfig : string -&gt; obj" Usage="System.Web.HttpContext.GetAppConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The application configuration tag for which information is requested.</param>
        <summary>Returns requested configuration information for the current application.</summary>
        <returns>An object containing configuration information. (Cast the returned configuration section to the appropriate configuration type before use.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.GetAppConfig%2A>-Methode ist veraltet. Verwenden der <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> Methode der <xref:System.Web.Configuration.WebConfigurationManager> Klasse zum Abrufen der Konfigurationsinformationen für die aktuelle Anwendung.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetConfig : string -&gt; obj" Usage="httpContext.GetConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The configuration tag for which information is requested.</param>
        <summary>Returns requested configuration information for the current HTTP request.</summary>
        <returns>The specified <see cref="T:System.Configuration.ConfigurationSection" />, <see langword="null" /> if the section does not exist, or an internal object if the section is not accessible at run time. (Cast the returned object to the appropriate configuration type before use.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.GetConfig%2A>-Methode ist veraltet. Verwenden der <xref:System.Web.HttpContext.GetSection%2A> -Methode zum Abrufen der Konfigurationsinformationen für die aktuelle HTTP-Anforderung.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets an application-level resource.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classKey">A string that represents the <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> property of the requested resource object.</param>
        <param name="resourceKey">A string that represents the <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> property of the requested resource object.</param>
        <summary>Gets an application-level resource object based on the specified <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> and <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> properties.</summary>
        <returns>An <see cref="T:System.Object" /> that represents the requested application-level resource object; otherwise, null if a resource object is not found or if a resource object is found but it does not have the requested property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.GetGlobalResourceObject%2A> Methode gibt eine globale Ressource, mit der Kultur, die im angegebenen die <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> Eigenschaft.  
  
> [!NOTE]
>  Bearbeiten Sie in einigen Umgebungen, wie z. B. [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)], Editor löst möglicherweise eine Entwurfszeit- <xref:System.Resources.MissingManifestResourceException> -Ausnahme aus, wenn Sie in der globalen Ressource-Key-Name einen Punkt (.) verwenden. Allerdings Dies hat keine Auswirkungen auf Ihre Fähigkeit, bearbeiten oder speichern Sie die Datei, und Sie können den Fehler ignorieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">A resource object with the specified <paramref name="classKey" /> parameter was not found.  \- or -  The main assembly does not contain the resources for the neutral culture, and these resources are required because the appropriate satellite assembly is missing.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="classKey">A string that represents the <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> property of the requested resource object.</param>
        <param name="resourceKey">A string that represents a <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> property of the requested resource object.</param>
        <param name="culture">A string that represents the <see cref="T:System.Globalization.CultureInfo" /> object of the requested resource.</param>
        <summary>Gets an application-level resource object based on the specified <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> and <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> properties, and on the <see cref="T:System.Globalization.CultureInfo" /> object.</summary>
        <returns>An <see cref="T:System.Object" /> that represents the requested application-level resource object, which is localized for the specified culture; otherwise, <see langword="null" /> if a resource object is not found or if a resource object is found but it does not have the requested property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Globalization.CultureInfo> Objekt darstellt, das die Kultur für die die Ressource lokalisiert wurde. Wenn die Ressource nicht für diese Kultur lokalisiert ist, wird die Suche nach einem Fallbackprozess einer geeigneten Ressource folgen. Weitere Informationen finden Sie unter [Verpacken und Bereitstellen von Ressourcen](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
> [!NOTE]
>  Der Editor kann in einigen Umgebungen bearbeiten wie z. B. Visual Web Developer eine Entwurfszeit-auslösen <xref:System.Resources.MissingManifestResourceException> -Ausnahme aus, wenn Sie in der globalen Ressource-Key-Name einen Punkt (.) verwenden. Allerdings Dies hat keine Auswirkungen auf Ihre Fähigkeit, bearbeiten oder speichern Sie die Datei, und Sie können den Fehler ignorieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">A resource object for which the specified <paramref name="classKey" /> parameter was not found.  \- or -  The main assembly does not contain the resources for the neutral culture, and these resources are required because the appropriate satellite assembly is missing.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a page-level resource.</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">The <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> property for the local resource object.</param>
        <param name="resourceKey">A string that represents a <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> property of the requested resource object</param>
        <summary>Gets a page-level resource object based on the specified <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> and <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> properties.</summary>
        <returns>An <see cref="T:System.Object" /> that represents the requested page-level resource object; otherwise, <see langword="null" /> if a matching resource object is found but not a <paramref name="resourceKey" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.GetLocalResourceObject%2A> Methode gibt eine lokale Ressource mit der Kultur, die im angegebenen die <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">A resource object was not found for the specified <paramref name="virtualPath" /> parameter.</exception>
        <exception cref="T:System.ArgumentException">The specified <paramref name="virtualPath" /> parameter is not in the current application's root directory.</exception>
        <exception cref="T:System.InvalidOperationException">The resource class for the page was not found.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="virtualPath">The <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> property for the local resource object.</param>
        <param name="resourceKey">A string that represents a <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> property of the requested resource object.</param>
        <param name="culture">A string that represents the <see cref="T:System.Globalization.CultureInfo" /> object of the requested resource object.</param>
        <summary>Gets a page-level resource object based on the specified <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> and <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> properties, and on the <see cref="T:System.Globalization.CultureInfo" /> object.</summary>
        <returns>An <see cref="T:System.Object" /> that represents the requested local resource object, which is localized for the specified culture; otherwise <see langword="null" /> if a matching resource object is found but not a <paramref name="resourceKey" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Ressource nicht für diese Kultur lokalisiert ist, wird die Suche nach einem Fallbackprozess einer geeigneten Ressource folgen. Weitere Informationen finden Sie unter [Verpacken und Bereitstellen von Ressourcen](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">A resource object was not found for the specified <paramref name="virtualPath" /> Parameter.</exception>
        <exception cref="T:System.ArgumentException">The specified <paramref name="virtualPath" /> parameter is not in the current application's root directory.</exception>
        <exception cref="T:System.InvalidOperationException">The resource class for the page was not found.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="member this.GetSection : string -&gt; obj" Usage="httpContext.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">The configuration section path (in XPath format) and the configuration element name.</param>
        <summary>Gets a specified configuration section for the current application's default configuration.</summary>
        <returns>The specified <see cref="T:System.Configuration.ConfigurationSection" />, <see langword="null" /> if the section does not exist, or an internal object if the section is not accessible at run time.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Web.IHttpHandler" /> object responsible for processing the HTTP request.</summary>
        <value>Ein für die Verarbeitung der HTTP-Anforderung verantwortliches <see cref="T:System.Web.IHttpHandler" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.Handler%2A> Eigenschaft enthält einen Verweis auf den Handler, die HTTP-Anforderung verarbeitet. Der Handler kann angegeben werden, mithilfe des Elements, oder einen benutzerdefinierten Handler im Benutzercode definiert. Weitere Informationen zu Ereignishandlern finden Sie unter [HTTP-Handler und Überblick über die HTTP-Module](http://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b).  
  
 Der Verweis auf die <xref:System.Web.HttpContext.Handler%2A> Eigenschaft bleibt gleich auch nach die aktuelle Seite von einer serverseitigen Methode, wie z. B. geändert wurde der <xref:System.Web.HttpServerUtility.Execute%2A> Methode oder der <xref:System.Web.HttpServerUtility.Transfer%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether custom errors are enabled for the current HTTP request.</summary>
        <value>
          <see langword="true" />, wenn benutzerdefinierte Fehler aktiviert sind, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current HTTP request is in debug mode.</summary>
        <value>
          <see langword="true" />, wenn sich die Anforderung im Debugmodus befindet, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that is the current processing point in the ASP.NET pipeline just after an <see cref="T:System.Web.HttpApplication" /> event has finished processing.</summary>
        <value>
          <see langword="true" />, wenn benutzerdefinierte Fehler aktiviert sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.IsPostNotification%2A> Eigenschaft wird nur unterstützt, mit dem integrierten Modus in [!INCLUDE[iisver](~/includes/iisver-md.md)] und mindestens .NET Framework 3.0. Sofern dieses verfügbar ist, gibt die Eigenschaft einen booleschen Wert, der angibt, ob ein Ereignis in der <xref:System.Web.HttpApplication> Objekt wurde beendet.  
  
 Die <xref:System.Web.HttpContext.IsPostNotification%2A> Eigenschaft sollte nicht festgelegt werden. Stattdessen wird es von bereitgestellt [!INCLUDE[iisver](~/includes/iisver-md.md)] an die ASP.NET-Laufzeitumgebung für jede Benachrichtigung. Festlegen der <xref:System.Web.HttpContext.IsPostNotification%2A> Eigenschaft führt zu einem Kompilierungsfehler.  
  
 In Szenarien, in denen mehrere Ereignisse des der <xref:System.Web.HttpApplication> Objekt von einem Ereignishandler behandelt werden, können Sie mit der <xref:System.Web.HttpContext.IsPostNotification%2A> Eigenschaft in Kombination mit der <xref:System.Web.RequestNotification> Enumeration um genau zu bestimmen, an welcher Stelle in den Lebenszyklus der Anwendung die aktuelle die Anforderung ist.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> wird in .NET Framework, Version 3.5 eingeführt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Web.HttpContext.IsPostNotification%2A> Eigenschaft, um zu bestimmen, wenn ein Ereignis von der <xref:System.Web.HttpApplication> Objekt hat die Verarbeitung aller zugehörigen Ereignishandler abgeschlossen. In diesem Beispiel wird der benutzerdefinierte Ereignishandler verarbeitet mehrere Ereignisse des der <xref:System.Web.HttpApplication> -Objekt, und die <xref:System.Web.HttpContext.IsPostNotification%2A> Eigenschaft wird verwendet, um zu bestimmen, welcher Code aufgerufen wird, nachdem ein bestimmtes Ereignis behandelt wird.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The operation requires the integrated pipeline mode in [!INCLUDE[iisver](~/includes/iisver-md.md)] and at least the .NET Framework 3.0.</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the request is an <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> request.</summary>
        <value>
          <see langword="true" />, wenn es sich bei der Anforderung um eine <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Anforderung handelt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `true` , wenn die Anforderung mit den ersten enthält <xref:System.Web.WebSockets.AspNetWebSocket> Handshake und die `WebSocket` -Modul von IIS ist aktiv.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the connection is upgrading from an HTTP connection to an <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> connection.</summary>
        <value>
          <see langword="true" />, wenn die Verbindung aktualisiert wird, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a key/value collection that can be used to organize and share data between an <see cref="T:System.Web.IHttpModule" /> interface and an <see cref="T:System.Web.IHttpHandler" /> interface during an HTTP request.</summary>
        <value>Eine <see cref="T:System.Collections.IDictionary" />-Schlüssel-/Wert-Auflistung, über die mithilfe eines angegebenen Schlüssels auf einen einzelnen Wert in der Auflistung zugegriffen werden kann.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a reference to the page-instrumentation service instance for this request.</summary>
        <value>Die Seiteninstrumentierungs-Dienstinstanz für diese Anforderung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Web.IHttpHandler" /> object for the parent handler.</summary>
        <value>Eine <see cref="T:System.Web.IHttpHandler" />-Instanz oder <see langword="null" />, wenn kein vorheriger Handler gefunden wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.PreviousHandler%2A> Eigenschaft entspricht dem letzten Ereignishandler, bevor die aktuelle Anforderung ausgeführt wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Web.Profile.ProfileBase" /> object for the current user profile.</summary>
        <value>Ein <see cref="T:System.Web.Profile.ProfileBase" />-Objekt, wenn die Konfigurationsdatei der Anwendung eine Definition der Eigenschaften des Profils enthält, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Web.HttpContext.Profile%2A> Eigenschaft wird für die dauerhafte Speicherung von strukturierten Daten mit einer typsicheren API verwendet. Wenn eine <xref:System.Web.HttpContext.Profile%2A> -Eigenschaft zugegriffen wird, aber kein Wert vorhanden ist, wird eine leere Instanz zurückgegeben. `null` wird nicht zurückgegeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContext.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
      </Parameters>
      <Docs>
        <param name="handler">The object that should process the request.</param>
        <summary>Enables you to specify a handler for the request.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Setzen Sie `handler` zu `null`, der Standard-Handler wird verwendet, um die Anforderung zu verarbeiten. Sie können festlegen, `handler` entweder ein asynchroner Handler oder ein synchroner Handler. Der Handler muss implementieren die <xref:System.Web.IHttpHandler> Schnittstelle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> method was called after the <see cref="E:System.Web.HttpApplication.MapRequestHandler" /> event occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Web.HttpRequest" /> object for the current HTTP request.</summary>
        <value>Das <see cref="T:System.Web.HttpRequest" />-Objekt für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.Request%2A> Eigenschaft ermöglicht den programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Web.HttpRequest> Klasse. Da ASP.NET-Seiten ein standardverweises auf enthalten die <xref:System.Web> Namespace (enthält die <xref:System.Web.HttpContext> Klasse), können Sie auf die Member verweisen <xref:System.Web.HttpRequest> auf eine ASPX-Seite ohne Verwendung des vollqualifizierten Verweises auf <xref:System.Web.HttpContext>. Beispielsweise können Sie `Request.Browser` um die Funktionen des Clientbrowsers abzurufen. Allerdings sollten Sie die Elemente der <xref:System.Web.HttpRequest> aus einem ASP.NET Code-Behind-Modul, müssen Sie enthalten einen Verweis auf die <xref:System.Web> -Namespace in das Modul und einen vollqualifizierten Verweis auf beide den derzeit aktiven Anforderung/Antwort-Kontext und die -Klasse im <xref:System.Web> , die Sie verwenden möchten. Z. B. in einer CodeBehind-Seite Geben Sie den voll gekennzeichneten Namen `HttpContext.Current.Request.Browser`.  
  
> [!NOTE]
>  ASP.NET wird eine Ausnahme ausgelöst, wenn Sie versuchen, diese Eigenschaft verwenden, wenn die <xref:System.Web.HttpRequest> Objekt ist nicht verfügbar. Beispielsweise ist dies wäre "true" in der Application_Start-Methode der Datei Global.asax oder in einer Methode, die von der Methode "Application_Start" aufgerufen wird. Zu diesem Zeitpunkt wurde noch keine HTTP-Anforderung erstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The Web application is running under IIS 7 in Integrated mode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Web.HttpResponse" /> object for the current HTTP response.</summary>
        <value>Das <see cref="T:System.Web.HttpResponse" />-Objekt für die aktuelle HTTP-Antwort.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.Response%2A> Eigenschaft ermöglicht den programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Web.HttpResponse> Klasse. Da ASP.NET-Seiten ein standardverweises auf enthalten die <xref:System.Web> Namespace (enthält die <xref:System.Web.HttpContext> Klasse), können Sie auf die Member verweisen <xref:System.Web.HttpContext> auf eine ASPX-Seite ohne Verwendung des vollqualifizierten Verweises auf <xref:System.Web.HttpContext>. Beispielsweise können Sie `Response.Write("some output")` Ausgabe in einen HTTP-Ausgabestream zu schreiben. Allerdings sollten Sie die Elemente der <xref:System.Web.HttpResponse> aus einem ASP.NET Code-Behind-Modul, müssen Sie enthalten einen Verweis auf die <xref:System.Web> -Namespace in das Modul und ein vollqualifizierter Verweis auf den derzeit aktiven Anforderung/Antwort-Kontext und die Klasse in <xref:System.Web> , die Sie verwenden möchten. Z. B. in einer CodeBehind-Seite Geben Sie den voll gekennzeichneten Namen `HttpContext.Current.Response.Write("some output")`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The Web application is running under IIS 7 in Integrated mode.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redirects a request for a resource to a different path than the one that is indicated by the requested URL. <see cref="Overload:System.Web.HttpContext.RewritePath" /> is used in cookieless session state to strip session IDs from URLs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string -&gt; unit" Usage="httpContext.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The internal rewrite path.</param>
        <summary>Rewrites the URL using the given path.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.RewritePath%28System.String%29> Methode leitet eine Anforderung für eine Ressource auf einen anderen Pfad als die, die von der angeforderten URL angegeben ist. Wenn Sie den virtuellen Pfad zurück, sodass Anforderungen vom Client für Serverressourcen ordnungsgemäß aufgelöst werden müssen, verwenden Sie die Überladung dieser Methode, die akzeptiert die `rebaseClientPath` Parameter und Festlegen des Parameters auf `false`.  
  
 URL-Umschreibung ist nützlich, wenn die Seiten in Ihrer Webanwendung umstrukturieren möchten, und Sie möchten, um sicherzustellen, dass Personen, die alten URLs, ein Lesezeichen erstellt haben diese aber weiterhin verwenden können, nachdem Sie die Seiten verschoben haben. URL-Umschreibung, können Sie transparent Weiterleiten von Anforderungen an den neuen Speicherort für die Seite.  
  
 Wenn Sie eine Site mit URLs, die Benutzerfreundlicher sind, und sind optimiert für Suchmaschinen aktivieren möchten, ist eine robustere Alternative ASP.NET-Routing verwenden. Weitere Informationen finden Sie unter [ASP.NET-Routing](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Web.HttpContext.RewritePath%2A> Methode zum Aktivieren einer Website auf URLs reagieren, die nicht die Dateistruktur in der Website widerspiegeln. Der erste Codeblock wird eine ASP.NET-Webseite mit dem Namen RewritePath.aspx. Es ist eine Abfragezeichenfolge erforderlich. Wenn der Name Ihrer Website WebSite1, die URL ist `http://localhost/WebSite1/RewritePath.aspx?page=1` "Seite 1" im Browser angezeigt. Der Codeblock, der auf der Webseite folgt wird den `Application_BeginRequest` -Ereignishandler in der Datei "Global.asax". Dieser Code fängt Anforderungen für URLs wie z. B. `http://localhost/WebSite1/page1` und konvertiert diese in das Formular, das für die RewritePath.aspx erforderlich ist, bevor sie verarbeitet werden. Aus diesem Grund die URL `http://localhost/WebSite1/page1` RewritePath.aspx aufruft, mit dem Abfragezeichenfolgen-Parameter, der "Seite 1" im Browser angezeigt wird. Wenn eine URL wie z. B. `http://localhost/WebSite1/page1` empfangen wird, eine Überladung der <xref:System.Web.HttpContext.RewritePath%2A> wird aufgerufen, mit der Sie einen Wert für die <xref:System.Web.HttpRequest.PathInfo%2A> Eigenschaft als auch eine Abfrage ein Zeichenfolgenparameter.  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="path" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">The <paramref name="path" /> parameter is not in the current application's root directory.</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * bool -&gt; unit" Usage="httpContext.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">The internal rewrite path.</param>
        <param name="rebaseClientPath">
          <see langword="true" /> to reset the virtual path; <see langword="false" /> to keep the virtual path unchanged.</param>
        <summary>Rewrites the URL using the given path and a Boolean value that specifies whether the virtual path for server resources is modified.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> Methode wird aufgerufen, indem die <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType> -Methode mit dem `rebaseClientPath` Parametersatz zu `true`. Um sicherzustellen, dass der virtuelle Pfad, der zum Erstellen von Pfaden zu Ressourcen verwendet wird, nicht geändert wird, legen die `rebaseClientPath` Parameter `false`. Ein häufiges Szenario, in denen Sie festlegen möchten `rebaseClientPath` zu `false` müssen Sie das Umschreiben der URL, und Sie werden unter Verwendung von Designs und Umleitung der URL an eine Ressource in einem anderen Ordner als die angeforderte Ressource ist.  
  
 URL-Umschreibung ist nützlich, wenn die Seiten in Ihrer Webanwendung umstrukturieren möchten, und Sie möchten, um sicherzustellen, dass Personen, die alten URLs, ein Lesezeichen erstellt haben diese aber weiterhin verwenden können, nachdem Sie die Seiten verschoben haben. URL-Umschreibung, können Sie transparent Weiterleiten von Anforderungen an den neuen Speicherort für die Seite.  
  
 Wenn Sie eine Site mit URLs, die Benutzerfreundlicher sind, und sind optimiert für Suchmaschinen aktivieren möchten, ist eine robustere Alternative ASP.NET-Routing verwenden. Weitere Informationen finden Sie unter [ASP.NET-Routing](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter den <xref:System.Web.HttpContext.RewritePath%28System.String%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="path" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">The <paramref name="path" /> parameter is not in the current application's root directory.</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">The internal rewrite path.</param>
        <param name="pathInfo">Additional path information for a resource. For more information, see <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">The request query string.</param>
        <summary>Rewrites the URL by using the given path, path information, and query string information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.RewritePath%2A> Methode leitet eine Anforderung für eine Ressource auf eine andere Ressource, ohne die URL zu ändern.  
  
 Die `filePath` Parameter enthält keinen der `pathInfo` Parameter-Inhalt. Für die URL http://www.microsoft.com/virdir/page.html/tail, `filePath` Parameter http://www.microsoft.com/virdir/page.html, und die `pathInfo` -Parameter ist Ende.  
  
 URL-Umschreibung ist nützlich, wenn die Seiten in Ihrer Webanwendung umstrukturieren möchten, und Sie möchten, um sicherzustellen, dass Personen, die alten URLs, ein Lesezeichen erstellt haben diese aber weiterhin verwenden können, nachdem Sie die Seiten verschoben haben. URL-Umschreibung, können Sie transparent Weiterleiten von Anforderungen an den neuen Speicherort für die Seite.  
  
 Wenn Sie eine Site mit URLs, die Benutzerfreundlicher sind, und sind optimiert für Suchmaschinen aktivieren möchten, ist eine robustere Alternative ASP.NET-Routing verwenden. Weitere Informationen finden Sie unter [ASP.NET-Routing](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Ein Codebeispiel, einschließlich eines Beispiels für die Überladung dieser Methode finden Sie unter den <xref:System.Web.HttpContext.RewritePath%28System.String%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="path" /> parameter is not in the current application's root directory.</exception>
        <exception cref="T:System.Web.HttpException">The <paramref name="filePath" /> parameter is not in the current application's root directory.</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filePath">The virtual path to the resource that services the request.</param>
        <param name="pathInfo">Additional path information to use for the URL redirect. For more information, see <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">The request query string to use for the URL redirect.</param>
        <param name="setClientFilePath">
          <see langword="true" /> to set the file path used for client resources to the value of the <c>filePath</c> parameter; otherwise <see langword="false" />.</param>
        <summary>Rewrites the URL using the given virtual path, path information, query string information, and a Boolean value that specifies whether the client file path is set to the rewrite path.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `filePath` Parameter umfasst nicht den Inhalt der `pathInfo` Parameter. Für die URL http://www.microsoft.com/virdir/page.html/tail, `filePath` Parameter http://www.microsoft.com/virdir/page.html, und die `pathInfo` -Parameter ist Ende.  
  
 Um sicherzustellen, dass der virtuelle Pfad, der zum Erstellen von Pfaden zu Ressourcen verwendet wird, nicht geändert wird, legen die `setClientFilePath` Parameter `false`. Ein häufiges Szenario, in denen Sie festlegen möchten `setClientFilePath` zu `false` müssen Sie das Umschreiben der URL, und Sie werden unter Verwendung von Designs und Umleitung der URL an eine Ressource in einem anderen Ordner als die angeforderte Ressource ist.  
  
 URL-Umschreibung ist nützlich, wenn die Seiten in Ihrer Webanwendung umstrukturieren möchten, und Sie möchten, um sicherzustellen, dass Personen, die alten URLs, ein Lesezeichen erstellt haben diese aber weiterhin verwenden können, nachdem Sie die Seiten verschoben haben. URL-Umschreibung, können Sie transparent Weiterleiten von Anforderungen an den neuen Speicherort für die Seite.  
  
 Wenn Sie eine Site mit URLs, die Benutzerfreundlicher sind, und sind optimiert für Suchmaschinen aktivieren möchten, ist eine robustere Alternative ASP.NET-Routing verwenden. Weitere Informationen finden Sie unter [ASP.NET-Routing](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter den <xref:System.Web.HttpContext.RewritePath%28System.String%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="path" /> parameter is not in the current application's root directory.</exception>
        <exception cref="T:System.Web.HttpException">The <paramref name="filePath" /> parameter is not in the current application's root directory.</exception>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Web.HttpServerUtility" /> object that provides methods used in processing Web requests.</summary>
        <value>Das <see cref="T:System.Web.HttpServerUtility" />-Objekt für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.Server%2A> Eigenschaft ermöglicht den programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Web.HttpServerUtility> Klasse. Da ASP.NET-Seiten ein standardverweises auf enthalten die <xref:System.Web> Namespace (enthält die <xref:System.Web.HttpContext> Klasse), können Sie auf die Member verweisen <xref:System.Web.HttpContext> auf eine ASPX-Seite ohne Verwendung des vollqualifizierten Verweises auf <xref:System.Web.HttpContext>. Beispielsweise können Sie `Server.CreateObject("MyCOMComponent")` eine Instanz eines COM-Objekts auf dem Server zu erstellen. Allerdings sollten Sie die Elemente der <xref:System.Web.HttpServerUtility> aus einem ASP.NET Code-Behind-Modul, müssen Sie enthalten einen Verweis auf die <xref:System.Web> -Namespace in das Modul und einen vollqualifizierten Verweis auf beide den derzeit aktiven Anforderung/Antwort-Kontext und die -Klasse im <xref:System.Web> , die Sie verwenden möchten. Z. B. in einer CodeBehind-Seite Geben Sie den voll gekennzeichneten Namen `HttpContext.Current.Server.CreateObject("MyCOMComponent")`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Web.SessionState.HttpSessionState" /> object for the current HTTP request.</summary>
        <value>Das <see cref="T:System.Web.SessionState.HttpSessionState" />-Objekt für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.Session%2A> Eigenschaft ermöglicht den programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Web.SessionState.HttpSessionState> Klasse.  
  
 Um den Sitzungszustand zu verwenden, um ihn zu aktivieren. Informationen dazu, wie Sie den Sitzungszustand aktivieren, finden Sie unter **Sitzungszustand konfigurieren** in [ASP.NET Session State Overview](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
 Informationen dazu, wie Sie die Werte im Sitzungsstatus zu speichern, finden Sie unter [Vorgehensweise: Speichern von Werten im Sitzungsstatus](http://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165). Weitere Informationen zum Lesen von Werten aus dem Sitzungszustand, finden Sie unter [wie: Lesen von Werten aus dem Sitzungszustand](http://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5).  
  
   
  
## Examples  
 Die folgenden Beispiele zeigen, wie Werte im Sitzungszustand gespeichert und zum Lesen von Werten aus dem Sitzungszustand.  
  
 Diese Beispiele erfordern Folgendes:  
  
-   Eine ASP.NET-Anwendung, die Sitzungsstatus aktiviert wurde.  
  
-   Eine Web Forms-Seite-Klasse, die Zugriff auf die <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType> Eigenschaft oder in einer Klasse, die Zugriff auf die <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> Eigenschaft.  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="member this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContext.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">One of the enumeration values that specifies what type of session state behavior is required.</param>
        <summary>Sets the type of session state behavior that is required in order to support an HTTP request.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Standardimplementierung von ASP.NET ein HTTP-Anforderungshandler gibt an, ob der Sitzungszustand durch die Implementierung benötigt der <xref:System.Web.SessionState.IRequiresSessionState> Schnittstelle oder die <xref:System.Web.SessionState.IReadOnlySessionState> Schnittstelle. Die <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> Methode und die <xref:System.Web.SessionState.SessionStateBehavior> Enumeration können Sie weitere Details zu welcher Typ podpory stavu zur Bearbeitung einer Anforderung benötigt wird. Weitere Informationen finden Sie unter der <xref:System.Web.SessionState.SessionStateBehavior>-Enumeration.  
  
 Die <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> Methode muss aufgerufen werden, bevor die <xref:System.Web.HttpApplication.AcquireRequestState> Pipelineereignis. Bewirkt, dass Aufrufe, die auftreten, während oder nach diesem Ereignis eine <xref:System.InvalidOperationException> Ausnahme.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The method was called after the <see cref="E:System.Web.HttpApplication.AcquireRequestState" /> event was raised.</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies whether the <see cref="T:System.Web.Security.UrlAuthorizationModule" /> object should skip the authorization check for the current request.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="T:System.Web.Security.UrlAuthorizationModule" />-Objekt die Autorisierungsprüfung überspringen soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.SkipAuthorization%2A> Eigenschaft sollte für die erweiterte Verwendung von Authentifizierungsmodule, die auf einer Seite umleiten, die anonyme Verbindungen zulässt. Das Modul zur Formularauthentifizierung und Modul für die Passport-Authentifizierung, beide festgelegt <xref:System.Web.HttpContext.SkipAuthorization%2A> beim Umleiten zu einer konfigurierten Anmeldeseite. Festlegen von <xref:System.Web.HttpContext.SkipAuthorization%2A> erfordert die `ControlPrincipal` Flag festgelegt sein. Informationen zu den `ControlPrincipal` kennzeichnen, finden Sie unter <xref:System.Security.Permissions.SecurityPermissionFlag>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">A type of <see cref="T:System.Web.HttpContext" /> service to set the service provider to.</param>
        <summary>Returns an object for the current service type.</summary>
        <returns>A <see cref="T:System.Web.HttpContext" />; otherwise, <see langword="null" /> if no service is found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode eignet sich für den Zugriff auf die zugrunde liegende <xref:System.Web.HttpWorkerRequest> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies whether the ASP.NET runtime should call <see cref="M:System.Threading.Thread.Abort" /> on the thread that is servicing this request when the request times out.</summary>
        <value>
          <see langword="true" />, wenn <see cref="M:System.Threading.Thread.Abort" /> aufgerufen wird, wenn das Timeout des Thread erreicht wird; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Handler und Module, die verwendet werden die <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> Eigenschaft, um einen kooperativen Abbruch, implementieren Sie deaktivieren möchten die <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> Verhalten, das standardmäßig ASP.NET ausgeführt werden soll, wenn eine Anforderung ein auftritt Timeout. Wenn diese Eigenschaft auf `false` können Sie sicherstellen, dass die Routinen für Abbruch und Bereinigung ausgeführt werden, ohne die von ASP.NET unterbrochen wird.  
  
 Wenn Sie diese Eigenschaft auf `false`, ASP.NET nicht zeigt automatisch eine Fehlerseite "Timeout für Anforderung" ein Timeout auftritt. Die Anwendung ist zuständig für das den Inhalt der Antwort entsprechend festlegen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the initial timestamp of the current HTTP request.</summary>
        <value>Der Timestamp der aktuellen HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von zurückgegebene Zeitstempel der <xref:System.Web.HttpContext.Timestamp%2A> Eigenschaft ist die lokale Zeit des Servers und wird festgelegt, während der Instanziierung des der <xref:System.Web.HttpContext> Objekt. Die lokale Zeit entspricht der UTC-Zeit plus der UTC-Offset.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Web.TraceContext" /> object for the current HTTP response.</summary>
        <value>Das <see cref="T:System.Web.TraceContext" />-Objekt für die aktuelle HTTP-Antwort.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets security information for the current HTTP request.</summary>
        <value>Sicherheitsinformationen für die aktuelle HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpContext.User%2A> Eigenschaft ermöglicht den programmgesteuerten Zugriff auf die Eigenschaften und Methoden der <xref:System.Security.Principal.IPrincipal> Schnittstelle.  
  
 Da ASP.NET-Seiten ein standardverweises auf enthalten die <xref:System.Web> Namespace (enthält die <xref:System.Web.HttpContext> Klasse), können Sie auf die Member verweisen <xref:System.Web.HttpContext> auf eine ASPX-Seite ohne Verwendung des vollqualifizierten Verweises auf <xref:System.Web.HttpContext>. Beispielsweise können Sie `User.Identity.Name` um dem Namen des Benutzers abzurufen, in dessen Namen des aktuellen Prozesses ausgeführt werden. Allerdings sollten Sie die Elemente der <xref:System.Security.Principal.IPrincipal> aus einem ASP.NET Code-Behind-Modul, müssen Sie enthalten einen Verweis auf die <xref:System.Web> -Namespace in das Modul und einen vollqualifizierten Verweis auf beide den derzeit aktiven Anforderung/Antwort-Kontext und die -Klasse im <xref:System.Web> , die Sie verwenden möchten. Z. B. in einer CodeBehind-Seite Geben Sie den voll gekennzeichneten Namen `HttpContext.Current.User.Identity.Name`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie den Zugriff auf Eigenschaften des aktuellen Benutzers über die <xref:System.Web.HttpContext.User%2A> Eigenschaft. Diese Eigenschaften werden verwendet, um den Titel der Webseite festzulegen.  
  
 Wenn die Anwendung Windows-Authentifizierung verwendet wird, enthält der Benutzername die Domäne an. Beispielsweise wäre die Titel der Seite "Für" Domäne\Benutzername "Startseite".  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the negotiated protocol that was sent from the server to the client for an <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> connection.</summary>
        <value>Das ausgehandelte Protokoll.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the ordered list of protocols requested by the client.</summary>
        <value>Die angeforderten Protokolle oder <see langword="null" />, wenn dies keine <see cref="T:System.Web.WebSockets.AspNetWebSocket" />-Anforderung ist oder wenn keine Liste vorhanden ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>