<Type Name="HttpRequest" FullName="System.Web.HttpRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a0eb37d6ae2f638490e9eacbee37ac609774ad2e" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70452206" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpRequest sealed" />
  <TypeSignature Language="F#" Value="type HttpRequest = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Ermöglicht es ASP.NET, die von einem Client bei einer Webanforderung gesendeten HTTP-Werte zu lesen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpRequest> Methoden und Eigenschaften der-Klasse werden durch die `Request` Eigenschaften der <xref:System.Web.HttpApplication>Klassen, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>und <xref:System.Web.UI.UserControl> verfügbar gemacht.  
  
 Für den Zugriff auf Daten <xref:System.Web.HttpRequest.QueryString%2A>aus <xref:System.Web.HttpRequest.Form%2A>den <xref:System.Web.HttpRequest.Cookies%2A>-, <xref:System.Web.HttpRequest.ServerVariables%2A> -,-oder- `Request["key"]`Auflistungen können Sie schreiben, wie <xref:System.Web.HttpRequest.QueryString%2A> im Beispiel für die-Eigenschaft gezeigt.  
  
> [!NOTE]
>  Die Unicode- <xref:System.Web.HttpRequest> Unterstützung für Klassenmember erfordert die IIS-Version 6,0 oder höher.  
  
   
  
## Examples  
 In den folgenden Beispielen wird <xref:System.Web.HttpRequest> auf die-Instanz für die aktuelle Anforderung <xref:System.Web.UI.Page.Request%2A> mithilfe der- <xref:System.Web.UI.Page> Eigenschaft der-Klasse zugegriffen.  
  
 Sie können eine vereinfachte Syntax für den Zugriff auf Daten <xref:System.Web.HttpRequest.QueryString%2A>aus <xref:System.Web.HttpRequest.Form%2A>den <xref:System.Web.HttpRequest.Cookies%2A>Auflistungen,, oder <xref:System.Web.HttpRequest.ServerVariables%2A> verwenden. Sie können schreiben `Request["key"]`.  
  
 Im ersten Beispiel wird gezeigt, wie ein Abfrage Zeichen folgen Wert beim Laden einer Seite abgerufen wird.  
  
```csharp  
public partial class AddToCart : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        string rawId = Request["ProductID"];  
        int productId;  
        if (!String.IsNullOrEmpty(rawId) && int.TryParse(rawId, out productId))  
        {  
            using (ShoppingCartActions usersShoppingCart = new ShoppingCartActions())  
            {  
                usersShoppingCart.AddToCart(productId);  
            }  
        }  
        else  
        {  
            throw new Exception("Tried to call AddToCart.aspx without setting a ProductId.");  
        }  
        Response.Redirect("ShoppingCart.aspx");  
    }  
}  
```  
  
```vb  
Public Class AddToCart  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        Dim rawId = Request("ProductID")  
        Dim productId As Integer  
        If Not String.IsNullOrEmpty(rawId) And Integer.TryParse(rawId, productId) Then  
            Using usersShoppingCart As New ShoppingCartActions()  
                usersShoppingCart.AddToCart(productId)  
            End Using  
  
        Else  
            Throw New Exception("Tried to call AddToCart.aspx without setting a ProductId.")  
        End If  
        Response.Redirect("ShoppingCart.aspx")  
    End Sub  
End Class  
```  
  
 Im nächsten Beispiel wird gezeigt, wie Sie überprüfen, ob die Anforderung authentifiziert ist, und die unformatierte URL abrufen.  
  
```csharp  
public partial class RestrictedPage : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        if (!Request.IsAuthenticated)  
        {  
            var rawUrl = Request.RawUrl;  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl));  
        }  
    }  
}  
```  
  
```vb  
Public Class RestrictedPage  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        If Not Request.IsAuthenticated Then  
            Dim rawUrl = Request.RawUrl  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl))  
        End If  
    End Sub  
End Class  
```  
  
 Für dieses Thema steht ein Visual Studio-Website Projekt mit Quellcode zur Verfügung: [herunterladen](https://go.microsoft.com/fwlink/?LinkID=191455).  
  
 In diesem Beispiel wird <xref:System.IO.StreamWriter> die-Klasse verwendet, um die <xref:System.Web.HttpRequest> Werte mehrerer Klasseneigenschaften in eine Datei zu schreiben. Bei Eigenschaften vom Typ "String" sind die Werte HTML-codiert, wenn Sie in die Datei geschrieben werden. Eigenschaften, die eine Auflistung darstellen, werden durchlaufen, und jedes in ihr enthaltenen Schlüssel-Wert-Paar wird in die Datei geschrieben.  
  
> [!IMPORTANT]
>  Dieses Beispiel umfasst ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles Sicherheitsrisiko darstellen. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Übersicht über Skriptangriffe](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpRequest (string filename, string url, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filename, string url, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filename As String, url As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpRequest(System::String ^ filename, System::String ^ url, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpRequest : string * string * string -&gt; System.Web.HttpRequest" Usage="new System.Web.HttpRequest (filename, url, queryString)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Der Name der Datei, die der Anforderung zugeordnet ist.</param>
        <param name="url">Informationen über die URL der aktuellen Anforderung.</param>
        <param name="queryString">Die gesamte mit der Anforderung gesendete Abfragezeichenfolge (alles nach dem <c>„?“</c>).</param>
        <summary>Initialisiert ein <see cref="T:System.Web.HttpRequest" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen keine eigene Instanz der <xref:System.Web.HttpRequest> -Klasse erstellen. Die <xref:System.Web.HttpRequest> Methoden und Eigenschaften der-Klasse werden über die `Request` -Eigenschaft der <xref:System.Web.HttpApplication>Klassen, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>und <xref:System.Web.UI.UserControl> verfügbar gemacht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt das Beenden der zugrunde liegenden TCP-Verbindung, woraufhin alle ausstehenden E/A-Vorgänge fehlschlagen. Sie können diese Methode als Reaktion auf einen Angriff von einem böswilligen HTTP-Client verwenden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist Thread sicher. Jeder Thread kann ihn jederzeit aufruft.  
  
 Diese Methode kann nur im integrierten Modus verwendet werden. Wenn Sie Sie im klassischen Modus aufrufen, wird eine Ausnahme ausgelöst. Verwenden <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>Sie, um den Pipeline Modus zu bestimmen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AcceptTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptTypes As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AcceptTypes { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AcceptTypes : string[]" Usage="System.Web.HttpRequest.AcceptTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Zeichenfolgenarray der vom Client unterstützten MIME-Accept-Typen ab.</summary>
        <value>Ein Zeichenfolgenarray der vom Client unterstützten MIME-Accept-Typen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel werden die von der <xref:System.Web.HttpRequest.AcceptTypes%2A> -Eigenschaft zurückgegebenen verschiedenen Werte in eine Objekt Variable erfasst und die Anzahl und der Name jedes Werts in eine separate Zeile der HTTP-Ausgabe geschrieben.  
  
 [!code-csharp[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnonymousID">
      <MemberSignature Language="C#" Value="public string AnonymousID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AnonymousID" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AnonymousID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AnonymousID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AnonymousID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AnonymousID : string" Usage="System.Web.HttpRequest.AnonymousID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den anonymen Bezeichner für den Benutzer ab, sofern vorhanden.</summary>
        <value>Eine Zeichenfolge, die den Bezeichner für den aktuellen anonymen Benutzer darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpRequest.AnonymousID%2A> -Eigenschaft weist einem nicht authentifizierten Benutzer einen langfristigen eindeutigen Bezeichner zu, der zum Nachverfolgen des Benutzers oder Zuweisen von Profil Eigenschaften zu diesem Benutzer verwendet werden kann, ohne Daten in `Session` einem-Objekt zu speichern. Standardmäßig wird die <xref:System.Web.HttpRequest.AnonymousID%2A> -Eigenschaft mithilfe eines Cookies nachverfolgt. Sie kann jedoch so festgelegt werden, dass Sie <xref:System.Web.Configuration.SessionStateSection.Cookieless%2A> den URI verwendet, wenn das-Attribut im Konfigurations Abschnitt für <xref:System.Web.HttpCookieMode.UseUri>die anonyme Identifizierung <xref:System.Web.HttpCookieMode.AutoDetect> entweder auf, <xref:System.Web.HttpCookieMode.UseDeviceProfile>oder festgelegt ist. Wert. Sie müssen das Cookie explizit löschen, wenn Sie es nicht mehr zur Verfügung stellen möchten, z. b. Wenn ein anonymer Benutzer authentifiziert wird.  
  
 Die anonyme Identifizierung wird verwendet, wenn es erforderlich ist, Entitäten zu identifizieren, die nicht authentifiziert sind, und wenn eine Autorisierung erforderlich ist. Weitere Informationen finden Sie unter [anonymousidentifi-Element (ASP.NET Settings Schema)](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100))  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Web.HttpRequest.AnonymousID%2A> -Eigenschaft verwendet wird <xref:System.Web.Security.AnonymousIdentificationModule.Creating> , indem das-Ereignis in der Datei "Global. asax" behandelt wird. Dieses Beispiel besteht aus zwei Teilen:  
  
-   Eine Methode in der Datei "Global. asax", <xref:System.Web.Security.AnonymousIdentificationModule.Creating> die das-Ereignis behandelt.  
  
-   Eine Web Forms Seite.  
  
 Der erste Teil des Code Beispiels zeigt, wie die <xref:System.Web.HttpRequest.AnonymousID%2A> -Eigenschaft festgelegt wird, indem das <xref:System.Web.Security.AnonymousIdentificationModule.Creating> -Ereignis in der Datei "Global. asax" behandelt wird. Mit der Methode mit dem `AnonymousIdentification_Creating` Namen wird <xref:System.Web.HttpRequest.AnonymousID%2A> die-Eigenschaft festgelegt, wenn eine anonyme ID erstellt wird.  
  
 [!code-csharp[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/global_asax.cs#2)]
 [!code-vb[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/global_asax.vb#2)]  
  
 Der zweite Teil des Code Beispiels zeigt, wie die neue <xref:System.Web.HttpRequest.AnonymousID%2A> angezeigt wird, die `AnonymousIdentification_Creating` vom Ereignishandler im vorherigen Beispiel erstellt wurde.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/anonid_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/anonid_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.IsAuthenticated" />
        <altmember cref="E:System.Web.Security.AnonymousIdentificationModule.Creating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100)">anonymousIdentification-Element (ASP.NET-Einstellungsschema)</related>
      </Docs>
    </Member>
    <Member MemberName="ApplicationPath">
      <MemberSignature Language="C#" Value="public string ApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationPath : string" Usage="System.Web.HttpRequest.ApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den virtuellen Pfad des Anwendungsstamms der ASP.NET-Anwendung auf dem Server ab.</summary>
        <value>Der virtuelle Pfad der aktuellen Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um eine URL relativ zum Anwendungs Stamm von einem Seiten-oder Webbenutzer Steuerelement zu erstellen, das sich nicht im Stammverzeichnis befindet. Dadurch können Seiten und freigegebene Steuerelemente, die auf unterschiedlichen Ebenen einer Verzeichnisstruktur vorhanden sind, denselben Code verwenden, um eine Verknüpfung mit Ressourcen an festgelegten Orten in der Anwendung zu ermöglichen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.StreamWriter.Write%2A> -Methode verwendet, um HTML-codiert und dann den Wert <xref:System.Web.HttpRequest.ApplicationPath%2A> der-Eigenschaft in eine Textdatei zu schreiben. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Web.HttpRequest> -Klasse bereitgestellt wird. Es wird davon ausgegangen, dass <xref:System.IO.StreamWriter> ein- `sw`Objekt mit dem Namen vorhanden ist  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 Im folgenden Beispiel wird die <xref:System.Web.HttpRequest.ApplicationPath%2A> -Eigenschaft verwendet, um einen Pfad zu einer Ressource Programm gesteuert zu erstellen, die sich an einem festgelegten Speicherort in der Anwendung befindet. Die Seite, die auf die Ressource verweist, muss sich nicht im selben Verzeichnis wie die Ressource befinden.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/ApplicationPath.aspx#2)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/ApplicationPath.aspx#2)]  
  
 Wenn Sie dieses Beispiel in einer Webanwendung mit dem Namen website1 ausführen `/WebSite1` , wird als Wert <xref:System.Web.HttpRequest.ApplicationPath%2A> der-Eigenschaft angezeigt und `/WebSite1/images/Image1.gif` als kompletter Pfad des Bilds angezeigt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeCurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string AppRelativeCurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AppRelativeCurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeCurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AppRelativeCurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den virtuellen Pfad des Anwendungsstamms ab und wandelt diesen mithilfe der Tildennotation (\~) in einen relativen Pfad um (z. B. „\~/page.aspx“).</summary>
        <value>Der virtuelle Pfad des Anwendungsstamms für die aktuelle Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um URL-Informationen bereitzustellen, die unverändert bleiben, auch wenn sich der Speicherort der Anwendung ändert. Dadurch kann derselbe URL-Zuordnungscode in einer Testumgebung und in der endgültigen Bereitstellungs Umgebung verwendet werden, oder er kann von Kopien von Webanwendungen in verschiedenen Domänen verwendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> -Eigenschaft verwendet, um die URL <xref:System.Web.UI.WebControls.Image> eines-Steuer Elements auf ein Bild im gleichen Verzeichnis wie die Seite festzulegen. Führen Sie diese Seite auf unterschiedlichen Ebenen einer Verzeichnisstruktur aus, um <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> die resultierenden Eigenschaftswerte anzuzeigen.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/CS/AppRelativeCurrentExecutionPathCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/VB/AppRelativeCurrentExecutionPathVB.aspx#1)]  
  
 Im folgenden Beispiel wird die <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> -Eigenschaft verwendet, um den Pfad basierend auf dem aktuellen Pfad der Seite Programm gesteuert auf eine Ressource festzulegen.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/apprelativecurrentexecutionfilepath.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/apprelativecurrentexecutionfilepath.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BinaryRead">
      <MemberSignature Language="C#" Value="public byte[] BinaryRead (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] BinaryRead(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.BinaryRead(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinaryRead (count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ BinaryRead(int count);" />
      <MemberSignature Language="F#" Value="member this.BinaryRead : int -&gt; byte[]" Usage="httpRequest.BinaryRead count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Die Anzahl der zu lesenden Bytes.</param>
        <summary>Führt einen binären Lesevorgang einer angegebenen Anzahl von Bytes aus dem aktuellen Eingabestream durch.</summary>
        <returns>Ein Bytearray.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpRequest.BinaryRead%2A> -Methode wird aus Gründen der Kompatibilität mit ASP bereitgestellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist 0.  
  
- oder - 
 <paramref name="count" /> ist größer als die verfügbare Anzahl von Bytes.</exception>
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="public System.Web.HttpBrowserCapabilities Browser { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Browser" />
      <MemberSignature Language="VB.NET" Value="Public Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); void set(System::Web::HttpBrowserCapabilities ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities with get, set" Usage="System.Web.HttpRequest.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Informationen über die Browserfunktionen des Clients ab, der die Anforderung gesendet hat, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Web.HttpBrowserCapabilities" />-Objekt, das die Funktionen des Clientbrowsers auflistet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird eine Liste der Funktionen des Browsers zurück an den Client in einer HTML-Seite gesendet.  
  
 [!code-csharp[Classic HttpRequest.Browser Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Browser Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
        <related type="Article" href="https://msdn.microsoft.com/library/143d14d6-9d12-4d4b-ae60-f00e0eb6938f">ASP.NET-Server Steuerelemente und Browser Funktionen</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificate">
      <MemberSignature Language="C#" Value="public System.Web.HttpClientCertificate ClientCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpClientCertificate ClientCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ClientCertificate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificate As HttpClientCertificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpClientCertificate ^ ClientCertificate { System::Web::HttpClientCertificate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificate : System.Web.HttpClientCertificate" Usage="System.Web.HttpRequest.ClientCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpClientCertificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Clientsicherheitszertifikat der aktuellen Anforderung ab.</summary>
        <value>Ein <see cref="T:System.Web.HttpClientCertificate" />-Objekt mit Informationen über die Sicherheitszertifikateinstellungen auf dem Client.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel werden die Zertifikat Einstellungen des Clients auf einer HTML-Seite zurück an den Client gesendet.  
  
 [!code-csharp[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpRequest.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zeichensatz des Einheitstextkörpers ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Text.Encoding" />-Objekt, das den Zeichensatz des Clients darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard-Inhalts Codierung kann im [globalization-Element (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) einer Konfigurationsdatei angegeben werden. Wenn die Inhalts Codierung auch vom Client angegeben wird, werden die Standard Konfigurationseinstellungen überschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird einer Zeichen folgen Variablen ein Wert zugewiesen, der die Beschreibung der aktuellen HTTP-Codierung darstellt.  
  
 [!code-csharp[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public int ContentLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContentLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int" Usage="System.Web.HttpRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Länge des vom Client gesendeten Inhalts in Bytes an.</summary>
        <value>Die Länge des vom Client gesendeten Inhalts in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird der Wert, der die Inhalts Länge der eingehenden Anforderung darstellt, einer ganzzahligen Variablen zugewiesen.  
  
 [!code-csharp[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den MIME-Inhaltstyp der eingehenden Anforderung ab oder legt diesen fest.</summary>
        <value>Eine Zeichenfolge, die den MIME-Inhaltstyp der eingehenden Anforderung darstellt, z. B. „text/html“. Zusätzliche allgemeine MIME-Typen schließen „audio.wav“, „image/gif“ und „application/pdf“ ein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird der Wert, der den Inhaltstyp der eingehenden Anforderung darstellt, einer Zeichen folgen Variablen zugewiesen.  
  
 [!code-csharp[Classic HttpRequest.ContentType Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/VB/source.vb#1)]  
  
 Das folgende Beispiel zeigt die Ausgabe, die möglicherweise von diesem Code erzeugt wird.  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpRequest.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung der vom Client gesendeten Cookies ab.</summary>
        <value>Ein <see cref="T:System.Web.HttpCookieCollection" />-Objekt, das die Cookievariablen des Clients darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET enthält zwei systeminterne Cookie-Auflistungen. Die <xref:System.Web.HttpRequest.Cookies%2A> Auflistung `Cookie`  , auf die über die <xref:System.Web.HttpRequest> -Auflistung zugegriffen wird, enthält Cookies, die vom Client an den Server im-Header übertragen werden. Die <xref:System.Web.HttpResponse.Cookies%2A> Auflistung `Set-Cookie`  , auf die über die <xref:System.Web.HttpResponse> -Auflistung zugegriffen wird, enthält neue Cookies, die auf dem Server erstellt und im-Header an den Client übermittelt werden.  
  
> [!NOTE]
>  Nachdem Sie ein Cookie mithilfe der <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> -Auflistung hinzugefügt haben, ist das Cookie sofort in der <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> Auflistung verfügbar, auch wenn die Antwort nicht an den Client gesendet wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle vom Client gesendeten Cookies durchlaufen und der Name, das Ablaufdatum, der Sicherheitsparameter und die Werte der einzelnen Cookies an die HTTP-Ausgabe gesendet.  
  
 [!code-csharp[Classic HttpRequest.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den virtuellen Pfad der aktuellen Anforderung ab.</summary>
        <value>Der virtuelle Pfad der aktuellen Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A>Gibt den Dateipfad zum aktuell ausgeführten Seiten Handler zurück. Bei Umleitungs Szenarien <xref:System.Web.HttpServerUtility.Execute%2A> mit <xref:System.Web.HttpServerUtility.Transfer%2A> -und-Methoden bedeutet <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> dies, dass die-Eigenschaft den Pfad zu der Seite zurückgibt, an die umgeleitet wird (untergeordnete Seite) Wenn der Client jedoch zu einer anderen Seite umgeleitet wird, gibt <xref:System.Web.HttpRequest.FilePath%2A> die-Eigenschaft den Pfad zur ursprünglichen Seite zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpUtility.HtmlEncode%2A> -Methode verwendet, um den Wert <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> der-Eigenschaft in HTML zu <xref:System.IO.TextWriter.WriteLine%2A> codieren, und die-Methode, um den codierten Wert in die Datei zu schreiben. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Web.HttpRequest> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="M:System.Web.HttpServerUtility.Execute(System.String)" />
        <altmember cref="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePathExtension">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePathExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePathExtension" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePathExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePathExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePathExtension : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Erweiterung des Dateinamens ab, die in der <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />-Eigenschaft angegeben wird.</summary>
        <value>Die Erweiterung des Dateinamens, die in der <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />-Eigenschaft angegeben wird.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilePath">
      <MemberSignature Language="C#" Value="public string FilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.FilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FilePath : string" Usage="System.Web.HttpRequest.FilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den virtuellen Pfad der aktuellen Anforderung ab.</summary>
        <value>Der virtuelle Pfad der aktuellen Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpRequest.FilePath%2A> -Eigenschaft enthält nicht den <xref:System.Web.HttpRequest.PathInfo%2A> -Nachspann. Für die URL `http://www.contoso.com/virdir/page.html/tail`lautet der <xref:System.Web.HttpRequest.FilePath%2A> Wert z. b./virdir/page.html.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpUtility.HtmlEncode%2A> -Methode verwendet, um den Wert <xref:System.Web.HttpRequest.FilePath%2A> der-Eigenschaft in HTML zu <xref:System.IO.TextWriter.WriteLine%2A> codieren, und die-Methode, um den codierten Wert in die Datei zu schreiben. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Web.HttpRequest> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
      </Docs>
    </Member>
    <Member MemberName="Files">
      <MemberSignature Language="C#" Value="public System.Web.HttpFileCollection Files { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpFileCollection Files" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Files" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Files As HttpFileCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpFileCollection ^ Files { System::Web::HttpFileCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Files : System.Web.HttpFileCollection" Usage="System.Web.HttpRequest.Files" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpFileCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der vom Client hochgeladenen Dateien im MIME-Multipart-Format ab.</summary>
        <value>Ein <see cref="T:System.Web.HttpFileCollection" />-Objekt, das eine Auflistung der vom Client hochgeladenen Dateien darstellt. Die Elemente des <see cref="T:System.Web.HttpFileCollection" />-Objekts sind vom Typ <see cref="T:System.Web.HttpPostedFile" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Datei Sammlung wird nur aufgefüllt, wenn der HTTP `Content-Type` -Anforderungs Wert "Multipart/Form-Data" lautet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Namen aller Dateien in der <xref:System.Web.HttpRequest.Files%2A> -Auflistung angezeigt.  
  
 [!code-csharp[Classic HttpRequest.Files Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Files Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Files Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Files Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpRequest.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Filter ab, der beim Lesen des aktuellen Eingabestreams verwendet werden soll, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.IO.Stream" />-Objekt, das als Filter verwendet werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel werden zwei neue Klassen erstellt `QQQ1` , `QQQ2` die die <xref:System.Web.HttpRequest.InputStream%2A>filtern. Platzieren Sie die Klassen in der Datei Global. asax im Verzeichnis einer ASP.NET-Anwendung, sodass alle Eingaben für alle ASP.NET-Webseiten in der Anwendung gefiltert werden.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Filter#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/CS/systemwebhttprequestfilter.cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Filter#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/VB/systemwebhttprequestfilter.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die angegebene <see cref="T:System.IO.Stream" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Form { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Form : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Formularvariablen ab.</summary>
        <value>Eine <see cref="T:System.Collections.Specialized.NameValueCollection" />, die eine Auflistung von Formularvariablen darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpRequest.Form%2A> -Eigenschaft wird aufgefüllt, wenn der `Content-Type` HTTP-Anforderungs Wert entweder "application/x-www-form-urlencoded" oder "Multipart/Form-Data" ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie die Werte in der Formular Auflistung gelesen werden, die von einem Browser gepostet wurde. Jedes Name/Wert-Paar in der Auflistung stellt ein Steuerelement im Formular und seinen Wert dar.  
  
 [!code-csharp[Classic HttpRequest.Form Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Form Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Form Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Form Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferedInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferedInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferedInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferedInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferedInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferedInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferedInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferedInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.IO.Stream" />-Objekt ab, das zum Lesen des eingehenden HTTP-Entitätentexts verwendet werden kann.</summary>
        <returns>Ein <see cref="T:System.IO.Stream" />-Objekt, das zum Lesen des eingehenden HTTP-Entitätentexts verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist mit identisch <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> , mit der Ausnahme, dass Sie auch die gelesenen Bytes in den von ASP.NET verwendeten internen Speicher kopiert, um <xref:System.Web.HttpRequest.Form%2A>die <xref:System.Web.HttpRequest.Files%2A>Eigenschaften, <xref:System.Web.HttpRequest.InputStream%2A> und aufzufüllen. Da diese Informationen beibehalten werden, wird Downstreamer-Code wie ASP.NET Web Forms-Seiten (ASPX-Dateien) erfolgreich ausgeführt. Dies ist nicht der Fall bei der <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A>-Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der Entitätstext der Anforderung wurde bereits geladen und wurde analysiert. Beispiele für Eigenschaften, die das Laden und Analysieren des Entitätstexts verursachen, umfassen Folgende: 
–   Die <see cref="P:System.Web.HttpRequest.Form" />-Eigenschaft.  
  
–   Die <see cref="P:System.Web.HttpRequest.Files" />-Eigenschaft.  
  
–   Die <see cref="P:System.Web.HttpRequest.InputStream" />-Eigenschaft.  
  
–   Die <see cref="M:System.Web.HttpRequest.GetBufferlessInputStream" />-Methode.  
  
Um diese Ausnahme zu vermeiden, rufen Sie die <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />-Methode zuerst auf. Diese Ausnahme wird auch ausgelöst, wenn der Client getrennt wird, während der Entitätstext gelesen wird.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBufferlessInputStream">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein <see cref="T:System.IO.Stream" />-Objekt ab, das zum Lesen des eingehenden HTTP-Entitätentexts verwendet werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.IO.Stream" />-Objekt ab, das zum Lesen des eingehenden HTTP-Entitätentexts verwendet werden kann.</summary>
        <returns>Ein <see cref="T:System.IO.Stream" />-Objekt, das zum Lesen des eingehenden HTTP-Entitätentexts verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bietet eine Alternative zur Verwendung der <xref:System.Web.HttpRequest.InputStream%2A> -Eigenschaft. Die <xref:System.Web.HttpRequest.InputStream%2A> -Eigenschaft wartet, bis die gesamte Anforderung empfangen wurde, bevor Sie <xref:System.IO.Stream> ein-Objekt zurückgibt. Im Gegensatz dazu gibt <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> die-Methode <xref:System.IO.Stream> das-Objekt sofort zurück. Sie können die-Methode verwenden, um mit der Verarbeitung des Entitäts Texts zu beginnen, bevor der gesamte Inhalt des Texts empfangen wurde.  
  
 Der Entitäts Text (oder so viel, wie Sie anfordern und empfangen wurde) wird nur zurückgegeben, wenn Sie das Objekt, das von dieser Methode zurückgegeben wird, zum Lesen des Streams verwenden, indem Sie <xref:System.IO.Stream.Read%2A> Methoden wie die-Methode aufrufen. Sie verwenden Parameter der <xref:System.IO.Stream.Read%2A> -Methode, um anzugeben, wie viel der zu lesenden Entitäts Text ist.  
  
 Das <xref:System.IO.Stream> von der ASP.NET-Methode zurückgegebene-Objekt unterstützt synchrone und asynchrone Lesemethoden. Das <xref:System.IO.Stream> -Objekt implementiert die <xref:System.IO.Stream.BeginRead%2A> - <xref:System.IO.Stream.EndRead%2A> Methode und die-Methode. Mit den asynchronen Methoden können Sie die Anforderungs Entität asynchron in Blöcken lesen, während ASP.NET den aktuellen Thread zwischen den einzelnen Iterationen einer asynchronen Lese Schleife freigibt.  
  
 Diese Methode kann nützlich sein, wenn die Anforderung eine große Datei hochlädt und Sie auf den Dateiinhalt zugreifen möchten, bevor der Upload abgeschlossen ist. Sie sollten diese Methode jedoch nur für Szenarien verwenden, in denen Sie die gesamte Verarbeitung des Entitäts Texts übernehmen möchten. Dies bedeutet, dass Sie diese Methode nicht von einer ASPX-Seite aus verwenden können, da der Entitäts Text beim Ausführen einer ASPX-Seite bereits gelesen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der Entitätstext der Anforderung wurde bereits geladen und wurde analysiert. Beispiele für Eigenschaften, die das Laden und Analysieren des Entitätstexts verursachen, umfassen Folgende: 
-   <see cref="P:System.Web.HttpRequest.Form" />  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" />  
  
-   <see cref="P:System.Web.HttpRequest.Files" />  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />  
  
Um diese Ausnahme zu vermeiden, rufen Sie die <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />-Methode zuerst auf. Diese Ausnahme wird auch ausgelöst, wenn der Client getrennt wird, während der Entitätstext gelesen wird.</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream (bool disableMaxRequestLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream(bool disableMaxRequestLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream (disableMaxRequestLength As Boolean) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream(bool disableMaxRequestLength);" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : bool -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream disableMaxRequestLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disableMaxRequestLength" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="disableMaxRequestLength"><see langword="true" />, um die Längenbeschränkung der Anforderung zu deaktivieren; andernfalls <see langword="false" />.</param>
        <summary>Ruft ein <see cref="T:System.IO.Stream" />-Objekt ab, das verwendet werden kann, um den eingehenden HTTP-Entitätstexts zu lesen, wobei optional die Anforderungslängenbegrenzung deaktiviert wird, die in der <see cref="P:System.Web.Configuration.HttpRuntimeSection.MaxRequestLength" />-Eigenschaft festgesetzt ist.</summary>
        <returns>Ein <see cref="T:System.IO.Stream" />-Objekt, das zum Lesen des eingehenden HTTP-Entitätentexts verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu dieser Methode finden Sie unter <xref:System.Web.HttpRequest.GetBufferlessInputStream> Überladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der Entitätstext der Anforderung wurde bereits geladen und wurde analysiert. Beispiele für Eigenschaften, die das Laden und Analysieren des Entitätstexts verursachen, umfassen Folgende: 
–   Die <see cref="P:System.Web.HttpRequest.Form" />-Eigenschaft.  
  
–   Die <see cref="P:System.Web.HttpRequest.Files" />-Eigenschaft.  
  
–   Die <see cref="P:System.Web.HttpRequest.InputStream" />-Eigenschaft.  
  
–   Die <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />-Methode.  
  
Um diese Ausnahme zu vermeiden, rufen Sie die <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />-Methode zuerst auf. Diese Ausnahme wird auch ausgelöst, wenn der Client getrennt wird, während der Entitätstext gelesen wird.</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von HTTP-Headern ab.</summary>
        <value>Eine <see cref="T:System.Collections.Specialized.NameValueCollection" /> von Headern.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Auflistung aller möglichen Header finden Sie unter [Anforderungs Header Felder](https://go.microsoft.com/fwlink/?LinkId=73147) auf der W3C-Website.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Namen und Werte aller Header in der HTTP-Anforderung angezeigt.  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HttpChannelBinding">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpChannelBinding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpChannelBinding As ChannelBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ChannelBinding ^ HttpChannelBinding { System::Security::Authentication::ExtendedProtection::ChannelBinding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpChannelBinding : System.Security.Authentication.ExtendedProtection.ChannelBinding" Usage="System.Web.HttpRequest.HttpChannelBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ChannelBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />-Objekt der aktuellen <see cref="T:System.Web.HttpWorkerRequest" />-Instanz ab.</summary>
        <value>Das <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />-Objekt der aktuellen <see cref="T:System.Web.HttpWorkerRequest" />-Instanz.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle <see cref="T:System.Web.HttpWorkerRequest" />-Objekt ist kein <see langword="System.Web.Hosting.IIS7WorkerRequest" />-Objekt oder kein <see langword="System.Web.Hosting.ISAPIWorkerRequestInProc" />-Objekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpMethod As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HttpMethod { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpMethod : string" Usage="System.Web.HttpRequest.HttpMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vom Client verwendete HTTP-Datenübertragungsmethode ab, z. B. <see langword="GET" />, <see langword="POST" /> oder <see langword="HEAD" />.</summary>
        <value>Die vom Client verwendete HTTP-Datenübertragungsmethode.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpUtility.HtmlEncode%2A> -Methode verwendet, um den Wert <xref:System.Web.HttpRequest.HttpMethod%2A> der-Eigenschaft in HTML zu <xref:System.IO.TextWriter.WriteLine%2A> codieren, und die-Methode, um den codierten Wert in die Datei zu schreiben. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Web.HttpRequest> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 Das folgende Beispiel zeigt die Ausgabe, die von diesem Code erzeugt wird.  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.InputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ InputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputStream : System.IO.Stream" Usage="System.Web.HttpRequest.InputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Inhalt des eingehenden HTTP-Einheitentexts ab.</summary>
        <value>Ein <see cref="T:System.IO.Stream" />-Objekt, das den Inhalt des eingehenden HTTP-Einheitentexts darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird der Inhalt eines <xref:System.Web.HttpRequest.InputStream%2A> in eine Zeichenfolge kopiert.  
  
 [!code-csharp[Classic HttpRequest.InputStream Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/cs/source.aspx#1)]
 [!code-vb[Classic HttpRequest.InputStream Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertEntityBody">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stellt einen verwalteten Wrapper für die IIS-Methode bereit, mit der ein HTTP-Anforderungsentitätstext in den Arbeitsspeicher eingefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpRequest.InsertEntityBody%2A> Methoden Überladungen bieten verwalteten Zugriff auf die IIS 7 `IHttpRequest::InsertEntityBody` -Methode. Die IIS-Methode fügt einen HTTP-Anforderungs Entitäts Text (die Daten, die von einem Client gesendet werden) in den Arbeitsspeicher ein. Dies ist hilfreich, da IIS eine Kopie der Anforderungs Entität nicht verwaltet, nachdem Sie gelesen wurde. Die <xref:System.Web.HttpRequest.InsertEntityBody%2A> -Methoden erstellen eine Kopie der HTTP-Anforderungs Entitäts Daten und stellen Sie für IIS zur weiteren benutzerdefinierten Behandlung zur Verfügung.  
  
> [!NOTE]
>  Die <xref:System.Web.HttpRequest.InsertEntityBody%2A> -Methoden Überladungen funktionieren nur unter IIS 7,0 oder höher, da `IHttpRequest::InsertEntityBody` die-Methode in IIS 7,0 hinzugefügt wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody();" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : unit -&gt; unit" Usage="httpRequest.InsertEntityBody " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt für IIS eine Kopie des HTTP-Anforderungseinheitentexts bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IIS behält keine Kopie der Anforderung bei, nachdem Sie gelesen wurde. Daher wird empfohlen, dass nur der Handler für eine HTTP-Anforderung die Anforderungs Entität lesen soll.  
  
 Die <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> -Methoden Überladung bietet IIS eine Kopie der Anforderungs Entität, wenn Sie zuvor von ASP.net gelesen wurde. Diese Methoden Überladung ist in Fällen nützlich, in denen ASP.net die Entitäts Anforderung gelesen hat und Sie die vorhandenen Anforderungs Daten wieder verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Methode wurde für eine frühere Version von IIS als IIS 7.0 aufgerufen.</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">Für den Betrieb in einer gehosteten Umgebung. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugehörige Enumeration:<see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : byte[] * int * int -&gt; unit" Usage="httpRequest.InsertEntityBody (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array, das die Anforderungsentitätsdaten enthält.</param>
        <param name="offset">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der das Speichern der Anforderungsentitätsdaten beginnen soll.</param>
        <param name="count">Die Anzahl der in den <paramref name="buffer" />-Array zu lesenden Bytes.</param>
        <summary>Stellt für IIS eine Kopie des HTTP-Anforderungseinheitentexts und Informationen zum Anforderungsentitätsobjekt bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IIS behält keine Kopie der Anforderung bei, nachdem Sie gelesen wurde. Daher wird empfohlen, dass nur der Handler für eine HTTP-Anforderung die Anforderungs Entität lesen soll.  
  
 Die <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> -Methoden Überladung ist nützlich, wenn Sie eine benutzerdefinierte Verarbeitung durchführen möchten, z. b. einen anderen Entitäts Text in den Arbeitsspeicher einfügen  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Die Methode wurde für eine frühere Version von IIS als IIS 7.0 aufgerufen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException">Die Elementzahl in <paramref name="count" /> ist größer als der verfügbare Platz in <paramref name="buffer" />, wenn der <paramref name="offset" />-Wert angegeben ist.</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">für den Betrieb in einer Hostumgebung. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugehörige Enumeration:<see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Web.HttpRequest.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anforderung authentifiziert wurde.</summary>
        <value><see langword="true" />, wenn die Anforderung authentifiziert wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpRequest.IsAuthenticated%2A> -Eigenschaft verwendet, um zu bestimmen, ob die aktuelle Anforderung authentifiziert wurde. Wenn Sie nicht authentifiziert wurde, wird die Anforderung an eine andere Seite umgeleitet, auf der Benutzer ihre Anmelde Informationen in die Webanwendung eingeben können. Dies ist ein gängiges Verfahren, das auf der Standardseite für eine Anwendung verwendet wird.  
  
 [!code-csharp[System.Web.HttpRequest_Sample3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/CS/isauthenticatedcs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/VB/isauthenticatedvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocal : bool" Usage="System.Web.HttpRequest.IsLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anforderung vom lokalen Computer stammt.</summary>
        <value><see langword="true" />, wenn die Anforderung vom lokalen Computer stammt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpRequest.IsLocal%2A> -Eigenschaft `true` gibt zurück, wenn die IP-Adresse des Anforderungs Ursprungs 127.0.0.1 ist oder die IP-Adresse der Anforderung mit der IP-Adresse des Servers identisch ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecureConnection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecureConnection : bool" Usage="System.Web.HttpRequest.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob bei der HTTP-Verbindung Secure Sockets, d. h. HTTPS, verwendet wird.</summary>
        <value><see langword="true" />, wenn die Verbindung eine SSL-Verbindung ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird bestimmt, <xref:System.Web.HttpRequest.IsSecureConnection%2A> ob die-Eigenschaft auf false festgelegt ist. Wenn dies der Fall ist <xref:System.Web.HttpResponse.SuppressContent%2A> , wird die-Eigenschaft auf true festgelegt, um zu verhindern, dass die Antwort gesendet wird.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public string this[string key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ key); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Web.HttpRequest.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Name des abzurufenden Members der Auflistung.</param>
        <summary>Ruft das angegebene Objekt aus der Auflistung <see cref="P:System.Web.HttpRequest.QueryString" />, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" /> oder <see cref="P:System.Web.HttpRequest.ServerVariables" /> ab.</summary>
        <value>Der im <paramref name="key" />-Parameter angegebene Member der <see cref="P:System.Web.HttpRequest.QueryString" />-Auflistung, der <see cref="P:System.Web.HttpRequest.Form" />-Auflistung, der <see cref="P:System.Web.HttpRequest.Cookies" />-Auflistung oder der <see cref="P:System.Web.HttpRequest.ServerVariables" />-Auflistung. Wenn der angegebene <paramref name="key" /> nicht gefunden wird, wird <see langword="null" /> zurückgegeben.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogonUserIdentity">
      <MemberSignature Language="C#" Value="public System.Security.Principal.WindowsIdentity LogonUserIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.WindowsIdentity LogonUserIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.LogonUserIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogonUserIdentity As WindowsIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::WindowsIdentity ^ LogonUserIdentity { System::Security::Principal::WindowsIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogonUserIdentity : System.Security.Principal.WindowsIdentity" Usage="System.Web.HttpRequest.LogonUserIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Security.Principal.WindowsIdentity" />-Typ für den aktuellen Benutzer ab.</summary>
        <value>Ein <see cref="T:System.Security.Principal.WindowsIdentity" />-Objekt für die aktuellen Authentifizierungseinstellungen von Microsoft-Internetinformationsdienste (IIS).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpRequest.LogonUserIdentity%2A> -Eigenschaft macht die Eigenschaften und Methoden <xref:System.Security.Principal.WindowsIdentity> des-Objekts für den aktuell verbundenen Benutzer mit Microsoft Internetinformationsdienste (IIS) verfügbar. Die Instanz der <xref:System.Security.Principal.WindowsIdentity> -Klasse, die von <xref:System.Web.HttpRequest.LogonUserIdentity%2A> verfügbar gemacht wird, verfolgt das IIS-Anforderungs Token und ermöglicht den einfachen Zugriff auf dieses Token für die aktuelle HTTP-Anforderung, die in ASP.NET verarbeitet wird. Eine Instanz der <xref:System.Security.Principal.WindowsIdentity> -Klasse wird automatisch erstellt, sodass Sie nicht erstellt werden muss, um Zugriff auf die Methoden und Eigenschaften zu erhalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die <xref:System.Web.HttpRequest.LogonUserIdentity%2A> -Eigenschaft für den aktuellen Benutzer abgerufen und die Werte der einzelnen Elemente in einer Textdatei geschrieben werden. Platzieren Sie diesen Code auf der ASP.NET-Seite, auf die `ACTION` vom-Attribut des Formulars verwiesen wird.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/CS/logonuseridentity_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/VB/logonuseridentity_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Webanwendung wird im integrierten Modus von IIS 7 ausgeführt, und das <see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" />-Ereignis wurde noch nicht ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapImageCoordinates">
      <MemberSignature Language="C#" Value="public int[] MapImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] MapImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapImageCoordinates (imageFieldName As String) As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ MapImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapImageCoordinates : string -&gt; int[]" Usage="httpRequest.MapImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">Der Name der Formular-Imagemap.</param>
        <summary>Ordnet einen eingehenden Formularparameter für ein Bildfeld den entsprechenden x- und y-Koordinatenwerten zu.</summary>
        <returns>Ein zweidimensionales Array von Ganzzahlen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordnet dem physikalischen Pfad auf dem Server den virtuellen Pfad in der angeforderten URL für die aktuelle Anforderung zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpRequest.MapPath virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Der absolute oder relative virtuelle Pfad für die aktuelle Anforderung.</param>
        <summary>Ordnet einem physikalischen Pfad den angegebenen virtuellen Pfad zu.</summary>
        <returns>Der physikalische Pfad auf dem durch <paramref name="virtualPath" /> angegebenen Server.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Die <xref:System.Web.HttpRequest.MapPath%2A> -Eigenschaft enthält potenziell vertrauliche Informationen über die Host Umgebung. Der Rückgabewert sollte Benutzern nicht angezeigt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpRequest.MapPath%2A> -Methode verwendet, um einen virtuellen Pfad in einen voll qualifizierten physischen Pfad auf dem Server zu konvertieren. Dieses Beispiel besteht aus zwei Teilen:  
  
-   Eine ASPX-Seite ordnet den Pfad zu, liest die Datei und zeigt die Ergebnisse des Lesevorgangs an.  
  
-   Eine Klasse, `UpperCaseFilterStream`, die alle an Großbuchstaben übergebenen Zeichen ändert.  
  
 Der erste Teil des Beispiels zeigt, wie Sie mithilfe der <xref:System.Web.HttpRequest.MapPath%2A> -Methode einen virtuellen Pfad in einen voll qualifizierten physischen Pfad konvertieren. Dieser physische Pfad wird dann an ein <xref:System.IO.StreamReader> -Objekt weitergeleitet, das den Inhalt der Datei abruft. Anschließend <xref:System.Web.HttpResponse.Write%2A> wird die-Methode aufgerufen, um den Inhalt der Datei auf der Seite anzuzeigen. Die <xref:System.Web.HttpResponse.Filter%2A> -Eigenschaft wird verwendet, um einen Filter an den Antwortstream anzufügen, der den Text in Großbuchstaben der Seite angezeigt wird.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 Der zweite Teil des Beispiels zeigt eine Klasse, die von <xref:System.IO.Stream> erbt, und konvertiert alle Zeichen in einem Stream in Großbuchstaben. Fügen Sie diesen Code in `App_Code` den Ordner für Ihre Anwendung ein.  
  
 [!code-csharp[System.Web.HttpRequest_Samples2#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/responsefilter.cs#2)]
 [!code-vb[System.Web.HttpRequest_Samples2#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/responsefilter.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Für die Anforderung wird kein <see cref="T:System.Web.HttpContext" />-Objekt definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath, string baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath, string baseVirtualDir, bool allowCrossAppMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String, baseVirtualDir As String, allowCrossAppMapping As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath, System::String ^ baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string * string * bool -&gt; string" Usage="httpRequest.MapPath (virtualPath, baseVirtualDir, allowCrossAppMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="baseVirtualDir" Type="System.String" />
        <Parameter Name="allowCrossAppMapping" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Der absolute oder relative virtuelle Pfad für die aktuelle Anforderung.</param>
        <param name="baseVirtualDir">Der virtuelle Pfad des Basisverzeichnisses, der für die Auflösung relativer Pfade verwendet wird.</param>
        <param name="allowCrossAppMapping"><see langword="true" /> gibt an, dass <paramref name="virtualPath" /> möglicherweise zu einer anderen Anwendung gehört, andernfalls <see langword="false" />.</param>
        <summary>Ordnet einem physikalischen Pfad den angegebenen virtuellen Pfad zu.</summary>
        <returns>Der physische Pfad auf dem Server.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Die <xref:System.Web.HttpRequest.MapPath%2A> -Eigenschaft enthält potenziell vertrauliche Informationen über die Host Umgebung. Der Rückgabewert sollte Benutzern nicht angezeigt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="allowCrossMapping" /> ist <see langword="false" />, und <paramref name="virtualPath" /> gehört zu einer anderen Anwendung.

- oder - 
Für die Anforderung wird kein <see cref="T:System.Web.HttpContext" />-Objekt definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapRawImageCoordinates">
      <MemberSignature Language="C#" Value="public double[] MapRawImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64[] MapRawImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapRawImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapRawImageCoordinates (imageFieldName As String) As Double()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;double&gt; ^ MapRawImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapRawImageCoordinates : string -&gt; double[]" Usage="httpRequest.MapRawImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">Der Name des Imagefelds.</param>
        <summary>Ordnet einen eingehenden Formularparameter für ein Bildfeld den entsprechenden x- und y-Koordinatenwerten zu.</summary>
        <returns>Die x- und y-Koordinatenwerte.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Params">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Params { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Params" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Params" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Params As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Params { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Params : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Params" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine kombinierte Auflistung der Elemente <see cref="P:System.Web.HttpRequest.QueryString" />, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" /> und <see cref="P:System.Web.HttpRequest.ServerVariables" /> ab.</summary>
        <value>Ein <see cref="T:System.Collections.Specialized.NameValueCollection" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Auflistung werden Name-Wert-Paare in der folgenden Reihenfolge hinzugefügt:  
  
1.  Abfrage Zeichen folgen Parameter.  
  
2.  Formularfelder.  
  
3.  KS.  
  
4.  Server Variablen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die- <xref:System.Web.HttpRequest.Params%2A> Eigenschaft für eine Seite durchlaufen und wie die einzelnen Schlüssel-Wert-Paare angezeigt werden.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Params#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Params/CS/requestparamscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Params#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Params/VB/requestparamsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Path" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Path : string" Usage="System.Web.HttpRequest.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den virtuellen Pfad der aktuellen Anforderung ab.</summary>
        <value>Der virtuelle Pfad der aktuellen Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Web.HttpRequest.Path%2A> ist die Verkettung <xref:System.Web.HttpRequest.FilePath%2A> von und dem <xref:System.Web.HttpRequest.PathInfo%2A> Nachspann. Beispielsweise <xref:System.Web.HttpRequest.Path%2A> ist für die URL `http://www.contoso.com/virdir/page.html/tail`/virdir/page.html/tail..  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpUtility.HtmlEncode%2A> -Methode verwendet, um den Wert <xref:System.Web.HttpRequest.Path%2A> der-Eigenschaft in HTML zu <xref:System.IO.TextWriter.WriteLine%2A> codieren, und die-Methode, um den codierten Wert in die Datei zu schreiben. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Web.HttpRequest> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
      </Docs>
    </Member>
    <Member MemberName="PathInfo">
      <MemberSignature Language="C#" Value="public string PathInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PathInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathInfo : string" Usage="System.Web.HttpRequest.PathInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die zusätzlichen Pfadinformationen für eine Ressource mit einer URL-Erweiterung ab.</summary>
        <value>Die zusätzlichen Pfadinformationen für eine Ressource.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für die URL `http://www.contoso.com/virdir/page.html/tail`lautet der <xref:System.Web.HttpRequest.PathInfo%2A> Wert/Tail.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird bestimmt, <xref:System.Web.HttpRequest.PathInfo%2A> ob die-Eigenschaft eine leere Zeichenfolge enthält. Wenn dies der Fall ist <xref:System.IO.StreamWriter.Write%2A> , schreibt die-Methode eine Zeichenfolge, die dies angibt, in eine Datei. Wenn dies nicht der Fall ist <xref:System.Web.HttpUtility.HtmlEncode%2A> , codiert die Methode den Wert <xref:System.Web.HttpRequest.PathInfo%2A> der-Eigenschaft in HTML <xref:System.IO.TextWriter.WriteLine%2A> , und die-Methode schreibt den codierten Wert in die Datei. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Web.HttpRequest> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#4)]
 [!code-vb[System.Web.HttpRequest_Sample1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
      </Docs>
    </Member>
    <Member MemberName="PhysicalApplicationPath">
      <MemberSignature Language="C#" Value="public string PhysicalApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalApplicationPath : string" Usage="System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den physikalischen Dateisystempfad für das Stammverzeichnis der gegenwärtig ausgeführten Serveranwendung ab.</summary>
        <value>Der Dateisystempfad für das Stammverzeichnis der aktuellen Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpUtility.HtmlEncode%2A> -Methode verwendet, um den Wert <xref:System.Web.HttpRequest.PhysicalApplicationPath%2A> der-Eigenschaft in HTML zu <xref:System.IO.TextWriter.WriteLine%2A> codieren, und die-Methode, um den codierten Wert in die Datei zu schreiben. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Web.HttpRequest> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalPath">
      <MemberSignature Language="C#" Value="public string PhysicalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalPath : string" Usage="System.Web.HttpRequest.PhysicalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den physikalischen Dateisystempfad entsprechend der angeforderten URL ab.</summary>
        <value>Der Dateisystempfad der aktuellen Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Umleitungs Szenarien <xref:System.Web.HttpServerUtility.Execute%2A> mit <xref:System.Web.HttpServerUtility.Transfer%2A>und gibt <xref:System.Web.HttpRequest.PhysicalPath%2A> die-Eigenschaft den Pfad zur ursprünglichen Seite zurück. Zum Ermitteln des physischen Pfads der aktuell ausgeführten Seite verwenden <xref:System.Web.HttpRequest.MapPath%2A> Sie die-Methode, wobei das Eingabe <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> Argument als-Eigenschaft festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpUtility.HtmlEncode%2A> -Methode verwendet, um den Wert <xref:System.Web.HttpRequest.PhysicalPath%2A> der-Eigenschaft in HTML zu <xref:System.IO.TextWriter.WriteLine%2A> codieren, und die-Methode, um den codierten Wert in die Datei zu schreiben. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Web.HttpRequest> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.MapPath(System.String)" />
        <altmember cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.QueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryString As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ QueryString { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryString : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.QueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung von Zeichenfolgenvariablen für HTTP-Abfragen ab.</summary>
        <value>Die Abfragezeichenfolgenvariablen, die vom Client gesendet werden. Schlüssel und Werte sind URL-entschlüsselt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel zeigt zwei Möglichkeiten, den Wert einer Variablen der Abfrage Zeichenfolge mit dem Namen "FullName" zu erhalten. In jedem Fall, wenn die URL lautet `http://www.contoso.com/default.aspx?fullname=Fadi%20Fakhouri`, ist der zurückgegebene Wert "Fadi fakhoruri", weil `%20` der URL-decodiert in ein Leerzeichen ist. Wenn die URL nicht über eine `fullname` Abfrage Zeichenfolgen-ID verfügt, ist `null`der zurückgegebene Wert.  
  
 Die erste Codezeile sucht nur in der Abfrage Zeichenfolge nach dem Schlüssel "FullName". die zweite Zeile sucht in allen HTTP-Anforderungs Auflistungen nach dem Schlüssel "FullName". Weitere Informationen zur zweiten Zeile finden <xref:System.Web.HttpRequest.Item%2A>Sie unter.  
  
```csharp  
string fullname1 = Request.QueryString["fullname"];  
string fullname2 = Request["fullname"];  
  
```  
  
```vb  
Dim fullname1 As String = Request.QueryString("fullname")  
Dim fullname2 As String = Request("fullname")  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RawUrl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawUrl { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawUrl : string" Usage="System.Web.HttpRequest.RawUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Basis-URL der aktuellen Anforderung ab.</summary>
        <value>Die Basis-URL der aktuellen Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die RAW-URL wird als Teil der URL definiert, die den Domänen Informationen folgt. In der URL- `http://www.contoso.com/articles/recent.aspx`Zeichenfolge lautet die unformatierte URL/articles/Recent.aspx. Die RAW-URL enthält die Abfrage Zeichenfolge, falls vorhanden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpUtility.HtmlEncode%2A> -Methode verwendet, um den Wert <xref:System.Web.HttpRequest.RawUrl%2A> der-Eigenschaft in HTML zu <xref:System.IO.TextWriter.WriteLine%2A> codieren, und die-Methode, um den codierten Wert in die Datei zu schreiben. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Web.HttpRequest> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEntityBodyMode">
      <MemberSignature Language="C#" Value="public System.Web.ReadEntityBodyMode ReadEntityBodyMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.ReadEntityBodyMode ReadEntityBodyMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadEntityBodyMode As ReadEntityBodyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ReadEntityBodyMode ReadEntityBodyMode { System::Web::ReadEntityBodyMode get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadEntityBodyMode : System.Web.ReadEntityBodyMode" Usage="System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ReadEntityBodyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Text der Anforderungsentität gelesen wurde, und wenn ja, wie er gelesen wurden.</summary>
        <value>Der Wert, der angibt, wie der Anforderungsentitätstext gelesen wurde, oder dass er nicht gelesen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um die Ausnahme zu vermeiden, die ausgelöst wird, wenn der Entitäts Text bereits gelesen wurde und versucht wird, ihn mit einer nicht kompatiblen Methode zu lesen. Zu den Methoden und Eigenschaften, die den Entitäts Text lesen, zählen die folgenden:  
  
-   Die <xref:System.Web.HttpRequest.Form%2A>-Eigenschaft  
  
-   Die <xref:System.Web.HttpRequest.Files%2A>-Eigenschaft  
  
-   Die <xref:System.Web.HttpRequest.InputStream%2A>-Eigenschaft  
  
-   Die <xref:System.Web.HttpRequest.GetBufferedInputStream%2A> -Methode.  
  
-   Die <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> -Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestContext">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RequestContext RequestContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RequestContext RequestContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestContext" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestContext As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RequestContext ^ RequestContext { System::Web::Routing::RequestContext ^ get(); void set(System::Web::Routing::RequestContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestContext : System.Web.Routing.RequestContext with get, set" Usage="System.Web.HttpRequest.RequestContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RequestContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Web.Routing.RequestContext" />-Instanz der aktuellen Anforderung ab.</summary>
        <value>Die <see cref="T:System.Web.Routing.RequestContext" />-Instanz der aktuellen Anforderung. Für nicht weitergeleitete Anforderungen ist das zurückgegebene <see cref="T:System.Web.Routing.RequestContext" />-Objekt leer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht den Zugriff auf <xref:System.Web.Routing.RouteData> das-Objekt für die aktuelle Anforderung. Weitere Informationen zum Routing von ASP.net finden Sie unter. [ASP.NET Routing](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Exemplarische Vorgehensweise: Verwenden des ASP.NET-Routings in einer Web Forms Anwendung</related>
        <related type="Article" href="https://msdn.microsoft.com/library/dc88e6ba-470c-4b20-b644-35874cfd781d">Gewusst wie: Zugreifen auf URL-Parameter auf einer gerouteten Seite</related>
      </Docs>
    </Member>
    <Member MemberName="RequestType">
      <MemberSignature Language="C#" Value="public string RequestType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RequestType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestType" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RequestType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestType : string with get, set" Usage="System.Web.HttpRequest.RequestType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vom Client verwendete HTTP-Datenübertragungsmethode ab (<see langword="GET" /> oder <see langword="POST" />) oder legt diese fest.</summary>
        <value>Eine Zeichenfolge, die den vom Client gesendeten HTTP-Aufruftyp darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpUtility.HtmlEncode%2A> -Methode verwendet, um den Wert <xref:System.Web.HttpRequest.RequestType%2A> der-Eigenschaft in HTML zu <xref:System.IO.TextWriter.WriteLine%2A> codieren, und die-Methode, um den codierten Wert in die Datei zu schreiben. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Web.HttpRequest> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAs">
      <MemberSignature Language="C#" Value="public void SaveAs (string filename, bool includeHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveAs(string filename, bool includeHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.SaveAs(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveAs (filename As String, includeHeaders As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveAs(System::String ^ filename, bool includeHeaders);" />
      <MemberSignature Language="F#" Value="member this.SaveAs : string * bool -&gt; unit" Usage="httpRequest.SaveAs (filename, includeHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="includeHeaders" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Der Pfad zum physischen Laufwerk.</param>
        <param name="includeHeaders">Ein boolescher Wert, der angibt, ob ein HTTP-Header auf dem Datenträger gespeichert werden soll.</param>
        <summary>Speichert eine HTTP-Anforderung auf dem Datenträger.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Speichern des Anforderungs Kontexts auf einem Datenträger kann beim Debuggen hilfreich sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpRequest.SaveAs%2A> -Methode aufgerufen, wenn eine Seite geladen wird. Der-Befehl gibt an, dass die Anforderung als Textdatei in einem Verzeichnis gespeichert werden soll, in dem die ASP.NET-Prozess Identität Schreibberechtigungen erteilt hat und dass alle in der Anforderung enthaltenen Header Informationen in der Datei enthalten sind.  
  
 [!code-csharp[System.Web.HttpRequest_Sample6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/cs/requestsample6cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/vb/requestsample6vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die <see cref="P:System.Web.Configuration.HttpRuntimeSection.RequireRootedSaveAsPath" />-Eigenschaft des <see cref="T:System.Web.Configuration.HttpRuntimeSection" /> wird auf <see langword="true" /> festgelegt, aber <paramref name="filename" /> ist kein absoluter Pfad.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection ServerVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection ServerVariables" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ServerVariables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServerVariables As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ ServerVariables { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServerVariables : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.ServerVariables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Webservervariablen ab.</summary>
        <value>Eine <see cref="T:System.Collections.Specialized.NameValueCollection" /> von Servervariablen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste der von IIS unterstützten Server Variablen finden Sie unter [IIS-Server Variablen](https://go.microsoft.com/fwlink/?LinkId=52471).  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Namen und Werte aller benannten Server Variablen an.  
  
 [!code-csharp[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimedOutToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken TimedOutToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken TimedOutToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TimedOutToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimedOutToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken TimedOutToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.TimedOutToken : System.Threading.CancellationToken" Usage="System.Web.HttpRequest.TimedOutToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Threading.CancellationToken" />-Objekt ab, das aktiviert wird, wenn eine Anforderung abgelaufen ist.</summary>
        <value>Das Abbruchtoken.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Timeout Zeitraum kann in der Datei "Web. config" (siehe <xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A?displayProperty=nameWithType>) oder Programm gesteuert angegeben werden <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType>(siehe). Der Timeout Zeitraum wird ab dem Zeitpunkt gemessen, an dem die Anforderung ankommt. Wenn das Standard Timeout von 110 Sekunden wirksam ist, wird das Abbruch Token nach Beginn der Anforderungs Verarbeitung nicht mehr als 110 Sekunden gekürzt. Sie können den <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType> Eigenschafts Wert ändern, und solange dieses Token noch nicht abgeschnitten wurde, wird der neue Timeout Wert berücksichtigt.  
  
 Derzeit bietet das Token nur eine Genauigkeit von 15 Sekunden, was bedeutet, dass das Token, wenn der Timeout Wert 110 Sekunden beträgt, zwischen 110 und 125 Sekunden nach Beginn der Anforderungs Verarbeitung gekürzt wird. Die Granularität kann sich in Zukunft ändern.  
  
 Obwohl diese Eigenschaft Thread sicher ist, gibt es Einschränkungen hinsichtlich ihrer Verwendung. Weitere Informationen finden Sie unter <xref:System.Web.HttpResponse.ClientDisconnectedToken%2A?displayProperty=nameWithType>.  
  
 Diese Eigenschaft ist bedeutungslos, wenn die Verarbeitung von websockets-Anforderungen gestartet wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TlsTokenBindingInfo">
      <MemberSignature Language="C#" Value="public System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TlsTokenBindingInfo As ITlsTokenBindingInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ITlsTokenBindingInfo ^ TlsTokenBindingInfo { System::Web::ITlsTokenBindingInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TlsTokenBindingInfo : System.Web.ITlsTokenBindingInfo" Usage="System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ITlsTokenBindingInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die TLS-Token-Bindungsinformationen ab. Die Eigenschaft ermöglicht Anwendungen das Abrufen von Tokeninformationen aus eingehenden HTTP-Anforderungen zur erweiterten Authentifizierung.</summary>
        <value>Das Bindungstoken für die aktuelle Verbindung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `null` auf nicht-Windows 10-Plattformen zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TotalBytes">
      <MemberSignature Language="C#" Value="public int TotalBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TotalBytes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TotalBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalBytes As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TotalBytes { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalBytes : int" Usage="System.Web.HttpRequest.TotalBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Bytes im aktuellen Eingabestream ab.</summary>
        <value>Die Anzahl der Bytes im Eingabestream.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird festgelegt <xref:System.Web.HttpRequest.TotalBytes%2A> , ob der-Eigenschafts Wert größer als 1000 Byte ist und diese Informationen in eine Datei schreibt.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#6)]
 [!code-vb[System.Web.HttpRequest_Sample1#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unvalidated">
      <MemberSignature Language="C#" Value="public System.Web.UnvalidatedRequestValues Unvalidated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UnvalidatedRequestValues Unvalidated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Unvalidated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Unvalidated As UnvalidatedRequestValues" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UnvalidatedRequestValues ^ Unvalidated { System::Web::UnvalidatedRequestValues ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unvalidated : System.Web.UnvalidatedRequestValues" Usage="System.Web.HttpRequest.Unvalidated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UnvalidatedRequestValues</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die HTTP-Anforderungswerte ab, ohne die Anforderungsvalidierung auszulösen.</summary>
        <value>Die HTTP-Anforderungswerte, die nicht mit der Anforderungsvalidierung überprüft wurden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anforderungs Überprüfung für HTML-Markup und-Skript, die möglicherweise auf einen potenziellen Website übergreifenden Scripting-Angriff hindeuten. Standardmäßig werden alle Werte mithilfe der Anforderungs Validierung überprüft. Wenn Werte ein Markup oder Skript enthalten, löst ASP.net eine <xref:System.Web.HttpRequestValidationException> Ausnahme aus. Verwenden Sie diese Methode, wenn Sie davon ausgehen, dass die Anforderung Markup enthalten soll (z. b. Wenn Sie Benutzern das Bereitstellen von Inhalten ermöglichen, die Markup enthalten), und dass Sie den Rohwert einer Anforderung erhalten möchten.  
  
> [!IMPORTANT]
>  Wenn Sie diese Eigenschaft verwenden, müssen Sie die Daten manuell auf mögliche Site übergreifende Skript Angriffe überprüfen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Web.HttpRequest.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Informationen über die URL der aktuellen Anforderung ab.</summary>
        <value>Ein <see cref="T:System.Uri" />-Objekt, das den URL der aktuelle Anforderung enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Uri> -Objekt der aktuellen Anforderung einer Objektvariablen zugewiesen, und der Wert von zwei Eigenschaften des URL-Objekts wird der HTTP-Ausgabe angezeigt.  
  
 [!code-csharp[Classic HttpRequest.Url Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Url Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Url Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Url Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Uri" />
        <altmember cref="P:System.Web.HttpRequest.RawUrl" />
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UrlReferrer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UrlReferrer As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UrlReferrer { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UrlReferrer : Uri" Usage="System.Web.HttpRequest.UrlReferrer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Informationen zur URL der vorhergehenden Anforderung des Clients ab, die mit der aktuellen URL verknüpft ist.</summary>
        <value>Ein <see cref="T:System.Uri" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird der Wert von zwei Eigenschaften der URL angezeigt, die den Client an die aktuelle Anwendung verwiesen hat.  
  
 [!code-csharp[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">Der HTTP-<see langword="Referer" />-Anforderungsheader ist fehlerhaft und kann nicht in ein <see cref="T:System.Uri" />-Objekt konvertiert werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string" Usage="System.Web.HttpRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die unformatierte Benutzer-Agent-Zeichenfolge des Clientbrowsers ab, der angegeben wurde. Beachten Sie, dass der Wert auch NULL sein kann.</summary>
        <value>Die unformatierte User-Agent-Zeichenfolge des Clientbrowsers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die Typidentifizierung des anfordernden Browsers einer Zeichen folgen Variablen zugewiesen.  
  
 [!code-csharp[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <related type="Article" href="https://msdn.microsoft.com/library/143d14d6-9d12-4d4b-ae60-f00e0eb6938f">ASP.NET-Server Steuerelemente und Browser Funktionen</related>
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostAddress { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostAddress : string" Usage="System.Web.HttpRequest.UserHostAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die IP-Hostadresse des Remoteclients ab.</summary>
        <value>Die IP-Adresse des Remoteclients.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpUtility.HtmlEncode%2A> -Methode verwendet, um den Wert <xref:System.Web.HttpRequest.UserHostAddress%2A> der-Eigenschaft in HTML zu <xref:System.IO.TextWriter.WriteLine%2A> codieren, und die-Methode, um den codierten Wert in die Datei zu schreiben. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Web.HttpRequest> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostName : string" Usage="System.Web.HttpRequest.UserHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den DNS-Namen des Remoteclients ab.</summary>
        <value>Der DNS-Name des Remoteclients.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.HttpUtility.HtmlEncode%2A> -Methode verwendet, um den Wert <xref:System.Web.HttpRequest.UserHostName%2A> der-Eigenschaft in HTML zu <xref:System.IO.TextWriter.WriteLine%2A> codieren, und die-Methode, um den codierten Wert in die Datei zu schreiben. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Web.HttpRequest> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserLanguages" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserLanguages As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ UserLanguages { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserLanguages : string[]" Usage="System.Web.HttpRequest.UserLanguages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein sortiertes Zeichenfolgenarray mit Clientspracheinstellungen ab.</summary>
        <value>Ein sortiertes Zeichenfolgenarray mit Clientspracheinstellungen, oder <see langword="null" />, wenn dieses leer ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel werden die von der <xref:System.Web.HttpRequest.UserLanguages%2A> -Eigenschaft zurückgegebenen verschiedenen Werte in ein Zeichen folgen Array erfasst und jeder sprach Name in eine separate Zeile der HTTP-Ausgabe geschrieben.  
  
 Die Sprachnamen werden vom Browser bereitgestellt, und es ist keine definitive Liste aller möglichen Codes vorhanden.  In der Regel bestehen diese aus zwei Zeichen Codes für die Sprache, einem Bindestrich und einem aus zwei Zeichen bestehende Code für die Kultur, z. b. "en-US" für US-Englisch und "fr-ca" für Französisch (Kanada).  
  
 [!code-csharp[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateInput">
      <MemberSignature Language="C#" Value="public void ValidateInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.ValidateInput" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateInput ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateInput();" />
      <MemberSignature Language="F#" Value="member this.ValidateInput : unit -&gt; unit" Usage="httpRequest.ValidateInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt Validierung für die Auflistungen, auf die über die Eigenschaften <see cref="P:System.Web.HttpRequest.Cookies" />, <see cref="P:System.Web.HttpRequest.Form" /> und <see cref="P:System.Web.HttpRequest.QueryString" /> zugegriffenen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.HttpRequest> -Klasse verwendet Eingabe Validierungs Flags, um zu überprüfen, ob die Anforderungs Auflistungen <xref:System.Web.HttpRequest.Cookies%2A>, auf die <xref:System.Web.HttpRequest.QueryString%2A> über die Eigenschaften, und zugegriffen wird <xref:System.Web.HttpRequest.Form%2A>, validiert werden. Die <xref:System.Web.HttpRequest.ValidateInput%2A> -Methode legt diese Flags so fest, dass beim Aufrufen der get <xref:System.Web.HttpRequest.Cookies%2A>-Accessoren <xref:System.Web.HttpRequest.QueryString%2A> für die-, <xref:System.Web.HttpRequest.Form%2A>-oder-Eigenschaft eine Eingabevalidierung durchgeführt wird. Die Validierung funktioniert, indem alle Eingabedaten anhand einer hart codierten Liste potenziell gefährlicher Daten überprüft werden.  
  
 Wenn das Validierungs Feature durch eine Seiten Direktive oder eine Konfiguration aktiviert ist, wird diese Methode während der `ProcessRequest` Verarbeitungsphase der Seite aufgerufen. Die <xref:System.Web.HttpRequest.ValidateInput%2A> -Methode kann von Ihrem Code aufgerufen werden, wenn das Validierungs Feature nicht aktiviert ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpRequestValidationException">Vom Client wurden Daten empfangen, die möglicherweise gefährlich sind.</exception>
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
  </Members>
</Type>
