<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c200bb14e9b286622509ade5fbfb3ca3adb9b4db" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69099117" /></Metadata><TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="F#" Value="type Task = class&#xA;    interface IAsyncResult&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="f3af1-101">Stellt einen asynchronen Vorgang dar.</span><span class="sxs-lookup"><span data-stu-id="f3af1-101">Represents an asynchronous operation.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 <span data-ttu-id="f3af1-102">Die <xref:System.Threading.Tasks.Task> -Klasse stellt einen einzelnen Vorgang dar, der keinen Wert zurückgibt und in der Regel asynchron ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-102">The <xref:System.Threading.Tasks.Task> class represents a single operation that does not return a value and that usually executes asynchronously.</span></span> <span data-ttu-id="f3af1-103"><xref:System.Threading.Tasks.Task>Objekte sind eine der zentralen Komponenten des [aufgabenbasierten asynchronen Musters](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) , das erstmals in der .NET Framework 4 eingeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-103"><xref:System.Threading.Tasks.Task> objects are one of the central components of the  [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) first introduced in the .NET Framework 4.</span></span> <span data-ttu-id="f3af1-104"><xref:System.Threading.Tasks.Task> Da die von einem-Objekt ausgeführte Arbeit in der Regel asynchron in einem Thread Pool Thread anstatt synchron im Hauptanwendungs Thread ausgeführt wird, können Sie die <xref:System.Threading.Tasks.Task.Status%2A> -Eigenschaft <xref:System.Threading.Tasks.Task.IsCompleted%2A>sowie die- <xref:System.Threading.Tasks.Task.IsCanceled%2A>Eigenschaft, die-Eigenschaft und die-Eigenschaft verwenden. <xref:System.Threading.Tasks.Task.IsFaulted%2A> Eigenschaften, um den Status einer Aufgabe zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-104">Because the work performed by a <xref:System.Threading.Tasks.Task> object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the <xref:System.Threading.Tasks.Task.Status%2A> property, as well as the <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, and <xref:System.Threading.Tasks.Task.IsFaulted%2A> properties, to determine the   state of a task.</span></span> <span data-ttu-id="f3af1-105">In den meisten Fällen wird ein Lambda-Ausdruck verwendet, um die Arbeit anzugeben, die vom Task ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-105">Most commonly, a lambda expression is used to specify the work that the task is to perform.</span></span>  
  
 <span data-ttu-id="f3af1-106">Für Vorgänge, die Werte zurückgeben, verwenden <xref:System.Threading.Tasks.Task%601> Sie die-Klasse.</span><span class="sxs-lookup"><span data-stu-id="f3af1-106">For operations that return values, you use the <xref:System.Threading.Tasks.Task%601> class.</span></span>  
  
 <span data-ttu-id="f3af1-107">In diesem Abschnitt</span><span class="sxs-lookup"><span data-stu-id="f3af1-107">In this section:</span></span>  
  
 <span data-ttu-id="f3af1-108">[Beispiele für die Instanziierung von Aufgaben](#Instant) </span><span class="sxs-lookup"><span data-stu-id="f3af1-108">[Task instantiation examples](#Instant) </span></span>  
 <span data-ttu-id="f3af1-109">[Erstellen und Ausführen einer Aufgabe](#Creating) </span><span class="sxs-lookup"><span data-stu-id="f3af1-109">[Creating and executing a task](#Creating) </span></span>  
 <span data-ttu-id="f3af1-110">[Trennen der Aufgaben Erstellung und-Ausführung](#Separating) </span><span class="sxs-lookup"><span data-stu-id="f3af1-110">[Separating task creation and execution](#Separating) </span></span>  
 <span data-ttu-id="f3af1-111">[Es wird auf den Abschluss einer oder mehrerer Aufgaben gewartet.](#WaitingForOne) </span><span class="sxs-lookup"><span data-stu-id="f3af1-111">[Waiting for one or more tasks to complete](#WaitingForOne) </span></span>  
 <span data-ttu-id="f3af1-112">[Aufgaben und Kultur](#Culture) </span><span class="sxs-lookup"><span data-stu-id="f3af1-112">[Tasks and culture](#Culture) </span></span>  
 [<span data-ttu-id="f3af1-113">Für Debugger-Entwickler</span><span class="sxs-lookup"><span data-stu-id="f3af1-113">For debugger developers</span></span>](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a><span data-ttu-id="f3af1-114">Task Instantiierung</span><span class="sxs-lookup"><span data-stu-id="f3af1-114">Task instantiation</span></span>  
 <span data-ttu-id="f3af1-115">Im folgenden Beispiel werden vier Aufgaben erstellt und ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-115">The following example creates and executes four tasks.</span></span> <span data-ttu-id="f3af1-116">Drei Tasks führen einen <xref:System.Action%601> Delegaten `action`mit dem Namen aus, der ein <xref:System.Object>Argument vom Typ akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="f3af1-116">Three tasks execute an <xref:System.Action%601> delegate named `action`, which accepts an argument of type <xref:System.Object>.</span></span> <span data-ttu-id="f3af1-117">Eine vierte Aufgabe führt einen Lambda Ausdruck (einen <xref:System.Action> -Delegaten) aus, der Inline im Aufruf der Task Erstellungs Methode definiert wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-117">A fourth task executes a lambda expression (an <xref:System.Action> delegate) that is defined inline in the call to the task creation method.</span></span> <span data-ttu-id="f3af1-118">Jede Aufgabe wird auf andere Weise instanziiert und ausgeführt:</span><span class="sxs-lookup"><span data-stu-id="f3af1-118">Each task is instantiated and run in a different way:</span></span>  
  
-   <span data-ttu-id="f3af1-119">Der `t1` Task wird durch Aufrufen eines taskklassenkonstruktors instanziiert, wird jedoch durch Aufrufen <xref:System.Threading.Tasks.Task.Start> der-Methode erst `t2` gestartet, nachdem die Aufgabe gestartet wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-119">Task `t1` is instantiated by calling a Task class constructor, but is started by calling its <xref:System.Threading.Tasks.Task.Start> method only after task `t2` has started.</span></span>  
  
-   <span data-ttu-id="f3af1-120">Der `t2` Task wird in einem einzelnen Methodenaufruf instanziiert und gestartet, indem <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> die-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-120">Task `t2` is instantiated and started in a single method call by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="f3af1-121">Der `t3` Task wird in einem einzelnen Methodenaufruf instanziiert und gestartet, indem <xref:System.Threading.Tasks.Task.Run%28System.Action%29> die-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-121">Task `t3` is instantiated and started in a single method call by calling the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span>  
  
-   <span data-ttu-id="f3af1-122">Der `t4` Task wird im Haupt Thread synchron ausgeführt, indem die <xref:System.Threading.Tasks.Task.RunSynchronously> -Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-122">Task `t4` is executed synchronously on the main thread by calling the <xref:System.Threading.Tasks.Task.RunSynchronously> method.</span></span>  
  
 <span data-ttu-id="f3af1-123">Da die `t4` Aufgabe synchron ausgeführt wird, wird Sie im Hauptanwendungs Thread ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-123">Because task `t4` executes synchronously, it executes on the main application thread.</span></span> <span data-ttu-id="f3af1-124">Die restlichen Aufgaben werden in der Regel asynchron in einem oder mehreren Threads des Thread Pools ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-124">The remaining tasks execute asynchronously typically on one or more thread pool threads.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a><span data-ttu-id="f3af1-125">Erstellen und Ausführen einer Aufgabe</span><span class="sxs-lookup"><span data-stu-id="f3af1-125">Creating and executing a task</span></span>  
 <span data-ttu-id="f3af1-126"><xref:System.Threading.Tasks.Task>Instanzen können auf verschiedene Arten erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-126"><xref:System.Threading.Tasks.Task> instances may be created in a variety of ways.</span></span> <span data-ttu-id="f3af1-127">Der häufigste Ansatz, der ab [!INCLUDE[net_v45](~/includes/net-v45-md.md)]verfügbar ist, besteht darin, die statische <xref:System.Threading.Tasks.Task.Run%2A> -Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-127">The most common approach, which is available starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], is to call the static <xref:System.Threading.Tasks.Task.Run%2A> method.</span></span> <span data-ttu-id="f3af1-128">Die <xref:System.Threading.Tasks.Task.Run%2A> -Methode bietet eine einfache Möglichkeit, um eine Aufgabe mit Standardwerten zu starten, ohne dass zusätzliche Parameter erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="f3af1-128">The <xref:System.Threading.Tasks.Task.Run%2A> method provides a simple way to start a task using default values and without requiring additional parameters.</span></span> <span data-ttu-id="f3af1-129">Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.Run%28System.Action%29> -Methode verwendet, um eine Aufgabe zu starten, die eine Schleife durchläuft und dann die Anzahl der Schleifen Iterationen anzeigt:</span><span class="sxs-lookup"><span data-stu-id="f3af1-129">The following example uses the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method to start a task that loops and then displays the number of loop iterations:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 <span data-ttu-id="f3af1-130">Eine Alternative und die gängigste Methode zum Starten einer Aufgabe in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]ist die statische <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="f3af1-130">An alternative, and the most common method to start a task in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], is the static <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f3af1-131">Die <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> -Eigenschaft gibt <xref:System.Threading.Tasks.TaskFactory> ein-Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-131">The <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> property returns a <xref:System.Threading.Tasks.TaskFactory> object.</span></span> <span data-ttu-id="f3af1-132">Über Ladungen der <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> -Methode können Sie Parameter angeben, die an die Aufgaben Erstellungs Optionen und einen Aufgabenplaner übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-132">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method let you specify parameters to pass to the task creation options and a task scheduler.</span></span> <span data-ttu-id="f3af1-133">Im folgenden Beispiel wird die <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> -Methode verwendet, um eine Aufgabe zu starten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-133">The following example uses the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method to start a task.</span></span> <span data-ttu-id="f3af1-134">Es ist funktional äquivalent zum Code im vorherigen Beispiel.</span><span class="sxs-lookup"><span data-stu-id="f3af1-134">It is functionally equivalent to the code in the previous example.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 <span data-ttu-id="f3af1-135">Ausführlichere Beispiele finden Sie unter [aufgabenbasierte asynchrone Programmierung](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-135">For more complete examples, see [Task-based Asynchronous Programming](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).</span></span>  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a><span data-ttu-id="f3af1-136">Trennen der Aufgaben Erstellung und-Ausführung</span><span class="sxs-lookup"><span data-stu-id="f3af1-136">Separating task creation and execution</span></span>  
 <span data-ttu-id="f3af1-137">Die <xref:System.Threading.Tasks.Task> -Klasse stellt auch Konstruktoren bereit, die die Aufgabe initialisieren, diese aber nicht für die Ausführung planen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-137">The <xref:System.Threading.Tasks.Task> class also provides constructors that initialize the task but that do not schedule it for execution.</span></span> <span data-ttu-id="f3af1-138">Aus Leistungsgründen ist die <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> - <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode oder die-Methode der bevorzugte Mechanismus zum Erstellen und Planen von Rechenaufgaben. in Szenarios, in denen die Erstellung und die Zeitplanung getrennt werden müssen, können Sie jedoch die-Konstruktoren verwenden und dann die <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> Methode, um den Task zu einem späteren Zeitpunkt für die Ausführung zu planen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-138">For performance reasons, the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method is the preferred mechanism for creating and scheduling computational tasks, but for scenarios where creation and scheduling must be separated, you can use the constructors and then call the <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> method to schedule the task for execution at a later time.</span></span>  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a><span data-ttu-id="f3af1-139">Es wird auf den Abschluss einer oder mehrerer Aufgaben gewartet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-139">Waiting for one or more tasks to complete</span></span>  
 <span data-ttu-id="f3af1-140">Da Aufgaben in der Regel asynchron in einem Thread Pool Thread ausgeführt werden, wird der Thread, der die Aufgabe erstellt und startet, mit der Ausführung fortgesetzt, sobald die Aufgabe instanziiert wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-140">Because tasks typically run asynchronously on a thread pool thread, the thread that creates and starts the task continues execution as soon as the task has been instantiated.</span></span> <span data-ttu-id="f3af1-141">In einigen Fällen, wenn der aufrufenden Thread der Hauptanwendungs Thread ist, kann die APP beendet werden, bevor die Ausführung der Aufgabe tatsächlich beginnt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-141">In some cases, when the calling thread is the main application thread, the app may terminate before any the task actually begins execution.</span></span> <span data-ttu-id="f3af1-142">In anderen Fällen kann es bei der Logik ihrer Anwendung erforderlich sein, dass der aufrufenden Thread die Ausführung nur dann fortsetzt, wenn eine oder mehrere Tasks die Ausführung abgeschlossen haben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-142">In others,   your application's logic may require that the calling thread continue execution only when one or more tasks has completed execution.</span></span> <span data-ttu-id="f3af1-143">Sie können die Ausführung des aufrufenden Threads und der asynchronen Aufgaben, die gestartet werden, synchronisieren `Wait` , indem Sie eine Methode aufrufen, die auf den Abschluss einer oder mehrerer Tasks wartet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-143">You can synchronize the execution of the calling thread and the asynchronous tasks it launches by calling a `Wait` method to wait for one or more tasks to complete.</span></span>  
  
 <span data-ttu-id="f3af1-144">Um auf den Abschluss einer einzelnen Aufgabe zu warten, können Sie die <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> zugehörige-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-144">To wait for a single task to complete, you can call its <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f3af1-145">Ein Aufruf der <xref:System.Threading.Tasks.Task.Wait%2A> -Methode blockiert den aufrufenden Thread, bis die Ausführung der einzelnen Klasseninstanz abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-145">A call to the  <xref:System.Threading.Tasks.Task.Wait%2A> method blocks the calling thread until the single class instance has completed execution.</span></span>  
  
 <span data-ttu-id="f3af1-146">Im folgenden Beispiel wird die Parameter lose <xref:System.Threading.Tasks.Task.Wait> -Methode aufgerufen, um bedingungslos zu warten, bis eine Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-146">The following example calls the parameterless <xref:System.Threading.Tasks.Task.Wait> method to wait unconditionally until a task completes.</span></span> <span data-ttu-id="f3af1-147">Der Task simuliert die Arbeit, indem die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> -Methode aufgerufen wird, um zwei Sekunden lang in den Standbymodus</span><span class="sxs-lookup"><span data-stu-id="f3af1-147">The task simulates work by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to sleep for two seconds.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 <span data-ttu-id="f3af1-148">Sie können auch bedingt auf den Abschluss einer Aufgabe warten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-148">You can also conditionally wait for a task to complete.</span></span> <span data-ttu-id="f3af1-149">Die <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> - <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> Methode und die-Methode blockieren den aufrufenden Thread, bis die Aufgabe abgeschlossen oder ein Timeout Intervall abläuft, je nachdem, was zuerst eintritt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-149">The <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> and <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> methods block the calling thread until the task finishes or a timeout interval elapses, whichever comes first.</span></span> <span data-ttu-id="f3af1-150">Da im folgenden Beispiel eine Aufgabe gestartet wird, die für zwei Sekunden gesperrt ist, aber einen Timeout Wert von einer Sekunde definiert, wird der aufrufende Thread blockiert, bis das Timeout abläuft und bevor die Ausführung der Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-150">Since the following example launches a task that sleeps for two seconds but defines a one-second timeout value, the calling thread blocks until the timeout expires and before the task has completed execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 <span data-ttu-id="f3af1-151">Sie können auch ein Abbruch Token angeben, indem Sie <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> die <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> -Methode und die-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-151">You can also supply a cancellation token by calling the <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> and  <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> methods.</span></span> <span data-ttu-id="f3af1-152">Wenn die-Eigenschaft <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> des Tokens `true` ist oder `true` während die <xref:System.Threading.Tasks.Task.Wait%2A> -Methode ausgeführt wird, löst die Methode <xref:System.OperationCanceledException>eine aus.</span><span class="sxs-lookup"><span data-stu-id="f3af1-152">If the  token's <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true` or becomes `true` while the <xref:System.Threading.Tasks.Task.Wait%2A> method is executing, the method throws an <xref:System.OperationCanceledException>.</span></span>  
  
 <span data-ttu-id="f3af1-153">In einigen Fällen möchten Sie möglicherweise warten, bis die erste Ausführung einer Reihe von Tasks ausgeführt wird, aber es ist nicht wichtig, welche Aufgabe es ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-153">In some cases, you may want to wait for the first of a series of executing tasks to complete, but don't care which task it is.</span></span>  <span data-ttu-id="f3af1-154">Zu diesem Zweck können Sie eine der über Ladungen der <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> -Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-154">For this purpose, you can call one of the overloads of the <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="f3af1-155">Im folgenden Beispiel werden drei Aufgaben erstellt, die jeweils für ein Intervall, das von einem Zufallszahlengenerator bestimmt wird, in Ruhezustand sind.</span><span class="sxs-lookup"><span data-stu-id="f3af1-155">The following example creates three tasks, each of which sleeps for an interval determine by a random number generator.</span></span> <span data-ttu-id="f3af1-156">Die <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> -Methode wartet, bis die erste Aufgabe beendet ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-156">The <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> method waits for the first task to complete.</span></span> <span data-ttu-id="f3af1-157">Im Beispiel werden dann Informationen zum Status aller drei Aufgaben angezeigt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-157">The example then displays information about the status of all three tasks.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 <span data-ttu-id="f3af1-158">Sie können auch warten, bis eine Reihe von Aufgaben durch Aufrufen der <xref:System.Threading.Tasks.Task.WaitAll%2A> -Methode vollständig ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-158">You can also wait for all of a series of tasks to complete by calling the <xref:System.Threading.Tasks.Task.WaitAll%2A> method.</span></span> <span data-ttu-id="f3af1-159">Im folgenden Beispiel werden zehn Tasks erstellt, auf den Abschluss aller zehn Tasks gewartet und dann der Status angezeigt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-159">The following example creates ten tasks, waits for all ten to complete, and then displays their status.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 <span data-ttu-id="f3af1-160">Beachten Sie, dass beim Warten auf den Abschluss einer oder mehrerer Aufgaben alle Ausnahmen, die in den ausgelaufenden Tasks ausgelöst werden, in dem Thread `Wait` weitergegeben werden, der die-Methode aufruft, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-160">Note that when you wait for one or more tasks to complete, any exceptions thrown in the running tasks are propagated on the thread that calls the `Wait` method, as the following example shows.</span></span> <span data-ttu-id="f3af1-161">Dabei werden 12 Aufgaben gestartet, von denen drei normal ausgeführt werden und drei eine Ausnahme auslösen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-161">It launches 12 tasks, three of which complete normally and three of which throw an exception.</span></span> <span data-ttu-id="f3af1-162">Von den verbleibenden sechs Aufgaben werden drei abgebrochen, bevor Sie gestartet werden, und drei werden während der Ausführung abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-162">Of the remaining six tasks, three are cancelled before they start, and three are cancelled while they are executing.</span></span> <span data-ttu-id="f3af1-163">Ausnahmen werden im <xref:System.Threading.Tasks.Task.WaitAll%2A> Methodenaufrufe ausgelöst und von / einem `try` `catch` -Block behandelt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-163">Exceptions are thrown in the <xref:System.Threading.Tasks.Task.WaitAll%2A> method call and are handled by a `try`/`catch` block.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 <span data-ttu-id="f3af1-164">Weitere Informationen zur Ausnahmebehandlung in aufgabenbasierten asynchronen Vorgängen finden Sie unter [Ausnahmebehandlung](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-164">For more information on exception handling in task-based asynchronous operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a><span data-ttu-id="f3af1-165">Aufgaben und Kultur</span><span class="sxs-lookup"><span data-stu-id="f3af1-165">Tasks and culture</span></span>  
 <span data-ttu-id="f3af1-166">Beginnend mit Desktop-Apps, die [!INCLUDE[net_v46](~/includes/net-v46-md.md)]auf ausgerichtet sind, wird die Kultur des Threads, der einen Task erstellt und aufruft, Teil des Thread Kontexts.</span><span class="sxs-lookup"><span data-stu-id="f3af1-166">Starting with desktop apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the culture of the thread that creates and invokes a task becomes part of the thread's context.</span></span> <span data-ttu-id="f3af1-167">Das heißt, unabhängig von der aktuellen Kultur des Threads, in dem die Aufgabe ausgeführt wird, ist die aktuelle Kultur der Aufgabe die Kultur des aufrufenden Threads.</span><span class="sxs-lookup"><span data-stu-id="f3af1-167">That is, regardless of the current culture of the thread on which the task executes, the current culture of the task is the culture of the calling thread.</span></span> <span data-ttu-id="f3af1-168">Für apps, die auf Versionen des .NET Framework vor dem [!INCLUDE[net_v46](~/includes/net-v46-md.md)]abzielen, ist die Kultur der Aufgabe die Kultur des Threads, in dem die Aufgabe ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-168">For apps that target versions of the .NET Framework prior to the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the culture of the task is the culture of the thread on which the task executes.</span></span> <span data-ttu-id="f3af1-169">Weitere Informationen finden Sie im Abschnitt "Kultur und aufgabenbasierte asynchrone Vorgänge" im <xref:System.Globalization.CultureInfo> Thema.</span><span class="sxs-lookup"><span data-stu-id="f3af1-169">For more information, see the "Culture and task-based asynchronous operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f3af1-170">Store-Apps folgen den Windows-Runtime unter Festlegen und erhalten der Standard Kultur.</span><span class="sxs-lookup"><span data-stu-id="f3af1-170">Store apps follow the Windows Runtime in setting and getting the default culture.</span></span>  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a><span data-ttu-id="f3af1-171">Für Debugger-Entwickler</span><span class="sxs-lookup"><span data-stu-id="f3af1-171">For debugger developers</span></span>  
 <span data-ttu-id="f3af1-172">Für Entwickler, die benutzerdefinierte debuggger implementieren, können mehrere interne und private Member der Aufgabe nützlich sein (diese können sich von Release zu Release ändern).</span><span class="sxs-lookup"><span data-stu-id="f3af1-172">For developers implementing custom debuggers, several internal and private members of task may be useful (these may change from release to release).</span></span> <span data-ttu-id="f3af1-173">Das `m_taskId` Feld dient als Sicherungs Speicher für die <xref:System.Threading.Tasks.Task.Id%2A> Eigenschaft. der Zugriff auf dieses Feld direkt von einem Debugger kann jedoch effizienter sein als der Zugriff auf denselben Wert über die Getter-Methode der Eigenschaft `s_taskIdCounter` (der Leistungs Bewert ist wird zum Abrufen der nächsten verfügbaren ID für einen Task verwendet.)</span><span class="sxs-lookup"><span data-stu-id="f3af1-173">The `m_taskId` field serves as the backing store for the <xref:System.Threading.Tasks.Task.Id%2A> property, however accessing this field directly from a debugger may be more efficient than accessing the same value through the property's getter method (the `s_taskIdCounter` counter is used to retrieve the next available ID for a task).</span></span> <span data-ttu-id="f3af1-174">Entsprechend speichert das `m_stateFlags` Feldinformationen zur aktuellen Lebenszyklusphase der Aufgabe, auf die auch über die <xref:System.Threading.Tasks.Task.Status%2A> -Eigenschaft zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="f3af1-174">Similarly, the `m_stateFlags` field stores information about the current lifecycle stage of the task, information also accessible through the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span> <span data-ttu-id="f3af1-175">Im `m_action` Feld wird ein Verweis auf den Delegaten der Aufgabe gespeichert, `m_stateObject` und im Feld wird der asynchrone Zustand gespeichert, der vom Entwickler an die Aufgabe übermittelt wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-175">The `m_action` field stores a reference to the task's delegate, and the `m_stateObject` field stores the async state passed to the task by the developer.</span></span> <span data-ttu-id="f3af1-176">Schließlich stellt die-Methode für debuggger, die Stapel Rahmen `InternalWait` analysieren, eine potenzielle Markierung für den Fall dar, dass eine Aufgabe in einen Warte Vorgang wechselt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-176">Finally, for debuggers that parse stack frames, the `InternalWait` method serves a potential marker for when a task is entering a wait operation.</span></span>   
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="f3af1-177">Alle Elemente von <see cref="T:System.Threading.Tasks.Task" />, mit Ausnahme <see cref="M:System.Threading.Tasks.Task.Dispose" />von, sind Thread sicher und können von mehreren Threads gleichzeitig verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-177">All members of <see cref="T:System.Threading.Tasks.Task" />, except for <see cref="M:System.Threading.Tasks.Task.Dispose" />, are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="f3af1-178">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="f3af1-178">Task Parallel Library (TPL)</span></span></related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="f3af1-179">Aufgabenbasierte asynchrone Programmierung</span><span class="sxs-lookup"><span data-stu-id="f3af1-179">Task-based Asynchronous Programming</span></span></related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364"><span data-ttu-id="f3af1-180">Beispiele für die parallele Programmierung mit dem .NET Framework</span><span class="sxs-lookup"><span data-stu-id="f3af1-180">Samples for Parallel Programming with the .NET Framework</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f3af1-181">Initialisiert eine neue <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-181">Initializes a new <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="f3af1-182">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-182">The delegate that represents the code to execute in the task.</span></span></param>
        <summary><span data-ttu-id="f3af1-183">Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit der angegebenen Aktion.</span><span class="sxs-lookup"><span data-stu-id="f3af1-183">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-184">Dieser Konstruktor sollte nur in erweiterten Szenarien verwendet werden, in denen es erforderlich ist, dass die Erstellung und der Start der Aufgabe getrennt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-184">This constructor should only be used in advanced scenarios where it is required that the creation and starting of the task is separated.</span></span>  
  
 <span data-ttu-id="f3af1-185">Anstatt diesen Konstruktor aufzurufen, ist die gängigste Methode zum Instanziieren <xref:System.Threading.Tasks.Task> eines-Objekts und zum Starten einer Aufgabe das Aufrufen <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> der <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> statischen-Methode oder der-Methode.</span><span class="sxs-lookup"><span data-stu-id="f3af1-185">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f3af1-186">Wenn eine Aufgabe ohne Aktion nur für den Consumer einer API erforderlich ist, um etwas zu erwarten, sollte eine <xref:System.Threading.Tasks.TaskCompletionSource%601> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-186">If a task with no action is needed just for the consumer of an API to have something to await, a <xref:System.Threading.Tasks.TaskCompletionSource%601> should be used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-187">Im folgenden Beispiel wird der <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> -Konstruktor verwendet, um Tasks zu erstellen, die die Dateinamen in angegebenen Verzeichnissen abrufen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-187">The following example uses the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> constructor to create tasks that retrieve the filenames in specified directories.</span></span> <span data-ttu-id="f3af1-188">Alle Tasks schreiben die Dateinamen in ein einzelnes <xref:System.Collections.Concurrent.ConcurrentBag%601> Objekt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-188">All tasks write the file names to a single <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span> <span data-ttu-id="f3af1-189">Das Beispiel ruft dann die <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> -Methode auf, um sicherzustellen, dass alle Aufgaben abgeschlossen sind, und zeigt dann die Gesamtzahl der in das <xref:System.Collections.Concurrent.ConcurrentBag%601> -Objekt geschriebenen Dateinamen an.</span><span class="sxs-lookup"><span data-stu-id="f3af1-189">The example then calls the <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 <span data-ttu-id="f3af1-190">Das folgende Beispiel ist identisch, mit der Ausnahme, dass <xref:System.Threading.Tasks.Task.Run%28System.Action%29> es die-Methode verwendet, um die Aufgabe in einem einzelnen Vorgang zu instanziieren und auszuführen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-190">The following example is identical, except that it used the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method to instantiate and run the task in a single operation.</span></span> <span data-ttu-id="f3af1-191">Die-Methode gibt <xref:System.Threading.Tasks.Task> das Objekt zurück, das die Aufgabe darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-191">The method returns the <xref:System.Threading.Tasks.Task> object that represents the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-192">Das <paramref name="action" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-192">The <paramref name="action" /> argument is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="f3af1-193">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-193">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-194">Das <see cref="T:System.Threading.CancellationToken" />, das die neue Aufgabe berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-194">The <see cref="T:System.Threading.CancellationToken" /> that the new  task will observe.</span></span></param>
        <summary><span data-ttu-id="f3af1-195">Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit der angegebenen Aktion und <see cref="T:System.Threading.CancellationToken" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-195">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and <see cref="T:System.Threading.CancellationToken" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-196">Anstatt diesen Konstruktor aufzurufen, ist die gängigste Methode zum Instanziieren <xref:System.Threading.Tasks.Task> eines-Objekts und zum Starten einer Aufgabe das Aufrufen <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> der <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> statischen-Methode und der-Methode.</span><span class="sxs-lookup"><span data-stu-id="f3af1-196">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="f3af1-197">Der einzige von diesem Konstruktor angebotene Vorteil besteht darin, dass die Objekt Instanziierung von einem Task Aufruf getrennt werden kann.</span><span class="sxs-lookup"><span data-stu-id="f3af1-197">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 <span data-ttu-id="f3af1-198">Weitere Informationen finden Sie unter [Aufgaben Parallelität (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) und [Abbruch in verwalteten Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-198">For more information, see [Task Parallelism (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Cancellation in Managed Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-199">Im folgenden Beispiel wird der <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> -Konstruktor aufgerufen, um eine Aufgabe zu erstellen, die die Dateien im Verzeichnis c:\Windows\System32 durchläuft.</span><span class="sxs-lookup"><span data-stu-id="f3af1-199">The following example calls the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> constructor to create a task that iterates the files in the C:\Windows\System32 directory.</span></span> <span data-ttu-id="f3af1-200">Der Lambda-Ausdruck ruft <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> die-Methode auf, um einem <xref:System.Collections.Generic.List%601> -Objektinformationen zu jeder Datei hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-200">The lambda expression calls the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to add information about each  file to a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="f3af1-201">Jede von der-Schleife aufgerufene getrennte <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> , von der-Schleife aufgerufene Aufgabe überprüft den Status des Abbruch Tokens und ruft, <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> wenn der Abbruch angefordert wird, die-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="f3af1-201">Each detached nested task invoked by the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> loop checks the state of the cancellation token and, if cancellation is requested, calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f3af1-202">Die <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> -Methode löst <xref:System.OperationCanceledException> eine Ausnahme aus, die in `catch` einem-Block behandelt wird, wenn <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> der aufrufende Thread die-Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="f3af1-202">The <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method throws an <xref:System.OperationCanceledException> exception that is handled in a `catch` block when the calling thread calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="f3af1-203">Anschließend <xref:System.Threading.Tasks.Task.Start%2A> wird die-Methode aufgerufen, um die Aufgabe zu starten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-203">The <xref:System.Threading.Tasks.Task.Start%2A> method is then called to start the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-204">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-204">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-205">Das <paramref name="action" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-205">The <paramref name="action" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="f3af1-206">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-206">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="f3af1-207">Das <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, das verwendet wird, um das Verhalten der Aufgabe zu ändern.</span><span class="sxs-lookup"><span data-stu-id="f3af1-207">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="f3af1-208">Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion und Erstellungsoptionen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-208">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and creation options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-209">Anstatt diesen Konstruktor aufzurufen, ist die gängigste Methode zum Instanziieren <xref:System.Threading.Tasks.Task> eines-Objekts und zum Starten einer Aufgabe das Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> der statischen-Methode.</span><span class="sxs-lookup"><span data-stu-id="f3af1-209">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f3af1-210">Der einzige von diesem Konstruktor angebotene Vorteil besteht darin, dass die Objekt Instanziierung von einem Task Aufruf getrennt werden kann.</span><span class="sxs-lookup"><span data-stu-id="f3af1-210">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-211">Das <paramref name="action" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-211">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-212">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> an.</span><span class="sxs-lookup"><span data-stu-id="f3af1-212">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="f3af1-213">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-213">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="f3af1-214">Ein Objekt, das Daten darstellt, die von der Aktion verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-214">An object representing data to be used by the action.</span></span></param>
        <summary><span data-ttu-id="f3af1-215">Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion und Zustand.</span><span class="sxs-lookup"><span data-stu-id="f3af1-215">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-216">Anstatt diesen Konstruktor aufzurufen, ist die gängigste Methode zum Instanziieren <xref:System.Threading.Tasks.Task> eines-Objekts und zum Starten einer Aufgabe das Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> der statischen-Methode.</span><span class="sxs-lookup"><span data-stu-id="f3af1-216">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f3af1-217">Der einzige von diesem Konstruktor angebotene Vorteil besteht darin, dass die Objekt Instanziierung von einem Task Aufruf getrennt werden kann.</span><span class="sxs-lookup"><span data-stu-id="f3af1-217">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-218">Im folgenden Beispiel wird ein Array aus 6 Buchstaben definiert.</span><span class="sxs-lookup"><span data-stu-id="f3af1-218">The following example defines an array of 6-letter words.</span></span> <span data-ttu-id="f3af1-219">Jedes Wort wird dann als Argument an den <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> Konstruktor übergeben, dessen <xref:System.Action%601> Delegat die Zeichen im Wort verstrichen und dann das ursprüngliche Wort und seine abgekratte Version anzeigt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-219">Each word is then passed as an argument to the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> constructor, whose <xref:System.Action%601> delegate scrambles the characters in the word, then displays the original word and its scrambled version.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-220">Das <paramref name="action" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-220">The <paramref name="action" /> argument is null.</span></span></exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="f3af1-221">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-221">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-222">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das die neue Aufgabe berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-222">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that the new task will observe.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="f3af1-223">Das <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, das verwendet wird, um das Verhalten der Aufgabe zu ändern.</span><span class="sxs-lookup"><span data-stu-id="f3af1-223">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="f3af1-224">Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion und Erstellungsoptionen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-224">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and creation options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-225">Anstatt diesen Konstruktor aufzurufen, ist die gängigste Methode zum Instanziieren <xref:System.Threading.Tasks.Task> eines-Objekts und zum Starten einer Aufgabe das Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> der statischen-Methode.</span><span class="sxs-lookup"><span data-stu-id="f3af1-225">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f3af1-226">Der einzige von diesem Konstruktor angebotene Vorteil besteht darin, dass die Objekt Instanziierung von einem Task Aufruf getrennt werden kann.</span><span class="sxs-lookup"><span data-stu-id="f3af1-226">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 <span data-ttu-id="f3af1-227">Weitere Informationen finden Sie unter [Aufgaben Parallelität (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) und [Aufgaben Abbruch](~/docs/standard/parallel-programming/task-cancellation.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-227">For more information, see [Task Parallelism (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Task Cancellation](~/docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-228">Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-228">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-229">Das <paramref name="action" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-229">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-230">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> an.</span><span class="sxs-lookup"><span data-stu-id="f3af1-230">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="f3af1-231">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-231">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="f3af1-232">Ein Objekt, das Daten darstellt, die von der Aktion verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-232">An object representing data to be used by the action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-233">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das die neue Aufgabe berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-233">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that the new task will observe.</span></span></param>
        <summary><span data-ttu-id="f3af1-234">Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion, Zustand und Optionen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-234">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-235">Anstatt diesen Konstruktor aufzurufen, ist die gängigste Methode zum Instanziieren <xref:System.Threading.Tasks.Task> eines-Objekts und zum Starten einer Aufgabe das Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> der statischen-Methode.</span><span class="sxs-lookup"><span data-stu-id="f3af1-235">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f3af1-236">Der einzige von diesem Konstruktor angebotene Vorteil besteht darin, dass die Objekt Instanziierung von einem Task Aufruf getrennt werden kann.</span><span class="sxs-lookup"><span data-stu-id="f3af1-236">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-237">Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-237">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-238">Das <paramref name="action" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-238">The <paramref name="action" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="f3af1-239">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-239">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="f3af1-240">Ein Objekt, das Daten darstellt, die von der Aktion verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-240">An object representing data to be used by the action.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="f3af1-241">Das <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, das verwendet wird, um das Verhalten der Aufgabe zu ändern.</span><span class="sxs-lookup"><span data-stu-id="f3af1-241">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="f3af1-242">Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion, Zustand und Optionen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-242">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-243">Anstatt diesen Konstruktor aufzurufen, ist die gängigste Methode zum Instanziieren <xref:System.Threading.Tasks.Task> eines-Objekts und zum Starten einer Aufgabe das Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> der statischen-Methode.</span><span class="sxs-lookup"><span data-stu-id="f3af1-243">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f3af1-244">Der einzige von diesem Konstruktor angebotene Vorteil besteht darin, dass die Objekt Instanziierung von einem Task Aufruf getrennt werden kann.</span><span class="sxs-lookup"><span data-stu-id="f3af1-244">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-245">Das <paramref name="action" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-245">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-246">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> an.</span><span class="sxs-lookup"><span data-stu-id="f3af1-246">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="f3af1-247">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-247">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="f3af1-248">Ein Objekt, das Daten darstellt, die von der Aktion verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-248">An object representing data to be used by the action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-249">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das die neue Aufgabe berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-249">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that the new task will observe.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="f3af1-250">Das <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, das verwendet wird, um das Verhalten der Aufgabe zu ändern.</span><span class="sxs-lookup"><span data-stu-id="f3af1-250">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="f3af1-251">Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion, Zustand und Optionen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-251">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-252">Anstatt diesen Konstruktor aufzurufen, ist die gängigste Methode zum Instanziieren <xref:System.Threading.Tasks.Task> eines-Objekts und zum Starten einer Aufgabe das Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> der statischen-Methode.</span><span class="sxs-lookup"><span data-stu-id="f3af1-252">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f3af1-253">Der einzige von diesem Konstruktor angebotene Vorteil besteht darin, dass die Objekt Instanziierung von einem Task Aufruf getrennt werden kann.</span><span class="sxs-lookup"><span data-stu-id="f3af1-253">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-254">Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-254">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-255">Das <paramref name="action" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-255">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-256">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> an.</span><span class="sxs-lookup"><span data-stu-id="f3af1-256">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f3af1-257">Ruft das beim Erstellen des <see cref="T:System.Threading.Tasks.Task" /> angegebene Zustandsobjekt ab, oder NULL, wenn kein Zustandsobjekt angegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-257">Gets the state object supplied when the <see cref="T:System.Threading.Tasks.Task" /> was created, or null if none was supplied.</span></span></summary>
        <value><span data-ttu-id="f3af1-258">Ein <see cref="T:System.Object" />, das die Zustandsdaten darstellt, die bei der Erstellung an die Aufgabe übergeben wurden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-258">An <see cref="T:System.Object" /> that represents the state data that was passed in to the task when it was created.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-259">Wandeln Sie das Objekt wieder in den ursprünglichen Typ um, um die Daten abzurufen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-259">Cast the object back to the original type to retrieve its data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedTask : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f3af1-260">Ruft eine Aufgabe ab, die bereits erfolgreich abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-260">Gets a task that has already completed successfully.</span></span></summary>
        <value><span data-ttu-id="f3af1-261">Die erfolgreich abgeschlossene Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-261">The successfully completed task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-262">Diese Eigenschaft gibt eine Aufgabe zurück <xref:System.Threading.Tasks.Task.Status%2A> , deren-Eigenschaft <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>auf festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-262">This property returns a task whose <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span></span> <span data-ttu-id="f3af1-263">Rufen Sie die <xref:System.Threading.Tasks.Task.FromResult%2A> -Methode auf, um eine Aufgabe zu erstellen, die einen Wert zurückgibt und bis zum Abschluss ausführt</span><span class="sxs-lookup"><span data-stu-id="f3af1-263">To create task that returns a value and runs to completion, call the <xref:System.Threading.Tasks.Task.FromResult%2A> method.</span></span>  
  
 <span data-ttu-id="f3af1-264">Wiederholte Versuche, diesen Eigenschafts Wert abzurufen, geben möglicherweise nicht immer dieselbe Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-264">Repeated attempts to retrieve this property value may not always return the same instance.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="member this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext"><span data-ttu-id="f3af1-265"><see langword="true" /> um zu versuchen, die Fortsetzung zurück in den ursprünglich erfassten Text zu marshallen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-265"><see langword="true" /> to attempt to marshal the continuation back to the original context captured; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f3af1-266">Konfiguriert einen Awaiter, der verwendet wird, um diese <see cref="T:System.Threading.Tasks.Task" /> zu erwarten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-266">Configures an awaiter used to await this <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <returns><span data-ttu-id="f3af1-267">Ein Objekt, das verwendet wird, um diese Aufgabe zu erwarten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-267">An object used to await this task.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f3af1-268">Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-268">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f3af1-269">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-269">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-270">Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-270">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <summary><span data-ttu-id="f3af1-271">Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-271">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f3af1-272">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-272">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-273">Der zurück <xref:System.Threading.Tasks.Task> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist, und zwar unabhängig davon, ob der Vorgang abgeschlossen ist, bis der Vorgang erfolgreich abgeschlossen wurde, ein Fehler aufgrund einer nicht behandelten Ausnahme aufgetreten ist oder ein frühzeitiger Abbruch abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-273">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-274">Im folgenden Beispiel wird eine Aufgabe definiert, die ein Array mit 100 zufälligen Datums-und Uhrzeitwerten auffüllt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-274">The following example defines a task that populates an array with 100 random date and time values.</span></span> <span data-ttu-id="f3af1-275">Die Methode verwendet <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> die-Methode, um den frühesten und den letzten Datumswert auszuwählen, sobald das Array vollständig aufgefüllt ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-275">It uses the <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> method to select the earliest and the latest date values once the array is fully populated.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 <span data-ttu-id="f3af1-276">Da eine Konsolenanwendung vor dem Ausführen der Fortsetzungs Aufgabe beendet werden <xref:System.Threading.Tasks.Task.Wait> kann, wird die-Methode aufgerufen, um sicherzustellen, dass die Fortsetzung abgeschlossen ist, bevor das Beispiel endet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-276">Because a console application may terminate before the continuation task executes, the <xref:System.Threading.Tasks.Task.Wait> method is called to ensure that the continuation finishes executing before the example ends.</span></span>  
  
 <span data-ttu-id="f3af1-277">Ein weiteres Beispiel finden Sie unter [Verketten von Aufgaben mithilfe von Fortsetzungs Aufgaben](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-277">For an additional example, see [Chaining Tasks by Using Continuation Tasks](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-278">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-278">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f3af1-279">Eine Aktion, die ausgeführt werden soll, wenn die Aufgabe abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-279">An action to run when the task completes.</span></span> <span data-ttu-id="f3af1-280">Wenn der Delegat ausgeführt wird, werden ihm der abgeschlossene Task und das vom Aufrufer bereitgestellte Zustandsobjekt als Argumente übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-280">When run, the delegate is passed the completed task and a caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f3af1-281">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-281">An object representing data to be used by the continuation action.</span></span></param>
        <summary><span data-ttu-id="f3af1-282">Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen empfängt, und wird ausgeführt, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-282">Creates a continuation that receives caller-supplied state information and executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f3af1-283">Eine neue Fortsetzungsaufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-283">A new continuation task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-284">Die zurück <xref:System.Threading.Tasks.Task> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist, und zwar unabhängig davon, ob Sie abgeschlossen wurde, bis der Vorgang erfolgreich abgeschlossen wurde, ein Fehler aufgrund einer nicht behandelten Ausnahme aufgetreten ist oder frühzeitig aufgrund eines Abbruchs beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-284">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting early due to cancellation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-285">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-285">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f3af1-286">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-286">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-287">Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-287">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-288">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-288">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="f3af1-289">Erstellt eine Fortsetzung, die ein Abbruchtoken empfängt und asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-289">Creates a continuation that receives a cancellation token and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f3af1-290">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-290">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-291">Der zurück <xref:System.Threading.Tasks.Task> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist, und zwar unabhängig davon, ob der Vorgang abgeschlossen ist, bis der Vorgang erfolgreich abgeschlossen wurde, ein Fehler aufgrund einer nicht behandelten Ausnahme aufgetreten ist oder ein frühzeitiger Abbruch abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-291">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-292">Die <see cref="T:System.Threading.CancellationTokenSource" />, die das Token erstellt hat, wurde bereits freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-292">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-293">Das <paramref name="continuationAction" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-293">The <paramref name="continuationAction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f3af1-294">Eine Aktion, die nach den angegebenen <paramref name="continuationOptions" /> ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-294">An action to run according to the specified <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="f3af1-295">Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-295">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f3af1-296">Optionen für die Planung und das Verhalten der Fortsetzung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-296">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f3af1-297">Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-297">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="f3af1-298">Erstellt eine Fortsetzung, die, sobald die Zielaufgabe abgeschlossen ist, entsprechend den Angaben in <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-298">Creates a continuation that executes when the target task completes according to the specified <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></summary>
        <returns><span data-ttu-id="f3af1-299">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-299">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-300">Die zurück <xref:System.Threading.Tasks.Task> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-300">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="f3af1-301">Wenn die durch den `continuationOptions` -Parameter angegebenen Fortsetzungs Kriterien nicht erfüllt werden, wird die Fortsetzungs Aufgabe abgebrochen und nicht geplant.</span><span class="sxs-lookup"><span data-stu-id="f3af1-301">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-302">Im folgenden Beispiel wird die <xref:System.Threading.Tasks.TaskContinuationOptions> Verwendung von veranschaulicht, um anzugeben, dass eine Fortsetzungs Aufgabe synchron ausgeführt werden soll, wenn die Vorgänger Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-302">The following example demonstrates using <xref:System.Threading.Tasks.TaskContinuationOptions> to specify that a continuation task should run synchronously when the antecedent task completes.</span></span> <span data-ttu-id="f3af1-303">(Wenn die angegebene Aufgabe bereits durch den <xref:System.Threading.Tasks.Task.ContinueWith%2A> Aufruf <xref:System.Threading.Tasks.Task.ContinueWith%2A>von abgeschlossen wurde, wird die synchrone Fortsetzung auf dem Thread ausgeführt, von dem aufgerufen wird.)</span><span class="sxs-lookup"><span data-stu-id="f3af1-303">(If the specified task has already completed by the time <xref:System.Threading.Tasks.Task.ContinueWith%2A> is called, the synchronous continuation will run on the thread calling <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)</span></span>  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-304">Das <paramref name="continuationAction" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-304">The <paramref name="continuationAction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-305">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</span><span class="sxs-lookup"><span data-stu-id="f3af1-305">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f3af1-306">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-306">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-307">Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-307">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f3af1-308">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-308">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="f3af1-309">Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-309">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-310">Die Fortsetzung verwendet einen angegebenen Zeitplan.</span><span class="sxs-lookup"><span data-stu-id="f3af1-310">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="f3af1-311">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-311">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-312">Der zurück <xref:System.Threading.Tasks.Task> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist, und zwar unabhängig davon, ob der Vorgang abgeschlossen ist, bis der Vorgang erfolgreich abgeschlossen wurde, ein Fehler aufgrund einer nicht behandelten Ausnahme aufgetreten ist oder ein frühzeitiger Abbruch abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-312">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-313"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-313">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-314">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-314">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f3af1-315">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-315">-or-</span></span> 
<span data-ttu-id="f3af1-316">Das <paramref name="scheduler" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-316">The <paramref name="scheduler" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f3af1-317">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-317">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-318">Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-318">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f3af1-319">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-319">An object representing data to be used by the continuation action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-320">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-320">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="f3af1-321">Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen sowie ein Abbruchtoken empfängt und asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-321">Creates a continuation that receives caller-supplied state information and a cancellation token and that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f3af1-322">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-322">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-323">Der zurück <xref:System.Threading.Tasks.Task> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist, und zwar unabhängig davon, ob der Vorgang abgeschlossen ist, bis der Vorgang erfolgreich abgeschlossen wurde, ein Fehler aufgrund einer nicht behandelten Ausnahme aufgetreten ist oder ein frühzeitiger Abbruch abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-323">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-324">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-324">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-325">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-325">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f3af1-326">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-326">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-327">Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-327">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f3af1-328">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-328">An object representing data to be used by the continuation action.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f3af1-329">Optionen für die Planung und das Verhalten der Fortsetzung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-329">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f3af1-330">Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-330">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="f3af1-331">Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen empfängt, und wird ausgeführt, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-331">Creates a continuation that receives caller-supplied state information and executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-332">Die Fortsetzung wird entsprechend einem Satz angegebener Bedingungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-332">The continuation executes based on a set of specified conditions.</span></span></summary>
        <returns><span data-ttu-id="f3af1-333">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-333">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-334">Die zurück <xref:System.Threading.Tasks.Task> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-334">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="f3af1-335">Wenn die durch den `continuationOptions` -Parameter angegebenen Fortsetzungs Kriterien nicht erfüllt werden, wird die Fortsetzungs Aufgabe abgebrochen und nicht geplant.</span><span class="sxs-lookup"><span data-stu-id="f3af1-335">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-336">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-336">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-337">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</span><span class="sxs-lookup"><span data-stu-id="f3af1-337">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f3af1-338">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-338">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span>  <span data-ttu-id="f3af1-339">Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-339">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f3af1-340">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-340">An object representing data to be used by the continuation action.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f3af1-341">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-341">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="f3af1-342">Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen empfängt, und wird asynchron ausgeführt, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-342">Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-343">Die Fortsetzung verwendet einen angegebenen Zeitplan.</span><span class="sxs-lookup"><span data-stu-id="f3af1-343">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="f3af1-344">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-344">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-345">Der zurück <xref:System.Threading.Tasks.Task> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist, und zwar unabhängig davon, ob der Vorgang abgeschlossen ist, bis der Vorgang erfolgreich abgeschlossen wurde, ein Fehler aufgrund einer nicht behandelten Ausnahme aufgetreten ist oder ein frühzeitiger Abbruch abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-345">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-346">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-346">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f3af1-347">Eine Aktion, die nach den angegebenen <paramref name="continuationOptions" /> ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-347">An action to run according to the specified <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="f3af1-348">Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-348">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-349">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-349">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f3af1-350">Optionen für die Planung und das Verhalten der Fortsetzung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-350">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f3af1-351">Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-351">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f3af1-352">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-352">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="f3af1-353">Erstellt eine Fortsetzung, die, sobald die Zielaufgabe abgeschlossen ist, entsprechend den Angaben in <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-353">Creates a continuation that executes when the target task competes according to the specified <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span> <span data-ttu-id="f3af1-354">Die Fortsetzung empfängt ein Abbruchtoken und verwendet einen angegebenen Zeitplan.</span><span class="sxs-lookup"><span data-stu-id="f3af1-354">The continuation receives a cancellation token and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="f3af1-355">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-355">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-356">Die zurück <xref:System.Threading.Tasks.Task> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-356">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="f3af1-357">Wenn die durch den `continuationOptions` -Parameter angegebenen Kriterien nicht erfüllt werden, wird die Fortsetzungs Aufgabe abgebrochen und nicht geplant.</span><span class="sxs-lookup"><span data-stu-id="f3af1-357">If the criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-358">Im folgenden finden Sie ein Beispiel für die Verwendung von ContinueWith zum Ausführen von Aufgaben im Hintergrund und in den Benutzeroberflächenthreads.</span><span class="sxs-lookup"><span data-stu-id="f3af1-358">The following is an example of using ContinueWith to run work both in the background and on the user interface threads.</span></span>  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-359">Die <see cref="T:System.Threading.CancellationTokenSource" />, die das Token erstellt hat, wurde bereits freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-359">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-360">Das <paramref name="continuationAction" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-360">The <paramref name="continuationAction" /> argument is null.</span></span>  
  
<span data-ttu-id="f3af1-361">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-361">-or-</span></span> 
<span data-ttu-id="f3af1-362">Das <paramref name="scheduler" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-362">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-363">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</span><span class="sxs-lookup"><span data-stu-id="f3af1-363">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f3af1-364">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-364">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-365">Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-365">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f3af1-366">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-366">An object representing data to be used by the continuation action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-367">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-367">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f3af1-368">Optionen für die Planung und das Verhalten der Fortsetzung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-368">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f3af1-369">Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-369">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f3af1-370">Der <see cref="T:System.Threading.Tasks.TaskScheduler" />, der der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-370">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its  execution.</span></span></param>
        <summary><span data-ttu-id="f3af1-371">Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen sowie ein Abbruchtoken empfängt und ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-371">Creates a continuation that receives caller-supplied state information and a cancellation token and that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-372">Die Fortsetzung wird entsprechend einem Satz angegebener Bedingungen ausgeführt und verwendet einen angegebenen Zeitplan.</span><span class="sxs-lookup"><span data-stu-id="f3af1-372">The continuation executes based on a set of specified conditions and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="f3af1-373">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-373">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-374">Die zurück <xref:System.Threading.Tasks.Task> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-374">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed.</span></span> <span data-ttu-id="f3af1-375">Wenn die durch den `continuationOptions` -Parameter angegebenen Kriterien nicht erfüllt werden, wird die Fortsetzungs Aufgabe abgebrochen und nicht geplant.</span><span class="sxs-lookup"><span data-stu-id="f3af1-375">If the criteria specified through the `continuationOptions` parameter  are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-376">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-376">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-377">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</span><span class="sxs-lookup"><span data-stu-id="f3af1-377">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-378">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-378">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-379">Der Typ des von der Fortsetzung generierten Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-379">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f3af1-380">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-380">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f3af1-381">Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-381">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <summary><span data-ttu-id="f3af1-382">Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen wurde, und gibt einen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-382">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes and returns a value.</span></span></summary>
        <returns><span data-ttu-id="f3af1-383">Eine neue Fortsetzungsaufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-383">A new continuation task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-384">Der zurück <xref:System.Threading.Tasks.Task%601> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist, und zwar unabhängig davon, ob der Vorgang abgeschlossen ist, bis der Vorgang erfolgreich abgeschlossen wurde, ein Fehler aufgrund einer nicht behandelten Ausnahme aufgetreten ist oder ein frühzeitiger Abbruch abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-384">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-385">Im folgenden Beispiel wird gezeigt, wie die ContinueWith-Methode verwendet wird:</span><span class="sxs-lookup"><span data-stu-id="f3af1-385">The following example shows how to use the ContinueWith method:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-386"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-386">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-387">Das <paramref name="continuationFunction" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-387">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-388">Der Typ des von der Fortsetzung generierten Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-388">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f3af1-389">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-389">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-390">Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-390">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f3af1-391">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-391">An object representing data to be used by the continuation function.</span></span></param>
        <summary><span data-ttu-id="f3af1-392">Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen empfängt, und wird asynchron ausgeführt, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist, und gibt einen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-392">Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span></summary>
        <returns><span data-ttu-id="f3af1-393">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-393">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-394">Der zurück <xref:System.Threading.Tasks.Task%601> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist, und zwar unabhängig davon, ob der Vorgang abgeschlossen ist, bis der Vorgang erfolgreich abgeschlossen wurde, ein Fehler aufgrund einer nicht behandelten Ausnahme aufgetreten ist oder ein frühzeitiger Abbruch abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-394">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-395">Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-395">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-396">Der Typ des von der Fortsetzung generierten Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-396">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f3af1-397">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-397">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-398">Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-398">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-399">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-399">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="f3af1-400">Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde, und gibt einen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-400">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="f3af1-401">Die Fortsetzung empfängt ein Abbruchtoken.</span><span class="sxs-lookup"><span data-stu-id="f3af1-401">The continuation receives a cancellation token.</span></span></summary>
        <returns><span data-ttu-id="f3af1-402">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-402">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-403">Der zurück <xref:System.Threading.Tasks.Task%601> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist, und zwar unabhängig davon, ob der Vorgang abgeschlossen ist, bis der Vorgang erfolgreich abgeschlossen wurde, ein Fehler aufgrund einer nicht behandelten Ausnahme aufgetreten ist oder ein frühzeitiger Abbruch abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-403">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-404"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-404">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span>  
  
<span data-ttu-id="f3af1-405">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-405">-or-</span></span> 
<span data-ttu-id="f3af1-406">Die <see cref="T:System.Threading.CancellationTokenSource" />, die das Token erstellt hat, wurde bereits freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-406">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-407">Das <paramref name="continuationFunction" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-407">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-408">Der Typ des von der Fortsetzung generierten Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-408">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f3af1-409">Eine Funktion, die entsprechend der in <paramref name="continuationOptions" /> angegebenen Bedingung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-409">A function to run according to the condition specified in <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="f3af1-410">Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-410">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f3af1-411">Optionen für die Planung und das Verhalten der Fortsetzung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-411">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f3af1-412">Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-412">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="f3af1-413">Erstellt eine Fortsetzung, die entsprechend den angegebenen Fortsetzungsoptionen ausgeführt wird, und gibt einen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-413">Creates a continuation that executes according to the specified continuation options and returns a value.</span></span></summary>
        <returns><span data-ttu-id="f3af1-414">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-414">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-415">Die zurück <xref:System.Threading.Tasks.Task%601> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-415">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="f3af1-416">Wenn die durch den `continuationOptions` -Parameter angegebenen Fortsetzungs Kriterien nicht erfüllt werden, wird die Fortsetzungs Aufgabe abgebrochen und nicht geplant.</span><span class="sxs-lookup"><span data-stu-id="f3af1-416">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-417"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-417">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-418">Das <paramref name="continuationFunction" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-418">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-419">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</span><span class="sxs-lookup"><span data-stu-id="f3af1-419">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-420">Der Typ des von der Fortsetzung generierten Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-420">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f3af1-421">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-421">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-422">Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-422">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f3af1-423">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-423">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="f3af1-424">Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde, und gibt einen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-424">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="f3af1-425">Die Fortsetzung verwendet einen angegebenen Zeitplan.</span><span class="sxs-lookup"><span data-stu-id="f3af1-425">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="f3af1-426">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-426">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-427">Der zurück <xref:System.Threading.Tasks.Task%601> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist, und zwar unabhängig davon, ob der Vorgang abgeschlossen ist, bis der Vorgang erfolgreich abgeschlossen wurde, ein Fehler aufgrund einer nicht behandelten Ausnahme aufgetreten ist oder ein frühzeitiger Abbruch abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-427">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-428"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-428">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-429">Das <paramref name="continuationFunction" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-429">The <paramref name="continuationFunction" /> argument is null.</span></span>  
  
<span data-ttu-id="f3af1-430">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-430">-or-</span></span> 
<span data-ttu-id="f3af1-431">Das <paramref name="scheduler" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-431">The <paramref name="scheduler" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-432">Der Typ des von der Fortsetzung generierten Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-432">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f3af1-433">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-433">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-434">Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-434">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f3af1-435">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-435">An object representing data to be used by the continuation function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-436">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-436">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="f3af1-437">Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde, und gibt einen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-437">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="f3af1-438">Die Fortsetzung empfängt vom Aufrufer bereitgestellte Zustandsinformationen sowie ein Abbruchtoken.</span><span class="sxs-lookup"><span data-stu-id="f3af1-438">The continuation receives caller-supplied state information and a cancellation token.</span></span></summary>
        <returns><span data-ttu-id="f3af1-439">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-439">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-440">Der zurück <xref:System.Threading.Tasks.Task%601> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist, und zwar unabhängig davon, ob der Vorgang abgeschlossen ist, bis der Vorgang erfolgreich abgeschlossen wurde, ein Fehler aufgrund einer nicht behandelten Ausnahme aufgetreten ist oder ein frühzeitiger Abbruch abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-440">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-441">Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-441">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-442">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-442">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-443">Der Typ des von der Fortsetzung generierten Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-443">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f3af1-444">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-444">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-445">Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-445">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f3af1-446">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-446">An object representing data to be used by the continuation function.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f3af1-447">Optionen für die Planung und das Verhalten der Fortsetzung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-447">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f3af1-448">Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-448">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="f3af1-449">Erstellt eine Fortsetzung, die entsprechend den angegebenen Aufgabenfortsetzungsoptionen ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-449">Creates a continuation that executes based on the specified task continuation options when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-450">Die Fortsetzung empfängt vom Aufrufer bereitgestellte Zustandsinformationen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-450">The continuation receives caller-supplied state information.</span></span></summary>
        <returns><span data-ttu-id="f3af1-451">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-451">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-452">Die zurück <xref:System.Threading.Tasks.Task%601> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-452">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="f3af1-453">Wenn die durch den `continuationOptions` -Parameter angegebenen Fortsetzungs Kriterien nicht erfüllt werden, wird die Fortsetzungs Aufgabe abgebrochen und nicht geplant.</span><span class="sxs-lookup"><span data-stu-id="f3af1-453">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-454">Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-454">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-455">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</span><span class="sxs-lookup"><span data-stu-id="f3af1-455">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-456">Der Typ des von der Fortsetzung generierten Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-456">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f3af1-457">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-457">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span>  <span data-ttu-id="f3af1-458">Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-458">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f3af1-459">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-459">An object representing data to be used by the continuation function.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f3af1-460">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-460">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="f3af1-461">Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-461">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-462">Die Fortsetzung empfängt vom Aufrufer bereitgestellte Zustandsinformationen und verwendet einen angegebenen Zeitplan.</span><span class="sxs-lookup"><span data-stu-id="f3af1-462">The continuation receives caller-supplied state information and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="f3af1-463">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-463">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-464">Der zurück <xref:System.Threading.Tasks.Task%601> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist, und zwar unabhängig davon, ob der Vorgang abgeschlossen ist, bis der Vorgang erfolgreich abgeschlossen wurde, ein Fehler aufgrund einer nicht behandelten Ausnahme aufgetreten ist oder ein frühzeitiger Abbruch abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-464">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-465">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-465">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-466">Der Typ des von der Fortsetzung generierten Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-466">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f3af1-467">Eine Funktion, die entsprechend der in <c>continuationOptions</c> angegebenen Bedingung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-467">A function to run according to the specified <c>continuationOptions.</c></span></span> <span data-ttu-id="f3af1-468">Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-468">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-469">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-469">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f3af1-470">Optionen für die Planung und das Verhalten der Fortsetzung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-470">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f3af1-471">Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-471">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f3af1-472">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-472">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="f3af1-473">Erstellt eine Fortsetzung, die entsprechend den angegebenen Fortsetzungsoptionen ausgeführt wird, und gibt einen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-473">Creates a continuation that executes according to the specified continuation options and returns a value.</span></span> <span data-ttu-id="f3af1-474">An die Fortsetzung wird ein Abbruchtoken übergeben, und sie verwendet einen angegebenen Zeitplan.</span><span class="sxs-lookup"><span data-stu-id="f3af1-474">The continuation is passed a cancellation token and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="f3af1-475">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-475">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-476">Die zurück <xref:System.Threading.Tasks.Task%601> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-476">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="f3af1-477">Wenn die durch den `continuationOptions` -Parameter angegebenen Kriterien nicht erfüllt werden, wird die Fortsetzungs Aufgabe abgebrochen und nicht geplant.</span><span class="sxs-lookup"><span data-stu-id="f3af1-477">If the criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-478">Im folgenden Beispiel wird gezeigt, wie die ContinueWith-Methode mit Fortsetzungs Optionen verwendet wird:</span><span class="sxs-lookup"><span data-stu-id="f3af1-478">The following example shows how to use the ContinueWith method with continuation options:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-479"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-479">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span>  
  
<span data-ttu-id="f3af1-480">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-480">-or-</span></span> 
<span data-ttu-id="f3af1-481">Die <see cref="T:System.Threading.CancellationTokenSource" />, die das Token erstellt hat, wurde bereits freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-481">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-482">Das <paramref name="continuationFunction" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-482">The <paramref name="continuationFunction" /> argument is null.</span></span>  
  
<span data-ttu-id="f3af1-483">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-483">-or-</span></span> 
<span data-ttu-id="f3af1-484">Das <paramref name="scheduler" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-484">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-485">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</span><span class="sxs-lookup"><span data-stu-id="f3af1-485">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-486">Der Typ des von der Fortsetzung generierten Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-486">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f3af1-487">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-487">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="f3af1-488">Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-488">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f3af1-489">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-489">An object representing data to be used by the continuation function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-490">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-490">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f3af1-491">Optionen für die Planung und das Verhalten der Fortsetzung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-491">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f3af1-492">Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-492">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f3af1-493">Der <see cref="T:System.Threading.Tasks.TaskScheduler" />, der der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-493">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its  execution.</span></span></param>
        <summary><span data-ttu-id="f3af1-494">Erstellt eine Fortsetzung, die entsprechend den angegebenen Aufgabenfortsetzungsoptionen ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist, und gibt einen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-494">Creates a continuation that executes based on the specified task continuation options when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="f3af1-495">Die Fortsetzung empfängt vom Aufrufer bereitgestellte Zustandsinformationen sowie ein Abbruchtoken und verwendet den angegebenen Zeitplan.</span><span class="sxs-lookup"><span data-stu-id="f3af1-495">The continuation receives caller-supplied state information and a cancellation token and uses the specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="f3af1-496">Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-496">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-497">Die zurück <xref:System.Threading.Tasks.Task%601> gegebene wird nicht für die Ausführung geplant, bis die aktuelle Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-497">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed.</span></span> <span data-ttu-id="f3af1-498">Wenn die durch den `continuationOptions` -Parameter angegebenen Kriterien nicht erfüllt werden, wird die Fortsetzungs Aufgabe abgebrochen und nicht geplant.</span><span class="sxs-lookup"><span data-stu-id="f3af1-498">If the criteria specified through the `continuationOptions` parameter  are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-499">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-499">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-500">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</span><span class="sxs-lookup"><span data-stu-id="f3af1-500">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-501">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-501">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f3af1-502">Ruft die zum Erstellen dieser Aufgabe verwendeten <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> ab.</span><span class="sxs-lookup"><span data-stu-id="f3af1-502">Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to create this task.</span></span></summary>
        <value><span data-ttu-id="f3af1-503">Die zum Erstellen dieser Aufgabe verwendeten <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-503">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to create this task.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentId : Nullable&lt;int&gt;" Usage="System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f3af1-504">Gibt die ID der momentan ausgeführten <see cref="T:System.Threading.Tasks.Task" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-504">Returns the ID of the currently executing <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <value><span data-ttu-id="f3af1-505">Eine ganze Zahl, die der gerade ausgeführten Aufgabe vom System zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-505">An integer that was assigned by the system to the currently-executing task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-506"><xref:System.Threading.Tasks.Task.CurrentId%2A>ist eine `static` (`Shared` in Visual Basic)-Eigenschaft, die verwendet wird, um den Bezeichner der aktuell ausgeführten Aufgabe aus dem Code zu erhalten, der von der Aufgabe ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-506"><xref:System.Threading.Tasks.Task.CurrentId%2A> is a `static` (`Shared` in Visual Basic) property that is used to get the identifier of the currently executing task from the code that the task is executing.</span></span> <span data-ttu-id="f3af1-507">Sie unterscheidet sich <xref:System.Threading.Tasks.Task.Id%2A> von der-Eigenschaft, die den Bezeichner <xref:System.Threading.Tasks.Task> einer bestimmten-Instanz zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-507">It differs from the <xref:System.Threading.Tasks.Task.Id%2A> property, which returns the identifier of a particular <xref:System.Threading.Tasks.Task> instance.</span></span> <span data-ttu-id="f3af1-508">Wenn Sie versuchen, den <xref:System.Threading.Tasks.Task.CurrentId%2A> Wert von außerhalb des Codes abzurufen, der von einem Task ausgeführt wird, gibt die-Eigenschaft zurück. `null`</span><span class="sxs-lookup"><span data-stu-id="f3af1-508">If you attempt to retrieve the <xref:System.Threading.Tasks.Task.CurrentId%2A> value from outside the code that a task is executing, the property returns `null`.</span></span>  
  
 <span data-ttu-id="f3af1-509">Obwohl Konflikte sehr selten auftreten, ist es nicht gewährleistet, dass Aufgaben Bezeichner eindeutig sind.</span><span class="sxs-lookup"><span data-stu-id="f3af1-509">Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f3af1-510">Erstellt eine Aufgabe, die nach einer Verzögerung abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-510">Creates a task that will complete after a time delay.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="static member Delay : int -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay"><span data-ttu-id="f3af1-511">Die Anzahl von Millisekunden, die gewartet wird, bevor die zurückgegebene Aufgabe abgeschlossen wird, oder -1, um unbegrenzt zu warten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-511">The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f3af1-512">Erstellt eine Aufgabe, die nach Ablauf einer festgelegten Anzahl an Millisekunden abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-512">Creates a task that completes after a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="f3af1-513">Eine Aufgabe, die die Verzögerung darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-513">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-514">Die <xref:System.Threading.Tasks.Task.Delay%2A> -Methode wird normalerweise verwendet, um den Vorgang eines gesamten oder eines Teils einer Aufgabe für ein bestimmtes Zeitintervall zu verzögern.</span><span class="sxs-lookup"><span data-stu-id="f3af1-514">The <xref:System.Threading.Tasks.Task.Delay%2A> method is typically used to delay the operation of all or part of a task for a specified time interval.</span></span> <span data-ttu-id="f3af1-515">In den meisten Fällen wird die Zeitverzögerung eingeführt:</span><span class="sxs-lookup"><span data-stu-id="f3af1-515">Most commonly, the time delay is introduced:</span></span>  
  
-   <span data-ttu-id="f3af1-516">Zu Beginn der Aufgabe, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-516">At the beginning of the task, as the following example shows.</span></span>  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   <span data-ttu-id="f3af1-517">Einige Zeit, während die Aufgabe ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-517">Sometime while the task is executing.</span></span> <span data-ttu-id="f3af1-518">In diesem Fall wird der Aufrufe der <xref:System.Threading.Tasks.Task.Delay%2A> -Methode als untergeordnete Aufgabe innerhalb einer Aufgabe ausgeführt, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-518">In this case, the call to the <xref:System.Threading.Tasks.Task.Delay%2A> method executes as a child task within a task, as the following example shows.</span></span> <span data-ttu-id="f3af1-519">Beachten Sie Folgendes: da der Task, <xref:System.Threading.Tasks.Task.Delay%2A> der die-Methode aufruft, asynchron ausgeführt wird, muss die übergeordnete Aufgabe mit `await` dem-Schlüsselwort auf den Abschluss warten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-519">Note that since the task that calls the <xref:System.Threading.Tasks.Task.Delay%2A> method executes asynchronously, the parent task must wait for it to complete by using the `await` keyword.</span></span>  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 <span data-ttu-id="f3af1-520">Nach der angegebenen Zeitverzögerung wird die Aufgabe im <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> -Zustand abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-520">After the specified time delay, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="f3af1-521">Diese Methode hängt von der Systemuhr ab.</span><span class="sxs-lookup"><span data-stu-id="f3af1-521">This method depends on the system clock.</span></span> <span data-ttu-id="f3af1-522">Dies bedeutet, dass die Zeitverzögerung ungefähr gleich der Auflösung der Systemuhr ist, wenn `millisecondsDelay` das Argument kleiner als die Auflösung der Systemuhr ist, was ungefähr 15 Millisekunden auf Windows-Systemen liegt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-522">This means that the time delay will approximately equal the resolution of the system clock if the `millisecondsDelay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-523">Das folgende Beispiel zeigt eine einfache Verwendung <xref:System.Threading.Tasks.Task.Delay%2A> der-Methode.</span><span class="sxs-lookup"><span data-stu-id="f3af1-523">The following example shows a simple use of the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-524">Das <paramref name="millisecondsDelay" />-Argument ist kleiner als -1.</span><span class="sxs-lookup"><span data-stu-id="f3af1-524">The <paramref name="millisecondsDelay" /> argument is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delay"><span data-ttu-id="f3af1-525">Die Zeitspanne, die abgewartet werden soll, bevor die zurückgegebene Aufgabe abgeschlossen wird, oder <see langword="TimeSpan.FromMilliseconds(-1)" />, um unbegrenzt zu warten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-525">The time span to wait before completing the returned task, or <see langword="TimeSpan.FromMilliseconds(-1)" /> to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f3af1-526">Erstellt eine Aufgabe, die nach Ablauf einer festgelegten Zeitspanne abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-526">Creates a task that completes after a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="f3af1-527">Eine Aufgabe, die die Verzögerung darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-527">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-528">Nach der angegebenen Zeitverzögerung wird die Aufgabe im <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-528">After the specified time delay, the task is completed in <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="f3af1-529">Verwendungs Szenarien und zusätzliche Beispiele finden Sie in der Dokumentation für die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> -Überladung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-529">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="f3af1-530">Diese Methode hängt von der Systemuhr ab.</span><span class="sxs-lookup"><span data-stu-id="f3af1-530">This method depends on the system clock.</span></span> <span data-ttu-id="f3af1-531">Dies bedeutet, dass die Zeitverzögerung ungefähr gleich der Auflösung der Systemuhr ist, wenn `delay` das Argument kleiner als die Auflösung der Systemuhr ist, was ungefähr 15 Millisekunden auf Windows-Systemen liegt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-531">This means that the time delay will approximately equal the resolution of the system clock if the `delay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-532">Das folgende Beispiel zeigt eine einfache Verwendung <xref:System.Threading.Tasks.Task.Delay%2A> der-Methode.</span><span class="sxs-lookup"><span data-stu-id="f3af1-532">The following example shows a simple use of the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-533"><paramref name="delay" /> stellt ein negatives Zeitintervall ungleich <see langword="TimeSpan.FromMilliseconds(-1)" /> dar.</span><span class="sxs-lookup"><span data-stu-id="f3af1-533"><paramref name="delay" /> represents a negative time interval other than <see langword="TimeSpan.FromMilliseconds(-1)" />.</span></span>  
  
<span data-ttu-id="f3af1-534">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-534">-or-</span></span> 
<span data-ttu-id="f3af1-535">Die <paramref name="delay" /> der <see cref="P:System.TimeSpan.TotalMilliseconds" />-Eigenschaft des Arguments ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-535">The <paramref name="delay" /> argument's <see cref="P:System.TimeSpan.TotalMilliseconds" /> property is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (millisecondsDelay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay"><span data-ttu-id="f3af1-536">Die Anzahl von Millisekunden, die gewartet wird, bevor die zurückgegebene Aufgabe abgeschlossen wird, oder -1, um unbegrenzt zu warten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-536">The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-537">Ein Abbruchtoken, das beim Warten auf den Abschluss der Aufgabe überwacht werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-537">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="f3af1-538">Erstellt eine stornierbare Aufgabe, die nach Ablauf einer festgelegten Anzahl an Millisekunden abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-538">Creates a cancellable task that completes after a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="f3af1-539">Eine Aufgabe, die die Verzögerung darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-539">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-540">Wenn das Abbruch Token vor der angegebenen Zeitverzögerung signalisiert wird, wird <xref:System.Threading.Tasks.TaskCanceledException> eine Ausnahme ausgelöst, und die Aufgabe wird <xref:System.Threading.Tasks.TaskStatus.Canceled> im-Zustand abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-540">If the cancellation token is signaled before the specified time delay, a <xref:System.Threading.Tasks.TaskCanceledException> exception results, and the task is completed in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  <span data-ttu-id="f3af1-541">Andernfalls wird die Aufgabe im <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand abgeschlossen, sobald die angegebene Zeitverzögerung verstrichen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-541">Otherwise, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state once the specified time delay has elapsed.</span></span>  
  
 <span data-ttu-id="f3af1-542">Verwendungs Szenarien und zusätzliche Beispiele finden Sie in der Dokumentation für die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> -Überladung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-542">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="f3af1-543">Diese Methode hängt von der Systemuhr ab.</span><span class="sxs-lookup"><span data-stu-id="f3af1-543">This method depends on the system clock.</span></span> <span data-ttu-id="f3af1-544">Dies bedeutet, dass die Zeitverzögerung ungefähr gleich der Auflösung der Systemuhr ist, wenn `millisecondsDelay` das Argument kleiner als die Auflösung der Systemuhr ist, was ungefähr 15 Millisekunden auf Windows-Systemen liegt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-544">This means that the time delay will approximately equal the resolution of the system clock if the `millisecondsDelay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-545">Im folgenden Beispiel wird eine Aufgabe gestartet, die einen-Rückruf <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> der-Methode mit einer Verzögerung von einer Sekunde einschließt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-545">The following example launches a task that includes a call to the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> method with a one second delay.</span></span> <span data-ttu-id="f3af1-546">Bevor das Verzögerungs Intervall abläuft, wird das Token abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-546">Before the delay interval elapses, the token is cancelled.</span></span> <span data-ttu-id="f3af1-547">Die Ausgabe des Beispiels zeigt, dass als Ergebnis eine <xref:System.Threading.Tasks.TaskCanceledException> ausgelöst wird und die- <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft der Tasks auf <xref:System.Threading.Tasks.TaskStatus.Canceled>festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-547">The output from the example shows that, as a result, a <xref:System.Threading.Tasks.TaskCanceledException> is thrown, and the tasks' <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-548">Das <paramref name="millisecondsDelay" />-Argument ist kleiner als -1.</span><span class="sxs-lookup"><span data-stu-id="f3af1-548">The <paramref name="millisecondsDelay" /> argument is less than -1.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="f3af1-549">Die Aufgabe wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-549">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-550">Das angegebene <paramref name="cancellationToken" /> wurde bereits freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-550">The provided <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (delay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delay"><span data-ttu-id="f3af1-551">Die Zeitspanne, die abgewartet werden soll, bevor die zurückgegebene Aufgabe abgeschlossen wird, oder <see langword="TimeSpan.FromMilliseconds(-1)" />, um unbegrenzt zu warten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-551">The time span to wait before completing the returned task, or <see langword="TimeSpan.FromMilliseconds(-1)" /> to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-552">Ein Abbruchtoken, das beim Warten auf den Abschluss der Aufgabe überwacht werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-552">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="f3af1-553">Erstellt eine abzubrechende Aufgabe, die nach Ablauf einer festgelegten Zeitspanne abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-553">Creates a cancellable task that completes after a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="f3af1-554">Eine Aufgabe, die die Verzögerung darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-554">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-555">Wenn das Abbruch Token vor der angegebenen Zeitverzögerung signalisiert wird, wird <xref:System.Threading.Tasks.TaskCanceledException> eine Ausnahme ausgelöst, und die Aufgabe wird <xref:System.Threading.Tasks.TaskStatus.Canceled> im-Zustand abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-555">If the cancellation token is signaled before the specified time delay, a <xref:System.Threading.Tasks.TaskCanceledException> exception results, and the task is completed in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  <span data-ttu-id="f3af1-556">Andernfalls wird die Aufgabe im <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand abgeschlossen, sobald die angegebene Zeitverzögerung verstrichen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-556">Otherwise, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state once the specified time delay has elapsed.</span></span>  
  
 <span data-ttu-id="f3af1-557">Verwendungs Szenarien und zusätzliche Beispiele finden Sie in der Dokumentation für die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> -Überladung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-557">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="f3af1-558">Diese Methode hängt von der Systemuhr ab.</span><span class="sxs-lookup"><span data-stu-id="f3af1-558">This method depends on the system clock.</span></span> <span data-ttu-id="f3af1-559">Dies bedeutet, dass die Zeitverzögerung ungefähr gleich der Auflösung der Systemuhr ist, wenn `delay` das Argument kleiner als die Auflösung der Systemuhr ist, was ungefähr 15 Millisekunden auf Windows-Systemen liegt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-559">This means that the time delay will approximately equal the resolution of the system clock if the `delay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-560">Im folgenden Beispiel wird eine Aufgabe gestartet, die einen-Aufrufvorgang der <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> -Methode mit einer Verzögerung von 1,5 Sekunden einschließt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-560">The following example launches a task that includes a call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method with a 1.5 second delay.</span></span> <span data-ttu-id="f3af1-561">Bevor das Verzögerungs Intervall abläuft, wird das Token abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-561">Before the delay interval elapses, the token is cancelled.</span></span> <span data-ttu-id="f3af1-562">Die Ausgabe des Beispiels zeigt, dass als Ergebnis eine <xref:System.Threading.Tasks.TaskCanceledException> ausgelöst wird und die- <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft der Tasks auf <xref:System.Threading.Tasks.TaskStatus.Canceled>festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-562">The output from the example shows that, as a result, a <xref:System.Threading.Tasks.TaskCanceledException> is thrown, and the tasks' <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 <span data-ttu-id="f3af1-563">Beachten Sie, dass dieses Beispiel eine potenzielle Racebedingung umfasst: Es hängt von der Aufgabe ab, die die Verzögerung asynchron ausführt, wenn das Token abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-563">Note that this example includes a potential race condition: it depends on the task asynchronously executing the delay when the token is cancelled.</span></span> <span data-ttu-id="f3af1-564">Obwohl bei der 1,5-Sekunden-Verzögerung des Aufrufes der <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> -Methode diese Annahme wahrscheinlich ist, kann es vorkommen, dass der <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> Methoden Aufrufvorgang möglicherweise zurückgibt, bevor das Token abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-564">Although the 1.5 second delay from the call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method makes that assumption likely, it is nevertheless possible that the call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method could return before the token is cancelled.</span></span> <span data-ttu-id="f3af1-565">In diesem Fall erzeugt das Beispiel die folgende Ausgabe:</span><span class="sxs-lookup"><span data-stu-id="f3af1-565">In that case, the example produces the following output:</span></span>  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-566"><paramref name="delay" /> stellt ein negatives Zeitintervall ungleich <see langword="TimeSpan.FromMilliseconds(-1)" /> dar.</span><span class="sxs-lookup"><span data-stu-id="f3af1-566"><paramref name="delay" /> represents a negative time interval other than <see langword="TimeSpan.FromMilliseconds(-1)" />.</span></span>  
  
<span data-ttu-id="f3af1-567">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-567">-or-</span></span> 
<span data-ttu-id="f3af1-568">Die <paramref name="delay" /> der <see cref="P:System.TimeSpan.TotalMilliseconds" />-Eigenschaft des Arguments ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-568">The <paramref name="delay" /> argument's <see cref="P:System.TimeSpan.TotalMilliseconds" /> property is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="f3af1-569">Die Aufgabe wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-569">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-570">Das angegebene <paramref name="cancellationToken" /> wurde bereits freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-570">The provided <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f3af1-571">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.Tasks.Task" />-Klasse verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="f3af1-571">Releases all resources used by the current instance of the <see cref="T:System.Threading.Tasks.Task" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="task.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f3af1-572">Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.Tasks.Task" />-Klasse verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="f3af1-572">Releases all resources used by the current instance of the <see cref="T:System.Threading.Tasks.Task" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-573">Die <xref:System.Threading.Tasks.Task> -Klasse implementiert <xref:System.IDisposable> die-Schnittstelle, da intern Ressourcen verwendet <xref:System.IDisposable>, die ebenfalls implementieren.</span><span class="sxs-lookup"><span data-stu-id="f3af1-573">The <xref:System.Threading.Tasks.Task> class implements the <xref:System.IDisposable> interface because internally it uses resources that also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="f3af1-574">Wenn Ihre APP [!INCLUDE[net_v45](~/includes/net-v45-md.md)] jedoch auf oder höher ausgerichtet ist, ist es nicht erforderlich, aufzurufen <xref:System.Threading.Tasks.Task.Dispose%2A> , es sei denn, Leistungs-oder Skalierbarkeits Tests geben an, dass die Leistung Ihrer APP basierend auf Ihren Verwendungs Mustern durch das Freigeben von Aufgaben verbessert wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-574">However, particularly if your app targets the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] or later, there is no need to call <xref:System.Threading.Tasks.Task.Dispose%2A> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</span></span> <span data-ttu-id="f3af1-575">Weitere Informationen finden Sie unter müssen [Sie Aufgaben verwerfen?](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) im Blog zur parallelen Programmierung mit .net.</span><span class="sxs-lookup"><span data-stu-id="f3af1-575">For more information, see [Do I need to dispose of Tasks?](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f3af1-576">Der Task ist nicht in einem der Endzustände: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> oder <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-576">The task is not in one of the final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="task.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="f3af1-577">Ein boolescher Wert, der angibt, ob diese Methode aufgrund eines Aufrufs von <see cref="M:System.Threading.Tasks.Task.Dispose" /> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-577">A Boolean value that indicates whether this method is being called due to a call to <see cref="M:System.Threading.Tasks.Task.Dispose" />.</span></span></param>
        <summary><span data-ttu-id="f3af1-578">Verwirft den <see cref="T:System.Threading.Tasks.Task" /> und gibt somit alle von ihm verwendeten nicht verwalteten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="f3af1-578">Disposes the <see cref="T:System.Threading.Tasks.Task" />, releasing all of its unmanaged resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-579">Die <xref:System.Threading.Tasks.Task> -Klasse implementiert <xref:System.IDisposable> die-Schnittstelle, da intern Ressourcen verwendet <xref:System.IDisposable>, die ebenfalls implementieren.</span><span class="sxs-lookup"><span data-stu-id="f3af1-579">The <xref:System.Threading.Tasks.Task> class implements the <xref:System.IDisposable> interface because internally it uses resources that also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="f3af1-580">Wenn Ihre APP [!INCLUDE[net_v45](~/includes/net-v45-md.md)] jedoch auf oder höher ausgerichtet ist, ist es nicht erforderlich, aufzurufen <xref:System.Threading.Tasks.Task.Dispose%2A> , es sei denn, Leistungs-oder Skalierbarkeits Tests geben an, dass die Leistung Ihrer APP basierend auf Ihren Verwendungs Mustern durch das Freigeben von Aufgaben verbessert wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-580">However, particularly if your app targets the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] or later, there is no need to call <xref:System.Threading.Tasks.Task.Dispose%2A> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</span></span> <span data-ttu-id="f3af1-581">Weitere Informationen finden Sie unter müssen [Sie Aufgaben verwerfen?](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) im Blog zur parallelen Programmierung mit .net.</span><span class="sxs-lookup"><span data-stu-id="f3af1-581">For more information, see [Do I need to dispose of Tasks?](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f3af1-582">Der Task ist nicht in einem der Endzustände: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> oder <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-582">The task is not in one of the final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</span></span></exception>
        <threadsafe><span data-ttu-id="f3af1-583">Im Gegensatz zu den meisten Membern <see cref="T:System.Threading.Tasks.Task" /> der-Klasse ist diese Methode nicht Thread sicher.</span><span class="sxs-lookup"><span data-stu-id="f3af1-583">Unlike most of the members of the <see cref="T:System.Threading.Tasks.Task" /> class, this method is not thread-safe.</span></span></threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Exception : AggregateException" Usage="System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f3af1-584">Ruft die <see cref="T:System.AggregateException" /> ab, die die vorzeitige Beendigung des <see cref="T:System.Threading.Tasks.Task" /> verursacht hat.</span><span class="sxs-lookup"><span data-stu-id="f3af1-584">Gets the <see cref="T:System.AggregateException" /> that caused the <see cref="T:System.Threading.Tasks.Task" /> to end prematurely.</span></span> <span data-ttu-id="f3af1-585">Wenn der <see cref="T:System.Threading.Tasks.Task" /> erfolgreich abgeschlossen wurde oder noch keine Ausnahmen ausgelöst wurden, wird <see langword="null" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-585">If the <see cref="T:System.Threading.Tasks.Task" /> completed successfully or has not yet thrown any exceptions, this will return <see langword="null" />.</span></span></summary>
        <value><span data-ttu-id="f3af1-586">Die <see cref="T:System.AggregateException" />, die die vorzeitige Beendigung des <see cref="T:System.Threading.Tasks.Task" /> verursacht hat.</span><span class="sxs-lookup"><span data-stu-id="f3af1-586">The <see cref="T:System.AggregateException" /> that caused the <see cref="T:System.Threading.Tasks.Task" /> to end prematurely.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-587">Tasks, die nicht behandelte Ausnahmen auslösen, speichern die resultierende Ausnahme und verteilen Sie in <xref:System.AggregateException> einem in Aufrufen <xref:System.Threading.Tasks.Task.Wait%2A> von oder in Zugriffen <xref:System.Threading.Tasks.Task.Exception%2A> auf die-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="f3af1-587">Tasks that throw unhandled exceptions store the resulting exception and propagate it wrapped in a <xref:System.AggregateException> in calls to <xref:System.Threading.Tasks.Task.Wait%2A> or in accesses to the <xref:System.Threading.Tasks.Task.Exception%2A> property.</span></span> <span data-ttu-id="f3af1-588">Alle Ausnahmen, die nicht durch den Zeitpunkt der Garbage Collection der Aufgaben Instanz beobachtet werden, werden im Finalizerthread weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-588">Any exceptions not observed by the time the task instance is garbage collected will be propagated on the finalizer thread.</span></span> <span data-ttu-id="f3af1-589">Weitere Informationen und ein Beispiel finden Sie unter [Ausnahmebehandlung (Task Parallel Library)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-589">For more information and an example, see [Exception Handling (Task Parallel Library)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory" Usage="System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f3af1-590">Bietet Zugriff auf Factorymethoden zum Erstellen und Konfigurieren von <see cref="T:System.Threading.Tasks.Task" />- und <see cref="T:System.Threading.Tasks.Task`1" />-Instanzen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-590">Provides access to factory methods for creating and configuring <see cref="T:System.Threading.Tasks.Task" /> and <see cref="T:System.Threading.Tasks.Task`1" /> instances.</span></span></summary>
        <value><span data-ttu-id="f3af1-591">Ein Factoryobjekt, das eine Vielzahl von <see cref="T:System.Threading.Tasks.Task" />- und <see cref="T:System.Threading.Tasks.Task`1" />-Objekten erstellen kann.</span><span class="sxs-lookup"><span data-stu-id="f3af1-591">A factory object that can create a variety of <see cref="T:System.Threading.Tasks.Task" /> and <see cref="T:System.Threading.Tasks.Task`1" /> objects.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-592">Diese Eigenschaft gibt eine Standard Instanz der <xref:System.Threading.Tasks.TaskFactory> -Klasse zurück, die mit der übereinstimmt, die durch Aufrufen des Parameter losen <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> Konstruktors erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-592">This property returns a default instance of the <xref:System.Threading.Tasks.TaskFactory> class that is identical to the one created by calling the parameterless <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="f3af1-593">Es verfügt über die folgenden Eigenschaftswerte:</span><span class="sxs-lookup"><span data-stu-id="f3af1-593">It has the following property values:</span></span>  
  
|<span data-ttu-id="f3af1-594">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="f3af1-594">Property</span></span>|<span data-ttu-id="f3af1-595">Wert</span><span class="sxs-lookup"><span data-stu-id="f3af1-595">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|<span data-ttu-id="f3af1-596">`null`, oder<xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="f3af1-596">`null`, or <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType></span></span>|  
  
 <span data-ttu-id="f3af1-597">Diese Eigenschaft wird am häufigsten verwendet, um eine neue Aufgabe zu erstellen und in einem einzelnen- <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methoden aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-597">The most common use of this property is to create and start a new task in a single call to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f3af1-598">Ab bietet die <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> -Methode die einfachste Möglichkeit zum Erstellen eines <xref:System.Threading.Tasks.Task> -Objekts mit Standard Konfigurations Werten. [!INCLUDE[net_v45](~/includes/net-v45-md.md)]</span><span class="sxs-lookup"><span data-stu-id="f3af1-598">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method provides the easiest way to create a <xref:System.Threading.Tasks.Task> object with default configuration values.</span></span>  
  
 <span data-ttu-id="f3af1-599">Im folgenden Beispiel wird die statische <xref:System.Threading.Tasks.Task.Factory%2A> -Eigenschaft verwendet, um zwei Aufrufe <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> an die-Methode durchführen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-599">The following example uses the static <xref:System.Threading.Tasks.Task.Factory%2A> property to make two calls to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f3af1-600">Füllt zunächst ein Array mit den Namen der Dateien im Verzeichnis "MyDocuments" des Benutzers auf, während das zweite ein Array mit den Namen der Unterverzeichnisse des Verzeichnisses "MyDocuments" des Benutzers auffüllt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-600">The first populates an array with the names of files in the user's MyDocuments directory, while the second populates an array with the names of subdirectories of the user's MyDocuments directory.</span></span> <span data-ttu-id="f3af1-601">Anschließend wird die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> -Methode aufgerufen, die Informationen über die Anzahl der Dateien und Verzeichnisse in den beiden Arrays anzeigt, nachdem die ersten beiden Tasks die Ausführung abgeschlossen haben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-601">It then calls the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> method, which displays information about the number of files and directories in the two arrays after the first two tasks have completed execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="f3af1-602">Das Abbruchtoken, mit dem die Aufgabe abgeschlossen werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-602">The cancellation token with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="f3af1-603">Erstellt einen durch Abbruch abgeschlossenen <see cref="T:System.Threading.Tasks.Task" /> mit einem angegebenen Abbruchtoken.</span><span class="sxs-lookup"><span data-stu-id="f3af1-603">Creates a <see cref="T:System.Threading.Tasks.Task" /> that's completed due to cancellation with a specified cancellation token.</span></span></summary>
        <returns><span data-ttu-id="f3af1-604">Die abgebrochene Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-604">The canceled task.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-605">Für <paramref name="cancellationToken" /> wurde kein Abbruch angefordert, dessen <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" />-Eigenschaft ist <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-605">Cancellation has not been requested for <paramref name="cancellationToken" />; its <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-606">Der Typ des von der Aufgabe zurückgegebenen Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-606">The type of the result returned by the task.</span></span></typeparam>
        <param name="cancellationToken"><span data-ttu-id="f3af1-607">Das Abbruchtoken, mit dem die Aufgabe abgeschlossen werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-607">The cancellation token with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="f3af1-608">Erstellt einen durch Abbruch abgeschlossenen <see cref="T:System.Threading.Tasks.Task`1" /> mit einem angegebenen Abbruchtoken.</span><span class="sxs-lookup"><span data-stu-id="f3af1-608">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed due to cancellation with a specified cancellation token.</span></span></summary>
        <returns><span data-ttu-id="f3af1-609">Die abgebrochene Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-609">The canceled task.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-610">Für <paramref name="cancellationToken" /> wurde kein Abbruch angefordert, dessen <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" />-Eigenschaft ist <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-610">Cancellation has not been requested for <paramref name="cancellationToken" />; its <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="exception"><span data-ttu-id="f3af1-611">Die Ausnahme, mit der die Aufgabe abgeschlossen werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-611">The exception with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="f3af1-612">Erstellt einen durch eine angegebene Ausnahme abgeschlossenen <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-612">Creates a <see cref="T:System.Threading.Tasks.Task" /> that has completed with a specified exception.</span></span></summary>
        <returns><span data-ttu-id="f3af1-613">Die fehlerhafte Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-613">The faulted task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-614">Diese Methode erstellt ein <xref:System.Threading.Tasks.Task> -Objekt <xref:System.Threading.Tasks.Task.Status%2A> , dessen <xref:System.Threading.Tasks.TaskStatus.Faulted> -Eigenschaft <xref:System.Threading.Tasks.Task.Exception%2A> ist und `exception`dessen-Eigenschaft enthält.</span><span class="sxs-lookup"><span data-stu-id="f3af1-614">This method creates a <xref:System.Threading.Tasks.Task> object whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.Faulted> and whose <xref:System.Threading.Tasks.Task.Exception%2A> property contains `exception`.</span></span> <span data-ttu-id="f3af1-615">Die-Methode wird häufig verwendet, wenn Sie sofort wissen, dass die Arbeit, die von einer Aufgabe ausgeführt wird, eine Ausnahme auslöst, bevor ein längerer Codepfad ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-615">The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</span></span> <span data-ttu-id="f3af1-616">Ein Beispiel finden Sie unter <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> Überladung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-616">For an example, see the <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-617">Der Typ des von der Aufgabe zurückgegebenen Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-617">The type of the result returned by the task.</span></span></typeparam>
        <param name="exception"><span data-ttu-id="f3af1-618">Die Ausnahme, mit der die Aufgabe abgeschlossen werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-618">The exception with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="f3af1-619">Erstellt einen durch eine angegebene Ausnahme abgeschlossenen <see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-619">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed with a specified exception.</span></span></summary>
        <returns><span data-ttu-id="f3af1-620">Die fehlerhafte Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-620">The faulted task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-621">Diese Methode erstellt ein <xref:System.Threading.Tasks.Task%601> -Objekt <xref:System.Threading.Tasks.Task.Status%2A> , dessen <xref:System.Threading.Tasks.TaskStatus.Faulted> -Eigenschaft <xref:System.Threading.Tasks.Task.Exception%2A> ist und `exception`dessen-Eigenschaft enthält.</span><span class="sxs-lookup"><span data-stu-id="f3af1-621">This method creates a <xref:System.Threading.Tasks.Task%601> object whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.Faulted> and whose <xref:System.Threading.Tasks.Task.Exception%2A> property contains `exception`.</span></span> <span data-ttu-id="f3af1-622">Die-Methode wird häufig verwendet, wenn Sie sofort wissen, dass die Arbeit, die von einer Aufgabe ausgeführt wird, eine Ausnahme auslöst, bevor ein längerer Codepfad ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-622">The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</span></span> <span data-ttu-id="f3af1-623">Dies wird im Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="f3af1-623">The example provides an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-624">Das folgende Beispiel ist ein Befehlszeilen-Hilfsprogramm, das die Anzahl der Bytes in den Dateien in jedem Verzeichnis berechnet, dessen Name als Befehlszeilenargument übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-624">The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</span></span> <span data-ttu-id="f3af1-625">Anstatt einen längeren Codepfad auszuführen, der ein <xref:System.IO.FileInfo> -Objekt instanziiert und den Wert seiner <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> -Eigenschaft für jede Datei im Verzeichnis abruft, ruft das Beispiel einfach <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> die-Methode auf, um eine Faulted-Aufgabe zu erstellen, wenn ein bestimmtes das Unterverzeichnis ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-625">Rather than executing a longer code path that instantiates a <xref:System.IO.FileInfo> object and retrieves the value of its <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> property for each file in the directory, the example simply calls the <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> method to create a faulted task if a particular subdirectory does not exist.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberSignature Language="F#" Value="static member FromResult : 'Result -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-626">Der Typ des von der Aufgabe zurückgegebenen Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-626">The type of the result returned by the task.</span></span></typeparam>
        <param name="result"><span data-ttu-id="f3af1-627">Das in der abgeschlossene Aufgabe zu speichernde Ergebnis.</span><span class="sxs-lookup"><span data-stu-id="f3af1-627">The result to store into the completed task.</span></span></param>
        <summary><span data-ttu-id="f3af1-628">Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, die erfolgreich mit dem angegebenen Ergebnis abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-628">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed successfully with the specified result.</span></span></summary>
        <returns><span data-ttu-id="f3af1-629">Die erfolgreich abgeschlossene Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-629">The successfully completed task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-630">Diese Methode erstellt ein <xref:System.Threading.Tasks.Task%601> -Objekt <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> , dessen `result` -Eigenschaft <xref:System.Threading.Tasks.Task.Status%2A> ist und <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>dessen-Eigenschaft ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-630">This method creates a <xref:System.Threading.Tasks.Task%601> object whose <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property is `result` and whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span></span> <span data-ttu-id="f3af1-631">Die-Methode wird häufig verwendet, wenn der Rückgabewert einer Aufgabe sofort bekannt ist, ohne dass ein längerer Codepfad ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-631">The method is commonly used when the return value of a task is immediately known without executing a longer code path.</span></span> <span data-ttu-id="f3af1-632">Dies wird im Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="f3af1-632">The example provides an illustration.</span></span>  
  
 <span data-ttu-id="f3af1-633">Zum Erstellen eines Task Objekts, das keinen Wert zurückgibt, rufen Sie das Task-Objekt <xref:System.Threading.Tasks.Task.CompletedTask%2A> aus der-Eigenschaft ab.</span><span class="sxs-lookup"><span data-stu-id="f3af1-633">To create a Task object that does not return a value, retrieve the Task object from the <xref:System.Threading.Tasks.Task.CompletedTask%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-634">Das folgende Beispiel ist ein Befehlszeilen-Hilfsprogramm, das die Anzahl der Bytes in den Dateien in jedem Verzeichnis berechnet, dessen Name als Befehlszeilenargument übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-634">The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</span></span> <span data-ttu-id="f3af1-635">Anstatt einen längeren Codepfad auszuführen, der <xref:System.IO.FileStream> ein-Objekt instanziiert und den Wert seiner <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> -Eigenschaft für jede Datei im Verzeichnis abruft, ruft das Beispiel einfach <xref:System.Threading.Tasks.Task.FromResult%2A> die-Methode auf, um <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> eine Aufgabe zu erstellen, deren die-Eigenschaft ist 0 (null), wenn ein Verzeichnis keine Dateien enthält.</span><span class="sxs-lookup"><span data-stu-id="f3af1-635">Rather than executing a longer code path that instantiates a <xref:System.IO.FileStream> object and retrieves the value of its <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> property for each file in the directory, the example simply calls the <xref:System.Threading.Tasks.Task.FromResult%2A> method to create a task whose <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property is zero (0) if a directory has no files.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberSignature Language="F#" Value="member this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f3af1-636">Ruft einen Awaiter ab, der verwendet wird, um dieses <see cref="T:System.Threading.Tasks.Task" /> zu erwarten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-636">Gets an awaiter used to await this <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <returns><span data-ttu-id="f3af1-637">Eine Awaiter-Instanz.</span><span class="sxs-lookup"><span data-stu-id="f3af1-637">An awaiter instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-638">Diese Methode ist für die Verwendung durch den Compiler vorgesehen, anstatt Sie im Anwendungscode zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-638">This method is intended for compiler use rather than for use in application code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f3af1-639">Ruft eine ID für diese <see cref="T:System.Threading.Tasks.Task" />-Instanz ab.</span><span class="sxs-lookup"><span data-stu-id="f3af1-639">Gets an ID for this <see cref="T:System.Threading.Tasks.Task" /> instance.</span></span></summary>
        <value><span data-ttu-id="f3af1-640">Der Bezeichner, der dieser <see cref="T:System.Threading.Tasks.Task" />-Instanz vom System zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-640">The identifier that is assigned by the system to this <see cref="T:System.Threading.Tasks.Task" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-641">Aufgaben-IDs werden bei Bedarf zugewiesen und stellen nicht notwendigerweise die Reihenfolge dar, in der Task Instanzen erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-641">Task IDs are assigned on-demand and do not necessarily represent the order in which task instances are created.</span></span> <span data-ttu-id="f3af1-642">Obwohl Konflikte sehr selten auftreten, ist es nicht gewährleistet, dass Aufgaben Bezeichner eindeutig sind.</span><span class="sxs-lookup"><span data-stu-id="f3af1-642">Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</span></span>  
  
 <span data-ttu-id="f3af1-643">Verwenden Sie die <xref:System.Threading.Tasks.Task.CurrentId%2A> -Eigenschaft, um die Task-ID der aktuell ausgeführten Aufgabe aus dem Code zu erhalten, der von der Aufgabe ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-643">To get the task ID of the currently executing task from within code that task is executing, use the <xref:System.Threading.Tasks.Task.CurrentId%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCanceled : bool" Usage="System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f3af1-644">Ruft einen Wert ab, der angibt, ob diese <see cref="T:System.Threading.Tasks.Task" />-Instanz die Ausführung aufgrund eines Abbruchs abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="f3af1-644">Gets whether this <see cref="T:System.Threading.Tasks.Task" /> instance has completed execution due to being canceled.</span></span></summary>
        <value><span data-ttu-id="f3af1-645"><see langword="true" /> wenn die Aufgabe aufgrund eines Abbruchs beendet wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-645"><see langword="true" /> if the task has completed due to being canceled; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-646">Eine <xref:System.Threading.Tasks.Task> wird unter den folgenden <xref:System.Threading.Tasks.TaskStatus.Canceled> Bedingungen im-Zustand vervollständigt:</span><span class="sxs-lookup"><span data-stu-id="f3af1-646">A <xref:System.Threading.Tasks.Task> will complete in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="f3af1-647"><xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> Der ist vor dem Starten der Task Ausführung für den Abbruch gekennzeichnet,</span><span class="sxs-lookup"><span data-stu-id="f3af1-647">Its <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> was marked for cancellation before the task started executing,</span></span>  
  
-   <span data-ttu-id="f3af1-648">Die Aufgabe hat die Abbruch Anforderung für die bereits Signalisierung <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> bestätigt, indem eine <xref:System.OperationCanceledException> ausgelöst wird <xref:System.Threading.CancellationToken>, die dieselbe hat.</span><span class="sxs-lookup"><span data-stu-id="f3af1-648">The task acknowledged the cancellation request on its already signaled <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> by throwing an <xref:System.OperationCanceledException> that bears the same <xref:System.Threading.CancellationToken>.</span></span>  
  
-   <span data-ttu-id="f3af1-649">Der Task hat die Abbruch Anforderung für den bereits signalisierten <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> bestätigt, indem er die <xref:System.Threading.CancellationToken> <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> -Methode für den aufruft.</span><span class="sxs-lookup"><span data-stu-id="f3af1-649">The task acknowledged the cancellation request on its already signaled <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> by calling the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> method on the <xref:System.Threading.CancellationToken>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f3af1-650">Wenn Sie den Wert der <xref:System.Threading.Tasks.Task.IsCanceled%2A> -Eigenschaft abrufen, wird der aufrufende Thread nicht blockiert, bis die Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-650">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsCanceled%2A> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f3af1-651">Ruft einen Wert ab, der angibt, ob die Aufgabe abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-651">Gets a value that indicates whether the task has completed.</span></span></summary>
        <value><span data-ttu-id="f3af1-652"><see langword="true" />, wenn die Aufgabe abgeschlossen wurde <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />(d <see langword="false" />. h., die Aufgabe befindet sich in einem der drei Endzustände: <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />oder); andernfalls.</span><span class="sxs-lookup"><span data-stu-id="f3af1-652"><see langword="true" /> if the task has completed (that is, the task is in one of the three final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />); otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> <span data-ttu-id="f3af1-653">Wenn Sie den Wert der <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> -Eigenschaft abrufen, wird der aufrufende Thread nicht blockiert, bis die Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-653">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompletedSuccessfully : bool" Usage="System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFaulted : bool" Usage="System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f3af1-654">Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Threading.Tasks.Task" /> aufgrund einer nicht behandelten Ausnahme abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-654">Gets whether the <see cref="T:System.Threading.Tasks.Task" /> completed due to an unhandled exception.</span></span></summary>
        <value><span data-ttu-id="f3af1-655"><see langword="true" /> wenn die Aufgabe einen Ausnahmefehler ausgelöst hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-655"><see langword="true" /> if the task has thrown an unhandled exception; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-656"><xref:System.Threading.Tasks.Task.IsFaulted%2A> <xref:System.Threading.Tasks.Task.Exception%2A> <xref:System.Threading.Tasks.TaskStatus.Faulted>Wenn den Wert <xref:System.Threading.Tasks.Task.Status%2A> hat, ist der der Aufgabe gleich, und die-Eigenschaft ist nicht NULL. `true`</span><span class="sxs-lookup"><span data-stu-id="f3af1-656">If <xref:System.Threading.Tasks.Task.IsFaulted%2A> is `true`, the task's <xref:System.Threading.Tasks.Task.Status%2A> is equal to <xref:System.Threading.Tasks.TaskStatus.Faulted>, and its <xref:System.Threading.Tasks.Task.Exception%2A> property will be non-null.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f3af1-657">Wenn Sie den Wert der <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> -Eigenschaft abrufen, wird der aufrufende Thread nicht blockiert, bis die Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-657">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f3af1-658">Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein Task- oder <see cref="T:System.Threading.Tasks.Task`1" />-Handle für diese Aufgabe zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-658">Queues the specified work to run on the ThreadPool and returns a task or <see cref="T:System.Threading.Tasks.Task`1" /> handle for that work.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-659">Die <xref:System.Threading.Tasks.Task.Run%2A> -Methode stellt eine Reihe von über Ladungen bereit, die das Starten einer Aufgabe mithilfe von Standardwerten erleichtern.</span><span class="sxs-lookup"><span data-stu-id="f3af1-659">The <xref:System.Threading.Tasks.Task.Run%2A> method provides a set of overloads that make it easy to start a task by using default values.</span></span> <span data-ttu-id="f3af1-660">Es ist eine leichte Alternative zu den <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> -über Ladungen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-660">It is a lightweight alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> overloads.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberSignature Language="F#" Value="static member Run : Action -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="f3af1-661">Die asynchron auszuführende Arbeit.</span><span class="sxs-lookup"><span data-stu-id="f3af1-661">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="f3af1-662">Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein <see cref="T:System.Threading.Tasks.Task" />-Objekt zurück, das diese Aufgabe darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-662">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task" /> object that represents that work.</span></span></summary>
        <returns><span data-ttu-id="f3af1-663">Eine Aufgabe, die die Arbeit darstellt, die sich in der Warteschlange befindet, um im Threadpool ausgeführt zu werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-663">A task that represents the work queued to execute in the ThreadPool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-664">Die <xref:System.Threading.Tasks.Task.Run%2A> -Methode ermöglicht es Ihnen, eine Aufgabe in einem einzelnen Methoden aufzurufen und ist eine einfachere Alternative <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> zur-Methode.</span><span class="sxs-lookup"><span data-stu-id="f3af1-664">The <xref:System.Threading.Tasks.Task.Run%2A> method allows you to create and execute a task in a single method call and is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method.</span></span> <span data-ttu-id="f3af1-665">Es wird eine Aufgabe mit den folgenden Standardwerten erstellt:</span><span class="sxs-lookup"><span data-stu-id="f3af1-665">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="f3af1-666">Das Abbruch Token ist <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f3af1-666">Its cancellation token is <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="f3af1-667">Der <xref:System.Threading.Tasks.Task.CreationOptions%2A> Eigenschafts Wert <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-667">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="f3af1-668">Dabei wird der standardmäßige Aufgabenplaner verwendet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-668">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="f3af1-669">Informationen zur Behandlung von Ausnahmen, die von Task Vorgängen ausgelöst werden, finden Sie unter [Ausnahmebehandlung](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-669">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-670">Im folgenden Beispiel wird eine `ShowThreadInfo` -Methode definiert, <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> die den des aktuellen Threads anzeigt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-670">The following example defines a `ShowThreadInfo` method  that displays the <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> of the current thread.</span></span> <span data-ttu-id="f3af1-671">Er wird direkt aus dem Anwendungs Thread aufgerufen und wird vom <xref:System.Action> Delegaten aufgerufen, der an die <xref:System.Threading.Tasks.Task.Run%28System.Action%29> -Methode übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-671">It is called directly from the application thread, and is called from the <xref:System.Action> delegate passed to the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 <span data-ttu-id="f3af1-672">Das folgende Beispiel ähnelt dem vorherigen, mit der Ausnahme, dass ein Lambda-Ausdruck verwendet wird, um den Code zu definieren, der vom Task ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-672">The following example is similar to the previous one, except that it uses a lambda expression to define the code that the task is to execute.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 <span data-ttu-id="f3af1-673">In den Beispielen wird gezeigt, dass die asynchrone Aufgabe in einem anderen Thread ausgeführt wird als der Haupt Anwendungs Thread.</span><span class="sxs-lookup"><span data-stu-id="f3af1-673">The examples show that the asynchronous task executes on a different thread than the main application thread.</span></span>  
  
 <span data-ttu-id="f3af1-674">Durch den-Aufrufvorgang <xref:System.Threading.Tasks.Task.Wait%2A> wird sichergestellt, dass die Aufgabe abgeschlossen ist und die Ausgabe vor dem Ende der Anwendung anzeigt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-674">The call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that the task completes and displays its output before the application ends.</span></span> <span data-ttu-id="f3af1-675">Andernfalls ist es möglich, dass die `Main` -Methode abgeschlossen wird, bevor die Aufgabe abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-675">Otherwise, it is possible that the `Main` method will complete before the task finishes.</span></span>  
  
 <span data-ttu-id="f3af1-676">Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.Run%28System.Action%29> -Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="f3af1-676">The following example illustrates the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span> <span data-ttu-id="f3af1-677">Er definiert ein Array von Verzeichnisnamen und startet eine separate Aufgabe zum Abrufen der Dateinamen in jedem Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="f3af1-677">It defines an array of directory names and starts a separate task to retrieve the file names in each directory.</span></span> <span data-ttu-id="f3af1-678">Alle Tasks schreiben die Dateinamen in ein einzelnes <xref:System.Collections.Concurrent.ConcurrentBag%601> Objekt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-678">All tasks write the file names to a single <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span> <span data-ttu-id="f3af1-679">Das Beispiel ruft dann die <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> -Methode auf, um sicherzustellen, dass alle Aufgaben abgeschlossen sind, und zeigt dann die Gesamtzahl der in das <xref:System.Collections.Concurrent.ConcurrentBag%601> -Objekt geschriebenen Dateinamen an.</span><span class="sxs-lookup"><span data-stu-id="f3af1-679">The example then calls the <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-680">Der <paramref name="action" />-Parameter war <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-680">The <paramref name="action" /> parameter was <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="f3af1-681">Ausnahmebehandlung (Task Parallel Library)</span><span class="sxs-lookup"><span data-stu-id="f3af1-681">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="f3af1-682">Die asynchron auszuführende Arbeit.</span><span class="sxs-lookup"><span data-stu-id="f3af1-682">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="f3af1-683">Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschleife hinzu und gibt einen Proxy für die Aufgabe zurück, die von <paramref name="function" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-683">Queues the specified work to run on the thread pool and returns a proxy for the  task returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="f3af1-684">Eine Aufgabe, die einen Proxy für die Aufgabe darstellt, die durch <paramref name="function" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-684">A task that represents a proxy for the task returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-685">Informationen zur Behandlung von Ausnahmen, die von Task Vorgängen ausgelöst werden, finden Sie unter [Ausnahmebehandlung](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-685">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-686">Der <paramref name="function" />-Parameter war <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-686">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="f3af1-687">Ausnahmebehandlung (Task Parallel Library)</span><span class="sxs-lookup"><span data-stu-id="f3af1-687">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="f3af1-688">Die asynchron auszuführende Arbeit.</span><span class="sxs-lookup"><span data-stu-id="f3af1-688">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-689">Ein Abbruchtoken, das verwendet werden kann, um die Arbeit abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-689">A cancellation token that can be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="f3af1-690">Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein <see cref="T:System.Threading.Tasks.Task" />-Objekt zurück, das diese Aufgabe darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-690">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task" /> object that represents that work.</span></span> <span data-ttu-id="f3af1-691">Ein Abbruchtoken ermöglicht den Abbruch der Arbeit.</span><span class="sxs-lookup"><span data-stu-id="f3af1-691">A cancellation token allows the work to be cancelled.</span></span></summary>
        <returns><span data-ttu-id="f3af1-692">Eine Aufgabe, die die Arbeit darstellt, die sich in der Warteschlange befindet, um im Threadpool ausgeführt zu werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-692">A task that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-693">Wenn der Abbruch angefordert wird, bevor die Ausführung der Aufgabe beginnt, wird der Task nicht ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-693">If cancellation is requested before the task begins execution, the task does not execute.</span></span> <span data-ttu-id="f3af1-694">Stattdessen wird er auf den <xref:System.Threading.Tasks.TaskStatus.Canceled> -Zustand festgelegt, und es wird eine <xref:System.Threading.Tasks.TaskCanceledException> -Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="f3af1-694">Instead it is set to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state and throws a <xref:System.Threading.Tasks.TaskCanceledException> exception.</span></span>  
  
 <span data-ttu-id="f3af1-695">Die <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> -Methode stellt eine einfachere Alternative <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> zur-Methode dar.</span><span class="sxs-lookup"><span data-stu-id="f3af1-695">The <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f3af1-696">Es wird eine Aufgabe mit den folgenden Standardwerten erstellt:</span><span class="sxs-lookup"><span data-stu-id="f3af1-696">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="f3af1-697">Der <xref:System.Threading.Tasks.Task.CreationOptions%2A> Eigenschafts Wert <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-697">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="f3af1-698">Dabei wird der standardmäßige Aufgabenplaner verwendet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-698">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="f3af1-699">Informationen zur Behandlung von Ausnahmen, die von Task Vorgängen ausgelöst werden, finden Sie unter [Ausnahmebehandlung](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-699">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-700">Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> -Methode aufgerufen, um eine Aufgabe zu erstellen, die die Dateien im Verzeichnis c:\Windows\System32 durchläuft.</span><span class="sxs-lookup"><span data-stu-id="f3af1-700">The following example calls the <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> method to create a task that iterates the files in the C:\Windows\System32 directory.</span></span> <span data-ttu-id="f3af1-701">Der Lambda-Ausdruck ruft <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> die-Methode auf, um einem <xref:System.Collections.Generic.List%601> -Objektinformationen zu jeder Datei hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-701">The lambda expression calls the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to add information about each  file to a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="f3af1-702">Jede von der-Schleife aufgerufene getrennte <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> , von der-Schleife aufgerufene Aufgabe überprüft den Status des Abbruch Tokens und ruft, <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> wenn der Abbruch angefordert wird, die-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="f3af1-702">Each detached nested task invoked by the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> loop checks the state of the cancellation token and, if cancellation is requested, calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f3af1-703">Die <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> -Methode löst <xref:System.OperationCanceledException> eine Ausnahme aus, die in `catch` einem-Block behandelt wird, wenn <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> der aufrufende Thread die-Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="f3af1-703">The <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method throws an <xref:System.OperationCanceledException> exception that is handled in a `catch` block when the calling thread calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-704">Der <paramref name="action" />-Parameter war <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-704">The <paramref name="action" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="f3af1-705">Die Aufgabe wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-705">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-706">Die <paramref name="cancellationToken" /> zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-706">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="f3af1-707">Ausnahmebehandlung (Task Parallel Library)</span><span class="sxs-lookup"><span data-stu-id="f3af1-707">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="f3af1-708">Die asynchron auszuführende Arbeit.</span><span class="sxs-lookup"><span data-stu-id="f3af1-708">The work to execute asynchronously.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-709">Ein Abbruchtoken, das verwendet werden soll, um die Arbeit abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-709">A cancellation token that should be used to cancel the work.</span></span></param>
        <summary><span data-ttu-id="f3af1-710">Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschleife hinzu und gibt einen Proxy für die Aufgabe zurück, die von <paramref name="function" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-710">Queues the specified work to run on the thread pool and returns a proxy for the task returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="f3af1-711">Eine Aufgabe, die einen Proxy für die Aufgabe darstellt, die durch <paramref name="function" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-711">A task that represents a proxy for the task returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-712">Informationen zur Behandlung von Ausnahmen, die von Task Vorgängen ausgelöst werden, finden Sie unter [Ausnahmebehandlung](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-712">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-713">Der <paramref name="function" />-Parameter war <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-713">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="f3af1-714">Die Aufgabe wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-714">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-715">Die <paramref name="cancellationToken" /> zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-715">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md"><span data-ttu-id="f3af1-716">Aufgabenabbruch</span><span class="sxs-lookup"><span data-stu-id="f3af1-716">Task Cancellation</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="f3af1-717">Ausnahmebehandlung (Task Parallel Library)</span><span class="sxs-lookup"><span data-stu-id="f3af1-717">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-718">Der Typ des von der Proxy-Aufgabe zurückgegebenen Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-718">The type of the result returned by the proxy task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="f3af1-719">Die asynchron auszuführende Arbeit.</span><span class="sxs-lookup"><span data-stu-id="f3af1-719">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="f3af1-720">Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschleife hinzu und gibt einen Proxy für die <see langword="Task(TResult)" /> zurück, die von <paramref name="function" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-720">Queues the specified work to run on the thread pool and returns a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="f3af1-721">Eine <see langword="Task(TResult)" />, die einen Proxy für die <see langword="Task(TResult)" /> darstellt, die durch <paramref name="function" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-721">A <see langword="Task(TResult)" /> that represents a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-722">Informationen zur Behandlung von Ausnahmen, die von Task Vorgängen ausgelöst werden, finden Sie unter [Ausnahmebehandlung](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-722">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-723">Der <paramref name="function" />-Parameter war <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-723">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="f3af1-724">Ausnahmebehandlung (Task Parallel Library)</span><span class="sxs-lookup"><span data-stu-id="f3af1-724">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-725">Der Rückgabetyp der Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-725">The return type of the task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="f3af1-726">Die asynchron auszuführende Arbeit.</span><span class="sxs-lookup"><span data-stu-id="f3af1-726">The work to execute asynchronously.</span></span></param>
        <summary><span data-ttu-id="f3af1-727">Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein <see cref="T:System.Threading.Tasks.Task`1" />-Objekt zurück, das diese Aufgabe darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-727">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task`1" /> object that represents that work.</span></span></summary>
        <returns><span data-ttu-id="f3af1-728">Ein Aufgabenobjekt zur Darstellung der Arbeit, die sich in der Warteschlange befindet, um im Threadpool ausgeführt zu werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-728">A task object that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-729">Die <xref:System.Threading.Tasks.Task.Run%2A> -Methode stellt eine einfachere Alternative <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> zur-Methode dar.</span><span class="sxs-lookup"><span data-stu-id="f3af1-729">The <xref:System.Threading.Tasks.Task.Run%2A> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f3af1-730">Es wird eine Aufgabe mit den folgenden Standardwerten erstellt:</span><span class="sxs-lookup"><span data-stu-id="f3af1-730">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="f3af1-731">Das Abbruch Token ist <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f3af1-731">Its cancellation token is <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="f3af1-732">Der <xref:System.Threading.Tasks.Task.CreationOptions%2A> Eigenschafts Wert <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-732">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="f3af1-733">Dabei wird der standardmäßige Aufgabenplaner verwendet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-733">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="f3af1-734">Informationen zur Behandlung von Ausnahmen, die von Task Vorgängen ausgelöst werden, finden Sie unter [Ausnahmebehandlung](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-734">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-735">Im folgenden Beispiel wird die ungefähre Anzahl von Wörtern in Textdateien gezählt, die veröffentlichte Bücher darstellen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-735">The following example counts the approximate number of words in text files that represent published books.</span></span> <span data-ttu-id="f3af1-736">Jede Aufgabe ist für das Öffnen einer Datei, das asynchrone Lesen des gesamten Inhalts und das Berechnen der Wort Anzahl mithilfe eines regulären Ausdrucks verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="f3af1-736">Each task is responsible for opening a file, reading its entire contents asynchronously, and calculating the word count by using a regular expression.</span></span> <span data-ttu-id="f3af1-737">Die <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> -Methode wird aufgerufen, um sicherzustellen, dass alle Aufgaben abgeschlossen sind, bevor die Wort Anzahl der einzelnen Bücher in der Konsole angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-737">The <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method is called to ensure that all tasks have completed before  displaying the word count of each book to the console.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 <span data-ttu-id="f3af1-738">Der reguläre Ausdruck `\p{P}*\s+` entspricht keinem, einem oder mehreren Interpunktions Zeichen, gefolgt von einem oder mehreren Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-738">The regular expression `\p{P}*\s+` matches zero, one, or more punctuation characters followed by one or more white-space characters.</span></span> <span data-ttu-id="f3af1-739">Dabei wird davon ausgegangen, dass die Gesamtzahl der Übereinstimmungen gleich der ungefähren Wort Anzahl ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-739">It assumes that the total number of matches equals the approximate word count.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-740">Der <paramref name="function" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-740">The <paramref name="function" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="f3af1-741">Ausnahmebehandlung (Task Parallel Library)</span><span class="sxs-lookup"><span data-stu-id="f3af1-741">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-742">Der Typ des von der Proxy-Aufgabe zurückgegebenen Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="f3af1-742">The type of the result returned by the proxy task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="f3af1-743">Die asynchron auszuführende Arbeit.</span><span class="sxs-lookup"><span data-stu-id="f3af1-743">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-744">Ein Abbruchtoken, das verwendet werden soll, um die Arbeit abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-744">A cancellation token that should be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="f3af1-745">Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschleife hinzu und gibt einen Proxy für die <see langword="Task(TResult)" /> zurück, die von <paramref name="function" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-745">Queues the specified work to run on the thread pool and returns a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="f3af1-746">Eine <see langword="Task(TResult)" />, die einen Proxy für die <see langword="Task(TResult)" /> darstellt, die durch <paramref name="function" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-746">A <see langword="Task(TResult)" /> that represents a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-747">Informationen zur Behandlung von Ausnahmen, die von Task Vorgängen ausgelöst werden, finden Sie unter [Ausnahmebehandlung](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-747">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-748">Der <paramref name="function" />-Parameter war <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-748">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="f3af1-749">Die Aufgabe wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-749">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-750">Die <paramref name="cancellationToken" /> zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-750">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md"><span data-ttu-id="f3af1-751">Aufgabenabbruch</span><span class="sxs-lookup"><span data-stu-id="f3af1-751">Task Cancellation</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="f3af1-752">Ausnahmebehandlung (Task Parallel Library)</span><span class="sxs-lookup"><span data-stu-id="f3af1-752">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-753">Der Ergebnistyp der Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-753">The result type of the task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="f3af1-754">Die asynchron auszuführende Arbeit.</span><span class="sxs-lookup"><span data-stu-id="f3af1-754">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-755">Ein Abbruchtoken, das verwendet werden soll, um die Arbeit abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-755">A cancellation token that should be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="f3af1-756">Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein <see langword="Task(TResult)" />-Objekt zurück, das diese Aufgabe darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-756">Queues the specified work to run on the thread pool and returns a <see langword="Task(TResult)" /> object that represents that work.</span></span> <span data-ttu-id="f3af1-757">Ein Abbruchtoken ermöglicht den Abbruch der Arbeit.</span><span class="sxs-lookup"><span data-stu-id="f3af1-757">A cancellation token allows the work to be cancelled.</span></span></summary>
        <returns><span data-ttu-id="f3af1-758">Eine <see langword="Task(TResult)" /> die die Arbeit darstellt, die sich in der Warteschlange befindet, um im Threadpool ausgeführt zu werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-758">A <see langword="Task(TResult)" /> that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-759">Wenn der Abbruch angefordert wird, bevor die Ausführung der Aufgabe beginnt, wird der Task nicht ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-759">If cancellation is requested before the task begins execution, the task does not execute.</span></span> <span data-ttu-id="f3af1-760">Stattdessen wird er auf den <xref:System.Threading.Tasks.TaskStatus.Canceled> -Zustand festgelegt, und es wird eine <xref:System.Threading.Tasks.TaskCanceledException> -Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="f3af1-760">Instead it is set to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state and throws a <xref:System.Threading.Tasks.TaskCanceledException> exception.</span></span>  
  
 <span data-ttu-id="f3af1-761">Die <xref:System.Threading.Tasks.Task.Run%2A> -Methode stellt eine einfachere Alternative <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> zur-Methode dar.</span><span class="sxs-lookup"><span data-stu-id="f3af1-761">The <xref:System.Threading.Tasks.Task.Run%2A> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method.</span></span> <span data-ttu-id="f3af1-762">Es wird eine Aufgabe mit den folgenden Standardwerten erstellt:</span><span class="sxs-lookup"><span data-stu-id="f3af1-762">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="f3af1-763">Der <xref:System.Threading.Tasks.Task.CreationOptions%2A> Eigenschafts Wert <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-763">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="f3af1-764">Dabei wird der standardmäßige Aufgabenplaner verwendet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-764">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="f3af1-765">Informationen zur Behandlung von Ausnahmen, die von Task Vorgängen ausgelöst werden, finden Sie unter [Ausnahmebehandlung](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-765">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-766">Im folgenden Beispiel werden 20 Aufgaben erstellt, die eine Schleife ausführen, bis ein Leistungswert auf den Wert 2 Millionen erhöht wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-766">The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</span></span> <span data-ttu-id="f3af1-767">Wenn die ersten 10 Tasks 2 Millionen erreichen, wird das Abbruch Token abgebrochen, und alle Tasks, deren Zähler nicht 2 Millionen erreicht haben, werden abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-767">When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</span></span> <span data-ttu-id="f3af1-768">Das Beispiel zeigt die mögliche Ausgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-768">The example shows possible output.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 <span data-ttu-id="f3af1-769">Anstatt die <xref:System.AggregateException.InnerExceptions%2A> -Eigenschaft zum Untersuchen von Ausnahmen zu verwenden, werden im Beispiel alle Aufgaben durchlaufen, um zu bestimmen, welche erfolgreich abgeschlossen wurden und welche abgebrochen wurden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-769">Instead of using the <xref:System.AggregateException.InnerExceptions%2A> property to   examine exceptions, the example iterates all tasks to determine which have completed successfully and which have been cancelled.</span></span> <span data-ttu-id="f3af1-770">Für diejenigen, die abgeschlossen wurden, wird der Wert angezeigt, der von der Aufgabe zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-770">For those that have completed, it displays the value returned by the task.</span></span>  
  
 <span data-ttu-id="f3af1-771">Da der Abbruch kooperativ ist, kann jede Aufgabe entscheiden, wie auf den Abbruch reagiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-771">Because cancellation is cooperative, each task can decide how to respond to cancellation.</span></span> <span data-ttu-id="f3af1-772">Das folgende Beispiel ähnelt dem ersten, mit dem Unterschied, dass, sobald das Token abgebrochen wird, die Aufgaben die Anzahl der Iterationen zurückgeben, die Sie abgeschlossen haben, anstatt eine Ausnahme auszulösen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-772">The following example is like the first, except that, once the token is cancelled, tasks return the number of iterations they've completed rather than throw an exception.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 <span data-ttu-id="f3af1-773">Im Beispiel muss die <xref:System.AggregateException> Ausnahme dennoch behandelt werden, da alle Tasks, die nicht gestartet wurden, wenn der Abbruch angefordert wird, trotzdem eine Ausnahme auslösen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-773">The example still must handle the <xref:System.AggregateException> exception,   since any tasks that have not started when cancellation is requested still throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-774">Der <paramref name="function" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-774">The <paramref name="function" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="f3af1-775">Die Aufgabe wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-775">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-776">Die <paramref name="cancellationToken" /> zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-776">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md"><span data-ttu-id="f3af1-777">Aufgabenabbruch</span><span class="sxs-lookup"><span data-stu-id="f3af1-777">Task Cancellation</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="f3af1-778">Ausnahmebehandlung (Task Parallel Library)</span><span class="sxs-lookup"><span data-stu-id="f3af1-778">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f3af1-779">Führt den <see cref="T:System.Threading.Tasks.Task" /> synchron mit dem aktuellen <see cref="T:System.Threading.Tasks.TaskScheduler" /> aus.</span><span class="sxs-lookup"><span data-stu-id="f3af1-779">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : unit -&gt; unit" Usage="task.RunSynchronously " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f3af1-780">Führt den <see cref="T:System.Threading.Tasks.Task" /> synchron mit dem aktuellen <see cref="T:System.Threading.Tasks.TaskScheduler" /> aus.</span><span class="sxs-lookup"><span data-stu-id="f3af1-780">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-781">Normalerweise werden Aufgaben asynchron in einem Thread Pool Thread ausgeführt, und der aufrufenden Thread wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="f3af1-781">Ordinarily, tasks are executed asynchronously on a thread pool thread and do not block the calling thread.</span></span> <span data-ttu-id="f3af1-782">Tasks, die durch den <xref:System.Threading.Tasks.Task.RunSynchronously> Aufruf der-Methode ausgeführt werden <xref:System.Threading.Tasks.TaskScheduler> , werden der aktuellen zugeordnet und werden auf dem aufrufenden Thread ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-782">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously> method are associated with the current <xref:System.Threading.Tasks.TaskScheduler> and are run on the calling thread.</span></span> <span data-ttu-id="f3af1-783">Wenn das Ziel Planer das Ausführen dieser Aufgabe für den aufrufenden Thread nicht unterstützt, wird die Ausführung der Aufgabe im Scheduler geplant, und der aufrufende Thread wird blockiert, bis die Ausführung der Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-783">If the target scheduler does not support running this task on the calling thread, the task will be scheduled for execution on the scheduler, and the calling thread will block until the task has completed execution.</span></span> <span data-ttu-id="f3af1-784">Obwohl die Aufgabe synchron ausgeführt wird, sollte der aufrufende Thread trotzdem aufrufen <xref:System.Threading.Tasks.Task.Wait%2A> , um alle Ausnahmen zu behandeln, die vom Task ausgelöst werden können.</span><span class="sxs-lookup"><span data-stu-id="f3af1-784">Even though the task runs synchronously, the calling thread should still call <xref:System.Threading.Tasks.Task.Wait%2A> to handle any exceptions that the task might throw.</span></span>  <span data-ttu-id="f3af1-785">Weitere Informationen zur Ausnahmebehandlung finden Sie unter [Ausnahmebehandlung](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-785">For more information on exception handling, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 <span data-ttu-id="f3af1-786">Tasks, die durch Aufrufen <xref:System.Threading.Tasks.Task.RunSynchronously%2A> der-Methode ausgeführt werden, werden durch <xref:System.Threading.Tasks.Task> aufrufen <xref:System.Threading.Tasks.Task%601> eines-oder-Klassenkonstruktors instanziiert</span><span class="sxs-lookup"><span data-stu-id="f3af1-786">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method are instantiated by calling a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> class constructor.</span></span> <span data-ttu-id="f3af1-787">Der Task, der synchron ausgeführt werden soll, muss sich <xref:System.Threading.Tasks.TaskStatus.Created> im-Zustand befinden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-787">The task to be run synchronously must be in the <xref:System.Threading.Tasks.TaskStatus.Created> state.</span></span> <span data-ttu-id="f3af1-788">Eine Aufgabe kann gestartet und nur einmal ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-788">A task may be started and run only once.</span></span> <span data-ttu-id="f3af1-789">Alle Versuche, eine Aufgabe ein zweites Mal zu planen, führen zu einer Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="f3af1-789">Any attempts to schedule a task a second time results in an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-790">Im folgenden Beispiel wird eine Aufgabe verglichen, die ausgeführt <xref:System.Threading.Tasks.Task.RunSynchronously%2A> wird, indem die-Methode aufgerufen wird, die asynchron ausgeführt wird</span><span class="sxs-lookup"><span data-stu-id="f3af1-790">The following example compares a task executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method with one executed asynchronously.</span></span> <span data-ttu-id="f3af1-791">In beiden Fällen führen die Tasks identische Lambda-Ausdrücke aus, die die Task-ID und die ID des Threads, in dem der Task ausgeführt wird, anzeigen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-791">In both cases, the tasks execute identical lambda expressions that display the task ID and the ID of the thread on which the task is running.</span></span> <span data-ttu-id="f3af1-792">Der Task berechnet die Summe der ganzen Zahlen zwischen 1 und 1 Million.</span><span class="sxs-lookup"><span data-stu-id="f3af1-792">The task calculates the sum of the integers between 1 and 1,000,000.</span></span> <span data-ttu-id="f3af1-793">Wie die Ausgabe des Beispiels zeigt, wird die durch den Aufruf der <xref:System.Threading.Tasks.Task.RunSynchronously%2A> -Methode ausgeführte Aufgabe im Anwendungs Thread ausgeführt, während dies bei der asynchronen Aufgabe nicht der gibt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-793">As the output from the example shows, the task executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method runs on the application thread, while the asynchronous task does not.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-794">Die <see cref="T:System.Threading.Tasks.Task" />-Instanz wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-794">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f3af1-795">Die <see cref="T:System.Threading.Tasks.Task" /> liegt nicht in einem gültigen Zustand vor, um gestartet werden zu können.</span><span class="sxs-lookup"><span data-stu-id="f3af1-795">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="f3af1-796">Möglicherweise wurde sie bereits gestartet, ausgeführt oder abgebrochen, oder sie wurde möglicherweise auf eine Weise erstellt, die keine direkte Planung unterstützt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-796">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="f3af1-797">Ausnahmebehandlung (Task Parallel Library)</span><span class="sxs-lookup"><span data-stu-id="f3af1-797">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.RunSynchronously scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler"><span data-ttu-id="f3af1-798">Der Taskplaner, mit dem diese Aufgabe inline ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-798">The scheduler on which to attempt to run this task inline.</span></span></param>
        <summary><span data-ttu-id="f3af1-799">Führt die <see cref="T:System.Threading.Tasks.Task" /> synchron mit dem bereitgestellten <see cref="T:System.Threading.Tasks.TaskScheduler" /> aus.</span><span class="sxs-lookup"><span data-stu-id="f3af1-799">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the <see cref="T:System.Threading.Tasks.TaskScheduler" /> provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-800">Tasks, die durch Aufrufen <xref:System.Threading.Tasks.Task.RunSynchronously%2A> der-Methode ausgeführt werden, werden durch <xref:System.Threading.Tasks.Task> aufrufen <xref:System.Threading.Tasks.Task%601> eines-oder-Klassenkonstruktors instanziiert</span><span class="sxs-lookup"><span data-stu-id="f3af1-800">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method are instantiated by calling a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> class constructor.</span></span> <span data-ttu-id="f3af1-801">Der Task, der synchron ausgeführt werden soll, muss sich <xref:System.Threading.Tasks.TaskStatus.Created> im-Zustand befinden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-801">The task to be run synchronously must be in the <xref:System.Threading.Tasks.TaskStatus.Created> state.</span></span> <span data-ttu-id="f3af1-802">Eine Aufgabe kann gestartet und nur einmal ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-802">A task may be started and run only once.</span></span> <span data-ttu-id="f3af1-803">Alle Versuche, eine Aufgabe ein zweites Mal zu planen, führen zu einer Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="f3af1-803">Any attempts to schedule a task a second time results in an exception.</span></span>  
  
 <span data-ttu-id="f3af1-804">Wenn das Ziel Planer das Ausführen dieser Aufgabe für den aktuellen Thread nicht unterstützt, wird die Ausführung der Aufgabe im Scheduler geplant, und der aktuelle Thread wird blockiert, bis die Ausführung der Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-804">If the target scheduler does not support running this task on the current thread, the task will be scheduled for execution on the scheduler, and the current thread will block until the task has completed execution.</span></span> <span data-ttu-id="f3af1-805">Aus diesem Grund muss der aufrufende Thread keine Methode aufrufen, wie z <xref:System.Threading.Tasks.Task.Wait%2A> . b., um sicherzustellen, dass die Ausführung der Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-805">Because of this, the calling thread does not need to call a method such as <xref:System.Threading.Tasks.Task.Wait%2A> to ensure that the task has completed execution.</span></span> <span data-ttu-id="f3af1-806">Weitere Informationen zur Ausnahmebehandlung für Task Vorgänge finden Sie unter [Ausnahmebehandlung](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-806">For more information on exception handling for task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-807">Die <see cref="T:System.Threading.Tasks.Task" />-Instanz wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-807">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-808">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-808">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f3af1-809">Die <see cref="T:System.Threading.Tasks.Task" /> liegt nicht in einem gültigen Zustand vor, um gestartet werden zu können.</span><span class="sxs-lookup"><span data-stu-id="f3af1-809">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="f3af1-810">Möglicherweise wurde sie bereits gestartet, ausgeführt oder abgebrochen, oder sie wurde möglicherweise auf eine Weise erstellt, die keine direkte Planung unterstützt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-810">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="f3af1-811">Ausnahmebehandlung (Task Parallel Library)</span><span class="sxs-lookup"><span data-stu-id="f3af1-811">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f3af1-812">Startet den <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-812">Starts the <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="task.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f3af1-813">Startet den <see cref="T:System.Threading.Tasks.Task" /> und plant seine Ausführung mit dem aktuellen <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-813">Starts the <see cref="T:System.Threading.Tasks.Task" />, scheduling it for execution to the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-814">Eine Aufgabe kann gestartet und nur einmal ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-814">A task may be started and run only once.</span></span> <span data-ttu-id="f3af1-815">Alle Versuche, eine Aufgabe ein zweites Mal zu planen, führen zu einer Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="f3af1-815">Any attempts to schedule a task a second time will result in an exception.</span></span>  
  
 <span data-ttu-id="f3af1-816">Wird verwendet, um eine Aufgabe auszuführen, die durch Aufrufen eines <xref:System.Threading.Tasks.Task> der-Konstruktoren erstellt wurde. <xref:System.Threading.Tasks.Task.Start%2A></span><span class="sxs-lookup"><span data-stu-id="f3af1-816">The <xref:System.Threading.Tasks.Task.Start%2A> is used to execute a task that has been created by calling one of the <xref:System.Threading.Tasks.Task> constructors.</span></span> <span data-ttu-id="f3af1-817">Dies geschieht in der Regel, wenn Sie die Erstellung der Aufgabe von ihrer Ausführung trennen müssen, z. b. Wenn Sie Aufgaben bedingt ausführen, die Sie erstellt haben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-817">Typically, you do this when you need to separate the task's creation from its execution, such as when you conditionally execute tasks that you've created.</span></span> <span data-ttu-id="f3af1-818">Für den gängigeren Fall, in dem Sie die Task Instanziierung nicht von der Ausführung trennen müssen, empfiehlt es sich, eine Überladung <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> der <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> -Methode oder der-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-818">For the more common case in which you don't need to separate  task instantiation from execution, we recommend that you call an overload of the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f3af1-819">Informationen zur Behandlung von Ausnahmen, die von Task Vorgängen ausgelöst werden, finden Sie unter [Ausnahmebehandlung](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-819">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-820">Im folgenden Beispiel wird der <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> -Konstruktor aufgerufen, um ein neues <xref:System.Threading.Tasks.Task> -Objekt zu instanziieren, das die Task-ID und die verwaltete Thread-ID anzeigt und dann eine-Schleife ausführt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-820">The following example calls the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> constructor to instantiate a new <xref:System.Threading.Tasks.Task> object that displays its task ID and managed thread ID and then executes a loop.</span></span> <span data-ttu-id="f3af1-821">Anschließend wird die <xref:System.Threading.Tasks.Task.Start%2A> -Methode aufgerufen, um die Aufgabe auszuführen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-821">It then calls the <xref:System.Threading.Tasks.Task.Start%2A> method to execute the task.</span></span>  <span data-ttu-id="f3af1-822">Da es sich hierbei um eine Konsolen-App handelt, <xref:System.Threading.Tasks.Task.Wait%2A> ist der Methodenaufrufe erforderlich, um zu verhindern, dass die APP beendet wird, bevor die Ausführung der Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-822">Since this is a console app, the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method is necessary to prevent the app from terminating before the task finishes execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-823">Die <see cref="T:System.Threading.Tasks.Task" />-Instanz wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-823">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f3af1-824">Die <see cref="T:System.Threading.Tasks.Task" /> liegt nicht in einem gültigen Zustand vor, um gestartet werden zu können.</span><span class="sxs-lookup"><span data-stu-id="f3af1-824">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="f3af1-825">Möglicherweise wurde sie bereits gestartet, ausgeführt oder abgebrochen, oder sie wurde möglicherweise auf eine Weise erstellt, die keine direkte Planung unterstützt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-825">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="f3af1-826">Ausnahmebehandlung (Task Parallel Library)</span><span class="sxs-lookup"><span data-stu-id="f3af1-826">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.Start : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.Start scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler"><span data-ttu-id="f3af1-827">Der <see cref="T:System.Threading.Tasks.TaskScheduler" />, dem diese Aufgabe zugeordnet und mit dem sie ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-827">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> with which to associate and execute this task.</span></span></param>
        <summary><span data-ttu-id="f3af1-828">Startet die <see cref="T:System.Threading.Tasks.Task" /> und plant ihre Ausführung mit dem angegebenen <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-828">Starts the <see cref="T:System.Threading.Tasks.Task" />, scheduling it for execution to the specified <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-829">Eine Aufgabe kann nur einmal gestartet und nur einmal ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-829">A task may only be started and run only once.</span></span> <span data-ttu-id="f3af1-830">Alle Versuche, eine Aufgabe ein zweites Mal zu planen, führen zu einer Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="f3af1-830">Any attempts to schedule a task a second time will result in an exception.</span></span>  
  
 <span data-ttu-id="f3af1-831">Informationen zur Behandlung von Ausnahmen, die von Task Vorgängen ausgelöst werden, finden Sie unter [Ausnahmebehandlung](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-831">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-832">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-832">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f3af1-833">Die <see cref="T:System.Threading.Tasks.Task" /> liegt nicht in einem gültigen Zustand vor, um gestartet werden zu können.</span><span class="sxs-lookup"><span data-stu-id="f3af1-833">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="f3af1-834">Möglicherweise wurde sie bereits gestartet, ausgeführt oder abgebrochen, oder sie wurde möglicherweise auf eine Weise erstellt, die keine direkte Planung unterstützt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-834">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-835">Die <see cref="T:System.Threading.Tasks.Task" />-Instanz wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-835">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException"><span data-ttu-id="f3af1-836">Der Planer konnte diesen Task nicht in die Warteschlange einreihen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-836">The scheduler was unable to queue this task.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="f3af1-837">Ausnahmebehandlung (Task Parallel Library)</span><span class="sxs-lookup"><span data-stu-id="f3af1-837">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberSignature Language="F#" Value="member this.Status : System.Threading.Tasks.TaskStatus" Usage="System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f3af1-838">Ruft den <see cref="T:System.Threading.Tasks.TaskStatus" /> dieser Aufgabe ab.</span><span class="sxs-lookup"><span data-stu-id="f3af1-838">Gets the <see cref="T:System.Threading.Tasks.TaskStatus" /> of this task.</span></span></summary>
        <value><span data-ttu-id="f3af1-839">Der aktuelle <see cref="T:System.Threading.Tasks.TaskStatus" /> dieser Aufgabeninstanz.</span><span class="sxs-lookup"><span data-stu-id="f3af1-839">The current <see cref="T:System.Threading.Tasks.TaskStatus" /> of this task instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-840">Wenn Sie den Wert der <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> -Eigenschaft abrufen, wird der aufrufende Thread nicht blockiert, bis die Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-840">Retrieving the value of the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 <span data-ttu-id="f3af1-841">Weitere Informationen und ein Beispiel finden Sie unter [Verketten von Aufgaben mithilfe von Fortsetzungs Aufgaben](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) und [Gewusst wie: Abbrechen einer Aufgabe und ihrer untergeordneten Elemente](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-841">For more information and an example, see [Chaining Tasks by Using Continuation Tasks](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) and [How to: Cancel a Task and Its Children](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-842">Im folgenden Beispiel werden 20 Aufgaben erstellt, die eine Schleife ausführen, bis ein Leistungswert auf den Wert 2 Millionen erhöht wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-842">The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</span></span> <span data-ttu-id="f3af1-843">Wenn die ersten 10 Tasks 2 Millionen erreichen, wird das Abbruch Token abgebrochen, und alle Tasks, deren Zähler nicht 2 Millionen erreicht haben, werden abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-843">When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</span></span> <span data-ttu-id="f3af1-844">Im Beispiel wird dann die <xref:System.Threading.Tasks.Task.Status%2A> -Eigenschaft jeder Aufgabe überprüft, um anzugeben, ob Sie erfolgreich abgeschlossen wurde oder abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-844">The example then examines the <xref:System.Threading.Tasks.Task.Status%2A> property of each task to indicate whether it completed successfully or was cancelled.</span></span> <span data-ttu-id="f3af1-845">Für diejenigen, die abgeschlossen wurden, wird der von der Aufgabe zurückgegebene Wert angezeigt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-845">For those that completed, it displays the value returned by the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System::IAsyncResult::AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f3af1-846">Ruft ein <see cref="T:System.Threading.WaitHandle" /> ab, das verwendet werden kann, um auf den Abschluss der Aufgabe zu warten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-846">Gets a <see cref="T:System.Threading.WaitHandle" /> that can be used to wait for the task to complete.</span></span></summary>
        <value><span data-ttu-id="f3af1-847">Ein <see cref="T:System.Threading.WaitHandle" />, das verwendet werden kann, um auf den Abschluss der Aufgabe zu warten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-847">A <see cref="T:System.Threading.WaitHandle" /> that can be used to wait for the task to complete.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-848">Die Verwendung der von <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> bereitgestellten Wait-Funktionalität empfiehlt sich der Verwendung <xref:System.IAsyncResult.AsyncWaitHandle%2A> von für eine ähnliche Funktionalität.</span><span class="sxs-lookup"><span data-stu-id="f3af1-848">Using the wait functionality provided by <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> is preferable to using <xref:System.IAsyncResult.AsyncWaitHandle%2A> for similar functionality.</span></span> <span data-ttu-id="f3af1-849">Weitere Informationen finden Sie im Abschnitt "warten auf Aufgaben" unter [aufgabenbasierte asynchrone Programmierung](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) und Verwenden von [TPL mit anderen asynchronen Mustern](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).</span><span class="sxs-lookup"><span data-stu-id="f3af1-849">For more information, see the "Waiting on Tasks" section in [Task-based Asynchronous Programming](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Using TPL with Other Asynchronous Patterns](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-850"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-850">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::IAsyncResult::CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f3af1-851">Ruft einen Wert ab, der angibt, ob der Vorgang synchron abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-851">Gets an indication of whether the operation completed synchronously.</span></span></summary>
        <value><span data-ttu-id="f3af1-852"><see langword="true" />, wenn der Vorgang synchron abgeschlossen wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-852"><see langword="true" /> if the operation completed synchronously; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f3af1-853">Wartet, bis der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung abschließt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-853">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="task.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f3af1-854">Wartet, bis der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung abschließt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-854">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-855"><xref:System.Threading.Tasks.Task.Wait%2A>ist eine Synchronisierungsmethode, die bewirkt, dass der aufrufende Thread wartet, bis die aktuelle Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-855"><xref:System.Threading.Tasks.Task.Wait%2A> is a synchronization method that causes the calling thread to wait until the current task has completed.</span></span> <span data-ttu-id="f3af1-856">Wenn die Ausführung der aktuellen Aufgabe nicht gestartet wurde, versucht die Wait-Methode, die Aufgabe aus dem Scheduler zu entfernen und Sie Inline im aktuellen Thread auszuführen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-856">If the current task has not started execution, the Wait method attempts to remove the task from the scheduler and execute it inline on the current thread.</span></span> <span data-ttu-id="f3af1-857">Wenn dies nicht möglich ist, oder wenn die Ausführung der aktuellen Aufgabe bereits begonnen hat, wird der aufrufende Thread blockiert, bis die Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-857">If it is unable to do that, or if the current task has already started execution, it blocks the calling thread until the task completes.</span></span> <span data-ttu-id="f3af1-858">Weitere Informationen finden Sie unter [Task. Wait und "Inlining"](https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/) im Blog zur parallelen Programmierung mit .net.</span><span class="sxs-lookup"><span data-stu-id="f3af1-858">For more information, see [Task.Wait and "Inlining"](https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/) in the Parallel Programming with .NET blog.</span></span>   
  
## Examples  
 <span data-ttu-id="f3af1-859">Im folgenden Beispiel wird eine Aufgabe gestartet, die 1 Million Random Integer zwischen 0 und 100 generiert und ihren Mittelwert berechnet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-859">The following example starts a task that generates one million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="f3af1-860">Das Beispiel verwendet die <xref:System.Threading.Tasks.Task.Wait%2A> -Methode, um sicherzustellen, dass die Aufgabe abgeschlossen ist, bevor die Anwendung beendet wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-860">The example uses the <xref:System.Threading.Tasks.Task.Wait%2A> method to ensure that the task completes before the application terminates.</span></span> <span data-ttu-id="f3af1-861">Da es sich hierbei um eine Konsolenanwendung handelt, wird das Beispiel beendet, bevor die Aufgabe den Mittelwert berechnen und anzeigen kann.</span><span class="sxs-lookup"><span data-stu-id="f3af1-861">Otherwise, because this is a console application, the example would terminate before the task can compute and display the mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-862"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-862">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="f3af1-863">Der Task wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-863">The task was canceled.</span></span> <span data-ttu-id="f3af1-864">Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-864">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="f3af1-865">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-865">-or-</span></span> 
<span data-ttu-id="f3af1-866">Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="f3af1-866">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="f3af1-867">Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-867">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
        <related type="ExternalDocumentation" href="https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/"><span data-ttu-id="f3af1-868">"Task. Wait" und "Inlining"</span><span class="sxs-lookup"><span data-stu-id="f3af1-868">Task.Wait and "Inlining"</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="task.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="f3af1-869">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="f3af1-869">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f3af1-870">Wartet darauf, dass die <see cref="T:System.Threading.Tasks.Task" /> innerhalb einer angegebenen Anzahl an Millisekunden vollständig ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-870">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="f3af1-871"><see langword="true" />, wenn der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-871"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-872"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>ist eine Synchronisierungsmethode, die bewirkt, dass der aufrufende Thread auf den Abschluss der aktuellen Aufgaben Instanz wartet, bis eine der folgenden Aktionen auftritt:</span><span class="sxs-lookup"><span data-stu-id="f3af1-872"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="f3af1-873">Der Task wurde erfolgreich abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-873">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="f3af1-874">Der Task selbst wird abgebrochen oder löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="f3af1-874">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="f3af1-875">In diesem Fall wird eine <xref:System.AggregateException> Ausnahme behandelt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-875">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="f3af1-876">Die <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> -Eigenschaft enthält Details zur Ausnahme oder zu Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-876">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="f3af1-877">Das durch `millisecondsTimeout` definierte Intervall verstreicht.</span><span class="sxs-lookup"><span data-stu-id="f3af1-877">The interval defined by `millisecondsTimeout` elapses.</span></span> <span data-ttu-id="f3af1-878">In diesem Fall wird die Ausführung des aktuellen Threads fortgesetzt, und die `false`Methode gibt zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-878">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-879">Im folgenden Beispiel wird eine Aufgabe gestartet, die 5 Millionen Random Integer zwischen 0 und 100 generiert und ihren Mittelwert berechnet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-879">The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="f3af1-880">Im Beispiel wird die <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> -Methode verwendet, um zu warten, bis die Anwendung innerhalb von 150 Millisekunden fertiggestellt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-880">The example uses the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> method to wait for the application to complete within 150 milliseconds.</span></span> <span data-ttu-id="f3af1-881">Wenn die Anwendung normal abgeschlossen ist, zeigt die Aufgabe die Summe und den Mittelwert der Zufallszahlen an, die Sie generiert hat.</span><span class="sxs-lookup"><span data-stu-id="f3af1-881">If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</span></span> <span data-ttu-id="f3af1-882">Wenn das Timeout Intervall abgelaufen ist, wird im Beispiel eine Meldung angezeigt, bevor Sie beendet wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-882">If the timeout interval has elapsed, the example displays a message before it terminates.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-883"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-883">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-884"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-884"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="f3af1-885">Der Task wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-885">The task was canceled.</span></span> <span data-ttu-id="f3af1-886">Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-886">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="f3af1-887">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-887">-or-</span></span> 
<span data-ttu-id="f3af1-888">Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="f3af1-888">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="f3af1-889">Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-889">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="task.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="f3af1-890">Ein Abbruchtoken, das beim Warten auf den Abschluss der Aufgabe überwacht werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-890">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="f3af1-891">Wartet, bis der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung abschließt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-891">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span> <span data-ttu-id="f3af1-892">Der Wartevorgang wird beendet, wenn ein Abbruchtoken abgebrochen wird, bevor die Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-892">The wait terminates if a cancellation token is canceled before the task completes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-893">Die <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> -Methode erstellt einen Abbruch, der abgebrochen werden kann, d. h., der aktuelle Thread wartet, bis eine der folgenden Aktionen auftritt:</span><span class="sxs-lookup"><span data-stu-id="f3af1-893">The <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> method creates a cancelable wait; that is, it causes the current thread to wait until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="f3af1-894">Die Aufgabe ist abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-894">The task completes.</span></span>  
  
-   <span data-ttu-id="f3af1-895">Das Abbruch Token wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-895">The cancellation token is canceled.</span></span> <span data-ttu-id="f3af1-896">In diesem Fall löst der Aufrufe der <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> -Methode eine <xref:System.OperationCanceledException>aus.</span><span class="sxs-lookup"><span data-stu-id="f3af1-896">In this case, the call to the <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> method throws an <xref:System.OperationCanceledException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f3af1-897">Das Abbrechen des `cancellationToken` Abbruch Tokens hat keine Auswirkung auf die laufende Aufgabe, es sei denn, es wurde auch das Abbruch Token übergeben und ist für die Behandlung von Abbruch vorbereitet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-897">Canceling the `cancellationToken` cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</span></span> <span data-ttu-id="f3af1-898">Wenn Sie `cancellationToken` das-Objekt an diese Methode übergeben, kann die Wartezeit einfach abgebrochen werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-898">Passing the `cancellationToken` object to this method simply allows the wait to be canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-899">Das folgende Beispiel veranschaulicht die einfache Verwendung eines Abbruch Tokens, um das warten auf den Abschluss einer Aufgabe abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-899">The following example illustrates the simple use of a cancellation token to cancel waiting for a task's completion.</span></span> <span data-ttu-id="f3af1-900">Ein Task wird gestartet, ruft die <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> -Methode auf, um die Abbruch Token der tokenquelle abzubrechen und dann fünf Sekunden lang zu Verzögerungen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-900">A task is launched, calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to cancel any of the token source's cancellation tokens, and then delays for five seconds.</span></span> <span data-ttu-id="f3af1-901">Beachten Sie, dass der Aufgabe selbst nicht das Abbruch Token übergeben wurde und nicht abgebrochen werden kann.</span><span class="sxs-lookup"><span data-stu-id="f3af1-901">Note that the task itself has not been passed the cancellation token and is not cancelable.</span></span> <span data-ttu-id="f3af1-902">Der Anwendungs Thread ruft die- <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Methode der Aufgabe auf, um auf den Abschluss der Aufgabe zu warten. der Warte Vorgang wird jedoch abgebrochen, sobald das Abbruch Token abgebrochen und eine <xref:System.OperationCanceledException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-902">The application thread calls the task's <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for the task to complete, but the wait is canceled once the cancellation token is cancelled and an <xref:System.OperationCanceledException> is thrown.</span></span> <span data-ttu-id="f3af1-903">Der Ausnahmehandler meldet die Ausnahme und wird sechs Sekunden lang in den Ruhezustand versetzt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-903">The exception handler reports the exception and then sleeps for six seconds.</span></span> <span data-ttu-id="f3af1-904">Wie die Ausgabe des Beispiels zeigt, ermöglicht diese Verzögerung die Fertigstellung der Aufgabe im <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> -Zustand.</span><span class="sxs-lookup"><span data-stu-id="f3af1-904">As the output from the example shows, that delay allows the task to complete in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="f3af1-905">Das <paramref name="cancellationToken" /> wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-905">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-906">Die Aufgabe wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-906">The task has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="f3af1-907">Der Task wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-907">The task was canceled.</span></span> <span data-ttu-id="f3af1-908">Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-908">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="f3af1-909">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-909">-or-</span></span> 
<span data-ttu-id="f3af1-910">Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="f3af1-910">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="f3af1-911">Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-911">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="task.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f3af1-912">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-912">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f3af1-913">Wartet darauf, dass die <see cref="T:System.Threading.Tasks.Task" /> innerhalb eines angegebenen Zeitintervalls vollständig ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-913">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution within a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="f3af1-914"><see langword="true" />, wenn der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-914"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-915"><xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>ist eine Synchronisierungsmethode, die bewirkt, dass der aufrufende Thread auf den Abschluss der aktuellen Aufgaben Instanz wartet, bis eine der folgenden Aktionen auftritt:</span><span class="sxs-lookup"><span data-stu-id="f3af1-915"><xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="f3af1-916">Der Task wurde erfolgreich abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-916">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="f3af1-917">Der Task selbst wird abgebrochen oder löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="f3af1-917">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="f3af1-918">In diesem Fall wird eine <xref:System.AggregateException> Ausnahme behandelt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-918">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="f3af1-919">Die <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> -Eigenschaft enthält Details zur Ausnahme oder zu Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-919">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="f3af1-920">Das durch `timeout` definierte Intervall verstreicht.</span><span class="sxs-lookup"><span data-stu-id="f3af1-920">The interval defined by `timeout` elapses.</span></span> <span data-ttu-id="f3af1-921">In diesem Fall wird die Ausführung des aktuellen Threads fortgesetzt, und die `false`Methode gibt zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-921">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-922">Im folgenden Beispiel wird eine Aufgabe gestartet, die 5 Millionen Random Integer zwischen 0 und 100 generiert und ihren Mittelwert berechnet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-922">The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="f3af1-923">Im Beispiel wird die <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> -Methode verwendet, um zu warten, bis die Anwendung innerhalb von 150 Millisekunden fertiggestellt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-923">The example uses the <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> method to wait for the application to complete within 150 milliseconds.</span></span> <span data-ttu-id="f3af1-924">Wenn die Anwendung normal abgeschlossen ist, zeigt die Aufgabe die Summe und den Mittelwert der Zufallszahlen an, die Sie generiert hat.</span><span class="sxs-lookup"><span data-stu-id="f3af1-924">If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</span></span> <span data-ttu-id="f3af1-925">Wenn das Timeout Intervall abgelaufen ist, wird im Beispiel eine Meldung angezeigt, bevor Sie beendet wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-925">If the timeout interval has elapsed, the example displays a message before it terminates.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-926"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-926">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-927"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-927"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f3af1-928">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-928">-or-</span></span> 
 <span data-ttu-id="f3af1-929"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-929"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="f3af1-930">Der Task wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-930">The task was canceled.</span></span> <span data-ttu-id="f3af1-931">Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-931">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="f3af1-932">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-932">-or-</span></span> 
<span data-ttu-id="f3af1-933">Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="f3af1-933">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="f3af1-934">Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-934">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="task.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="f3af1-935">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="f3af1-935">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-936">Ein Abbruchtoken, das beim Warten auf den Abschluss der Aufgabe überwacht werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-936">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="f3af1-937">Wartet, bis der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung abschließt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-937">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span> <span data-ttu-id="f3af1-938">Der Wartevorgang wird beendet, wenn ein Timeoutintervall abläuft oder ein Abbruchtoken abgebrochen wird, bevor die Aufgabe abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-938">The wait terminates if a timeout interval elapses or a cancellation token is canceled before the task completes.</span></span></summary>
        <returns><span data-ttu-id="f3af1-939"><see langword="true" />, wenn der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-939"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-940"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>ist eine Synchronisierungsmethode, die bewirkt, dass der aufrufende Thread auf den Abschluss der aktuellen Aufgaben Instanz wartet, bis eine der folgenden Aktionen auftritt:</span><span class="sxs-lookup"><span data-stu-id="f3af1-940"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="f3af1-941">Der Task wurde erfolgreich abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-941">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="f3af1-942">Der Task selbst wird abgebrochen oder löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="f3af1-942">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="f3af1-943">In diesem Fall wird eine <xref:System.AggregateException> Ausnahme behandelt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-943">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="f3af1-944">Die <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> -Eigenschaft enthält Details zur Ausnahme oder zu Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-944">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="f3af1-945">Das `cancellationToken` Abbruch Token wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-945">The `cancellationToken` cancellation token is canceled.</span></span> <span data-ttu-id="f3af1-946">In diesem Fall löst der Aufrufe der <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> -Methode eine <xref:System.OperationCanceledException>aus.</span><span class="sxs-lookup"><span data-stu-id="f3af1-946">In this case, the call to the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> method throws an <xref:System.OperationCanceledException>.</span></span>  
  
-   <span data-ttu-id="f3af1-947">Das durch `millisecondsTimeout` definierte Intervall verstreicht.</span><span class="sxs-lookup"><span data-stu-id="f3af1-947">The interval defined by `millisecondsTimeout` elapses.</span></span> <span data-ttu-id="f3af1-948">In diesem Fall wird die Ausführung des aktuellen Threads fortgesetzt, und die `false`Methode gibt zurück.</span><span class="sxs-lookup"><span data-stu-id="f3af1-948">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f3af1-949">Das Abbrechen des `cancellationToken` Abbruch Tokens hat keine Auswirkung auf die laufende Aufgabe, es sei denn, es wurde auch das Abbruch Token übergeben und ist für die Behandlung von Abbruch vorbereitet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-949">Canceling the `cancellationToken` cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</span></span> <span data-ttu-id="f3af1-950">Wenn Sie `cancellationToken` das-Objekt an diese Methode übergeben, kann der Warte Vorgang auf der Grundlage einer Bedingung einfach abgebrochen werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-950">Passing the `cancellationToken` object to this method simply allows the wait to be canceled based on some condition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-951">Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> -Methode aufgerufen, um sowohl einen Timeout Wert als auch ein Abbruch Token bereitzustellen, das das warten auf den Abschluss einer Aufgabe beenden kann.</span><span class="sxs-lookup"><span data-stu-id="f3af1-951">The following example calls the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> method to provide both a timeout value and a cancellation token that can end the wait for a task's completion.</span></span> <span data-ttu-id="f3af1-952">Ein neuer Thread wird gestartet, und die `CancelToken` -Methode wird ausgeführt, die angehalten wird <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> und dann die-Methode aufruft, um die Abbruch Token abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-952">A new thread is started and executes the `CancelToken` method, which pauses and then calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to cancel the cancellation tokens.</span></span> <span data-ttu-id="f3af1-953">Anschließend wird ein Task gestartet und der Vorgang um 5 Sekunden verzögert.</span><span class="sxs-lookup"><span data-stu-id="f3af1-953">A task is then launched and delays for 5 seconds.</span></span> <span data-ttu-id="f3af1-954">Die <xref:System.Threading.Tasks.Task.Wait%2A> -Methode wird dann aufgerufen, um auf den Abschluss der Aufgabe zu warten, und wird sowohl einen kurzen Timeout Wert als auch ein Abbruch Token bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-954">The <xref:System.Threading.Tasks.Task.Wait%2A> method is then called to wait for the task's completion and is provided both a brief timeout value and a cancellation token.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 <span data-ttu-id="f3af1-955">Beachten Sie, dass die genaue Ausgabe des Beispiels davon abhängt, ob der Warte Vorgang aufgrund des Abbruch Tokens abgebrochen wurde oder weil das Timeout Intervall abgelaufen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-955">Note that the precise output from the example depends on whether the wait was canceled because of the cancellation token or because the timeout interval elapsed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="f3af1-956">Das <paramref name="cancellationToken" /> wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-956">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-957"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-957">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-958"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-958"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="f3af1-959">Der Task wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-959">The task was canceled.</span></span> <span data-ttu-id="f3af1-960">Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-960">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="f3af1-961">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-961">-or-</span></span> 
<span data-ttu-id="f3af1-962">Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="f3af1-962">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="f3af1-963">Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-963">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f3af1-964">Wartet darauf, dass alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" /> -Objekte die Ausführung abschließt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-964">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="f3af1-965">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-965">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <summary><span data-ttu-id="f3af1-966">Wartet, bis alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-966">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f3af1-967">Im folgenden Beispiel werden 10 Aufgaben gestartet, von denen jeder als-Status Objekt an einen Index übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-967">The following example starts 10 tasks, each of which is passed an index as a state object.</span></span> <span data-ttu-id="f3af1-968">Tasks mit einem Index zwischen zwei und fünf Throw-Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-968">Tasks with an index from two to five throw exceptions.</span></span> <span data-ttu-id="f3af1-969">Durch den Aufruf der <xref:System.Threading.Tasks.Task.WaitAll%2A> -Methode werden alle Ausnahmen in <xref:System.AggregateException> einem-Objekt umschlossen und an den aufrufenden Thread weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-969">The call to the <xref:System.Threading.Tasks.Task.WaitAll%2A> method wraps all exceptions in an <xref:System.AggregateException> object and propagates it to the calling thread.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-970">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-970">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-971">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-971">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-972">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</span><span class="sxs-lookup"><span data-stu-id="f3af1-972">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="f3af1-973">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-973">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="f3af1-974">Wenn ein Task abgebrochen wurde, enthält die <see cref="T:System.AggregateException" />-Ausnahme eine <see cref="T:System.OperationCanceledException" />-Ausnahme in ihrer <see cref="P:System.AggregateException.InnerExceptions" />-Auflistung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-974">If a task was canceled, the <see cref="T:System.AggregateException" /> exception contains an <see cref="T:System.OperationCanceledException" /> exception in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="f3af1-975">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-975">-or-</span></span> 
<span data-ttu-id="f3af1-976">Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="f3af1-976">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="f3af1-977">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-977">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="f3af1-978">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="f3af1-978">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f3af1-979">Wartet darauf, dass alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte innerhalb einer angegebenen Anzahl an Millisekunden vollständig ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-979">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="f3af1-980"><see langword="true" /> wenn alle <see cref="T:System.Threading.Tasks.Task" />-Instanzen die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen haben, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-980"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-981">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-981">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-982">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-982">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="f3af1-983">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-983">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="f3af1-984">Wenn ein Task abgebrochen wurde, enthält die <see cref="T:System.AggregateException" /> eine <see cref="T:System.OperationCanceledException" /> in ihrer <see cref="P:System.AggregateException.InnerExceptions" />-Auflistung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-984">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="f3af1-985">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-985">-or-</span></span> 
<span data-ttu-id="f3af1-986">Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="f3af1-986">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-987"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-987"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-988">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</span><span class="sxs-lookup"><span data-stu-id="f3af1-988">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="f3af1-989">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-989">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-990">Ein <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das beim Warten auf den Abschluss der Aufgaben überwacht werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-990">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for the tasks to complete.</span></span></param>
        <summary><span data-ttu-id="f3af1-991">Wartet, bis alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließen oder bis der Wartevorgang abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-991">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution unless the wait is cancelled.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-992">Das `cancellationToken` -Argument wird verwendet, um den warte Vorgang abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-992">The `cancellationToken` argument is used to cancel the wait operation.</span></span> <span data-ttu-id="f3af1-993">Der Abbruch der Tasks ist ein eindeutiger Vorgang, der durch das <xref:System.AggregateException> signalisiert wird, wie oben erwähnt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-993">Cancellation of the tasks is a distinct operation, and is signaled by the <xref:System.AggregateException> as noted above.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="f3af1-994">Das <paramref name="cancellationToken" /> wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-994">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-995">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-995">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="f3af1-996">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-996">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="f3af1-997">Wenn ein Task abgebrochen wurde, enthält die <see cref="T:System.AggregateException" /> eine <see cref="T:System.OperationCanceledException" /> in ihrer <see cref="P:System.AggregateException.InnerExceptions" />-Auflistung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-997">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="f3af1-998">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-998">-or-</span></span> 
<span data-ttu-id="f3af1-999">Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="f3af1-999">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1000">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1000">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-1001">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1001">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * TimeSpan -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="f3af1-1002">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1002">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="f3af1-1003">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1003">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f3af1-1004">Wartet darauf, dass alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte, die abgebrochen werden können, innerhalb eines angegebenen Zeitintervalls vollständig ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1004">Waits for all of the provided cancellable <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1005"><see langword="true" /> wenn alle <see cref="T:System.Threading.Tasks.Task" />-Instanzen die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen haben, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1005"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-1006">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1006">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1007">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1007">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="f3af1-1008">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1008">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="f3af1-1009">Wenn ein Task abgebrochen wurde, enthält die <see cref="T:System.AggregateException" /> eine <see cref="T:System.OperationCanceledException" /> in ihrer <see cref="P:System.AggregateException.InnerExceptions" />-Auflistung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1009">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="f3af1-1010">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-1010">-or-</span></span> 
<span data-ttu-id="f3af1-1011">Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1011">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-1012"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1012"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f3af1-1013">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-1013">-or-</span></span> 
 <span data-ttu-id="f3af1-1014"><paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1014"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1015">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1015">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="f3af1-1016">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1016">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="f3af1-1017">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1017">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-1018">Ein <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das beim Warten auf den Abschluss der Aufgaben überwacht werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1018">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for the tasks to complete.</span></span></param>
        <summary><span data-ttu-id="f3af1-1019">Wartet darauf, dass alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte innerhalb einer angegebenen Anzahl an Millisekunden oder vollständig ausgeführt werden, oder bis zum Abbruch des Wartevorgangs.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1019">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds or until the wait is cancelled.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1020"><see langword="true" /> wenn alle <see cref="T:System.Threading.Tasks.Task" />-Instanzen die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen haben, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1020"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-1021">Das `cancellationToken` -Argument wird verwendet, um den warte Vorgang abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1021">The `cancellationToken` argument is used to cancel the wait operation.</span></span> <span data-ttu-id="f3af1-1022">Der Abbruch der Tasks ist ein eindeutiger Vorgang und wird durch die <xref:System.AggregateException> oben angegebene signalisiert.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1022">Cancellation of the tasks is a distinct operation, and is signaled by the <xref:System.AggregateException> noted above.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-1023">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1023">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1024">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1024">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="f3af1-1025">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1025">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="f3af1-1026">Wenn ein Task abgebrochen wurde, enthält die <see cref="T:System.AggregateException" /> eine <see cref="T:System.OperationCanceledException" /> in ihrer <see cref="P:System.AggregateException.InnerExceptions" />-Auflistung.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1026">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="f3af1-1027">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-1027">-or-</span></span> 
<span data-ttu-id="f3af1-1028">Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1028">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-1029"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1029"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1030">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1030">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="f3af1-1031">Das <paramref name="cancellationToken" /> wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1031">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f3af1-1032">Wartet, bis eines der bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1032">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="f3af1-1033">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1033">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <summary><span data-ttu-id="f3af1-1034">Wartet, bis eines der bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1034">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1035">Der Index des abgeschlossenen <see cref="T:System.Threading.Tasks.Task" />-Objekts im <paramref name="tasks" />-Array.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1035">The index of the completed <see cref="T:System.Threading.Tasks.Task" /> object in the <paramref name="tasks" /> array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f3af1-1036">Im folgenden Beispiel werden fünf Aufgaben gestartet, die jeweils für mindestens 50 Millisekunden oder maximal 1.050 Millisekunden geöffnet sind.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1036">The following example launches five tasks, each of which sleeps for a minimum of 50 milliseconds or a maximum of 1,050 milliseconds.</span></span> <span data-ttu-id="f3af1-1037">Die <xref:System.Threading.Tasks.Task.WaitAny%2A> -Methode wartet dann, bis eine der Aufgaben beendet ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1037">The <xref:System.Threading.Tasks.Task.WaitAny%2A> method then waits for any of the tasks to complete.</span></span> <span data-ttu-id="f3af1-1038">Das Beispiel zeigt die Task-ID der Aufgabe an, die den warte Vorgang beendet hat, sowie den aktuellen Status aller Tasks.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1038">The example displays the task ID of the task that ended the wait, as well as the current status of all the tasks.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-1039"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1039">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1040">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1040">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1041">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1041">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="f3af1-1042">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1042">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="f3af1-1043">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1043">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f3af1-1044">Wartet darauf, dass bereitgestellte <see cref="T:System.Threading.Tasks.Task" />-Objekte innerhalb einer angegebenen Anzahl an Millisekunden vollständig ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1044">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1045">Der Index der abgeschlossenen Aufgabe im <paramref name="tasks" />-Arrayargument oder -1, wenn das Timeout aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1045">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-1046"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1046">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1047">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1047">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-1048"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1048"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1049">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1049">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="f3af1-1050">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1050">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-1051">Ein <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das beim Warten auf den Abschluss einer Aufgabe überwacht werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1051">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for a task to complete.</span></span></param>
        <summary><span data-ttu-id="f3af1-1052">Wartet, bis bereitgestellte <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließen oder bis der Wartevorgang abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1052">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution unless the wait is cancelled.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1053">Der Index der ausgeführten Aufgabe im <paramref name="tasks" />-Arrayargument.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1053">The index of the completed task in the <paramref name="tasks" /> array argument.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-1054"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1054">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1055">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1055">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1056">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1056">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="f3af1-1057">Das <paramref name="cancellationToken" /> wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1057">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * TimeSpan -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="f3af1-1058">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1058">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="f3af1-1059">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1059">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f3af1-1060">Wartet darauf, dass bereitgestellte <see cref="T:System.Threading.Tasks.Task" />-Objekte, die abgebrochen werden können, innerhalb eines angegebenen Zeitintervalls vollständig ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1060">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1061">Der Index der abgeschlossenen Aufgabe im <paramref name="tasks" />-Arrayargument oder -1, wenn das Timeout aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1061">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-1062"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1062">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1063">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1063">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-1064">Die <see cref="P:System.TimeSpan.TotalMilliseconds" />-Eigenschaft des <paramref name="timeout" />-Arguments ist eine negative Zahl ungleich -1, was für ein unbegrenztes Zeitlimit steht.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1064">The <see cref="P:System.TimeSpan.TotalMilliseconds" /> property of the <paramref name="timeout" /> argument is a negative number other than -1, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f3af1-1065">- oder -</span><span class="sxs-lookup"><span data-stu-id="f3af1-1065">-or-</span></span> 
<span data-ttu-id="f3af1-1066">Die <see cref="P:System.TimeSpan.TotalMilliseconds" />-Eigenschaft des <paramref name="timeout" />-Argument ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1066">The <see cref="P:System.TimeSpan.TotalMilliseconds" /> property of the <paramref name="timeout" /> argument is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1067">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1067">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="f3af1-1068">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1068">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="f3af1-1069">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1069">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f3af1-1070">Ein <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das beim Warten auf den Abschluss einer Aufgabe überwacht werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1070">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for a task to complete.</span></span></param>
        <summary><span data-ttu-id="f3af1-1071">Wartet darauf, dass bereitgestellte <see cref="T:System.Threading.Tasks.Task" />-Objekte innerhalb einer angegebenen Anzahl an Millisekunden oder vollständig ausgeführt werden, oder bis ein Abbruchtoken abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1071">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds or until a cancellation token is cancelled.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1072">Der Index der abgeschlossenen Aufgabe im <paramref name="tasks" />-Arrayargument oder -1, wenn das Timeout aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1072">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f3af1-1073"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1073">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1074">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1074">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f3af1-1075"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1075"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1076">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1076">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="f3af1-1077">Das <paramref name="cancellationToken" /> wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1077">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f3af1-1078">Erstellt eine Aufgabe, die abgeschlossen wird, wenn alle angegebenen Aufgaben abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1078">Creates a task that will complete when all of the supplied tasks have completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="f3af1-1079">Die Aufgaben, auf deren Abschluss gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1079">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="f3af1-1080">Erstellt eine Aufgabe, die abgeschlossen wird, wenn alle <see cref="T:System.Threading.Tasks.Task" />-Objekte in einer aufzählbaren Sammlung abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1080">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task" /> objects in an enumerable collection have completed.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1081">Eine Aufgabe, die den Abschluss aller angegebenen Aufgaben darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1081">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-1082">Die über Ladungen der <xref:System.Threading.Tasks.Task.WhenAll%2A> -Methode, die ein <xref:System.Threading.Tasks.Task> -Objekt zurückgeben, werden in der Regel aufgerufen, wenn Sie am Status eines Satzes von Tasks oder in den Ausnahmen interessiert sind, die von einem Satz von Tasks ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1082">The overloads of the <xref:System.Threading.Tasks.Task.WhenAll%2A> method that return a <xref:System.Threading.Tasks.Task> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f3af1-1083">Durch den Aufruf <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> der-Methode wird der aufrufende Thread nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1083">The call to <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method does not block the calling thread.</span></span>  
  
 <span data-ttu-id="f3af1-1084">Wenn eine der angegebenen Aufgaben in einem fehlerhaften Zustand abgeschlossen wird, wird die zurückgegebene Aufgabe auch in einem <xref:System.Threading.Tasks.TaskStatus.Faulted> -Zustand abgeschlossen, wobei ihre Ausnahmen die Aggregation des Satzes von nicht umschließenden Ausnahmen aus den einzelnen bereitgestellten Tasks enthalten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1084">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state,  where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="f3af1-1085">Wenn keine der angegebenen Tasks einen Fehler verursacht hat, aber mindestens einer davon abgebrochen wurde, endet die zurückgegebene Aufgabe im <xref:System.Threading.Tasks.TaskStatus.Canceled> -Zustand.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1085">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="f3af1-1086">Wenn keiner der Tasks einen Fehler verursacht hat und keine der Aufgaben abgebrochen wurde, endet die resultierende Aufgabe im <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> -Zustand.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1086">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="f3af1-1087">Wenn das angegebene Array/Enumerable keine Aufgaben enthält, wechselt die zurückgegebene Aufgabe sofort in einen <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand, bevor Sie an den Aufrufer zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1087">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-1088">Im folgenden Beispiel wird eine Reihe von Tasks erstellt, mit denen die URLs in einem Array gepingt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1088">The following example creates a set of tasks that ping the URLs in an array.</span></span> <span data-ttu-id="f3af1-1089">Die Tasks werden in einer `List<Task>` Auflistung gespeichert, die an die <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> -Methode übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1089">The tasks are stored in a `List<Task>` collection that is passed to the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method.</span></span> <span data-ttu-id="f3af1-1090">Nachdem der Aufrufe <xref:System.Threading.Tasks.Task.Wait%2A> der-Methode sichergestellt hat, dass alle Threads abgeschlossen sind, wird <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> im Beispiel die-Eigenschaft untersucht, um zu bestimmen, ob Tasks einen Fehler verursacht haben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1090">After the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that all threads have completed, the example examines the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property to determine whether any tasks have faulted.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1091">Das <paramref name="tasks" />-Argument war <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1091">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1092">Die <paramref name="tasks" />-Auflistung enthält eine <see langword="null" />-Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1092">The <paramref name="tasks" /> collection contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="f3af1-1093">Die Aufgaben, auf deren Abschluss gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1093">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="f3af1-1094">Erstellt eine Aufgabe, die abgeschlossen wird, wenn alle <see cref="T:System.Threading.Tasks.Task" />-Objekte in einem Array abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1094">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task" /> objects in an array have completed.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1095">Eine Aufgabe, die den Abschluss aller angegebenen Aufgaben darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1095">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-1096">Die über Ladungen der <xref:System.Threading.Tasks.Task.WhenAll%2A> -Methode, die ein <xref:System.Threading.Tasks.Task> -Objekt zurückgeben, werden in der Regel aufgerufen, wenn Sie am Status eines Satzes von Tasks oder in den Ausnahmen interessiert sind, die von einem Satz von Tasks ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1096">The overloads of the <xref:System.Threading.Tasks.Task.WhenAll%2A> method that return a <xref:System.Threading.Tasks.Task> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f3af1-1097">Durch den Aufruf <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> der-Methode wird der aufrufende Thread nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1097">The call to <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> method does not block the calling thread.</span></span>  
  
 <span data-ttu-id="f3af1-1098">Wenn eine der angegebenen Aufgaben in einem fehlerhaften Zustand abgeschlossen wird, wird die zurückgegebene Aufgabe auch in einem <xref:System.Threading.Tasks.TaskStatus.Faulted> -Zustand abgeschlossen, wobei ihre Ausnahmen die Aggregation des Satzes von nicht umschließenden Ausnahmen aus den einzelnen bereitgestellten Tasks enthalten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1098">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="f3af1-1099">Wenn keine der angegebenen Tasks einen Fehler verursacht hat, aber mindestens einer davon abgebrochen wurde, endet die zurückgegebene Aufgabe im <xref:System.Threading.Tasks.TaskStatus.Canceled> -Zustand.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1099">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="f3af1-1100">Wenn keiner der Tasks einen Fehler verursacht hat und keine der Aufgaben abgebrochen wurde, endet die resultierende Aufgabe im <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> -Zustand.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1100">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="f3af1-1101">Wenn das angegebene Array/Enumerable keine Aufgaben enthält, wechselt die zurückgegebene Aufgabe sofort in einen <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand, bevor Sie an den Aufrufer zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1101">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-1102">Im folgenden Beispiel wird eine Reihe von Tasks erstellt, mit denen die URLs in einem Array gepingt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1102">The following example creates a set of tasks that ping the URLs in an array.</span></span> <span data-ttu-id="f3af1-1103">Die Aufgaben werden in einer `List<Task>` Auflistung gespeichert, die in ein Array konvertiert und an die <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> -Methode übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1103">The tasks are stored in a `List<Task>` collection that is converted to an array and passed to the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method.</span></span> <span data-ttu-id="f3af1-1104">Nachdem der Aufrufe <xref:System.Threading.Tasks.Task.Wait%2A> der-Methode sichergestellt hat, dass alle Threads abgeschlossen sind, wird <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> im Beispiel die-Eigenschaft untersucht, um zu bestimmen, ob Tasks einen Fehler verursacht haben.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1104">After the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that all threads have completed, the example examines the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property to determine whether any tasks have faulted.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1105">Das <paramref name="tasks" />-Argument war <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1105">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1106">Das <paramref name="tasks" />-Array enthielt eine <see langword="null" />-Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1106">The <paramref name="tasks" /> array contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-1107">Der Typ der abgeschlossenen Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1107">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="f3af1-1108">Die Aufgaben, auf deren Abschluss gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1108">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="f3af1-1109">Erstellt eine Aufgabe, die abgeschlossen wird, wenn alle <see cref="T:System.Threading.Tasks.Task`1" />-Objekte in einer aufzählbaren Sammlung abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1109">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task`1" /> objects in an enumerable collection have completed.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1110">Eine Aufgabe, die den Abschluss aller angegebenen Aufgaben darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1110">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-1111">Durch den Aufruf <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> der-Methode wird der aufrufende Thread nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1111">The call to <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> method does not block the calling thread.</span></span> <span data-ttu-id="f3af1-1112">Ein Aufruf der zurückgegebenen <xref:System.Threading.Tasks.Task%601.Result%2A> Eigenschaft blockiert jedoch den aufrufenden Thread.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1112">However, a call to the returned <xref:System.Threading.Tasks.Task%601.Result%2A> property does block the calling thread.</span></span>  
  
 <span data-ttu-id="f3af1-1113">Wenn eine der angegebenen Aufgaben in einem fehlerhaften Zustand abgeschlossen wird, wird die zurückgegebene Aufgabe auch in einem <xref:System.Threading.Tasks.TaskStatus.Faulted> -Zustand abgeschlossen, wobei ihre Ausnahmen die Aggregation des Satzes von nicht umschließenden Ausnahmen aus den einzelnen bereitgestellten Tasks enthalten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1113">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="f3af1-1114">Wenn keine der angegebenen Tasks einen Fehler verursacht hat, aber mindestens einer davon abgebrochen wurde, endet die zurückgegebene Aufgabe im <xref:System.Threading.Tasks.TaskStatus.Canceled> -Zustand.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1114">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="f3af1-1115">Wenn keiner der Tasks einen Fehler verursacht hat und keine der Aufgaben abgebrochen wurde, endet die resultierende Aufgabe im <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> -Zustand.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1115">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  <span data-ttu-id="f3af1-1116">Die <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> -Eigenschaft der zurückgegebenen Aufgabe wird auf ein Array festgelegt, das alle Ergebnisse der angegebenen Aufgaben in derselben Reihenfolge enthält, in der Sie bereitgestellt wurden (z. b. wenn das Eingabe Aufgaben Array T1, T2, T3 enthielt <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> ), gibt die-Eigenschaft der Ausgabe Aufgabe zurück. ein `TResult[]` Where`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`-.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1116">The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property will return an `TResult[]` where `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.</span></span>  
  
 <span data-ttu-id="f3af1-1117">Wenn das `tasks` -Argument keine Aufgaben enthält, wechselt die zurückgegebene Aufgabe sofort in <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> einen Zustand, bevor Sie an den Aufrufer zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1117">If the `tasks` argument contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span> <span data-ttu-id="f3af1-1118">Der zurück `TResult[]` gegebene ist ein Array von 0 Elementen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1118">The returned `TResult[]` will be an array of 0 elements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-1119">Im folgenden Beispiel werden zehn Aufgaben erstellt, von denen jede einen Zufallszahlengenerator instanziiert, der 1.000 Zufallszahlen zwischen 1 und 1.000 erstellt und ihren Mittelwert berechnet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1119">The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</span></span> <span data-ttu-id="f3af1-1120">Die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> -Methode wird verwendet, um die Instanziierung der Zufallszahlengeneratoren zu verzögern, sodass Sie nicht mit identischen Seed-Werten erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1120">The <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</span></span> <span data-ttu-id="f3af1-1121">Der- <xref:System.Threading.Tasks.Task.WhenAll%2A> Methodenaufrufe gibt dann ein <xref:System.Int64> Array zurück, das den von jedem Task berechneten Mittelwert enthält.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1121">The call to the <xref:System.Threading.Tasks.Task.WhenAll%2A> method then returns an <xref:System.Int64> array that contains the mean computed by each task.</span></span> <span data-ttu-id="f3af1-1122">Diese werden dann verwendet, um den allgemeinen Mittelwert zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1122">These are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 <span data-ttu-id="f3af1-1123">In diesem Fall werden die zehn einzelnen Aufgaben in einem <xref:System.Collections.Generic.List%601> -Objekt gespeichert.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1123">In this case, the ten individual tasks are stored in a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="f3af1-1124"><xref:System.Collections.Generic.List%601> implementiert die <xref:System.Collections.Generic.IEnumerable%601>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1124"><xref:System.Collections.Generic.List%601> implements the <xref:System.Collections.Generic.IEnumerable%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1125">Das <paramref name="tasks" />-Argument war <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1125">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1126">Die <paramref name="tasks" />-Auflistung enthält eine <see langword="null" />-Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1126">The <paramref name="tasks" /> collection contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-1127">Der Typ der abgeschlossenen Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1127">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="f3af1-1128">Die Aufgaben, auf deren Abschluss gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1128">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="f3af1-1129">Erstellt eine Aufgabe, die abgeschlossen wird, wenn alle <see cref="T:System.Threading.Tasks.Task`1" />-Objekte in einem Array abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1129">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task`1" /> objects in an array have completed.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1130">Eine Aufgabe, die den Abschluss aller angegebenen Aufgaben darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1130">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-1131">Durch den Aufruf <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> der-Methode wird der aufrufende Thread nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1131">The call to <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> method does not block the calling thread.</span></span> <span data-ttu-id="f3af1-1132">Ein Aufruf der zurückgegebenen <xref:System.Threading.Tasks.Task%601.Result%2A> Eigenschaft blockiert jedoch den aufrufenden Thread.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1132">However, a call to the returned <xref:System.Threading.Tasks.Task%601.Result%2A> property does block the calling thread.</span></span>  
  
 <span data-ttu-id="f3af1-1133">Wenn eine der angegebenen Aufgaben in einem fehlerhaften Zustand abgeschlossen wird, wird die zurückgegebene Aufgabe auch in einem <xref:System.Threading.Tasks.TaskStatus.Faulted> -Zustand abgeschlossen, wobei ihre Ausnahmen die Aggregation des Satzes von nicht umschließenden Ausnahmen aus den einzelnen bereitgestellten Tasks enthalten.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1133">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="f3af1-1134">Wenn keine der angegebenen Tasks einen Fehler verursacht hat, aber mindestens einer davon abgebrochen wurde, endet die zurückgegebene Aufgabe im <xref:System.Threading.Tasks.TaskStatus.Canceled> -Zustand.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1134">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="f3af1-1135">Wenn keiner der Tasks einen Fehler verursacht hat und keine der Aufgaben abgebrochen wurde, endet die resultierende Aufgabe im <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> -Zustand.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1135">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  <span data-ttu-id="f3af1-1136">Der <xref:System.Threading.Tasks.Task%601.Result%2A> der zurückgegebenen Aufgabe wird auf ein Array festgelegt, das alle Ergebnisse der angegebenen Aufgaben in derselben Reihenfolge enthält, in der Sie bereitgestellt wurden (z. b. wenn das Eingabe Aufgaben Array T1, T2, T3 enthielt) <xref:System.Threading.Tasks.Task%601.Result%2A> , gibt der `TResult[]` Ausgabe Task einen Where `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1136">The <xref:System.Threading.Tasks.Task%601.Result%2A> of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output   task's <xref:System.Threading.Tasks.Task%601.Result%2A> will return an `TResult[]` where `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.</span></span>  
  
 <span data-ttu-id="f3af1-1137">Wenn das angegebene Array/Enumerable keine Aufgaben enthält, wechselt die zurückgegebene Aufgabe sofort in einen <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand, bevor Sie an den Aufrufer zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1137">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  <span data-ttu-id="f3af1-1138">Der zurück `TResult[]` gegebene ist ein Array von 0 Elementen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1138">The returned `TResult[]` will be an array of 0 elements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3af1-1139">Im folgenden Beispiel werden zehn Aufgaben erstellt, von denen jede einen Zufallszahlengenerator instanziiert, der 1.000 Zufallszahlen zwischen 1 und 1.000 erstellt und ihren Mittelwert berechnet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1139">The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</span></span> <span data-ttu-id="f3af1-1140">In diesem Fall werden die zehn einzelnen Aufgaben in einem `Task<Int64>` -Array gespeichert.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1140">In this case, the ten individual tasks are stored in a `Task<Int64>` array.</span></span>  <span data-ttu-id="f3af1-1141">Die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> -Methode wird verwendet, um die Instanziierung der Zufallszahlengeneratoren zu verzögern, sodass Sie nicht mit identischen Seed-Werten erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1141">The <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</span></span> <span data-ttu-id="f3af1-1142">Der- <xref:System.Threading.Tasks.Task.WhenAll%2A> Methodenaufrufe gibt dann ein <xref:System.Int64> Array zurück, das den von jedem Task berechneten Mittelwert enthält.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1142">The call to the <xref:System.Threading.Tasks.Task.WhenAll%2A> method then returns an <xref:System.Int64> array that contains the mean computed by each task.</span></span> <span data-ttu-id="f3af1-1143">Diese werden dann verwendet, um den allgemeinen Mittelwert zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1143">These are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1144">Das <paramref name="tasks" />-Argument war <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1144">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1145">Das <paramref name="tasks" />-Array enthielt eine <see langword="null" />-Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1145">The <paramref name="tasks" /> array contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f3af1-1146">Erstellt eine Aufgabe, die abgeschlossen wird, wenn eine der angegebenen Aufgaben abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1146">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="f3af1-1147">Die Aufgaben, auf deren Abschluss gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1147">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="f3af1-1148">Erstellt eine Aufgabe, die abgeschlossen wird, wenn eine der angegebenen Aufgaben abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1148">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1149">Eine Aufgabe, die den Abschluss einer der angegebenen Aufgaben darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1149">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="f3af1-1150">Das zurückgegebene Ergebnis der Aufgabe ist die Aufgabe, die abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1150">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-1151">Die zurückgegebene Aufgabe wird abgeschlossen, wenn eine der angegebenen Aufgaben abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1151">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="f3af1-1152">Die zurückgegebene Aufgabe endet immer mit dem `RanToCompletion` Zustand, wobei das Resultset auf die erste Aufgabe abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1152">The returned task will always end in the `RanToCompletion` state  with its Result set to the first task to complete.</span></span>  <span data-ttu-id="f3af1-1153">Dies gilt auch, wenn die erste Aufgabe, die abgeschlossen werden soll `Canceled` , `Faulted` im-Zustand oder im-Zustand endet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1153">This is true even if the first task to complete ended in the `Canceled` or `Faulted` state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1154">Das <paramref name="tasks" />-Argument war <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1154">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1155">Das Array <paramref name="tasks" /> enthielt eine NULL-Aufgabe oder war leer.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1155">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="f3af1-1156">Die Aufgaben, auf deren Abschluss gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1156">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="f3af1-1157">Erstellt eine Aufgabe, die abgeschlossen wird, wenn eine der angegebenen Aufgaben abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1157">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1158">Eine Aufgabe, die den Abschluss einer der angegebenen Aufgaben darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1158">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="f3af1-1159">Das zurückgegebene Ergebnis der Aufgabe ist die Aufgabe, die abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1159">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-1160">Die zurückgegebene Aufgabe wird abgeschlossen, wenn eine der angegebenen Aufgaben abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1160">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="f3af1-1161">Die zurückgegebene Aufgabe endet immer `RanToCompletion` `Result` mit dem Zustand, in dem die erste Aufgabe abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1161">The returned task will always end in the `RanToCompletion` state   with its `Result` set to the first task to complete.</span></span>  <span data-ttu-id="f3af1-1162">Dies gilt auch, wenn die erste Aufgabe, die abgeschlossen werden soll `Canceled` , `Faulted` im-Zustand oder im-Zustand endet.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1162">This is true even if the first task to complete ended in the `Canceled` or `Faulted` state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1163">Das <paramref name="tasks" />-Argument war null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1163">The <paramref name="tasks" /> argument was null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1164">Das Array <paramref name="tasks" /> enthielt eine NULL-Aufgabe oder war leer.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1164">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-1165">Der Typ der abgeschlossenen Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1165">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="f3af1-1166">Die Aufgaben, auf deren Abschluss gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1166">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="f3af1-1167">Erstellt eine Aufgabe, die abgeschlossen wird, wenn eine der angegebenen Aufgaben abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1167">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1168">Eine Aufgabe, die den Abschluss einer der angegebenen Aufgaben darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1168">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="f3af1-1169">Das zurückgegebene Ergebnis der Aufgabe ist die Aufgabe, die abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1169">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-1170">Die zurückgegebene Aufgabe wird abgeschlossen, wenn eine der angegebenen Aufgaben abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1170">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="f3af1-1171">Die zurückgegebene Aufgabe endet immer mit dem Zustand "randecompletion", wobei das Resultset auf die erste Aufgabe abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1171">The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</span></span> <span data-ttu-id="f3af1-1172">Dies gilt auch, wenn die erste Aufgabe abgeschlossen wurde, die abgebrochen oder fehlerhaft war.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1172">This is true even if the first task to complete ended in the Canceled or Faulted state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1173">Das <paramref name="tasks" />-Argument war <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1173">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1174">Das Array <paramref name="tasks" /> enthielt eine NULL-Aufgabe oder war leer.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1174">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="f3af1-1175">Der Typ der abgeschlossenen Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1175">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="f3af1-1176">Die Aufgaben, auf deren Abschluss gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1176">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="f3af1-1177">Erstellt eine Aufgabe, die abgeschlossen wird, wenn eine der angegebenen Aufgaben abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1177">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1178">Eine Aufgabe, die den Abschluss einer der angegebenen Aufgaben darstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1178">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="f3af1-1179">Das zurückgegebene Ergebnis der Aufgabe ist die Aufgabe, die abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1179">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-1180">Die zurückgegebene Aufgabe wird abgeschlossen, wenn eine der angegebenen Aufgaben abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1180">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="f3af1-1181">Die zurückgegebene Aufgabe endet immer mit dem Zustand "randecompletion", wobei das Resultset auf die erste Aufgabe abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1181">The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</span></span> <span data-ttu-id="f3af1-1182">Dies gilt auch, wenn die erste Aufgabe abgeschlossen wurde, die abgebrochen oder fehlerhaft war.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1182">This is true even if the first task to complete ended in the Canceled or Faulted state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f3af1-1183">Das <paramref name="tasks" />-Argument war null.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1183">The <paramref name="tasks" /> argument was null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f3af1-1184">Das Array <paramref name="tasks" /> enthielt eine NULL-Aufgabe oder war leer.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1184">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Runtime.CompilerServices.YieldAwaitable" Usage="System.Threading.Tasks.Task.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f3af1-1185">Erstellt einen Awaitable-Task, das asynchron an den aktuellen Kontext liefert, wenn erwartet wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1185">Creates an awaitable task that asynchronously yields back to the current context when awaited.</span></span></summary>
        <returns><span data-ttu-id="f3af1-1186">Ein Kontext, der während des Abwartens asynchron wieder in den aktuellen Kontext zum Zeitpunkt des Abwartens übergeht.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1186">A context that, when awaited, will asynchronously transition back into the current context at the time of the await.</span></span> <span data-ttu-id="f3af1-1187">Wenn der aktuelle <see cref="T:System.Threading.SynchronizationContext" /> nicht Null ist, wird er als der aktuelle Kontext behandelt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1187">If the current <see cref="T:System.Threading.SynchronizationContext" /> is non-null, it is treated as the current context.</span></span> <span data-ttu-id="f3af1-1188">Andernfalls wird der Taskplaner, der mit der aktuell ausgeführten Aufgabe zugeordnet ist, als der aktuelle Kontext behandelt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1188">Otherwise, the task scheduler that is associated with the currently executing task is treated as the current context.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3af1-1189">Sie können in `await Task.Yield();` einer asynchronen-Methode verwenden, um zu erzwingen, dass die-Methode asynchron ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1189">You can use `await Task.Yield();` in an asynchronous method to force the method to complete asynchronously.</span></span> <span data-ttu-id="f3af1-1190">Wenn ein aktueller Synchronisierungs Kontext (<xref:System.Threading.SynchronizationContext> -Objekt) vorhanden ist, wird der Rest der Ausführung der Methode wieder in diesem Kontext bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1190">If there is a current synchronization context (<xref:System.Threading.SynchronizationContext> object), this will post the remainder of the method's execution back to that context.</span></span> <span data-ttu-id="f3af1-1191">Der Kontext entscheidet jedoch, wie diese Arbeit in Relation zu anderen ausstehenden Aufgaben priorisiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1191">However, the context will decide how to prioritize this work relative to other work that may be pending.</span></span> <span data-ttu-id="f3af1-1192">Der Synchronisierungs Kontext, der in den meisten Benutzeroberflächen Umgebungen in einem UI-Thread vorhanden ist, priorisiert häufig Aufgaben, die im Kontext bereitgestellt werden, die höher als die Eingabe-und Rendering</span><span class="sxs-lookup"><span data-stu-id="f3af1-1192">The synchronization context that is present on a UI thread in most UI environments will often prioritize work posted to the context higher than input and rendering work.</span></span> <span data-ttu-id="f3af1-1193">Verlassen `await Task.Yield();` Sie sich aus diesem Grund nicht darauf, dass eine Benutzeroberfläche reaktionsfähig bleibt.</span><span class="sxs-lookup"><span data-stu-id="f3af1-1193">For this reason, do not rely on `await Task.Yield();` to keep a UI responsive.</span></span>  <span data-ttu-id="f3af1-1194">Weitere Informationen finden Sie im Eintrag [nützliche Abstraktionen, die mit ContinueWith aktiviert](https://devblogs.microsoft.com/pfxteam/useful-abstractions-enabled-with-continuewith/) sind, im Blog Parallel Programming with .net (parallele Programmierung mit .net).</span><span class="sxs-lookup"><span data-stu-id="f3af1-1194">For more information, see the entry [Useful Abstractions Enabled with ContinueWith](https://devblogs.microsoft.com/pfxteam/useful-abstractions-enabled-with-continuewith/) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
