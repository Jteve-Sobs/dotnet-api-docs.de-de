<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7eb4e73011dcc6387d4b3dac6d38b797fd4d76cd" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53395850" /></Metadata><TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="F#" Value="type Task = class&#xA;    interface IAsyncResult&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen asynchronen Vorgang dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 Die <xref:System.Threading.Tasks.Task> -Klasse stellt ein einzelnen Vorgang, die keinen Wert und die in der Regel zurückgibt wird asynchron ausgeführt. <xref:System.Threading.Tasks.Task> Objekte sind eine der zentralen Komponenten von der [aufgabenbasierte asynchrone Muster](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) in .NET Framework 4 eingeführt wurden. Da die Arbeit, indem geleistet eine <xref:System.Threading.Tasks.Task> Objekt in der Regel führt asynchron auf einem Threadpoolthread anstatt synchron auf dem Hauptanwendungsthread, Sie verwenden können der <xref:System.Threading.Tasks.Task.Status%2A> -Eigenschaft, als auch die <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, und <xref:System.Threading.Tasks.Task.IsFaulted%2A> Eigenschaften, um den Status eines Vorgangs zu bestimmen. In den meisten Fällen wird ein Lambda-Ausdruck verwendet, an die Arbeit, die die Aufgabe auszuführen.  
  
 Für Vorgänge, die Werte zurückgeben, verwenden Sie die <xref:System.Threading.Tasks.Task%601> Klasse.  
  
 In diesem Abschnitt  
  
 [Instanziierung-Beispiele](#Instant)   
 [Erstellen und Ausführen einer Aufgabe](#Creating)   
 [Trennung von Erstellung und Ausführung](#Separating)   
 [Warten auf eine oder mehrere Aufgaben ausführen](#WaitingForOne)   
 [Aufgaben und Kultur](#Culture)   
 [Für Debuggerentwickler](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a>Task-Instanziierung  
 Das folgende Beispiel erstellt und vier Aufgaben ausführt. Führen Sie drei Aufgaben ein <xref:System.Action%601> Delegat mit dem Namen `action`, akzeptiert ein Argument des Typs <xref:System.Object>. Eine vierte-Aufgabe führt einen Lambda-Ausdruck (ein <xref:System.Action> Delegaten), Inline definiert im Aufruf der Methode zum Erstellen von Tasks. Jede Aufgabe instanziiert und auf andere Weise ausführen:  
  
-   Aufgabe `t1` durch den Aufruf eines Klassenkonstruktors Aufgabe instanziiert wird, jedoch wird gestartet, durch den Aufruf der <xref:System.Threading.Tasks.Task.Start> Methode nur nach Aufgabe `t2` wurde gestartet.  
  
-   Aufgabe `t2` instanziiert und Schritte in einem einzelnen Methodenaufruf durch Aufrufen der <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> Methode.  
  
-   Aufgabe `t3` instanziiert und Schritte in einem einzelnen Methodenaufruf durch Aufrufen der <xref:System.Threading.Tasks.Task.Run%28System.Action%29> Methode.  
  
-   Aufgabe `t4` wird synchron im Hauptthread ausgeführt, durch den Aufruf der <xref:System.Threading.Tasks.Task.RunSynchronously> Methode.  
  
 Da Aufgabe `t4` wird synchron ausgeführt. sie führt auf dem Thread der hauptanwendung. Die restlichen Aufgaben werden asynchron auf eine oder mehrere Threads im Threadpool in der Regel ausgeführt.  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a>Erstellen und Ausführen einer Aufgabe  
 <xref:System.Threading.Tasks.Task> Instanzen können auf verschiedene Arten erstellt werden. Die am häufigsten verwendete Ansatz, nämlich verfügbar ab der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], besteht im Aufrufen der statischen <xref:System.Threading.Tasks.Task.Run%2A> Methode. Die <xref:System.Threading.Tasks.Task.Run%2A> Methode bietet eine einfache Möglichkeit zum Starten einer Aufgabe, die unter Verwendung von Standardwerten ohne zusätzliche Parameter. Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.Run%28System.Action%29> Methode, um eine Aufgabe zu starten, Schleifen und zeigt dann die Anzahl der Schleifeniterationen:  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 Eine Alternative und die am häufigsten verwendete Methode für den Aufgabenstart nutzt [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], wird die statische <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode. Die <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> -Eigenschaft gibt eine <xref:System.Threading.Tasks.TaskFactory> Objekt. Der Überladungen der <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode können Sie angeben, an die Aufgabenerstellungsoptionen und einen Aufgabenplaner zu übergebenden Parameter. Im folgenden Beispiel wird die <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode für den Aufgabenstart nutzt. Es ist funktionell gleichwertig mit der Code im vorherigen Beispiel.  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 Ausführlichere Beispiele finden Sie unter [aufgabenbasierte asynchrone Programmierung](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a>Trennung von Erstellung und Ausführung  
 Die <xref:System.Threading.Tasks.Task> Klasse stellt außerdem Konstruktoren, die den Task initialisiert, aber nicht planen sie für die Ausführung, bereit. Aus Leistungsgründen die <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> oder <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode ist der bevorzugte Mechanismus zum Erstellen und Planen von Berechnungsaufgaben, aber für Szenarien, in denen Erstellung und Planung getrennt werden müssen, können Sie verwenden die Konstruktoren, und rufen dann die <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> Methode, um die Aufgabe für die Ausführung zu einem späteren Zeitpunkt zu planen.  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a>Warten auf eine oder mehrere Aufgaben ausführen  
 Da Aufgaben in der Regel asynchron auf einem Threadpoolthread ausgeführt werden, wird die Ausführung des Threads, die erstellt und startet den Task, sobald die Aufgabe instanziiert wurde fortgesetzt. In einigen Fällen, wenn der aufrufende Thread der Thread der hauptanwendung, ist die app kann beendet werden vor allen den Task startet die Ausführung tatsächlich. In anderen Fällen kann die Logik Ihrer Anwendung erforderlich, dass der aufrufende Thread die Ausführung fortsetzen, nur, wenn eine oder mehrere Aufgaben die Ausführung abgeschlossen hat. Können Sie die Ausführung des aufrufenden Threads synchronisieren der asynchronen Aufgaben und er startet durch Aufrufen einer `Wait` Methode warten, eine oder mehrere Aufgaben ausführen.  
  
 Um für die Durchführung einer einzelnen Aufgabe zu warten, rufen Sie die <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Methode. Ein Aufruf der <xref:System.Threading.Tasks.Task.Wait%2A> Methode blockiert den aufrufenden Thread, bis die Instanz der Klasse die Ausführung abgeschlossen hat.  
  
 Im folgenden Beispiel wird die parameterlose <xref:System.Threading.Tasks.Task.Wait> Methode bedingungslos warten, bis eine Aufgabe abgeschlossen ist. Die Aufgabe simuliert Arbeit durch Aufrufen der <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode für zwei Sekunden in den Ruhezustand.  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 Sie können auch bedingt auf den Abschluss einer Aufgabe warten. Die <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> und <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> Methoden blockiert den aufrufenden Thread, bis die Aufgabe abgeschlossen ist oder ein Timeoutintervall abläuft, welcher Fall zuerst eintritt. Da im folgende Beispiel wird eine Aufgabe, die zwei Sekunden wartet jedoch definiert einen 1-Sekunden-Timeout-Wert, der aufrufende Thread blockiert gestartet, bis das Timeout abläuft, und bevor ist Ausführung der Aufgabe abgeschlossen werden.  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 Sie können auch ein Abbruchtoken angeben, durch den Aufruf der <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> und <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> Methoden. Wenn des Tokens <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> Eigenschaft `true` oder `true` während der <xref:System.Threading.Tasks.Task.Wait%2A> Methode ausgeführt wird, löst die Methode eine <xref:System.OperationCanceledException>.  
  
 In einigen Fällen möchten Sie möglicherweise warten, für die ersten einer Reihe von Ausführen von Aufgaben abgeschlossen, aber sorgfältig auf die diese Aufgabe ist.  Zu diesem Zweck können Sie eine der Überladungen von Aufrufen der <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> Methode.  Das folgende Beispiel erstellt drei Aufgaben, von denen jeder im Ruhezustand ist für ein Intervall bestimmen, indem Sie einen Zufallszahlengenerator. Die <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> Methode wartet, bis die erste Aufgabe ausführen. Das Beispiel zeigt anschließend Informationen über den Status aller drei Aufgaben.  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 Sie können auch warten, für alle einer Reihe von Aufgaben durch Aufrufen der <xref:System.Threading.Tasks.Task.WaitAll%2A> Methode. Im folgenden Beispiel werden zehn Aufgaben erstellt, die wartet, bis alle zehn abgeschlossen werden, und klicken Sie dann ihren Status angezeigt.  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 Beachten Sie, dass wenn Sie eine oder mehrere Aufgaben zum Abschluss warten, die ausgeführten Aufgaben ausgelöste Ausnahmen für den Thread weitergegeben werden, die aufruft, die `Wait` Methode, wie im folgenden Beispiel gezeigt. Es startet 12 Aufgaben, von denen drei nicht regulär abgeschlossen werden und drei der welche lösen eine Ausnahme. Die verbleibenden sechs Aufgaben werden drei vor dem Start abgebrochen, und drei werden abgebrochen, während sie ausgeführt. Ausnahmen werden ausgelöst, der <xref:System.Threading.Tasks.Task.WaitAll%2A> Methodenaufruf und werden anhand einer `try` / `catch` Block.  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 Weitere Informationen zur Ausnahmebehandlung in aufgabenbasierte asynchrone Vorgänge finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a>Aufgaben und Kultur  
 Beginnend mit desktop-apps für die [!INCLUDE[net_v46](~/includes/net-v46-md.md)], die Kultur des Threads, der erstellt, und ruft eine Aufgabe wird der Kontext des Threads. Unabhängig von der aktuellen Kultur des Threads auf dem der Task ausgeführt wird, ist die aktuelle Kultur der Aufgabe, also die Kultur des aufrufenden Threads. Für apps mit Zielversionen von .NET Framework vor der [!INCLUDE[net_v46](~/includes/net-v46-md.md)], die der Aufgabe ist die Kultur des Threads auf dem der Task ausgeführt wird. Weitere Informationen finden Sie im Abschnitt "Kultur und aufgabenbasierte asynchrone Vorgänge" in der <xref:System.Globalization.CultureInfo> Thema.  
  
> [!NOTE]
>  Store-apps, die Windows-Runtime in festlegen und Abrufen der Standardkultur folgen.  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a>Für Debuggerentwickler  
 Für Entwickler, die benutzerdefinierte Debugger implementieren können mehrere interne und private Member des Tasks hilfreich sein (Dies können sich von Version zu Version ändern). Die `m_taskId` Feld dient als Sicherungsspeicher für die <xref:System.Threading.Tasks.Task.Id%2A> Eigenschaft jedoch den Zugriff auf dieses Feld direkt von einem Debugger effizienter als der Zugriff auf den gleichen Wert der Eigenschaft Getter-Methode sein kann (die `s_taskIdCounter` Zähler ist verwendet, um die nächste verfügbare ID für einen Task abrufen). Auf ähnliche Weise die `m_stateFlags` Feld speichert Informationen über die aktuelle Lebenszyklusphase der Aufgabe, Informationen, die auch über die <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft. Die `m_action` Feld speichert einen Verweis auf den Delegaten der Aufgabe, und die `m_stateObject` Feld speichert den Async-Zustand, der vom Entwickler an die Aufgabe übergeben. Schließlich für den Debugger, die Stapelrahmen, Analysieren der `InternalWait` Methode dient potenziellen Marker für die bei eine Aufgabe einen Wartevorgang eingibt.   
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Mitglieder der <see cref="T:System.Threading.Tasks.Task" />, mit Ausnahme von <see cref="M:System.Threading.Tasks.Task.Dispose" />sind threadsicher und können von mehreren Threads gleichzeitig verwendet werden.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Beispiele für die parallele Programmierung mit .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <summary>Initialisiert eine neue <see cref="T:System.Threading.Tasks.Task" /> mit der angegebenen Aktion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> oder <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> angegebenen Verzeichnissen zu Konstruktor, um Aufgaben zu erstellen, die alle Dateinamen in abrufen. Alle Aufgaben schreiben die Dateinamen in einer einzelnen <xref:System.Collections.Concurrent.ConcurrentBag%601> Objekt. Das Beispiel ruft dann die <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> Methode, um sicherzustellen, dass alle Aufgaben abgeschlossen haben, und klicken Sie dann zeigt die Anzahl der Gesamtzahl von Dateinamen geschrieben, um die <xref:System.Collections.Concurrent.ConcurrentBag%601> Objekt.  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 Das folgende Beispiel ist nahezu identisch, außer dass sie verwendet die <xref:System.Threading.Tasks.Task.Run%28System.Action%29> Methode zum Instanziieren und Ausführen der Aufgabe in einem einzigen Vorgang. Die Methode gibt die <xref:System.Threading.Tasks.Task> -Objekt, das die Aufgabe darstellt.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument lautet <see langword="null" />.</exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das die neue Aufgabe berücksichtigt.</param>
        <summary>Initialisiert eine neue <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion und <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> und <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Methoden. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
 Weitere Informationen finden Sie unter [Aufgabenparallelität (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) und [Abbruch in verwalteten Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> Konstruktor zum Erstellen einer Aufgabe, die die Dateien in das Verzeichnis C:\Windows\System32 durchläuft. Ruft die Lambda-Ausdruck die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode, um Informationen zu jeder Datei zum Hinzufügen einer <xref:System.Collections.Generic.List%601> Objekt. Jede getrennt geschachtelte Aufgabe aufgerufen, indem die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Schleife überprüft den Status des Abbruchtokens und, wenn der Abbruch angefordert wird, ruft der <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Methode. Die <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> -Methode löst eine <xref:System.OperationCanceledException> in behandelte Ausnahme einer `catch` blockieren, wenn der aufrufende Thread Ruft die <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Methode.  Die <xref:System.Threading.Tasks.Task.Start%2A> Methode wird aufgerufen, um die Aufgabe gestartet.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <param name="creationOptions">Die <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, die verwendet werden, um das Verhalten der Aufgabe zu ändern.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion und Erstellungsoptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> an.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Aktion verwendet werden sollen.</param>
        <summary>Initialisiert eine neue <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion und Zustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
   
  
## Examples  
 Das folgende Beispiel definiert ein Array von 6 Buchstaben von Wörtern. Jedes Wort wird dann als Argument übergeben die <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> Konstruktor, dessen <xref:System.Action%601> Delegaten durcheinanderbringt die Zeichen im Wort und zeigt anschließend der ursprüngliche Begriff und deren unverständliche Version.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das die neue Aufgabe berücksichtigt.</param>
        <param name="creationOptions">Die <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, die verwendet werden, um das Verhalten der Aufgabe zu ändern.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion und Erstellungsoptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
 Weitere Informationen finden Sie unter [Aufgabenparallelität (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) und [Aufgabenabbruch](~/docs/standard/parallel-programming/task-cancellation.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> an.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Aktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das die neue Aufgabe berücksichtigt.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion, Zustand und Optionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Aktion verwendet werden sollen.</param>
        <param name="creationOptions">Die <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, die verwendet werden, um das Verhalten der Aufgabe zu ändern.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion, Zustand und Optionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> an.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Aktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das die neue Aufgabe berücksichtigt.</param>
        <param name="creationOptions">Die <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, die verwendet werden, um das Verhalten der Aufgabe zu ändern.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task" /> mit den angegebenen Werten für Aktion, Zustand und Optionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> an.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das beim Erstellen der <see cref="T:System.Threading.Tasks.Task" /> angegebene Zustandsobjekt ab, oder NULL, wenn kein Zustandsobjekt angegeben wurde.</summary>
        <value>Ein <see cref="T:System.Object" />, das die Zustandsdaten darstellt, die bei der Erstellung an die Aufgabe übergeben wurden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wandeln Sie das Objekt wieder in den ursprünglichen Typ seine Daten abruft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedTask : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Aufgabe ab, die bereits erfolgreich abgeschlossen wurde.</summary>
        <value>Die erfolgreich abgeschlossene Aufgabe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt einen Task zurück, dessen <xref:System.Threading.Tasks.Task.Status%2A> -Eigenschaftensatz auf <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Um die Aufgabe zu erstellen, gibt einen Wert zurück, und bis zum Ende ausgeführt, rufen Sie die <xref:System.Threading.Tasks.Task.FromResult%2A> Methode.  
  
 Wiederholte Versuche zum Abrufen der Wert dieser Eigenschaft möglicherweise nicht immer die gleiche Instanz zurück.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="member this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext"><see langword="true" /> um zu versuchen, die Fortsetzung zurück in den ursprünglich erfassten Text zu marshallen, andernfalls <see langword="false" />.</param>
        <summary>Konfiguriert einen Awaiter, der verwendet wird, um diese <see cref="T:System.Threading.Tasks.Task" /> zu erwarten.</summary>
        <returns>Ein Objekt, das verwendet wird, um diese Aufgabe zu erwarten.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine Aufgabe, die ein Array mit 100 zufälligen Date und Time-Werten aufgefüllt wird. Er verwendet den <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> Methode zum Auswählen der frühesten und den neuesten Date-Werten, sobald das Array vollständig aufgefüllt ist.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 Da eine Konsolenanwendung beenden kann, bevor die Fortsetzungsaufgabe ausgeführt wird, die <xref:System.Threading.Tasks.Task.Wait> Methode wird aufgerufen, um sicherzustellen, dass die Fortsetzung, die vor dem Ende des Beispiel Ausführung abgeschlossen ist.  
  
 Ein zusätzliches Beispiel finden Sie unter [Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die ausgeführt werden soll, wenn die Aufgabe abgeschlossen wurde. Wenn der Delegat ausgeführt wird, werden ihm der abgeschlossene Task und das vom Aufrufer bereitgestellte Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <summary>Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen empfängt, und wird ausgeführt, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.</summary>
        <returns>Eine neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang abgeschlossen wurde, erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden frühzeitig auf einen Abbruch zurückzuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt eine Fortsetzung, die ein Abbruchtoken empfängt und asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die das Token erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die nach den angegebenen <paramref name="continuationOptions" /> ausgeführt werden soll. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Erstellt eine Fortsetzung, die, sobald die Zielaufgabe abgeschlossen ist, entsprechend den Angaben in <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> ausgeführt wird.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht für die Ausführung geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Fortsetzungskriterien über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird jedoch abgebrochen statt geplant.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung <xref:System.Threading.Tasks.TaskContinuationOptions> um anzugeben, dass eine Fortsetzungsaufgabe synchron ausgeführt werden soll, wenn die vorangehende Aufgabe abgeschlossen ist. (Wenn die angegebene Aufgabe bereits, mit der Zeit abgeschlossen wurde <xref:System.Threading.Tasks.Task.ContinueWith%2A> aufgerufen wird, die synchrone Fortsetzung ausgeführt wird, auf dem Thread, von <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde. Die Fortsetzung verwendet einen angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="scheduler" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen sowie ein Abbruchtoken empfängt und asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen empfängt, und wird ausgeführt, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Die Fortsetzung wird entsprechend einem Satz angegebener Bedingungen ausgeführt.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht für die Ausführung geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Fortsetzungskriterien über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird jedoch abgebrochen statt geplant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll.  Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen empfängt, und wird asynchron ausgeführt, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Die Fortsetzung verwendet einen angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die nach den angegebenen <paramref name="continuationOptions" /> ausgeführt werden soll. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die, sobald die Zielaufgabe abgeschlossen ist, entsprechend den Angaben in <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> ausgeführt wird. Die Fortsetzung empfängt ein Abbruchtoken und verwendet einen angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht für die Ausführung geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Kriterien, über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird abgebrochen statt geplant.  
  
   
  
## Examples  
 Folgendes ist ein Beispiel für die Verwendung von ContinueWith für die Arbeit im Hintergrund sowohl für den Benutzer Schnittstelle Threads ausgeführt werden.  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die das Token erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument ist null.  
  
- oder -  
Das <paramref name="scheduler" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task" /> ausgeführt werden soll. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen sowie ein Abbruchtoken empfängt und ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde. Die Fortsetzung wird entsprechend einem Satz angegebener Bedingungen ausgeführt und verwendet einen angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht für die Ausführung geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Kriterien, über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird abgebrochen statt geplant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen wurde, und gibt einen Wert zurück.</summary>
        <returns>Eine neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der ContinueWith-Methode:  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <summary>Erstellt eine Fortsetzung, die vom Aufrufer bereitgestellte Zustandsinformationen empfängt, und wird asynchron ausgeführt, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist, und gibt einen Wert zurück.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde, und gibt einen Wert zurück. Die Fortsetzung empfängt ein Abbruchtoken.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.  
  
- oder -  
Die <see cref="T:System.Threading.CancellationTokenSource" />, die das Token erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die entsprechend der in <paramref name="continuationOptions" /> angegebenen Bedingung ausgeführt wird. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Erstellt eine Fortsetzung, die entsprechend den angegebenen Fortsetzungsoptionen ausgeführt wird, und gibt einen Wert zurück.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht für die Ausführung geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Fortsetzungskriterien über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird jedoch abgebrochen statt geplant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde, und gibt einen Wert zurück. Die Fortsetzung verwendet einen angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.  
  
- oder -  
Das <paramref name="scheduler" />-Argument ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde, und gibt einen Wert zurück. Die Fortsetzung empfängt vom Aufrufer bereitgestellte Zustandsinformationen sowie ein Abbruchtoken.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Erstellt eine Fortsetzung, die entsprechend den angegebenen Aufgabenfortsetzungsoptionen ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Die Fortsetzung empfängt vom Aufrufer bereitgestellte Zustandsinformationen.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht für die Ausführung geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Fortsetzungskriterien über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird jedoch abgebrochen statt geplant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist.  Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde. Die Fortsetzung empfängt vom Aufrufer bereitgestellte Zustandsinformationen und verwendet einen angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die entsprechend der in <c>continuationOptions</c> angegebenen Bedingung ausgeführt wird. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die entsprechend den angegebenen Fortsetzungsoptionen ausgeführt wird, und gibt einen Wert zurück. An die Fortsetzung wird ein Abbruchtoken übergeben, und sie verwendet einen angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht für die Ausführung geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Kriterien, über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird abgebrochen statt geplant.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die ContinueWith-Methode mit Optionen für die Fortsetzung verwenden:  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.  
  
- oder -  
Die <see cref="T:System.Threading.CancellationTokenSource" />, die das Token erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.  
  
- oder -  
Das <paramref name="scheduler" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die entsprechend den angegebenen Aufgabenfortsetzungsoptionen ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task" /> abgeschlossen ist, und gibt einen Wert zurück. Die Fortsetzung empfängt vom Aufrufer bereitgestellte Zustandsinformationen sowie ein Abbruchtoken und verwendet den angegebenen Zeitplan.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht für die Ausführung geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Kriterien, über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird abgebrochen statt geplant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die zum Erstellen dieser Aufgabe verwendeten <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> ab.</summary>
        <value>Die zum Erstellen dieser Aufgabe verwendeten <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentId : Nullable&lt;int&gt;" Usage="System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die ID der momentan ausgeführten <see cref="T:System.Threading.Tasks.Task" /> zurück.</summary>
        <value>Eine ganze Zahl, die der gerade ausgeführten Aufgabe vom System zugewiesen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.CurrentId%2A> ist eine `static` (`Shared` in Visual Basic)-Eigenschaft, die verwendet wird, um den Bezeichner der derzeit ausgeführten Aufgabe aus dem Code zu erhalten, die die Aufgabe ausgeführt wird. Es unterscheidet sich von der <xref:System.Threading.Tasks.Task.Id%2A> Eigenschaft, die den Bezeichner einer bestimmten zurückgibt <xref:System.Threading.Tasks.Task> Instanz. Wenn Sie versuchen, das Abrufen der <xref:System.Threading.Tasks.Task.CurrentId%2A> Wert von außerhalb der Code, der eine Aufgabe ausführt, wird, die Eigenschaft zurückgibt `null`.  
  
 Beachten Sie, dass obwohl Konflikte äußerst selten sind, Task-IDs nicht garantiert eindeutig sein.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Aufgabe, die nach einer Verzögerung abgeschlossen wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="static member Delay : int -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Die Anzahl der Millisekunden, die gewartet wird, bevor die zurückgegebene Aufgabe abgeschlossen wird, oder -1, um unbegrenzt zu warten.</param>
        <summary>Erstellt eine Aufgabe, die nach Ablauf einer festgelegten Anzahl an Millisekunden abgeschlossen wird.</summary>
        <returns>Eine Aufgabe, die die Verzögerung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task.Delay%2A> Methode wird normalerweise verwendet, um die Vorgänge aller oder Teil eines Tasks für ein angegebenes Zeitintervall zu verzögern. In den meisten Fällen wird die zeitliche Verzögerung eingeführt:  
  
-   AT wird der Beginn des Vorgangs, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   Einige Zeit, während die Aufgabe ausgeführt wird. In diesem Fall ist der Aufruf der <xref:System.Threading.Tasks.Task.Delay%2A> Methode als eine untergeordnete Aufgabe innerhalb einer Aufgabe ausgeführt wird, wie im folgenden Beispiel gezeigt. Beachten Sie, dass seit der Aufgabe aufruft, die <xref:System.Threading.Tasks.Task.Delay%2A> Methode asynchron ausgeführt wird, die übergeordnete Aufgabe muss auf den Abschluss mit warten, bis die `await` Schlüsselwort.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 Nach der angegebenen Verzögerung, die Aufgabe abgeschlossen ist, der <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand.  
  
 Diese Methode hängt von der Systemuhr ab. Dies bedeutet, dass die Wartezeit ungefähr die Auflösung der Systemuhr wenn gleich wird die `millisecondsDelay` -Argument ist kleiner als die Auflösung der Systemuhr, handelt es sich etwa 15 Millisekunden auf Windows-Systemen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine einfache Verwendung von der <xref:System.Threading.Tasks.Task.Delay%2A> Methode.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="millisecondsDelay" />-Argument ist kleiner als -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">Die Zeitspanne, die abgewartet werden soll, bevor die zurückgegebene Aufgabe abgeschlossen wird, oder <see langword="TimeSpan.FromMilliseconds(-1)" />, um unbegrenzt zu warten.</param>
        <summary>Erstellt eine Aufgabe, die nach Ablauf einer festgelegten Zeitspanne abgeschlossen wird.</summary>
        <returns>Eine Aufgabe, die die Verzögerung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach der angegebenen Verzögerung, die Aufgabe abgeschlossen ist, im <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand.  
  
 Verwendungsszenarien und Beispiele finden Sie in der Dokumentation für die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> überladen.  
  
 Diese Methode hängt von der Systemuhr ab. Dies bedeutet, dass die Wartezeit ungefähr die Auflösung der Systemuhr wenn gleich wird die `delay` -Argument ist kleiner als die Auflösung der Systemuhr, handelt es sich etwa 15 Millisekunden auf Windows-Systemen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine einfache Verwendung von der <xref:System.Threading.Tasks.Task.Delay%2A> Methode.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="delay" /> stellt ein negatives Zeitintervall ungleich <see langword="TimeSpan.FromMillseconds(-1)" /> dar.  
  
- oder -  
Die <paramref name="delay" /> der <see cref="P:System.TimeSpan.TotalMilliseconds" />-Eigenschaft des Arguments ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (millisecondsDelay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Die Anzahl der Millisekunden, die gewartet wird, bevor die zurückgegebene Aufgabe abgeschlossen wird, oder -1, um unbegrenzt zu warten.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das beim Warten auf den Abschluss der Aufgabe überwacht werden soll.</param>
        <summary>Erstellt eine stornierbare Aufgabe, die nach Ablauf einer festgelegten Anzahl an Millisekunden abgeschlossen wird.</summary>
        <returns>Eine Aufgabe, die die Verzögerung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Abbruchtoken, das signalisiert wird, bevor Sie die angegebenen zeitverzögerung, eine <xref:System.Threading.Tasks.TaskCanceledException> Laufzeitausnahme tritt auf, und die Aufgabe abgeschlossen ist, der <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand.  Andernfalls wird die Aufgabe abgeschlossen, der <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand, nachdem die Verzögerung für die angegebene Zeit verstrichen ist.  
  
 Verwendungsszenarien und Beispiele finden Sie in der Dokumentation für die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> überladen.  
  
 Diese Methode hängt von der Systemuhr ab. Dies bedeutet, dass die Wartezeit ungefähr die Auflösung der Systemuhr wenn gleich wird die `millisecondsDelay` -Argument ist kleiner als die Auflösung der Systemuhr, handelt es sich etwa 15 Millisekunden auf Windows-Systemen.  
  
   
  
## Examples  
 Im folgende Beispiel startet eine Aufgabe, die einen Aufruf, umfasst die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> -Methode mit einer Verzögerung von einer Sekunde. Bevor das Verzögerungsintervall verstrichen ist, wird das Token abgebrochen. Die Ausgabe im Beispiel wird veranschaulicht, wie daher, ein <xref:System.Threading.Tasks.TaskCanceledException> ausgelöst wird, und die Tasks' <xref:System.Threading.Tasks.Task.Status%2A> -Eigenschaftensatz auf <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="millisecondsDelay" />-Argument ist kleiner als -1.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Die Aufgabe wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <paramref name="cancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (delay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="delay">Die Zeitspanne, die abgewartet werden soll, bevor die zurückgegebene Aufgabe abgeschlossen wird, oder <see langword="TimeSpan.FromMilliseconds(-1)" />, um unbegrenzt zu warten.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das beim Warten auf den Abschluss der Aufgabe überwacht werden soll.</param>
        <summary>Erstellt eine abzubrechende Aufgabe, die nach Ablauf einer festgelegten Zeitspanne abgeschlossen wird.</summary>
        <returns>Eine Aufgabe, die die Verzögerung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Abbruchtoken, das signalisiert wird, bevor Sie die angegebenen zeitverzögerung, eine <xref:System.Threading.Tasks.TaskCanceledException> Laufzeitausnahme tritt auf, und die Aufgabe abgeschlossen ist, der <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand.  Andernfalls wird die Aufgabe abgeschlossen, der <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand, nachdem die Verzögerung für die angegebene Zeit verstrichen ist.  
  
 Verwendungsszenarien und Beispiele finden Sie in der Dokumentation für die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> überladen.  
  
 Diese Methode hängt von der Systemuhr ab. Dies bedeutet, dass die Wartezeit ungefähr die Auflösung der Systemuhr wenn gleich wird die `delay` -Argument ist kleiner als die Auflösung der Systemuhr, handelt es sich etwa 15 Millisekunden auf Windows-Systemen.  
  
   
  
## Examples  
 Im folgende Beispiel startet eine Aufgabe, die einen Aufruf, umfasst die <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> -Methode mit einer Verzögerung von 1,5 Sekunden. Bevor das Verzögerungsintervall verstrichen ist, wird das Token abgebrochen. Die Ausgabe im Beispiel wird veranschaulicht, wie daher, ein <xref:System.Threading.Tasks.TaskCanceledException> ausgelöst wird, und die Tasks' <xref:System.Threading.Tasks.Task.Status%2A> -Eigenschaftensatz auf <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 Beachten Sie, dass in diesem Beispiel wird eine mögliche Racebedingung enthält: hängt die Aufgabe, die die Verzögerung asynchron ausgeführt werden, wenn das Token abgebrochen wird. Obwohl die zweite 1,5 durch den Aufruf verzögern der <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> Methode macht diese Annahme wahrscheinlich, dennoch ist es möglich, die den Aufruf von der <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> Methode zurückgeben kann, bevor das Token abgebrochen wird. In diesem Fall wird im Beispiel wird die folgende Ausgabe:  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="delay" /> stellt ein negatives Zeitintervall ungleich <see langword="TimeSpan.FromMillseconds(-1)" /> dar.  
  
- oder -  
Die <paramref name="delay" /> der <see cref="P:System.TimeSpan.TotalMilliseconds" />-Eigenschaft des Arguments ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Die Aufgabe wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <paramref name="cancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.Tasks.Task" />-Klasse verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="task.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.Tasks.Task" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task> -Klasse implementiert die <xref:System.IDisposable> Schnittstelle, da intern verwendet Ressourcen, die ebenfalls implementieren <xref:System.IDisposable>. Jedoch insbesondere dann, wenn Ihre app für die [!INCLUDE[net_v45](~/includes/net-v45-md.md)] oder höher, besteht keine Notwendigkeit zum Aufrufen <xref:System.Threading.Tasks.Task.Dispose%2A> , wenn die Leistung oder Skalierbarkeit Testen an, dass basierend auf Ihren Verwendungsmustern, die Leistung Ihrer app würde verbessert werden durch das Löschen von Aufgaben. Weitere Informationen finden Sie unter [benötige ich zum Verwerfen von Vorgängen?](https://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Task ist nicht in einem der Endzustände: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> oder <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="task.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Ein boolescher Wert, der angibt, ob diese Methode aufgrund eines Aufrufs von <see cref="M:System.Threading.Tasks.Task.Dispose" /> aufgerufen wird.</param>
        <summary>Verwirft den <see cref="T:System.Threading.Tasks.Task" /> und gibt somit alle von ihm verwendeten nicht verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task> -Klasse implementiert die <xref:System.IDisposable> Schnittstelle, da intern verwendet Ressourcen, die ebenfalls implementieren <xref:System.IDisposable>. Jedoch insbesondere dann, wenn Ihre app für die [!INCLUDE[net_v45](~/includes/net-v45-md.md)] oder höher, besteht keine Notwendigkeit zum Aufrufen <xref:System.Threading.Tasks.Task.Dispose%2A> , wenn die Leistung oder Skalierbarkeit Testen an, dass basierend auf Ihren Verwendungsmustern, die Leistung Ihrer app würde verbessert werden durch das Löschen von Aufgaben. Weitere Informationen finden Sie unter [benötige ich zum Verwerfen von Vorgängen?](https://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Task ist nicht in einem der Endzustände: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> oder <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <threadsafe>Im Gegensatz zu den Großteil der Member der <see cref="T:System.Threading.Tasks.Task" /> -Klasse, die diese Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Exception : AggregateException" Usage="System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.AggregateException" /> ab, die die vorzeitige Beendigung der <see cref="T:System.Threading.Tasks.Task" /> verursacht hat. Wenn die <see cref="T:System.Threading.Tasks.Task" /> erfolgreich abgeschlossen wurde oder noch keine Ausnahmen ausgelöst wurden, wird <see langword="null" /> zurückgegeben.</summary>
        <value>Die <see cref="T:System.AggregateException" />, die die vorzeitige Beendigung der <see cref="T:System.Threading.Tasks.Task" /> verursacht hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufgaben, die nicht behandelte Ausnahmen auslösen, speichern Sie die resultierende Ausnahme und weitergeben innerhalb einer <xref:System.AggregateException> in Aufrufen von <xref:System.Threading.Tasks.Task.Wait%2A> oder Zugriffe auf die <xref:System.Threading.Tasks.Task.Exception%2A> Eigenschaft. Alle Ausnahmen, die mit der Zeit, die die Aufgabeninstanz Garbage Collection wird nicht beachtet werden der Finalizer-Thread weitergegeben. Weitere Informationen und ein Beispiel finden Sie unter [Ausnahmebehandlung (Task Parallel Library)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory" Usage="System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bietet Zugriff auf Factorymethoden zum Erstellen und Konfigurieren von <see cref="T:System.Threading.Tasks.Task" />- und <see cref="T:System.Threading.Tasks.Task`1" />-Instanzen.</summary>
        <value>Ein Factoryobjekt, das eine Vielzahl von <see cref="T:System.Threading.Tasks.Task" />- und <see cref="T:System.Threading.Tasks.Task`1" />-Objekten erstellen kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt eine Standardinstanz von die <xref:System.Threading.Tasks.TaskFactory> Klasse, die identisch mit dem Kennwort erstellt, durch den Aufruf eines parameterlosen <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> Konstruktor. Es hat die folgenden Eigenschaftenwerte fest:  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|`null`, oder <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 Die häufigste Verwendung dieser Eigenschaft wird zum Erstellen und starten eine neue Aufgabe in einem einzigen Aufruf der <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode bietet die einfachste Möglichkeit zum Erstellen einer <xref:System.Threading.Tasks.Task> Objekt mit den Standardwerten für die Konfiguration.  
  
 Im folgenden Beispiel wird die statische <xref:System.Threading.Tasks.Task.Factory%2A> Eigenschaft zwei Aufrufe an die <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode. Die erste füllt ein Array mit den Namen der Dateien im Verzeichnis Eigene Dateien des Benutzers, während das zweite ein Array mit den Namen der Unterverzeichnisse des MyDocuments-Verzeichnis des Benutzers aufgefüllt. Es ruft dann die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> -Methode, die Informationen über die Anzahl von Dateien und Verzeichnissen in die beiden Arrays angezeigt, nachdem die ersten beiden Aufgaben ausgeführt.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Das Abbruchtoken, mit dem die Aufgabe abgeschlossen werden soll.</param>
        <summary>Erstellt eine durch Abbruch abgeschlossene <see cref="T:System.Threading.Tasks.Task" /> mit einem angegebenen Abbruchtoken.</summary>
        <returns>Die abgebrochene Aufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für <paramref name="cancellationToken" /> wurde kein Abbruch angefordert, dessen <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" />-Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Aufgabe zurückgegebenen Ergebnisses.</typeparam>
        <param name="cancellationToken">Das Abbruchtoken, mit dem die Aufgabe abgeschlossen werden soll.</param>
        <summary>Erstellt eine durch Abbruch abgeschlossene <see cref="T:System.Threading.Tasks.Task`1" /> mit einem angegebenen Abbruchtoken.</summary>
        <returns>Die abgebrochene Aufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für <paramref name="cancellationToken" /> wurde kein Abbruch angefordert, dessen <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" />-Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Die Ausnahme, mit der die Aufgabe abgeschlossen werden soll.</param>
        <summary>Erstellt eine durch eine angegebene Ausnahme abgeschlossene <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Die fehlgeschlagene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine <xref:System.Threading.Tasks.Task> Objekt, dessen <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft <xref:System.Threading.Tasks.TaskStatus.Faulted> und dessen <xref:System.Threading.Tasks.Task.Exception%2A> Eigenschaft enthält `exception`. Die Methode wird häufig verwendet, wenn Sie wissen sofort, dass die Arbeit, die eine Aufgabe ausführt, eine Ausnahme vor der Ausführung eines längeren Codepfads ausgelöst wird. Ein Beispiel finden Sie unter den <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> überladen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Aufgabe zurückgegebenen Ergebnisses.</typeparam>
        <param name="exception">Die Ausnahme, mit der die Aufgabe abgeschlossen werden soll.</param>
        <summary>Erstellt eine durch eine angegebene Ausnahme abgeschlossene <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Die fehlgeschlagene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine <xref:System.Threading.Tasks.Task%601> Objekt, dessen <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft <xref:System.Threading.Tasks.TaskStatus.Faulted> und dessen <xref:System.Threading.Tasks.Task.Exception%2A> Eigenschaft enthält `exception`. Die Methode wird häufig verwendet, wenn Sie wissen sofort, dass die Arbeit, die eine Aufgabe ausführt, eine Ausnahme vor der Ausführung eines längeren Codepfads ausgelöst wird. Dies wird im Beispiel veranschaulicht.  
  
   
  
## Examples  
 Das folgende Beispiel ist ein Befehlszeilen-Hilfsprogramm, das die Anzahl der Bytes in den Dateien in jedem Verzeichnis berechnet, deren Name als Befehlszeilenargument übergeben wird. Anstatt die Ausführung eines längeren Codepfads, der instanziiert ein <xref:System.IO.FileInfo> -Objekt und ruft den Wert des der <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> Eigenschaft für jede Datei in das Verzeichnis, das Beispiel ruft die <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> Methode, um einen fehlerhaften Vorgang erstellen, falls ein bestimmter Unterverzeichnis ist nicht vorhanden.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberSignature Language="F#" Value="static member FromResult : 'Result -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Aufgabe zurückgegebenen Ergebnisses.</typeparam>
        <param name="result">Das in der abgeschlossenen Aufgabe zu speichernde Ergebnis.</param>
        <summary>Erstellt eine <see cref="T:System.Threading.Tasks.Task`1" />, die erfolgreich mit dem angegebenen Ergebnis abgeschlossen wurde.</summary>
        <returns>Die erfolgreich abgeschlossene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine <xref:System.Threading.Tasks.Task%601> Objekt, dessen <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Eigenschaft `result` und dessen <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Die Methode wird häufig verwendet, wenn der Rückgabewert eines Vorgangs sofort bekannt ist, ohne einen längeren Codepfad auszuführen. Dies wird im Beispiel veranschaulicht.  
  
 Um eine Task-Objekt zu erstellen, die keinen Wert zurückgibt, rufen Sie im Task-Objekt, aus der <xref:System.Threading.Tasks.Task.CompletedTask%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel ist ein Befehlszeilen-Hilfsprogramm, das die Anzahl der Bytes in den Dateien in jedem Verzeichnis berechnet, deren Name als Befehlszeilenargument übergeben wird. Anstatt die Ausführung eines längeren Codepfads, der instanziiert ein <xref:System.IO.FileStream> -Objekt und ruft den Wert des der <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> Eigenschaft für jede Datei in das Verzeichnis, das Beispiel ruft die <xref:System.Threading.Tasks.Task.FromResult%2A> Methode, um eine Aufgabe zu erstellen, deren <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Eigenschaft ist 0 (null) an, wenn ein Verzeichnis keine Dateien enthält.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberSignature Language="F#" Value="member this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Awaiter ab, der verwendet wird, um diese <see cref="T:System.Threading.Tasks.Task" /> zu erwarten.</summary>
        <returns>Eine Awaiter-Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für die Verwendung durch den Compiler und nicht für die Verwendung in Anwendungscode vorgesehen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine ID für diese <see cref="T:System.Threading.Tasks.Task" />-Instanz ab.</summary>
        <value>Der Bezeichner, der dieser <see cref="T:System.Threading.Tasks.Task" />-Instanz vom System zugewiesen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Task-IDs bei Bedarf zugewiesen und ist nicht notwendigerweise die Reihenfolge, in welche, die Aufgabe Instanzen erstellt werden. Beachten Sie, dass obwohl Konflikte äußerst selten sind, Task-IDs nicht garantiert eindeutig sein.  
  
 Um der Task-ID der aktuell ausgeführten Aufgabe aus Code heraus zu dieser Aufgabe erhalten ausgeführt werden, verwenden Sie die <xref:System.Threading.Tasks.Task.CurrentId%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCanceled : bool" Usage="System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob diese <see cref="T:System.Threading.Tasks.Task" />-Instanz die Ausführung aufgrund eines Abbruchs abgeschlossen hat.</summary>
        <value><see langword="true" />, wenn die Aufgabe aufgrund eines Abbruchs beendet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Threading.Tasks.Task> abgeschlossen in den <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand unter einer der folgenden Bedingungen:  
  
-   Die <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> für die Stornierung markiert wurde, bevor die Aufgabe ausgeführt,  
  
-   Die Aufgabe hat, bestätigt die abbruchanforderung für die bereits signalisiert <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> durch Auslösen einer <xref:System.OperationCanceledException> zweitaktuellste gleich <xref:System.Threading.CancellationToken>.  
  
-   Die Aufgabe hat, bestätigt die abbruchanforderung für die bereits signalisiert <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> durch Aufrufen der <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> Methode für die <xref:System.Threading.CancellationToken>.  
  
> [!IMPORTANT]
>  Abrufen des Werts der <xref:System.Threading.Tasks.Task.IsCanceled%2A> Eigenschaft wird den aufrufenden Thread nicht blockiert, bis die Aufgabe abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob diese <see cref="T:System.Threading.Tasks.Task" /> abgeschlossen wurde.</summary>
        <value><see langword="true" />, wenn die Aufgabe abgeschlossen wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.IsCompleted%2A> Gibt `true` wann der Vorgang ist in einem der drei Endzustände: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, oder <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
> [!IMPORTANT]
>  Abrufen des Werts der <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> Eigenschaft wird den aufrufenden Thread nicht blockiert, bis die Aufgabe abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompletedSuccessfully : bool" Usage="System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFaulted : bool" Usage="System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Threading.Tasks.Task" /> aufgrund einer nicht behandelten Ausnahme abgeschlossen wurde.</summary>
        <value><see langword="true" />, wenn die Aufgabe einen Ausnahmefehler ausgelöst hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Threading.Tasks.Task.IsFaulted%2A> ist `true`, der Aufgabe <xref:System.Threading.Tasks.Task.Status%2A> gleich <xref:System.Threading.Tasks.TaskStatus.Faulted>, und die zugehörige <xref:System.Threading.Tasks.Task.Exception%2A> Eigenschaft ist nicht Null sein.  
  
> [!IMPORTANT]
>  Abrufen des Werts der <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> Eigenschaft wird den aufrufenden Thread nicht blockiert, bis die Aufgabe abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein Aufgaben- oder <see cref="T:System.Threading.Tasks.Task`1" />-Handle für diese Aufgabe zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task.Run%2A> Methode bietet eine Reihe von Überladungen, die für den Aufgabenstart nutzt, mit Standardwerten zu erleichtern. Es ist eine einfache Alternative zu den <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Überladungen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberSignature Language="F#" Value="static member Run : Action -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Die asynchron auszuführende Arbeit.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein <see cref="T:System.Threading.Tasks.Task" />-Objekt zurück, das diese Aufgabe darstellt.</summary>
        <returns>Eine Aufgabe, die die Arbeit darstellt, die sich in der Warteschlange befindet, um im Threadpool ausgeführt zu werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task.Run%2A> -Methode können Sie zum Erstellen und Ausführen einer Aufgabe in einem einzelnen Methodenaufruf und ist eine einfachere Alternative zu den <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Methode. Es erstellt eine Aufgabe mit den folgenden Standardwerten:  
  
-   Wird von dessen abbrechbarkeitstoken <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Die <xref:System.Threading.Tasks.Task.CreationOptions%2A> Eigenschaftswert ist <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Den standardmäßige Taskplaner verwendet.  
  
 Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `ShowThreadInfo` -Methode, die zeigt die <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> des aktuellen Threads. Es direkt aus dem Thread der Anwendung aufgerufen wird, und wird aufgerufen, von der <xref:System.Action> Delegaten zu übergeben, um die <xref:System.Threading.Tasks.Task.Run%28System.Action%29> Methode.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 Im folgende Beispiel ähnelt dem vorherigen Beispiel, außer dass er einen Lambda-Ausdruck verwendet, um den Code zu definieren, den die Aufgabe ist, führen Sie.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 Die Beispiele zeigen, dass die asynchrone Aufgabe auf einem anderen Thread als dem Hauptanwendungsthread ausgeführt wird.  
  
 Der Aufruf der <xref:System.Threading.Tasks.Task.Wait%2A> Methode stellt sicher, dass die Aufgabe abgeschlossen ist, und die Ausgabe vor dem Beenden der Anwendung zeigt. Andernfalls ist es möglich, die die `Main` Methode wird abgeschlossen, bevor die Aufgabe abgeschlossen ist.  
  
 Das folgende Beispiel veranschaulicht die <xref:System.Threading.Tasks.Task.Run%28System.Action%29> Methode. Es definiert ein Array von Verzeichnisnamen und startet eine separate Aufgabe, um die Dateinamen in jedem Verzeichnis abzurufen. Alle Aufgaben schreiben die Dateinamen in einer einzelnen <xref:System.Collections.Concurrent.ConcurrentBag%601> Objekt. Das Beispiel ruft dann die <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> Methode, um sicherzustellen, dass alle Aufgaben abgeschlossen haben, und klicken Sie dann zeigt die Anzahl der Gesamtzahl von Dateinamen geschrieben, um die <xref:System.Collections.Concurrent.ConcurrentBag%601> Objekt.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="action" />-Parameter war <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Ausnahmebehandlung (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Die asynchron auszuführende Arbeit.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschleife hinzu und gibt einen Proxy für die Aufgabe zurück, die von <paramref name="function" /> zurückgegeben wird.</summary>
        <returns>Eine Aufgabe, die einen Proxy für die Aufgabe darstellt, die durch <paramref name="function" /> zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="function" />-Parameter war <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Ausnahmebehandlung (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Die asynchron auszuführende Arbeit.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das verwendet werden kann, um die Arbeit abzubrechen.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein <see cref="T:System.Threading.Tasks.Task" />-Objekt zurück, das diese Aufgabe darstellt. Ein Abbruchtoken ermöglicht den Abbruch der Arbeit.</summary>
        <returns>Eine Aufgabe, die die Arbeit darstellt, die sich in der Warteschlange befindet, um im Threadpool ausgeführt zu werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Abbruch angefordert wird, bevor der Task die Ausführung beginnt, wird die Aufgabe nicht ausgeführt. Stattdessen wird er auf festgelegt die <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand und löst eine <xref:System.Threading.Tasks.TaskCanceledException> Ausnahme.  
  
 Die <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> Methode ist eine einfachere Alternative zu den <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Methode. Es erstellt eine Aufgabe mit den folgenden Standardwerten:  
  
-   Die <xref:System.Threading.Tasks.Task.CreationOptions%2A> Eigenschaftswert ist <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Den standardmäßige Taskplaner verwendet.  
  
 Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> Methode, um eine Aufgabe zu erstellen, die die Dateien in das Verzeichnis C:\Windows\System32 durchläuft. Ruft die Lambda-Ausdruck die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode, um Informationen zu jeder Datei zum Hinzufügen einer <xref:System.Collections.Generic.List%601> Objekt. Jede getrennt geschachtelte Aufgabe aufgerufen, indem die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Schleife überprüft den Status des Abbruchtokens und, wenn der Abbruch angefordert wird, ruft der <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Methode. Die <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> -Methode löst eine <xref:System.OperationCanceledException> in behandelte Ausnahme einer `catch` blockieren, wenn der aufrufende Thread Ruft die <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Methode.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="action" />-Parameter war <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Die Aufgabe wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <paramref name="cancellationToken" /> zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde verworfen.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Ausnahmebehandlung (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Die asynchron auszuführende Arbeit.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das verwendet werden soll, um die Arbeit abzubrechen.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschleife hinzu und gibt einen Proxy für die Aufgabe zurück, die von <paramref name="function" /> zurückgegeben wird.</summary>
        <returns>Eine Aufgabe, die einen Proxy für die Aufgabe darstellt, die durch <paramref name="function" /> zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="function" />-Parameter war <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Die Aufgabe wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <paramref name="cancellationToken" /> zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde verworfen.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Ausnahmebehandlung (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Proxy-Aufgabe zurückgegebenen Ergebnisses.</typeparam>
        <param name="function">Die asynchron auszuführende Arbeit.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschleife hinzu und gibt einen Proxy für die <see langword="Task(TResult)" /> zurück, die von <paramref name="function" /> zurückgegeben wird.</summary>
        <returns>Eine <see langword="Task(TResult)" />, die einen Proxy für die <see langword="Task(TResult)" /> darstellt, die durch <paramref name="function" /> zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="function" />-Parameter war <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Ausnahmebehandlung (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabetyp der Aufgabe.</typeparam>
        <param name="function">Die asynchron auszuführende Arbeit.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein <see cref="T:System.Threading.Tasks.Task`1" />-Objekt zurück, das diese Aufgabe darstellt.</summary>
        <returns>Ein Aufgabenobjekt, das die Arbeit darstellt, die sich in der Warteschlange befindet, um im Threadpool ausgeführt zu werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task.Run%2A> Methode ist eine einfachere Alternative zu den <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> Methode. Es erstellt eine Aufgabe mit den folgenden Standardwerten:  
  
-   Wird von dessen abbrechbarkeitstoken <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Die <xref:System.Threading.Tasks.Task.CreationOptions%2A> Eigenschaftswert ist <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Den standardmäßige Taskplaner verwendet.  
  
 Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird die ungefähre Anzahl der Wörter im Textdateien, die veröffentlichten Bücher darstellen. Jede Aufgabe ist verantwortlich für eine Datei zu öffnen, lesen den gesamten Inhalt asynchron und berechnen die Anzahl der Wörter mithilfe eines regulären Ausdrucks. Die <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> Methode wird aufgerufen, um sicherzustellen, dass alle Aufgaben abgeschlossen haben, bevor Sie die Anzahl der Wörter für jedes Buch in der Konsole anzeigen.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 Der reguläre Ausdruck `\p{P}*\s+` entspricht 0 (null), eine oder mehrere Interpunktionszeichen, gefolgt von einem oder mehreren Leerzeichen. Es wird davon ausgegangen, dass die Gesamtzahl der Übereinstimmungen wortzählung ungefähr gleich ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="function" />-Parameter ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Ausnahmebehandlung (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des von der Proxy-Aufgabe zurückgegebenen Ergebnisses.</typeparam>
        <param name="function">Die asynchron auszuführende Arbeit.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das verwendet werden soll, um die Arbeit abzubrechen.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschleife hinzu und gibt einen Proxy für die <see langword="Task(TResult)" /> zurück, die von <paramref name="function" /> zurückgegeben wird.</summary>
        <returns>Eine <see langword="Task(TResult)" />, die einen Proxy für die <see langword="Task(TResult)" /> darstellt, die durch <paramref name="function" /> zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="function" />-Parameter war <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Die Aufgabe wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <paramref name="cancellationToken" /> zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde verworfen.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Ausnahmebehandlung (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Ergebnistyp der Aufgabe.</typeparam>
        <param name="function">Die asynchron auszuführende Arbeit.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das verwendet werden soll, um die Arbeit abzubrechen.</param>
        <summary>Fügt die angegebene Verarbeitung zur Ausführung im Threadpool der Warteschlange hinzu und gibt ein <see langword="Task(TResult)" />-Objekt zurück, das diese Aufgabe darstellt. Ein Abbruchtoken ermöglicht den Abbruch der Arbeit.</summary>
        <returns>Eine <see langword="Task(TResult)" /> die die Arbeit darstellt, die sich in der Warteschlange befindet, um im Threadpool ausgeführt zu werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Abbruch angefordert wird, bevor der Task die Ausführung beginnt, wird die Aufgabe nicht ausgeführt. Stattdessen wird er auf festgelegt die <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand und löst eine <xref:System.Threading.Tasks.TaskCanceledException> Ausnahme.  
  
 Die <xref:System.Threading.Tasks.Task.Run%2A> Methode ist eine einfachere Alternative zu den <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Methode. Es erstellt eine Aufgabe mit den folgenden Standardwerten:  
  
-   Die <xref:System.Threading.Tasks.Task.CreationOptions%2A> Eigenschaftswert ist <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Den standardmäßige Taskplaner verwendet.  
  
 Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt 20 Aufgaben, die Schleife durchlaufen werden, bis auf einen Wert von 2 Millionen erhöht wird. Wenn die ersten 10 Aufgaben 2 Millionen erreichen, wird das Abbruchtoken abgebrochen wird, und alle Aufgaben, deren Leistungsindikatoren 2 Millionen nicht erreicht haben, werden abgebrochen. Das Beispiel zeigt mögliche Ausgabe.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 Anstatt die <xref:System.AggregateException.InnerExceptions%2A> Eigenschaft untersuchen Sie Ausnahmen, im Beispiel durchläuft alle Aufgaben aus, um zu bestimmen, die erfolgreich abgeschlossen wurden und die abgebrochen wurden. Für diejenigen, die abgeschlossen wurden, wird die von der Aufgabe zurückgegebenen Werts angezeigt.  
  
 Da der Aufgabenabbruch kooperativ ist, können jede Aufgabe wie Sie auf den Abbruch zu reagieren. Im folgende Beispiel ist wie der erste, außer dass, nachdem das Token abgebrochen wird, Aufgaben die Anzahl der Iterationen zurück, die Sie ausgeführt haben und nicht als eine Ausnahme auslösen.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 Das Beispiel weiterhin verarbeiten muss die <xref:System.AggregateException> Ausnahme, da alle Aufgaben, die nicht gestartet wurden, wenn der Abbruch angefordert wird, immer noch eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="function" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Die Aufgabe wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <paramref name="cancellationToken" /> zugeordnete <see cref="T:System.Threading.CancellationTokenSource" /> wurde verworfen.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Ausnahmebehandlung (Task Parallel Library)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt den <see cref="T:System.Threading.Tasks.Task" /> synchron mit dem aktuellen <see cref="T:System.Threading.Tasks.TaskScheduler" /> aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : unit -&gt; unit" Usage="task.RunSynchronously " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt den <see cref="T:System.Threading.Tasks.Task" /> synchron mit dem aktuellen <see cref="T:System.Threading.Tasks.TaskScheduler" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise werden die Aufgaben asynchron auf einem Threadpoolthread ausgeführt werden und der aufrufenden Thread nicht blockieren. Aufgaben, die durch einen Aufruf von der <xref:System.Threading.Tasks.Task.RunSynchronously> Methode sind verknüpft, mit dem aktuellen <xref:System.Threading.Tasks.TaskScheduler> und für den aufrufenden Thread ausgeführt werden. Wenn der Zielplaner das Ausführen dieser Aufgabe im aufrufenden Thread nicht unterstützt, die Aufgabe zur Ausführung auf den Planer geplant werden, und der aufrufende Thread blockiert, bis der Task die Ausführung abgeschlossen ist. Auch wenn der Vorgang synchron ausgeführt wird, sollten immer noch der aufrufende Thread Aufrufen <xref:System.Threading.Tasks.Task.Wait%2A> , alle Ausnahmen zu behandeln, die die Aufgabe möglicherweise auslösen.  Weitere Informationen zur Ausnahmebehandlung finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 Aufgaben, die durch einen Aufruf von der <xref:System.Threading.Tasks.Task.RunSynchronously%2A> Methode werden instanziiert, durch den Aufruf einer <xref:System.Threading.Tasks.Task> oder <xref:System.Threading.Tasks.Task%601> Klassenkonstruktor. Die Task synchron ausgeführt werden muss, der <xref:System.Threading.Tasks.TaskStatus.Created> Zustand. Eine Aufgabe kann gestartet und werden nur einmal ausgeführt werden. Alle Versuche, einer Aufgabe ein zweites Mal führt zu einer Ausnahme zu planen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Aufgabe, die durch einen Aufruf von der <xref:System.Threading.Tasks.Task.RunSynchronously%2A> Methode mit einem der asynchron ausgeführt. Führen Sie identische Lambda-Ausdrücke, die die Task-ID und die ID des Threads anzeigen in beiden Fällen die Aufgaben auf dem der Task ausgeführt wird. Der Task berechnet die Summe der ganzen Zahlen zwischen 1 und 1.000.000. Wie die Ausgabe des Beispiels zeigt, wird die Aufgabe ausgeführt, durch den Aufruf der <xref:System.Threading.Tasks.Task.RunSynchronously%2A> Methode auf dem Thread der Anwendung ausgeführt wird, während die asynchrone Aufgabe nicht der Fall ist.  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.Tasks.Task" />-Instanz wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Threading.Tasks.Task" /> liegt nicht in einem gültigen Zustand vor, um gestartet werden zu können. Möglicherweise wurde sie bereits gestartet, ausgeführt oder abgebrochen, oder sie wurde möglicherweise auf eine Weise erstellt, die keine direkte Planung unterstützt.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Ausnahmebehandlung (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.RunSynchronously scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Der Taskplaner, mit dem diese Aufgabe inline ausgeführt werden soll.</param>
        <summary>Führt die <see cref="T:System.Threading.Tasks.Task" /> synchron mit dem bereitgestellten <see cref="T:System.Threading.Tasks.TaskScheduler" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufgaben, die durch einen Aufruf von der <xref:System.Threading.Tasks.Task.RunSynchronously%2A> Methode werden instanziiert, durch den Aufruf einer <xref:System.Threading.Tasks.Task> oder <xref:System.Threading.Tasks.Task%601> Klassenkonstruktor. Die Task synchron ausgeführt werden muss, der <xref:System.Threading.Tasks.TaskStatus.Created> Zustand. Eine Aufgabe kann gestartet und werden nur einmal ausgeführt werden. Alle Versuche, einer Aufgabe ein zweites Mal führt zu einer Ausnahme zu planen.  
  
 Wenn der Zielplaner Ausführen dieser Aufgabe für den aktuellen Thread nicht unterstützt wird, der Task zur Ausführung auf den Planer geplant werden und der aktuelle Thread blockiert, bis der Task die Ausführung abgeschlossen ist. Aus diesem Grund der aufrufende Thread muss nicht auf eine Methode aufrufen, z. B. <xref:System.Threading.Tasks.Task.Wait%2A> um sicherzustellen, dass der Task die Ausführung abgeschlossen ist. Weitere Informationen zur Ausnahmebehandlung für Vorgänge, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.Tasks.Task" />-Instanz wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Threading.Tasks.Task" /> liegt nicht in einem gültigen Zustand vor, um gestartet werden zu können. Möglicherweise wurde sie bereits gestartet, ausgeführt oder abgebrochen, oder sie wurde möglicherweise auf eine Weise erstellt, die keine direkte Planung unterstützt.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Ausnahmebehandlung (Task Parallel Library)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet den <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="task.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet die <see cref="T:System.Threading.Tasks.Task" /> und plant ihre Ausführung mit dem aktuellen <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Aufgabe kann gestartet und werden nur einmal ausgeführt werden. Jeder Versuch, eine Aufgabe planen Sie ein zweites Mal führt zu einer Ausnahme.  
  
 Die <xref:System.Threading.Tasks.Task.Start%2A> wird verwendet, um eine Aufgabe auszuführen, die durch einen Aufruf der erstellt wurde die <xref:System.Threading.Tasks.Task> Konstruktoren. In der Regel führen Sie dies, wenn Sie trennen die taskerstellung, aus der Ausführung, z. B. Wenn Sie bedingte Aufgaben ausführen, die Sie erstellt haben müssen. Für den meisten Fällen, in dem Sie keine Aufgabe Instanziierung von der Ausführung trennen müssen, empfehlen wir, dass Sie eine Überladung von Aufrufen der <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> oder <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode.  
  
 Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> Konstruktor zum Instanziieren einer neuen <xref:System.Threading.Tasks.Task> Objekt, das die Task-ID und der verwaltete Thread-ID angezeigt und führt dann eine Schleife. Es ruft dann die <xref:System.Threading.Tasks.Task.Start%2A> Methode, um die Aufgabe auszuführen.  Da dies eine Konsolen-app, den Aufruf von ist das <xref:System.Threading.Tasks.Task.Wait%2A> Methode ist erforderlich, um zu verhindern, dass die app wird beendet, bevor der Task die Ausführung beendet.  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.Tasks.Task" />-Instanz wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Threading.Tasks.Task" /> liegt nicht in einem gültigen Zustand vor, um gestartet werden zu können. Möglicherweise wurde sie bereits gestartet, ausgeführt oder abgebrochen, oder sie wurde möglicherweise auf eine Weise erstellt, die keine direkte Planung unterstützt.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Ausnahmebehandlung (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.Start : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.Start scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Der <see cref="T:System.Threading.Tasks.TaskScheduler" />, dem diese Aufgabe zugeordnet und mit dem sie ausgeführt werden soll.</param>
        <summary>Startet die <see cref="T:System.Threading.Tasks.Task" /> und plant ihre Ausführung mit dem angegebenen <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Aufgabe kann nur gestartet und nur einmal ausgeführt werden. Jeder Versuch, eine Aufgabe planen Sie ein zweites Mal führt zu einer Ausnahme.  
  
 Informationen zur Behandlung von Ausnahmen, die durch Vorgänge ausgelöst werden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Threading.Tasks.Task" /> liegt nicht in einem gültigen Zustand vor, um gestartet werden zu können. Möglicherweise wurde sie bereits gestartet, ausgeführt oder abgebrochen, oder sie wurde möglicherweise auf eine Weise erstellt, die keine direkte Planung unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.Tasks.Task" />-Instanz wurde verworfen.</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">Der Planer konnte diesen Task nicht in die Warteschlange einreihen.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Ausnahmebehandlung (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberSignature Language="F#" Value="member this.Status : System.Threading.Tasks.TaskStatus" Usage="System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Threading.Tasks.TaskStatus" /> dieser Aufgabe ab.</summary>
        <value>Der aktuelle <see cref="T:System.Threading.Tasks.TaskStatus" /> dieser Aufgabeninstanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abrufen des Werts der <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> Eigenschaft wird den aufrufenden Thread nicht blockiert, bis die Aufgabe abgeschlossen wurde.  
  
 Weitere Informationen und ein Beispiel finden Sie unter [Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) und [Vorgehensweise: Abbrechen einer Aufgabe und ihren untergeordneten Elementen](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt 20 Aufgaben, die Schleife durchlaufen werden, bis auf einen Wert von 2 Millionen erhöht wird. Wenn die ersten 10 Aufgaben 2 Millionen erreichen, wird das Abbruchtoken abgebrochen wird, und alle Aufgaben, deren Leistungsindikatoren 2 Millionen nicht erreicht haben, werden abgebrochen. Im Beispiel wird dann untersucht die <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft der einzelnen Aufgaben an, ob er erfolgreich abgeschlossen oder abgebrochen wurde. Für diejenigen, die abgeschlossen, wird die von der Aufgabe zurückgegebenen Werts angezeigt.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System::IAsyncResult::AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Threading.WaitHandle" /> ab, das verwendet werden kann, um auf den Abschluss der Aufgabe zu warten.</summary>
        <value>Ein <see cref="T:System.Threading.WaitHandle" />, das verwendet werden kann, um auf den Abschluss der Aufgabe zu warten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Wait-Funktion verwenden, <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> empfiehlt sich, mithilfe von <xref:System.IAsyncResult.AsyncWaitHandle%2A> für ähnliche Funktionen. Weitere Informationen finden Sie im Abschnitt "Warten auf Aufgaben" in [aufgabenbasierte asynchrone Programmierung](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) und [mithilfe von TPL mit anderen asynchronen Mustern](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::IAsyncResult::CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Vorgang synchron abgeschlossen wurde.</summary>
        <value><see langword="true" />, wenn der Vorgang synchron abgeschlossen wurde, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wartet, bis der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung abschließt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="task.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wartet, bis der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung abschließt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A> ist eine Synchronisierungsmethode, die bewirkt, dass den aufrufenden Thread wartet, bis der aktuelle Task abgeschlossen ist. Wenn die Ausführung nicht von die aktuelle Aufgabe gestartet wurde, versucht die Wait-Methode entfernen Sie die Aufgabe vom Planer, und führen Sie es Inline für den aktuellen Thread. Wenn dies möglich ist, oder wenn die Ausführung in die aktuelle Aufgabe bereits gestartet wurde, er den aufrufenden Thread, blockiert bis die Aufgabe abgeschlossen ist. Weitere Informationen finden Sie unter ["Task.Wait" und "Inlining"](https://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx) im zur parallelen Programmierung mit .NET Blog.   
  
## Examples  
 Das folgende Beispiel startet eine Aufgabe, die eine Million zufällige ganze Zahlen zwischen 0 und 100 generiert und ihrem Mittelwert berechnet. Im Beispiel wird die <xref:System.Threading.Tasks.Task.Wait%2A> Methode, um sicherzustellen, dass die Aufgabe abgeschlossen ist, bevor die Anwendung beendet wird. Da es sich um eine Konsolenanwendung handelt, würde andernfalls im Beispiel beendet, bevor die Aufgabe zu berechnen und den Mittelwert anzeigen kann.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.AggregateException">Der Task wurde abgebrochen. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.  
  
- oder -  
Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</exception>
        <related type="ExternalDocumentation" href="https://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx">"Task.Wait" und "Inlining"</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="task.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <summary>Wartet darauf, dass die <see cref="T:System.Threading.Tasks.Task" /> innerhalb einer angegebenen Anzahl an Millisekunden vollständig ausgeführt wird.</summary>
        <returns><see langword="true" />, wenn der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> ist eine Synchronisierungsmethode, die bewirkt, den aufrufenden Thread wartet für die aktuelle Aufgabeninstanz dass abgeschlossen wird, bis eines der folgenden Ereignisse eintritt:  
  
-   Der Task erfolgreich abgeschlossen.  
  
-   Die eigentliche Aufgabe abgebrochen wird, oder löst eine Ausnahme aus. In diesem Fall behandeln Sie ein <xref:System.AggregateException> Ausnahme. Die <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Eigenschaft enthält die Details der Ausnahme oder Ausnahmen.  
  
-   Das Intervall von definierten `millisecondsTimeout` abgelaufen ist. In diesem Fall wird der aktuelle Thread die Ausführung fortgesetzt und die Methode gibt `false`.  
  
   
  
## Examples  
 Das folgende Beispiel startet eine Aufgabe, die fünf Millionen zufällige ganzer Zahlen zwischen 0 und 100 generiert und ihrem Mittelwert berechnet. Im Beispiel wird die <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> -Methode warten, für die Anwendung innerhalb von 150 Millisekunden abgeschlossen. Wenn die Anwendung normal abgeschlossen wird, zeigt die Aufgabe, die Summe und Mittelwert der zufälligen Zahlen, die sie generiert hat. Wenn das Timeoutintervall abgelaufen ist, zeigt das Beispiel eine Meldung an, bevor er beendet wird.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.AggregateException">Der Task wurde abgebrochen. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.  
  
- oder -  
Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="task.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Ein Abbruchtoken, das beim Warten auf den Abschluss der Aufgabe überwacht werden soll.</param>
        <summary>Wartet, bis der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung abschließt. Der Wartevorgang wird beendet, wenn ein Abbruchtoken abgebrochen wird, bevor die Aufgabe abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> -Methode erstellt einen Wartevorgang abgebrochen werden; d. h. er bewirkt, dass den aktuellen Thread wartet, bis eine der folgenden Bedingungen zutrifft:  
  
-   Die Aufgabe abgeschlossen ist.  
  
-   Das Abbruchtoken abgebrochen wird. In diesem Fall ist der Aufruf der <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> -Methode löst eine <xref:System.OperationCanceledException>.  
  
> [!NOTE]
>  Abbrechen der `cancellationToken` Abbruchtoken hat keine Auswirkungen auf die ausgeführte Aufgabe aus, es sei denn, es auch das Abbruchtoken übergeben wurde und einen Abbruch behandeln vorbereitet ist. Übergeben der `cancellationToken` Objekt an diese Methode kann einfach den Wartevorgang abgebrochen werden soll.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die einfache Verwendung von ein Abbruchtoken, das zum Warten auf den Abschluss einer Aufgabe abbrechen. Eine Aufgabe gestartet wird, ruft der <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> Methode, um der Tokenquelle Abbruchtoken und Verzögerungen bei der fünf Sekunden abgebrochen. Beachten Sie, dass die eigentliche Aufgabe nicht das Abbruchtoken übergeben wurde und kann nicht abgebrochen werden. Thread der Anwendung Aufrufen des Vorgangs <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> -Methode warten, bis die Aufgabe abgeschlossen, aber der Wartevorgang abgebrochen wird, sobald das Abbruchtoken abgebrochen wird, und ein <xref:System.OperationCanceledException> ausgelöst. Der Ausnahmehandler über die Ausnahme, und klicken Sie dann auf sechs Sekunden wartet. Wie die Ausgabe des Beispiels zeigt, können Sie diese Verzögerung im Abschluss die Aufgabe die <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Das <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Aufgabe wurde verworfen.</exception>
        <exception cref="T:System.AggregateException">Der Task wurde abgebrochen. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.  
  
- oder -  
Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="task.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
        <summary>Wartet darauf, dass die <see cref="T:System.Threading.Tasks.Task" /> innerhalb eines angegebenen Zeitintervalls vollständig ausgeführt wird.</summary>
        <returns><see langword="true" />, wenn der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> ist eine Synchronisierungsmethode, die bewirkt, den aufrufenden Thread wartet für die aktuelle Aufgabeninstanz dass abgeschlossen wird, bis eines der folgenden Ereignisse eintritt:  
  
-   Der Task erfolgreich abgeschlossen.  
  
-   Die eigentliche Aufgabe abgebrochen wird, oder löst eine Ausnahme aus. In diesem Fall behandeln Sie ein <xref:System.AggregateException> Ausnahme. Die <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Eigenschaft enthält die Details der Ausnahme oder Ausnahmen.  
  
-   Das Intervall von definierten `timeout` abgelaufen ist. In diesem Fall wird der aktuelle Thread die Ausführung fortgesetzt und die Methode gibt `false`.  
  
   
  
## Examples  
 Das folgende Beispiel startet eine Aufgabe, die fünf Millionen zufällige ganzer Zahlen zwischen 0 und 100 generiert und ihrem Mittelwert berechnet. Im Beispiel wird die <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> -Methode warten, für die Anwendung innerhalb von 150 Millisekunden abgeschlossen. Wenn die Anwendung normal abgeschlossen wird, zeigt die Aufgabe, die Summe und Mittelwert der zufälligen Zahlen, die sie generiert hat. Wenn das Timeoutintervall abgelaufen ist, zeigt das Beispiel eine Meldung an, bevor er beendet wird.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt. 
- oder -  
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">Der Task wurde abgebrochen. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.  
  
- oder -  
Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="task.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das beim Warten auf den Abschluss der Aufgabe überwacht werden soll.</param>
        <summary>Wartet, bis der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung abschließt. Der Wartevorgang wird beendet, wenn ein Timeoutintervall abläuft oder ein Abbruchtoken abgebrochen wird, bevor die Aufgabe abgeschlossen ist.</summary>
        <returns><see langword="true" />, wenn der <see cref="T:System.Threading.Tasks.Task" /> die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> ist eine Synchronisierungsmethode, die bewirkt, den aufrufenden Thread wartet für die aktuelle Aufgabeninstanz dass abgeschlossen wird, bis eines der folgenden Ereignisse eintritt:  
  
-   Der Task erfolgreich abgeschlossen.  
  
-   Die eigentliche Aufgabe abgebrochen wird, oder löst eine Ausnahme aus. In diesem Fall behandeln Sie ein <xref:System.AggregateException> Ausnahme. Die <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Eigenschaft enthält die Details der Ausnahme oder Ausnahmen.  
  
-   Die `cancellationToken` Abbruchtoken wird abgebrochen. In diesem Fall ist der Aufruf der <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> -Methode löst eine <xref:System.OperationCanceledException>.  
  
-   Das Intervall von definierten `millisecondsTimeout` abgelaufen ist. In diesem Fall wird der aktuelle Thread die Ausführung fortgesetzt und die Methode gibt `false`.  
  
> [!NOTE]
>  Abbrechen der `cancellationToken` Abbruchtoken hat keine Auswirkungen auf die ausgeführte Aufgabe aus, es sei denn, es auch das Abbruchtoken übergeben wurde und einen Abbruch behandeln vorbereitet ist. Übergeben der `cancellationToken` Objekt, das diese Methode einfach die Möglichkeit des Wartevorgang abgebrochen werden basierend auf einer Bedingung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> Methode zum Bereitstellen der sowohl einen Timeoutwert als auch ein Abbruch-token kann das Warten auf den Abschluss einer Aufgabe zu beenden. Ein neuer Thread gestartet und führt die `CancelToken` -Methode, die angehalten wird, und ruft dann die <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> Methode der Abbruchtoken abgebrochen. Ein Task wird dann gestartet und 5 Sekunden lang verzögert. Die <xref:System.Threading.Tasks.Task.Wait%2A> -Methode wird aufgerufen, um die Task Abschluss gewartet werden soll, und sowohl einen kurzen Timeoutwert und einem Abbruchtoken bereitgestellt wird.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 Beachten Sie, dass die genaue Ausgabe aus dem Beispiel abhängt, ob die Wartezeit aufgrund der Abbruchtoken abgebrochen wurde oder weil das Timeoutintervall abgelaufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Das <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.AggregateException">Der Task wurde abgebrochen. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.  
  
- oder -  
Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wartet, bis alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <summary>Wartet, bis alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel startet 10 Aufgaben, von die jede einen Index als ein Zustandsobjekt übergeben wird. Aufgaben mit einem Index zwei bis fünf lösen Ausnahmen aus. Der Aufruf der <xref:System.Threading.Tasks.Task.WaitAll%2A> Methode dient als Wrapper für alle Ausnahmen in eine <xref:System.AggregateException> Objekt aus, und immer wieder an den aufrufenden Thread.  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.  
  
- oder -  
Das <paramref name="tasks" />-Argument ist ein leeres Array.</exception>
        <exception cref="T:System.AggregateException">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen. Wenn ein Task abgebrochen wurde, enthält die <see cref="T:System.AggregateException" />-Ausnahme eine <see cref="T:System.OperationCanceledException" />-Ausnahme in ihrer <see cref="P:System.AggregateException.InnerExceptions" />-Auflistung.  
  
- oder -  
Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <summary>Wartet darauf, dass alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte innerhalb einer angegebenen Anzahl an Millisekunden vollständig ausgeführt werden.</summary>
        <returns><see langword="true" /> wenn alle <see cref="T:System.Threading.Tasks.Task" />-Instanzen die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen haben, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen. Wenn ein Task abgebrochen wurde, enthält die <see cref="T:System.AggregateException" /> eine <see cref="T:System.OperationCanceledException" /> in ihrer <see cref="P:System.AggregateException.InnerExceptions" />-Auflistung.  
  
- oder -  
Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.  
  
- oder -  
Das <paramref name="tasks" />-Argument ist ein leeres Array.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="cancellationToken">Ein <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das beim Warten auf den Abschluss der Aufgaben überwacht werden soll.</param>
        <summary>Wartet, bis alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließen oder bis der Wartevorgang abgebrochen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `cancellationToken` Argument wird verwendet, um den Wartevorgang abgebrochen. Abbruch der Aufgaben einen distinct-Vorgang ist, und signalisiert wird, durch die <xref:System.AggregateException> wie oben bereits erwähnt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Das <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen. Wenn ein Task abgebrochen wurde, enthält die <see cref="T:System.AggregateException" /> eine <see cref="T:System.OperationCanceledException" /> in ihrer <see cref="P:System.AggregateException.InnerExceptions" />-Auflistung.  
  
- oder -  
Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.  
  
- oder -  
Das <paramref name="tasks" />-Argument ist ein leeres Array.</exception>
        <exception cref="T:System.ObjectDisposedException">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * TimeSpan -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
        <summary>Wartet darauf, dass alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte, die abgebrochen werden können, innerhalb eines angegebenen Zeitintervalls vollständig ausgeführt werden.</summary>
        <returns><see langword="true" /> wenn alle <see cref="T:System.Threading.Tasks.Task" />-Instanzen die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen haben, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen. Wenn ein Task abgebrochen wurde, enthält die <see cref="T:System.AggregateException" /> eine <see cref="T:System.OperationCanceledException" /> in ihrer <see cref="P:System.AggregateException.InnerExceptions" />-Auflistung.  
  
- oder -  
Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ist eine negative Zahl ungleich „-1 Millisekunden“, die ein unendliches Timeout darstellt. 
- oder -  
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.  
  
- oder -  
Das <paramref name="tasks" />-Argument ist ein leeres Array.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <param name="cancellationToken">Ein <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das beim Warten auf den Abschluss der Aufgaben überwacht werden soll.</param>
        <summary>Wartet darauf, dass alle bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte innerhalb einer angegebenen Anzahl an Millisekunden oder vollständig ausgeführt werden, oder bis zum Abbruch des Wartevorgangs.</summary>
        <returns><see langword="true" /> wenn alle <see cref="T:System.Threading.Tasks.Task" />-Instanzen die Ausführung innerhalb der zugewiesenen Zeit abgeschlossen haben, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `cancellationToken` Argument wird verwendet, um den Wartevorgang abgebrochen. Abbruch der Aufgaben einen distinct-Vorgang ist, und signalisiert wird, durch die <xref:System.AggregateException> wie oben beschrieben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eines der <see cref="T:System.Threading.Tasks.Task" />-Objekte in <paramref name="tasks" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Mindestens eine der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde abgebrochen. Wenn ein Task abgebrochen wurde, enthält die <see cref="T:System.AggregateException" /> eine <see cref="T:System.OperationCanceledException" /> in ihrer <see cref="P:System.AggregateException.InnerExceptions" />-Auflistung.  
  
- oder -  
Während der Ausführung mindestens einer der <see cref="T:System.Threading.Tasks.Task" />-Instanzen wurde eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.  
  
- oder -  
Das <paramref name="tasks" />-Argument ist ein leeres Array.</exception>
        <exception cref="T:System.OperationCanceledException">Das <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wartet, bis eines der bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <summary>Wartet, bis eines der bereitgestellten <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließt.</summary>
        <returns>Der Index des abgeschlossenen <see cref="T:System.Threading.Tasks.Task" />-Objekts im <paramref name="tasks" />-Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird gestartet, fünf Tasks, von denen jeder mindestens 50 Millisekunden oder bis zu 1.050 Millisekunden im Ruhezustand ist. Die <xref:System.Threading.Tasks.Task.WaitAny%2A> Methode wartet dann eine der Aufgaben ausführen. Das Beispiel zeigt die Task-ID der Aufgabe, die den Wartevorgang beendet wurde, sowie den aktuellen Status aller Aufgaben.  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <summary>Wartet darauf, dass bereitgestellte <see cref="T:System.Threading.Tasks.Task" />-Objekte innerhalb einer angegebenen Anzahl an Millisekunden vollständig ausgeführt werden.</summary>
        <returns>Der Index der abgeschlossenen Aufgabe im <paramref name="tasks" />-Arrayargument oder -1, wenn das Timeout aufgetreten ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="cancellationToken">Ein <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das beim Warten auf den Abschluss einer Aufgabe überwacht werden soll.</param>
        <summary>Wartet, bis bereitgestellte <see cref="T:System.Threading.Tasks.Task" />-Objekte die Ausführung abschließen oder bis der Wartevorgang abgebrochen wird.</summary>
        <returns>Der Index der ausgeführten Aufgabe im <paramref name="tasks" />-Arrayargument.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</exception>
        <exception cref="T:System.OperationCanceledException">Das <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * TimeSpan -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
        <summary>Wartet darauf, dass bereitgestellte <see cref="T:System.Threading.Tasks.Task" />-Objekte, die abgebrochen werden können, innerhalb eines angegebenen Zeitintervalls vollständig ausgeführt werden.</summary>
        <returns>Der Index der abgeschlossenen Aufgabe im <paramref name="tasks" />-Arrayargument oder -1, wenn das Timeout aufgetreten ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ist eine negative Zahl ungleich „-1 Millisekunden“, die ein unendliches Timeout darstellt. 
- oder -  
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Ein Array von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, auf die gewartet werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <param name="cancellationToken">Ein <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das beim Warten auf den Abschluss einer Aufgabe überwacht werden soll.</param>
        <summary>Wartet darauf, dass bereitgestellte <see cref="T:System.Threading.Tasks.Task" />-Objekte innerhalb einer angegebenen Anzahl an Millisekunden oder vollständig ausgeführt werden, oder bis ein Abbruchtoken abgebrochen wird.</summary>
        <returns>Der Index der abgeschlossenen Aufgabe im <paramref name="tasks" />-Arrayargument oder -1, wenn das Timeout aufgetreten ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Argument enthält ein NULL-Element.</exception>
        <exception cref="T:System.OperationCanceledException">Das <paramref name="cancellationToken" /> wurde abgebrochen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn alle angegebenen Aufgaben abgeschlossen sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn alle <see cref="T:System.Threading.Tasks.Task" />-Objekte in einer aufzählbaren Auflistung abgeschlossen sind.</summary>
        <returns>Eine Aufgabe, die den Abschluss aller angegebenen Aufgaben darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladungen der der <xref:System.Threading.Tasks.Task.WhenAll%2A> Methode, die Zurückgeben einer <xref:System.Threading.Tasks.Task> Objekt werden in der Regel aufgerufen, wenn Sie möchten, in den Status einer Reihe von Aufgaben oder in der durch eine Reihe von Aufgaben ausgelösten Ausnahmen sind.  
  
> [!NOTE]
>  Der Aufruf von <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> Methode wird den aufrufenden Thread nicht blockiert.  
  
 Wenn die angegebenen Aufgaben abgeschlossen ist, in einem fehlerhaften Zustand, wird die zurückgegebene Aufgabe auch abgeschlossen ein <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, die Ausnahmen, in dem die Aggregation des Satzes von entwrappte Ausnahmen aller angegebenen Aufgaben enthält.  
  
 Wenn keiner der angegebenen Aufgaben einen Fehler verursacht, aber mindestens eine von ihnen abgebrochen wurde, endet die zurückgegebene Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand.  
  
 Wenn keiner der Vorgänge einen Fehler verursacht, und keinen der Tasks abgebrochen wurden, endet die resultierende Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand.  
  
 Wenn das angegebene Array/aufzählbare Element keine Aufgaben enthält, die zurückgegebene Aufgabe geht sofort in eine <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Status, bevor es an den Aufrufer zurückgegeben wird.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Reihe von Aufgaben, die die URLs in einem Array zu pingen. Die Aufgaben werden gespeichert, einem `List<Task>` -Auflistung, die an die <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> Methode. Nach dem Aufruf der <xref:System.Threading.Tasks.Task.Wait%2A> Methode stellt sicher, dass alle Threads abgeschlossen haben, im Beispiel wird untersucht die <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> Eigenschaft, um zu bestimmen, ob alle Tasks einen Fehler verursacht haben.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautete <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" />-Auflistung enthielt eine <see langword="null" />-Aufgabe.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn alle <see cref="T:System.Threading.Tasks.Task" />-Objekte in einem Array abgeschlossen sind.</summary>
        <returns>Eine Aufgabe, die den Abschluss aller angegebenen Aufgaben darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladungen der der <xref:System.Threading.Tasks.Task.WhenAll%2A> Methode, die Zurückgeben einer <xref:System.Threading.Tasks.Task> Objekt werden in der Regel aufgerufen, wenn Sie möchten, in den Status einer Reihe von Aufgaben oder in der durch eine Reihe von Aufgaben ausgelösten Ausnahmen sind.  
  
> [!NOTE]
>  Der Aufruf von <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> Methode wird den aufrufenden Thread nicht blockiert.  
  
 Wenn die angegebenen Aufgaben abgeschlossen ist, in einem fehlerhaften Zustand, wird die zurückgegebene Aufgabe auch abgeschlossen ein <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, die Ausnahmen, in dem die Aggregation des Satzes von entwrappte Ausnahmen aller angegebenen Aufgaben enthält.  
  
 Wenn keiner der angegebenen Aufgaben einen Fehler verursacht, aber mindestens eine von ihnen abgebrochen wurde, endet die zurückgegebene Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand.  
  
 Wenn keiner der Vorgänge einen Fehler verursacht, und keinen der Tasks abgebrochen wurden, endet die resultierende Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand.  
  
 Wenn das angegebene Array/aufzählbare Element keine Aufgaben enthält, die zurückgegebene Aufgabe geht sofort in eine <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Status, bevor es an den Aufrufer zurückgegeben wird.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Reihe von Aufgaben, die die URLs in einem Array zu pingen. Die Aufgaben werden gespeichert, einem `List<Task>` -Auflistung, die in ein Bytearray konvertierten und übergeben die <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> Methode. Nach dem Aufruf der <xref:System.Threading.Tasks.Task.Wait%2A> Methode stellt sicher, dass alle Threads abgeschlossen haben, im Beispiel wird untersucht die <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> Eigenschaft, um zu bestimmen, ob alle Tasks einen Fehler verursacht haben.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautete <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthielt eine <see langword="null" />-Aufgabe.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der abgeschlossenen Aufgabe.</typeparam>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn alle <see cref="T:System.Threading.Tasks.Task`1" />-Objekte in einer aufzählbaren Auflistung abgeschlossen sind.</summary>
        <returns>Eine Aufgabe, die den Abschluss aller angegebenen Aufgaben darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Aufruf von <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> Methode wird den aufrufenden Thread nicht blockiert. Allerdings einen Aufruf zurückgegebenen <xref:System.Threading.Tasks.Task%601.Result%2A> Eigenschaft wird den aufrufenden Thread blockiert.  
  
 Wenn die angegebenen Aufgaben abgeschlossen ist, in einem fehlerhaften Zustand, wird die zurückgegebene Aufgabe auch abgeschlossen ein <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, die Ausnahmen, in dem die Aggregation des Satzes von entwrappte Ausnahmen aller angegebenen Aufgaben enthält.  
  
 Wenn keiner der angegebenen Aufgaben einen Fehler verursacht, aber mindestens eine von ihnen abgebrochen wurde, endet die zurückgegebene Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand.  
  
 Wenn keiner der Vorgänge einen Fehler verursacht, und keinen der Tasks abgebrochen wurden, endet die resultierende Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand.  Die <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Eigenschaft der zurückgegebenen Aufgabe wird festgelegt werden, auf ein Array mit alle Ergebnisse der angegebenen Aufgaben in der gleichen Reihenfolge, da sie bereitgestellt wurden (z. B. wenn die Eingabe enthaltene Array t1, t2, t3, die Ausgabe des Tasks Aufgaben <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Eigenschaft zurück ein `TResult[]` , in denen `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Wenn die `tasks` Argument enthält keine Vorgänge, die zurückgegebene Aufgabe geht sofort in eine <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Status, bevor es an den Aufrufer zurückgegeben wird. Das zurückgegebene `TResult[]` werden ein Array mit 0 Elementen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt, zehn Aufgaben, von die jede einen Zufallszahlengenerator instanziiert, der 1.000 zufällige Zahlen zwischen 1 und 1.000 erstellt und ihrem Mittelwert berechnet wird. Die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> Methode wird verwendet, um die Instanziierung von random Number-Generatoren zu verzögern, damit sie nicht mit dem identischen Startwerten erstellt werden. Der Aufruf der <xref:System.Threading.Tasks.Task.WhenAll%2A> Methodenrückgabe klicken Sie dann eine <xref:System.Int64> Array mit den Mittelwert berechnet wird, durch die einzelnen Tasks. Diese werden dann verwendet, dem gesamtmittelwert zu berechnen.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 In diesem Fall werden die einzelnen zehn Tasks gespeichert, einem <xref:System.Collections.Generic.List%601> Objekt. <xref:System.Collections.Generic.List%601> implementiert die <xref:System.Collections.Generic.IEnumerable%601>-Schnittstelle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautete <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="tasks" />-Auflistung enthielt eine <see langword="null" />-Aufgabe.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der abgeschlossenen Aufgabe.</typeparam>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn alle <see cref="T:System.Threading.Tasks.Task`1" />-Objekte in einem Array abgeschlossen sind.</summary>
        <returns>Eine Aufgabe, die den Abschluss aller angegebenen Aufgaben darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Aufruf von <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> Methode wird den aufrufenden Thread nicht blockiert. Allerdings einen Aufruf zurückgegebenen <xref:System.Threading.Tasks.Task%601.Result%2A> Eigenschaft wird den aufrufenden Thread blockiert.  
  
 Wenn die angegebenen Aufgaben abgeschlossen ist, in einem fehlerhaften Zustand, wird die zurückgegebene Aufgabe auch abgeschlossen ein <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, die Ausnahmen, in dem die Aggregation des Satzes von entwrappte Ausnahmen aller angegebenen Aufgaben enthält.  
  
 Wenn keiner der angegebenen Aufgaben einen Fehler verursacht, aber mindestens eine von ihnen abgebrochen wurde, endet die zurückgegebene Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand.  
  
 Wenn keiner der Vorgänge einen Fehler verursacht, und keinen der Tasks abgebrochen wurden, endet die resultierende Aufgabe in der <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Zustand.  Die <xref:System.Threading.Tasks.Task%601.Result%2A> der zurückgegebenen Aufgabe wird festgelegt auf ein Array mit alle Ergebnisse der angegebenen Aufgaben in der gleichen Reihenfolge, da sie bereitgestellt wurden (z. B. wenn die Eingabe enthaltene Array t1, t2, t3, die Ausgabe des Tasks Aufgaben <xref:System.Threading.Tasks.Task%601.Result%2A> gibt ein `TResult[]` wo `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Wenn das angegebene Array/aufzählbare Element keine Aufgaben enthält, die zurückgegebene Aufgabe geht sofort in eine <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Status, bevor es an den Aufrufer zurückgegeben wird.  Das zurückgegebene `TResult[]` werden ein Array mit 0 Elementen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt, zehn Aufgaben, von die jede einen Zufallszahlengenerator instanziiert, der 1.000 zufällige Zahlen zwischen 1 und 1.000 erstellt und ihrem Mittelwert berechnet wird. In diesem Fall werden die einzelnen zehn Tasks gespeichert, einem `Task<Int64>` Array.  Die <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> Methode wird verwendet, um die Instanziierung von random Number-Generatoren zu verzögern, damit sie nicht mit dem identischen Startwerten erstellt werden. Der Aufruf der <xref:System.Threading.Tasks.Task.WhenAll%2A> Methodenrückgabe klicken Sie dann eine <xref:System.Int64> Array mit den Mittelwert berechnet wird, durch die einzelnen Tasks. Diese werden dann verwendet, dem gesamtmittelwert zu berechnen.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautete <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthielt eine <see langword="null" />-Aufgabe.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn eine der angegebenen Aufgaben abgeschlossen ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn eine der angegebenen Aufgaben abgeschlossen ist.</summary>
        <returns>Eine Aufgabe, die den Abschluss einer der angegebenen Aufgaben darstellt.  Das zurückgegebene Ergebnis der Aufgabe ist die Aufgabe, die abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene Aufgabe wird beendet, wenn die angegebenen Aufgaben abgeschlossen wurde.  Die zurückgegebene Aufgabe endet immer in der `RanToCompletion` Zustand mit das Resultset auf den ersten Task abgeschlossen.  Dies gilt auch, wenn die erste Aufgabe abgeschlossen beendet wurde die `Canceled` oder `Faulted` Zustand.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautete <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das Array <paramref name="tasks" /> enthielt eine NULL-Aufgabe oder war leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn eine der angegebenen Aufgaben abgeschlossen ist.</summary>
        <returns>Eine Aufgabe, die den Abschluss einer der angegebenen Aufgaben darstellt.  Das zurückgegebene Ergebnis der Aufgabe ist die Aufgabe, die abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene Aufgabe wird beendet, wenn die angegebenen Aufgaben abgeschlossen wurde.  Endet die zurückgegebene Aufgabe immer in der `RanToCompletion` Zustand mit der `Result` auf den ersten Task auf abgeschlossen festgelegt.  Dies gilt auch, wenn die erste Aufgabe abgeschlossen beendet wurde die `Canceled` oder `Faulted` Zustand.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument war null.</exception>
        <exception cref="T:System.ArgumentException">Das Array <paramref name="tasks" /> enthielt eine NULL-Aufgabe oder war leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der abgeschlossenen Aufgabe.</typeparam>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn eine der angegebenen Aufgaben abgeschlossen ist.</summary>
        <returns>Eine Aufgabe, die den Abschluss einer der angegebenen Aufgaben darstellt.  Das zurückgegebene Ergebnis der Aufgabe ist die Aufgabe, die abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene Aufgabe wird beendet, wenn die angegebenen Aufgaben abgeschlossen wurde.  Die zurückgegebene Aufgabe endet immer im Zustand "RanToCompletion" mit das Resultset auf den ersten Task abgeschlossen. Dies gilt auch, wenn die erste Aufgabe zum Abschließen der abgebrochen oder Faulted-Zustand beendet wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument lautete <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das Array <paramref name="tasks" /> enthielt eine NULL-Aufgabe oder war leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der abgeschlossenen Aufgabe.</typeparam>
        <param name="tasks">Die Aufgaben, auf deren Abschluss gewartet werden soll.</param>
        <summary>Erstellt eine Aufgabe, die abgeschlossen wird, wenn eine der angegebenen Aufgaben abgeschlossen ist.</summary>
        <returns>Eine Aufgabe, die den Abschluss einer der angegebenen Aufgaben darstellt.  Das zurückgegebene Ergebnis der Aufgabe ist die Aufgabe, die abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene Aufgabe wird beendet, wenn die angegebenen Aufgaben abgeschlossen wurde.  Die zurückgegebene Aufgabe endet immer im Zustand "RanToCompletion" mit das Resultset auf den ersten Task abgeschlossen. Dies gilt auch, wenn die erste Aufgabe zum Abschließen der abgebrochen oder Faulted-Zustand beendet wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Argument war null.</exception>
        <exception cref="T:System.ArgumentException">Das Array <paramref name="tasks" /> enthielt eine NULL-Aufgabe oder war leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Runtime.CompilerServices.YieldAwaitable" Usage="System.Threading.Tasks.Task.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Awaitable-Aufgabe, die asynchron an den aktuellen Kontext liefert, wenn erwartet.</summary>
        <returns>Ein Kontext, der während des Abwartens asynchron wieder in den aktuellen Kontext zum Zeitpunkt des Abwartens übergeht. Wenn der aktuelle <see cref="T:System.Threading.SynchronizationContext" /> nicht Null ist, wird er als der aktuelle Kontext behandelt. Andernfalls wird der Taskplaner, der der aktuell ausgeführten Aufgabe zugeordnet ist, als der aktuelle Kontext behandelt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können `await Task.Yield();` in einer asynchronen Methode zu erzwingen, dass die Methode, die asynchron abgeschlossen. Es ist ein aktuelle Synchronisierungskontext (<xref:System.Threading.SynchronizationContext> Objekt), wird dadurch den Rest der Ausführung der Methode an diesem Kontext buchen. Allerdings wird der Kontext entscheiden, wie diese Arbeit relativ zu anderen Aufgaben zu priorisieren, die ausstehend sein können. Der Synchronisierungskontext, der auf einem UI-Thread in den meisten Umgebungen der Benutzeroberfläche vorhanden ist wird häufig arbeiten, die in den Kontext höher ist als Eingabe und Rendering Work veröffentlicht priorisieren. Aus diesem Grund verlassen Sie sich nicht auf `await Task.Yield();` auf eine Benutzeroberfläche weiterhin reaktionsfähig bleibt.  Weitere Informationen finden Sie im Eintrag [nützlich, Abstraktionen mit ContinueWith aktiviert](https://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>