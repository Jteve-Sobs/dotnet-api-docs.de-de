<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TaskScheduler.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5ddd94061f594e353cba8674c76ffcb77a643ddb1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ddd94061f594e353cba8674c76ffcb77a643ddb1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Represents an object that handles the low-level work of queuing tasks onto threads.</source>
          <target state="translated">Stellt ein Objekt dar, das die Einreihung von Aufgaben in Threads auf niedriger Ebene behandelt.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> class represents a task scheduler.</source>
          <target state="translated">Eine Instanz von der <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> Klasse stellt einen Aufgabenplaner.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>A task scheduler ensures that the work of a task is eventually executed.</source>
          <target state="translated">Durch einen Aufgabenplaner wird sichergestellt, dass die Arbeit einer Aufgabe schließlich ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</source>
          <target state="translated">Der standardmäßige Taskplaner basiert auf dem .NET Framework 4-Threadpool, der Arbeitsübernahme für Lastenausgleich und Threadeinfügung/-deaktivierung für maximalen Durchsatz ermöglicht und für eine gute Gesamtleistung sorgt.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It should be sufficient for most scenarios.</source>
          <target state="translated">Dies ist für die meisten Szenarien in der Regel ausreichend.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> class also serves as the extension point for all customizable scheduling logic.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> Klasse dient auch als Erweiterungspunkt für alle anpassbaren Planungslogik.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</source>
          <target state="translated">Dies schließt die Mechanismen, z. B. einen Task für die Ausführung und wie geplante Aufgaben zu planen, Debugger verfügbar gemacht werden sollen.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</source>
          <target state="translated">Wenn Sie spezielle Funktionen benötigen, können Sie einen benutzerdefinierten Planer erstellen und ihn für bestimmte Aufgaben oder Abfragen aktivieren.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In this topic:</source>
          <target state="translated">In diesem Thema:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>The default task scheduler and the thread pool<ept id="p1">](#Default)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Der standardmäßige Aufgabenplaner und der Threadpool<ept id="p1">](#Default)</ept></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>The global queue vs. local queues<ept id="p1">](#Queues)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Der globalen Warteschlange im Vergleich zu lokalen Warteschlangen<ept id="p1">](#Queues)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Work stealing<ept id="p1">](#Stealing)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Arbeitsübernahme<ept id="p1">](#Stealing)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Long-running tasks<ept id="p1">](#LongRunning)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lang ausgeführte Aufgaben<ept id="p1">](#LongRunning)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Task inlining<ept id="p1">](#Inlining)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Aufgabeninlining<ept id="p1">](#Inlining)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Specifying a synchronization context<ept id="p1">](#Sync)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Angeben eines Synchronisierungskontexts<ept id="p1">](#Sync)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default task scheduler and the thread pool</source>
          <target state="translated">Der standardmäßige Aufgabenplaner und der Threadpool</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class, to queue and execute work.</source>
          <target state="translated">Der Standardplaner für die Task Parallel Library und PLINQ verwendet das .NET Framework-Threadpool, der dargestellt wird, indem Sie die <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> -Klasse, um die Warteschlange und Ausführen des Arbeitselements.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The thread pool uses the information that is provided by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</source>
          <target state="translated">Verwendet die Informationen, die vom bereitgestellt wird, der Threadpool dem <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> Typ, um den differenzierten Parallelismus (kurzlebige Arbeitseinheiten), den Parallele Aufgaben und Abfragen oft darstellen effizient zu unterstützen.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The global queue vs. local queues</source>
          <target state="translated">Der globalen Warteschlange im Vergleich zu lokalen Warteschlangen</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</source>
          <target state="translated">Der Threadpool behält verarbeiten (Warteschlange) für Threads in jeder Anwendungsdomäne eine globale FIFO-Reihenfolge (First-in-First-Out).</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Whenever a program calls the <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph> (or <ph id="ph2">&lt;xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</source>
          <target state="translated">Wenn ein Programm aufruft, die <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph> (oder <ph id="ph2">&lt;xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph>) Methode, die Arbeit in dieser freigegebenen Warteschlange abgelegt und schließlich Deduplizierung in der Warteschlange im nächsten Thread, der verfügbar wird.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> class.</source>
          <target state="translated">Beginnend mit .NET Framework 4, diese Warteschlange wurde verbessert, um einen sperrenfreien Algorithmus zu verwenden, die ähnelt der <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</source>
          <target state="translated">Mithilfe dieser sperrenfreien Implementierung verbringt die Threadpool weniger Zeit, wenn Deduplizierung die Warteschlange gestellt und Arbeitsaufgaben.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This performance benefit is available to all programs that use the thread pool.</source>
          <target state="translated">Dieser Leistungsvorteil steht auf alle Programme, die den Threadpool zu verwenden.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</source>
          <target state="translated">Aufgaben der obersten Ebene, bei denen es sich um Aufgaben handelt, die nicht im Kontext einer anderen Aufgabe erstellt werden, werden wie jedes andere Arbeitselement in der globalen Warteschlange abgelegt.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>However, nested or child tasks, which are created in the context of another task, are handled quite differently.</source>
          <target state="translated">Geschachtelte oder untergeordnete Aufgaben, die im Kontext einer anderen Aufgabe erstellt werden, werden hingegen anders behandelt.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</source>
          <target state="translated">Ein untergeordnetes Element oder eine geschachtelte Aufgabe wird in einer lokalen Warteschlange abgelegt, die speziell für den Thread vorgesehen ist, in dem die übergeordnete Aufgabe ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The parent task may be a top-level task or it also may be the child of another task.</source>
          <target state="translated">Die übergeordnete Aufgabe ist möglicherweise eine Aufgabe der obersten Ebene. Es kann sich jedoch auch um das untergeordnete Element einer anderen Aufgabe handeln.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>When this thread is ready for more work, it first looks in the local queue.</source>
          <target state="translated">Wenn dieser Thread für weitere Arbeitsvorgänge bereit ist, wird zuerst eine Suche in der lokalen Warteschlange ausgeführt.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If work items are waiting there, they can be accessed quickly.</source>
          <target state="translated">Wenn darin Arbeitselemente warten, kann darauf schnell zugegriffen werden.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</source>
          <target state="translated">Die lokalen Warteschlangen erfolgt in der Last in, First Out (LIFO)-Prinzip Cacheort beizubehalten und Konflikte zu minimieren.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For more information about child tasks and nested tasks, see <bpt id="p1">[</bpt>Attached and Detached Child Tasks<ept id="p1">](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu untergeordneten und geschachtelten Aufgaben finden Sie unter <bpt id="p1">[</bpt>angefügte und getrennte untergeordnete Aufgaben<ept id="p1">](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</source>
          <target state="translated">Die Verwendung von lokalen Warteschlangen nicht nur reduziert Druck auf die globale Warteschlange, sondern nutzt auch den Ort der Daten.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Work items in the local queue frequently reference data structures that are physically near one another in memory.</source>
          <target state="translated">Arbeitsaufgaben in der lokalen Warteschlange häufig Verweis-Datenstrukturen, die im Arbeitsspeicher physisch nahe beieinander liegen.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</source>
          <target state="translated">In diesen Fällen sind die Daten bereits im Cache, nachdem die erste Aufgabe ausgeführt wurde, sodass schnell zugegriffen werden kann.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Both <bpt id="p1">[</bpt>Parallel LINQ (PLINQ)<ept id="p1">](~/docs/standard/parallel-programming/parallel-linq-plinq.md)</ept> and the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel&gt;</ph> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</source>
          <target state="translated">Beide <bpt id="p1">[</bpt>Parallel LINQ (PLINQ)<ept id="p1">](~/docs/standard/parallel-programming/parallel-linq-plinq.md)</ept> und die <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel&gt;</ph> -Klasse werden extensiv geschachtelte und untergeordnete Aufgaben verwendet und deutliche geschwindigkeitssteigerungen mithilfe der lokalen Warteschlangen.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Work stealing</source>
          <target state="translated">Arbeitsübernahme</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</source>
          <target state="translated">Beginnend mit .NET Framework 4, Funktionen der Threadpool einen Arbeitsübernahme-Algorithmus, um sicherzustellen, dass keine Threads im Ruhezustand sind im Leerlauf, während die anderen noch Arbeitsvorgänge in ihre Warteschlangen.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</source>
          <target state="translated">Wenn ein Threadpoolthread zusätzliche Arbeit übernehmen kann, wird zuerst am Anfang der lokalen Warteschlange, anschließend in der globalen Warteschlange und zuletzt in den lokalen Warteschlangen anderer Threads gesucht.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</source>
          <target state="translated">Wenn ein Arbeitselement in der lokalen Warteschlange eines anderen Threads gefunden wird, wird zunächst Heuristik angewendet, um sicherzustellen, dass die Arbeit effizient ausgeführt werden kann.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If it can, it de-queues the work item from the tail (in FIFO order).</source>
          <target state="translated">Wenn dies möglich ist, Warteschlange wird entfernt die Arbeitsaufgabe am Ende aus der (in FIFO-Reihenfolge).</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This reduces contention on each local queue and preserves data locality.</source>
          <target state="translated">Dadurch werden Konflikte in jeder lokalen Warteschlange verringert und der Datenort beibehalten.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This architecture helps the  thread pool load-balance work more efficiently than past versions did.</source>
          <target state="translated">Dank dieser Architektur kann die Thread-Pool des Lastenausgleichs effizienter arbeiten als in früheren Versionen war.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Long-running tasks</source>
          <target state="translated">Lang ausgeführte Aufgaben</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>You may want to explicitly prevent a task from being put on a local queue.</source>
          <target state="translated">Unter Umständen möchten Sie ausdrücklich verhindern, dass eine Aufgabe in einer lokalen Warteschlange abgelegt wird.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</source>
          <target state="translated">Sie wissen möglicherweise z. B., dass eine bestimmte Arbeitsaufgabe für eine relativ lange Zeit ausgeführt wird und daher wahrscheinlich alle anderen Arbeitsaufgaben in der lokalen Warteschlange blockiert.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In this case, you can specify the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType&gt;</ph> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</source>
          <target state="translated">In diesem Fall können Sie die <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType&gt;</ph>-Option angeben, die den Planer darauf hinweist, dass u. U. ein weiterer Thread für die Aufgabe erforderlich ist, damit der Fortschritt anderer Threads oder Arbeitsaufgaben in der lokalen Warteschlange nicht blockiert wird.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>By using this option you avoid the thread pool completely, including the global and local queues.</source>
          <target state="translated">Mit dieser Option vermeiden Sie den Threadpool vollständig, einschließlich der globalen und lokalen Warteschlangen.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Task inlining</source>
          <target state="translated">Aufgabeninlining</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In some cases when a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</source>
          <target state="translated">In einigen Fällen ein <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> wird gewartet, es kann ausgeführt werden synchron für den Thread, der den Wartevorgang ausführt.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</source>
          <target state="translated">Dies verbessert die Leistung von entfällt die Notwendigkeit einen zusätzlichen Thread, und verwenden Sie stattdessen des vorhandenen Threads verwendet, der andernfalls blockiert worden wäre.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</source>
          <target state="translated">Um Fehler aufgrund des Wiedereintritts zu verhindern, tritt Aufgabeninlining nur auf, wenn das Wartevorgangsziel in der lokalen Warteschlange des relevanten Threads gefunden wird.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Specifying a synchronization context</source>
          <target state="translated">Angeben eines Synchronisierungskontexts</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> method to specify that a task should be scheduled to run on a particular thread.</source>
          <target state="translated">Sie können mit der <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph>-Methode angeben, dass eine Aufgabe für die Ausführung in einem bestimmten Thread geplant werden soll.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</source>
          <target state="translated">Dies ist in Frameworks wie Windows Forms und Windows Presentation Foundation hilfreich, wo der Zugriff auf Benutzeroberflächenobjekte oftmals auf Code beschränkt ist, der in dem Thread ausgeführt wird, in dem das Benutzeroberflächenobjekt erstellt wurde.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> Methode in einer Windows Presentation Foundation (WPF)-app zum Planen eines Tasks auf dem gleichen Thread, der auf das Steuerelement der Benutzeroberfläche (UI) erstellt wurde.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example creates a mosaic of images that are randomly selected from a specified directory.</source>
          <target state="translated">Das Beispiel erstellt ein Mosaik von Bildern, die nach dem Zufallsprinzip aus einem angegebenen Verzeichnis ausgewählt werden.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The WPF objects are used to load and resize the images.</source>
          <target state="translated">Die WPF-Objekte werden zum Laden und die Bildgröße.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The raw pixels are then passed to a task that uses a <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A&gt;</ph> loop to write the pixel data into a large single-byte array.</source>
          <target state="translated">Die unformatierten Pixel werden dann an eine Aufgabe, die verwendet übergeben einer <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A&gt;</ph> Schleife, um die Pixeldaten in einem großen Single-Byte-Array zu schreiben.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>No synchronization is required because no two tiles occupy the same array elements.</source>
          <target state="translated">Keine Synchronisierung ist erforderlich, da keine zwei Kacheln die gleichen Arrayelemente belegen.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The tiles can also be written in any order because their position is calculated independently of any other tile.</source>
          <target state="translated">Die Kacheln können auch in beliebiger Reihenfolge geschrieben werden, da ihre Position unabhängig von anderen Kacheln berechnet wird.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</source>
          <target state="translated">Große Array wird dann an die Aufgabe übergeben, die im UI-Thread ausgeführt wird, in die Pixeldaten in eines Bildsteuerelements geladen werden.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example moves data off the UI thread, modifies it by using parallel loops and <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objects, and then passes it back to a task that runs on the UI thread.</source>
          <target state="translated">Das Beispiel verschiebt Daten aus den UI-Thread, ändert sie mithilfe von parallelen Schleifen und <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> Objekte, und übergibt diese an eine Aufgabe, die auf den UI-Thread ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</source>
          <target state="translated">Dieser Ansatz ist hilfreich, wenn Sie keine der Task Parallel Library verwenden, um Vorgänge auszuführen, die nicht von der WPF-API unterstützt werden oder nicht schnell genug sind.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Another way to create an image mosaic in WPF is to use a <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType&gt;</ph> control and add images to it.</source>
          <target state="translated">So erstellen Sie ein Image Mosaik in WPF eine andere Möglichkeit ist die Verwendung einer <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType&gt;</ph> steuern und Bilder hinzuzufügen.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel&gt;</ph> handles the work of positioning the tiles.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel&gt;</ph> Positionierung der Kacheln behandelt.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>However, this work can only be performed on the UI thread.</source>
          <target state="translated">Dieser Arbeit kann jedoch nur auf den UI-Thread ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>To create the example, create a WPF application project in Visual Studio and assign it a name of your choice.</source>
          <target state="translated">Um das Beispiel zu erstellen, erstellen Sie ein WPF-Anwendungsprojekt in Visual Studio, und weisen Sie ihr einen Namen Ihrer Wahl.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Then do the following:</source>
          <target state="translated">Führen Sie dann folgende Schritte aus:</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In design view, drag an <ph id="ph1">&lt;xref:System.Windows.Controls.Image&gt;</ph> control from the <bpt id="p1">**</bpt>Toolbox<ept id="p1">**</ept> to the design surface.</source>
          <target state="translated">Ziehen Sie in der Entwurfsansicht ein <ph id="ph1">&lt;xref:System.Windows.Controls.Image&gt;</ph> -Steuerelement aus der <bpt id="p1">**</bpt>Toolbox<ept id="p1">**</ept> auf die Entwurfsoberfläche.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In XAML view, specify the horizontal alignment as "Left."</source>
          <target state="translated">Geben Sie im XAML-Ansicht die horizontale Ausrichtung als "Left".</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The size does not matter because the control is be dynamically resized at run time.</source>
          <target state="translated">Die Größe spielt keine Rolle, da das Steuerelement wird zur Laufzeit dynamisch geändert werden.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Accept the default name, "image".</source>
          <target state="translated">Akzeptieren Sie den Standardnamen, "image".</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Drag a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control from the <bpt id="p1">**</bpt>Toolbox<ept id="p1">**</ept> to the lower left part of the application window.</source>
          <target state="translated">Ziehen Sie eine <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> -Steuerelement aus der <bpt id="p1">**</bpt>Toolbox<ept id="p1">**</ept> auf der linken unteren Teil des Anwendungsfensters.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Double-click the button to add a <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event handler.</source>
          <target state="translated">Doppelklicken Sie auf die Schaltfläche zum Hinzufügen einer <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> -Ereignishandler.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In XAML view, specify the <ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph> property of the button as "Make a Mosaic" and specify its horizontal alignment as "Left".</source>
          <target state="translated">Geben Sie im XAML-Ansicht der <ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph> Eigenschaft der Schaltfläche als "Mosaik erstellen", und geben Sie die horizontale Ausrichtung als "Left".</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Accept the default name, "button".</source>
          <target state="translated">Akzeptieren Sie den Standardnamen "button".</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</source>
          <target state="translated">Ersetzen Sie den gesamten Inhalt der Datei "MainWindow.Xaml.cs" oder "MainWindow.Xaml.vb" durch den Code aus diesem Beispiel.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Make sure that the name of the workspace matches the project name.</source>
          <target state="translated">Stellen Sie sicher, dass der Name des Arbeitsbereichs auf den Projektnamen übereinstimmt.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures<ph id="ph1">\\</ph>.</source>
          <target state="translated">Im Beispiel liest JPEG-Bilder aus einem Verzeichnis namens C:\Users\Public\Pictures\Sample Bilder<ph id="ph1">\\</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</source>
          <target state="translated">Erstellen Sie das Verzeichnis und versehen Sie einige Images oder ändern Sie den Pfad zu einem anderen Verzeichnis zu verweisen, die Bilder enthält.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This example has some limitations.</source>
          <target state="translated">In diesem Beispiel weist einige Einschränkungen.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <ph id="ph1">&lt;xref:System.Windows.Media.Imaging.BitmapImage&gt;</ph> object during the resizing operation.</source>
          <target state="translated">Beispielsweise werden nur 32-Bit pro Pixel Bilder unterstützt. vom Bildern in andere Formate beschädigt sind die <ph id="ph1">&lt;xref:System.Windows.Media.Imaging.BitmapImage&gt;</ph> Objekt während des Vorgangs Größenänderung von Fenstern annimmt.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Also, the source images must all be larger than the tile size.</source>
          <target state="translated">Darüber hinaus müssen die Quellbilder alle größer als die Größe der Kacheln sein.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</source>
          <target state="translated">Als weitere Übung können Sie Funktionen zur Behandlung von mehreren Pixelformate und Dateigrößen hinzufügen.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The following example is taken from the <bpt id="p1">[</bpt>Samples for Parallel Programming with the .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept> on the MSDN Code Gallery Web site.</source>
          <target state="translated">Das folgende Beispiel stammt aus dem <bpt id="p1">[</bpt>Beispiele zur parallelen Programmierung mit .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept> auf der MSDN Code Gallery-Website.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It creates a custom task scheduler that limits the number of threads used by the app.</source>
          <target state="translated">Erstellen ein benutzerdefinierten Taskplaners, das die Anzahl der Threads, die von der Anwendung verwendeten beschränkt.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</source>
          <target state="translated">Anschließend startet dieser zwei Sätze von Aufgaben, und zeigt Informationen über die Aufgabe sowie den Thread, in dem der Task ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In addition, several sample task schedulers are available on Code Gallery: <bpt id="p1">[</bpt>Samples for Parallel Programming with the .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept>.</source>
          <target state="translated">Darüber hinaus mehrere Beispiel Aufgabenplaner befinden sich auf Code Gallery zur Verfügung: <bpt id="p1">[</bpt>Beispiele zur parallelen Programmierung mit .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>All members of the abstract <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> type are thread-safe and may be used from multiple threads concurrently.</source>
          <target state="translated">Alle Member des abstrakten <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> Typs sind threadsicher und können von mehreren Threads gleichzeitig verwendet werden.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.#ctor">
          <source>Initializes the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Initialisiert das <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the currently executing task.</source>
          <target state="translated">Ruft den zugeordneten <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> der derzeit ausgeführten Aufgabe ab.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the currently executing task.</source>
          <target state="translated">Gibt den zugeordneten <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> der momentan ausgeführten Aufgabe zurück.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>When not called from within a task, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A&gt;</ph> will return the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Default%2A&gt;</ph> scheduler.</source>
          <target state="translated">Nicht von innerhalb einer Aufgabe aufgerufen <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A&gt;</ph> gibt zurück, die <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Default%2A&gt;</ph> Planer.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>Gets the default <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> instance that is provided by the .NET Framework.</source>
          <target state="translated">Ruft die <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>-Standardinstanz ab, die von .NET Framework bereitgestellt wird.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>Returns the default <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> instance.</source>
          <target state="translated">Gibt die <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>-Standardinstanz zurück.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Aufgabenplaner<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the current <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>.</source>
          <target state="translated">Erstellt einen <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>, der dem aktuellen <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph> zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the current <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>, as determined by <ph id="ph3">&lt;see cref="P:System.Threading.SynchronizationContext.Current" /&gt;</ph>.</source>
          <target state="translated">Ein dem aktuellen <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph> gemäß Vorgabe durch den <ph id="ph3">&lt;see cref="P:System.Threading.SynchronizationContext.Current" /&gt;</ph> zugeordneter <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>All <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances queued to the returned scheduler will be executed through a call to the <ph id="ph2">&lt;xref:System.Threading.SynchronizationContext.Post%2A&gt;</ph> method on that context.</source>
          <target state="translated">Alle <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> Instanzen in der Warteschlange für das zurückgegebene Zeitplan wird ausgeführt durch einen Aufruf von der <ph id="ph2">&lt;xref:System.Threading.SynchronizationContext.Post%2A&gt;</ph> -Methode für diesen Kontext.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Aufgabenplaner<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>The current SynchronizationContext may not be used as a TaskScheduler.</source>
          <target state="translated">Der aktuelle SynchronizationContext kann nicht als TaskScheduler verwendet werden.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>For debugger support only, generates an enumerable of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances currently queued to the scheduler waiting to be executed.</source>
          <target state="translated">Nur für Debuggerunterstützung: Generiert eine Enumeration von <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>-Instanzen, die sich gegenwärtig in der Warteschlange des Taskplaners befinden und auf ihre Ausführung warten.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</source>
          <target state="translated">Eine Aufzählung, in der von einem Debugger die gegenwärtig in der Warteschlange dieses Taskplaners enthaltenen Aufgaben durchsucht werden können.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this method in order to support integration with debuggers.</source>
          <target state="translated">Eine abgeleitete Klasse <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implementiert diese Methode, um die Integration in Debugger zu unterstützen.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This method will only be invoked by the .NET Framework when the debugger requests access to the data.</source>
          <target state="translated">Diese Methode wird von .NET Framework nur aufgerufen werden, wenn der Debugger Zugriff auf die Daten anfordert.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</source>
          <target state="translated">Das aufzählbare Objekt zurückgegeben wird durchlaufen, indem Sie die Hilfsprogramme für den Zugriff auf die Aufgaben Debuggen derzeit in der Warteschlange für diesen Planer, wodurch der Debugger eine Darstellung dieser Informationen in der Benutzeroberfläche bereitzustellen.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>It is important to note that, when this method is called, all other threads in the process will be frozen.</source>
          <target state="translated">Es ist wichtig zu beachten, dass, wenn diese Methode aufgerufen wird, alle anderen Threads im Prozess eingefroren werden.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</source>
          <target state="translated">Aus diesem Grund ist es wichtig, um Synchronisierung mit anderen Threads zu vermeiden, die zu einer Blockierung führen können.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang.</source>
          <target state="translated">Wenn Synchronisierung erforderlich ist und kann die Sperre in dieser Methode werden, sollten Sie eine Ausnahme auslösen, damit der Debugger nicht hängen bleibt.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The following example shows one possible approach in C#:</source>
          <target state="translated">Das folgende Beispiel zeigt einen möglichen Ansatz in c#:</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Additionally, this method and the enumerable returned must not modify any globally visible state.</source>
          <target state="translated">Darüber hinaus müssen diese Methode und das zurückgegebene aufzählbare Element nicht global sichtbaren Zustand ändern.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The returned enumerable should never be null.</source>
          <target state="translated">Die zurückgegebene aufzählbare darf nie null sein.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>If there are currently no queued tasks, an empty enumerable should be returned instead.</source>
          <target state="translated">Wenn aktuell keine Tasks in der Warteschlange vorhanden sind, sollte stattdessen ein leeres aufzählbares Element zurückgegeben werden.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method <ph id="ph1">`GetScheduledTasksForDebugger`</ph> instead: <ph id="ph2">`internal Task[] GetScheduledTasksForDebugger()`</ph>.</source>
          <target state="translated">Entwickler, die benutzerdefinierte Debugger implementieren diese Methode sollte nicht direkt aufrufen, aber die interne Wrappermethode die zu verwendende <ph id="ph1">`GetScheduledTasksForDebugger`</ph> stattdessen: <ph id="ph2">`internal Task[] GetScheduledTasksForDebugger()`</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This wrapper method returns an array of tasks instead of an enumerable.</source>
          <target state="translated">Dieser Wrappermethode gibt ein Array von Aufgaben anstatt ein aufzählbares Element zurück.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>To retrieve a list of active schedulers, use the internal method <ph id="ph1">`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`</ph>.</source>
          <target state="translated">Verwenden Sie zum Abrufen einer Liste der aktive Planer die interne Methode <ph id="ph1">`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This static method returns an array of all active <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> instances.</source>
          <target state="translated">Diese statische Methode gibt ein Array aller aktiven <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> Instanzen.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>You can then use <ph id="ph1">`GetScheduledTasksForDebugger`</ph> on each scheduler instance to retrieve its list of scheduled tasks.</source>
          <target state="translated">Anschließend können Sie <ph id="ph1">`GetScheduledTasksForDebugger`</ph> auf jede Planerinstanz zum Abrufen der Liste der geplanten Aufgaben.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This scheduler is unable to generate a list of queued tasks at this time.</source>
          <target state="translated">Dieser Planer kann derzeit keine Liste in der Warteschlange stehender Aufgaben generieren.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>Gets the unique ID for this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Ruft die eindeutige ID für diesen <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>Returns the unique ID for this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Gibt die eindeutige ID für diesen <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Aufgabenplaner<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>Indicates the maximum concurrency level this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> is able to support.</source>
          <target state="translated">Gibt die maximale Parallelitätsebene an, die dieser <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> unterstützt.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>Returns an integer that represents the maximum concurrency level.</source>
          <target state="translated">Gibt eine ganze Zahl zurück, die die maximale Parallelitätsebene darstellt.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>The default scheduler returns <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Der Standardplaner gibt <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Aufgabenplaner<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be queued.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, der in die Warteschlange eingereiht werden soll.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>Queues a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to the scheduler.</source>
          <target state="translated">Fügt einen <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> in die Warteschlange des Planers ein.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this method to accept tasks being scheduled on the scheduler.</source>
          <target state="translated">Eine abgeleitete Klasse <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implementiert diese Methode, um die Aufgaben, die auf den Planer geplant akzeptieren.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</source>
          <target state="translated">Eine typische Implementierung würde die Aufgabe in eine interne Datenstruktur speichern, die von Threads gewartet werden würde, die diese Aufgaben zu einem Zeitpunkt in der Zukunft ausführen würden.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</source>
          <target state="translated">Diese Methode ist nur zum Aufrufen durch .NET Framework vorgesehen und sollte nicht direkt von der abgeleiteten Klasse aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>This is necessary for maintaining the consistency of the system.</source>
          <target state="translated">Dies ist für die Erhaltung der Konsistenz des Systems erforderlich.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="task" /&gt;</ph>-Argument ist null.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be dequeued.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, das aus der Warteschlange entfernt werden soll.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>Attempts to dequeue a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> that was previously queued to this scheduler.</source>
          <target state="translated">Versucht, einen zuvor in die Warteschlange dieses Planers eingereihten <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> aus der Warteschlange zu entfernen.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>A Boolean denoting whether the <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument was successfully dequeued.</source>
          <target state="translated">Ein boolescher Wert, der angibt, ob das <ph id="ph1">&lt;paramref name="task" /&gt;</ph>-Argument erfolgreich aus der Warteschlange entfernt wurde.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Aufgabenplaner<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <ph id="ph1">&lt;xref:System.Threading.CancellationTokenRegistration&gt;</ph> objects can be disposed of in a timely manner.</source>
          <target state="translated">Ausführen dieser Methode kann einer finally-block; aus diesem Grund sollte zurückgegeben so schnell wie möglich so, dass alle Ressourcen, z. B. <ph id="ph1">&lt;xref:System.Threading.CancellationTokenRegistration&gt;</ph> Objekte zeitnah beseitigt werden können.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="task" /&gt;</ph>-Argument ist null.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object to be executed.</source>
          <target state="translated">Ein auszuführendes <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>Attempts to execute the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> on this scheduler.</source>
          <target state="translated">Versucht, den angegebenen <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> mit diesem Planer auszuführen.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A Boolean that is true if <ph id="ph1">&lt;paramref name="task" /&gt;</ph> was successfully executed, false if it was not.</source>
          <target state="translated">Ein boolescher Wert, der true ist, wenn <ph id="ph1">&lt;paramref name="task" /&gt;</ph> erfolgreich ausgeführt wurde. Andernfalls ist dieser Wert false.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</source>
          <target state="translated">Ein häufiger Grund für Ausführungsfehler besteht darin, dass die Aufgabe zuvor ausgeführt wurde oder gerade von einem anderen Thread ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>Scheduler implementations are provided with <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances to be executed through either the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> method or the <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A&gt;</ph> method.</source>
          <target state="translated">Scheduler-Implementierungen sind im Lieferumfang <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> Instanzen entweder durch auszuführenden der <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> Methode oder die <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>When the scheduler deems it appropriate to run the provided task, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> should be used to do so.</source>
          <target state="translated">Wenn der Planer zum Ausführen der angegebenen Aufgabe geeignete hält <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> sollte dazu verwendet werden.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</source>
          <target state="translated">TryExecuteTask behandelt alle Aspekte beim Ausführen einer Aufgabe, einschließlich Aktionsaufruf, Ausnahmebehandlung, Zustandsverwaltung und Lebenszyklus-Steuerelement.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> muss nur für Aufgaben, die für diesen Planer bereitgestellt werden, von der .NET Framework-Infrastruktur verwendet werden.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>It should not be used to execute arbitrary tasks obtained through custom mechanisms.</source>
          <target state="translated">Es sollte nicht verwendet werden, zum Ausführen von beliebiger Aufgaben, die durch benutzerdefinierte Mechanismen abgerufen.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> is not associated with this scheduler.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="task" /&gt;</ph> ist nicht diesem Planer zugeordnet.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be executed.</source>
          <target state="translated">Das auszuführende <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A Boolean denoting whether or not task has previously been queued.</source>
          <target state="translated">Ein boolescher Wert, der angibt, ob die Aufgabe zuvor in die Warteschlange eingereiht wurde.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</source>
          <target state="translated">Wenn dieser Parameter true ist, wurde die Aufgabe möglicherweise zuvor in die Warteschlange eingereiht (geplant). Ist er false, wurde die Aufgabe bekanntermaßen nicht in die Warteschlange eingereiht, und dieser Aufruf wird ausgeführt, um die Aufgabe inline auszuführen, ohne sie in die Warteschlange einzureihen.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Determines whether the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> can be executed synchronously in this call, and if it can, executes it.</source>
          <target state="translated">Bestimmt, ob der angegebene <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> in diesem Aufruf synchron ausgeführt werden kann, und führt ihn aus, wenn dies der Fall ist.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A Boolean value indicating whether the task was executed inline.</source>
          <target state="translated">Ein boolescher Wert, der angibt, ob die Aufgabe inline ausgeführt wurde.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</source>
          <target state="translated">Eine abgeleitete Klasse <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implementiert diese Funktion, um die Inlineausführung einer Aufgabe in einem Thread zu unterstützen, einen Wartevorgang auf das Taskobjekt initiiert.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Inline execution is optional, and the request may be rejected by returning false.</source>
          <target state="translated">Inline-Ausführung ist optional, und die Anforderung wird möglicherweise zurückgewiesen, indem Sie "false" zurückgeben.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>However, the more tasks that can be inlined, the better the scheduler will scale.</source>
          <target state="translated">Allerdings weitere Aufgaben können inline gesetzt werden, desto bessere der Planer kann skaliert werden.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>In fact, a scheduler that inlines too little may be prone to deadlocks.</source>
          <target state="translated">Tatsächlich kann ein Zeitplanungsmodul, Inlines zu wenig zu Deadlocks sein.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</source>
          <target state="translated">Eine richtige Implementierung sollten sicherstellen, dass eine Anforderung, die unter den Richtlinien, die vom Planer garantiert ausgeführt können erfolgreich Inline.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</source>
          <target state="translated">Z. B. sollten ein Planer einen dedizierten Thread zum Ausführen von Tasks verwendet wird, alle inlining Anforderungen von diesem Thread aus erfolgreich.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> method with the provided task object, propagating the return value.</source>
          <target state="translated">Wenn ein Planer für die Inlineausführung entscheidet, sollten sie dies tun, durch Aufrufen der Basis TaskScheduler <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> Methode mit dem bereitgestellten Taskobjekt des Rückgabewerts.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</source>
          <target state="translated">Außerdem kann es werden entsprechende für den Planer eine Inline-Aufgabe aus seiner internen Datenstrukturen entfernen, wenn er entscheidet, die inlining Anforderung berücksichtigt.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> method.</source>
          <target state="translated">Beachten Sie jedoch, dass unter bestimmten Umständen ein Planer Inline zu setzen eine Aufgabe aufgefordert werden kann, die mit nicht zuvor bereitgestellt wurde die <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</source>
          <target state="translated">Der abgeleitete Planer ist dafür verantwortlich, dass Sie sicher, dass der aufrufende Thread eignet sich zum Ausführen der angegebenen Aufgabe so weit wie die eigene Planung und Ausführungsrichtlinien betrifft.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Aufgabenplaner<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="task" /&gt;</ph>-Argument ist null.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> was already executed.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="task" /&gt;</ph> wurde bereits ausgeführt.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</source>
          <target state="translated">Tritt auf, kurz bevor eine nicht überwachte Ausnahme eines Tasks, bei dem ein Fehler aufgetreten ist, eine Ausnahmeausweitungsrichtlinie auslöst, was standardmäßig den Prozess beenden würde.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</source>
          <target state="translated">Dieses Ereignis zu Anwendungsfehler domänenweite bietet einen Mechanismus zum ausweitungsrichtlinien Ausnahme zu verhindern (d. h. wird standardmäßig der Prozess beendet wird) auslöst.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>To make it easier for developers to write asynchronous code based on tasks, the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> changes the default exception behavior for unobserved exceptions.</source>
          <target state="translated">Für Entwickler zum Schreiben von asynchronem Code auf Grundlage der Aufgaben, erleichtern die <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> ändert das Standardverhalten für die Ausnahme für nicht überwachte Ausnahmen.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Although unobserved exceptions still raise the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException&gt;</ph> exception, the process does not terminate by default.</source>
          <target state="translated">Zwar immer noch nicht überwachte Ausnahmen auslösen der <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException&gt;</ph> Ausnahme, der Prozess wird standardmäßig nicht beendet.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</source>
          <target state="translated">Stattdessen wird die Ausnahme von der Laufzeit behandelt, nach dem das Ereignis ausgelöst wird, unabhängig davon, ob ein Ereignishandler für die Ausnahme berücksichtigt.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>This behavior can be configured.</source>
          <target state="translated">Dieses Verhalten kann konfiguriert werden.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, you can use the  configuration element to revert to the behavior of the <ph id="ph2">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> and terminate the process:</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, können Sie das Konfigurationselement, um das Verhalten des wiederherzustellen die <ph id="ph2">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> und den Prozess zu beenden:</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>