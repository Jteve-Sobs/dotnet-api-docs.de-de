<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5060134ecbdeaec5293e426623e57eb461ac9ad6" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83945731" /></Metadata><TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading.Tasks" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Objekt dar, das die Einreihung von Aufgaben in Threads auf niedriger Ebene behandelt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanz der <xref:System.Threading.Tasks.TaskScheduler>-Klasse stellt einen Aufgabenplaner dar. Durch einen Taskplaner wird sichergestellt, dass die Arbeit einer Aufgabe schließlich ausgeführt wird.  
  
 Der standardmäßige Taskplaner basiert auf dem .NET Framework 4-Threadpool, der Arbeitsübernahme für Lastenausgleich und Threadeinfügung/-deaktivierung für maximalen Durchsatz ermöglicht und für eine gute Gesamtleistung sorgt. Dies ist für die meisten Szenarien in der Regel ausreichend.  
  
 Die <xref:System.Threading.Tasks.TaskScheduler>-Klasse dient auch als Erweiterungs Punkt für alle anpassbaren Planungslogik.  Dies schließt Mechanismen ein, z. b. das Planen einer Aufgabe für die Ausführung und die Art und Weise, wie geplante Aufgaben für debuggger verfügbar gemacht werden sollen. Wenn Sie spezielle Funktionen benötigen, können Sie einen benutzerdefinierten Planer erstellen und für bestimmte Tasks oder Abfragen aktivieren.  
  
 Inhalte dieses Themas:  
[Der Standardaufgaben Planer und der Thread Pool](#Default)  
 [Die globale Warteschlange im Vergleich zu lokalen Warteschlangen](#Queues)  
 [Arbeits Diebstahl](#Stealing)  
 [Aufgaben mit langer Ausführungszeit](#LongRunning)  
 [Task Inlining](#Inlining)  
[Angeben eines Synchronisierungs Kontexts](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>Der Standardaufgaben Planer und der Thread Pool  
 Der Standard Planer für die Task Parallel Library und PLINQ verwendet den .NET Framework Thread Pool, der durch die <xref:System.Threading.ThreadPool>-Klasse dargestellt wird, um Arbeit in die Warteschlange zu stellen und auszuführen. Der Thread Pool verwendet die Informationen, die vom <xref:System.Threading.Tasks.Task>-Typ bereitgestellt werden, um die differenzierte Parallelität (kurzlebige Arbeitseinheiten) effizient zu unterstützen, die parallele Tasks und Abfragen häufig darstellen.  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>Die globale Warteschlange im Vergleich zu lokalen Warteschlangen  
 Der Thread Pool verwaltet eine globale FIFO-Arbeits Warteschlange (First in, First Out) für Threads in jeder Anwendungsdomäne. Wenn ein Programm die <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (oder <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>)-Methode aufruft, wird die Arbeit in diese freigegebene Warteschlange eingereiht und schließlich auf den nächsten Thread, der verfügbar wird, deaktiviert. Beginnend mit der .NET Framework 4 wurde diese Warteschlange verbessert, um einen Sperr freien Algorithmus zu verwenden, der der <xref:System.Collections.Concurrent.ConcurrentQueue%601>-Klasse ähnelt. Mit dieser sperrenfreien Implementierung verbringt der Thread Pool weniger Zeit, wenn Arbeitselemente in die Warteschlange eingereiht und aus der Warteschlange entfernt werden. Dieser Leistungsvorteil ist für alle Programme verfügbar, die den Thread Pool verwenden.  
  
 Aufgaben der obersten Ebene, bei denen es sich um Aufgaben handelt, die nicht im Kontext einer anderen Aufgabe erstellt werden, werden wie jedes andere Arbeitselement in der globalen Warteschlange abgelegt. Geschachtelte oder untergeordnete Aufgaben, die im Kontext einer anderen Aufgabe erstellt werden, werden hingegen anders behandelt. Ein untergeordnetes Element oder eine geschachtelte Aufgabe wird in einer lokalen Warteschlange abgelegt, die speziell für den Thread vorgesehen ist, in dem die übergeordnete Aufgabe ausgeführt wird. Die übergeordnete Aufgabe ist möglicherweise eine Aufgabe der obersten Ebene. Es kann sich jedoch auch um das untergeordnete Element einer anderen Aufgabe handeln. Wenn dieser Thread für weitere Arbeitsvorgänge bereit ist, wird zuerst eine Suche in der lokalen Warteschlange ausgeführt. Wenn darin Arbeitsaufgaben warten, kann darauf schnell zugegriffen werden. Auf die lokalen Warteschlangen wird in der Last-in-First-Out-Reihenfolge (LIFO) zugegriffen, um die Cache Lokalität beizubehalten und Konflikte zu verringern. Weitere Informationen zu untergeordneten und untergeordneten Aufgaben finden Sie unter [angefügte und getrennte](/dotnet/standard/parallel-programming/attached-and-detached-child-tasks)untergeordnete Aufgaben.  
  
 Durch die Verwendung lokaler Warteschlangen wird nicht nur der Druck der globalen Warteschlange verringert, sondern auch die Daten Lokalität genutzt. Arbeitselemente in der lokalen Warteschlange verweisen häufig auf Datenstrukturen, die im Arbeitsspeicher physisch nahe beieinander liegen. In diesen Fällen befinden sich die Daten bereits im Cache, nachdem die erste Aufgabe ausgeführt wurde und schnell auf Sie zugegriffen werden kann. Sowohl [parallele LINQ (PLINQ)](/dotnet/standard/parallel-programming/parallel-linq-plinq) als auch die <xref:System.Threading.Tasks.Parallel>-Klasse verwenden in großem Umfang geschachtelte Tasks und untergeordnete Aufgaben und erzielen mithilfe der lokalen Arbeits Warteschlangen deutliche Beschleunigung.  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>Arbeits Diebstahl  
 Beginnend mit dem .NET Framework 4 verfügt der Thread Pool auch über einen Arbeits Übernahme-Algorithmus, um sicherzustellen, dass sich keine Threads im Leerlauf befinden, während andere weiterhin in ihren Warteschlangen arbeiten. Wenn ein Threadpoolthread zusätzliche Arbeit übernehmen kann, wird zuerst am Anfang der lokalen Warteschlange, anschließend in der globalen Warteschlange und zuletzt in den lokalen Warteschlangen anderer Threads gesucht. Wenn ein Arbeitselement in der lokalen Warteschlange eines anderen Threads gefunden wird, wird zunächst Heuristik angewendet, um sicherzustellen, dass die Arbeit effizient ausgeführt werden kann. Wenn dies der Fall ist, wird das Arbeits Element aus der Warteschlange entfernt (in FIFO-Reihenfolge). Dadurch werden Konflikte in jeder lokalen Warteschlange verringert und der Datenort beibehalten. Diese Architektur unterstützt den Thread Pool-Lastenausgleich effizienter als in früheren Versionen.  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>Aufgaben mit langer Ausführungszeit  
 Unter Umständen möchten Sie ausdrücklich verhindern, dass eine Aufgabe in einer lokalen Warteschlange abgelegt wird. Sie wissen möglicherweise z. B., dass ein bestimmtes Arbeitselement für eine relativ lange Zeit ausgeführt wird und daher wahrscheinlich alle anderen Arbeitselemente in der lokalen Warteschlange blockiert. In diesem Fall können Sie die <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>-Option angeben, die den Planer darauf hinweist, dass u. U. ein weiterer Thread für die Aufgabe erforderlich ist, damit der Fortschritt anderer Threads oder Arbeitselemente in der lokalen Warteschlange nicht blockiert wird. Mit dieser Option vermeiden Sie den Thread Pool vollständig, einschließlich der globalen und lokalen Warteschlangen.  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>Task Inlining  
 In einigen Fällen, in denen eine <xref:System.Threading.Tasks.Task> gewartet wird, wird Sie möglicherweise synchron in dem Thread ausgeführt, der den warte Vorgang ausführt. Dadurch wird die Leistung verbessert, da ein zusätzlicher Thread nicht mehr benötigt wird und stattdessen der vorhandene Thread verwendet wird, der andernfalls blockiert wäre. Um Fehler aufgrund eines erneuten Eintretens zu vermeiden, tritt das Inlining der Aufgabe nur auf, wenn das warte Ziel in der lokalen Warteschlange des relevanten Threads gefunden wird.  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>Angeben eines Synchronisierungs Kontexts  
 Sie können mit der <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType>-Methode angeben, dass eine Aufgabe für die Ausführung in einem bestimmten Thread geplant werden soll. Dies ist in Frameworks wie Windows Forms und Windows Presentation Foundation hilfreich, wo der Zugriff auf Benutzeroberflächenobjekte oftmals auf Code beschränkt ist, der in dem Thread ausgeführt wird, in dem das Benutzeroberflächenobjekt erstellt wurde.  
  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType>-Methode in einer Windows Presentation Foundation (WPF)-App verwendet, um eine Aufgabe im gleichen Thread zu planen, in dem auch das Steuerelement der Benutzeroberfläche erstellt wurde.   Im Beispiel wird ein Mosaik von Bildern erstellt, die nach dem Zufallsprinzip aus einem angegebenen Verzeichnis ausgewählt werden. Die WPF-Objekte werden verwendet, um die Bilder zu laden und zu ändern. Die Rohdaten werden dann an eine Aufgabe weitergegeben, die eine <xref:System.Threading.Tasks.Parallel.For%2A> Schleife verwendet, um die Pixeldaten in ein großes Einzel Byte Array zu schreiben. Es ist keine Synchronisierung erforderlich, da keine zwei Kacheln dieselben Array Elemente belegen. Die Kacheln können auch in beliebiger Reihenfolge geschrieben werden, da ihre Position unabhängig von einer anderen Kachel berechnet wird. Das große Array wird dann an einen Task weitergeleitet, der im UI-Thread ausgeführt wird, in dem die Pixeldaten in ein Bild Steuerelement geladen werden.  
  
 Im Beispiel werden Daten aus dem UI-Thread verschoben, mithilfe paralleler Schleifen und <xref:System.Threading.Tasks.Task> Objekten geändert und dann an eine Aufgabe zurückgeleitet, die im UI-Thread ausgeführt wird. Diese Vorgehensweise ist nützlich, wenn Sie die Task Parallel Library zum Durchführen von Vorgängen verwenden müssen, die von der WPF-API nicht unterstützt werden oder nicht ausreichend schnell sind. Eine weitere Möglichkeit zum Erstellen eines Bild Mosaiks in WPF ist die Verwendung eines <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> Steuer Elements und das Hinzufügen von Bildern. Der <xref:System.Windows.Controls.WrapPanel> behandelt die Positionierung der Kacheln. Diese Arbeit kann jedoch nur im UI-Thread ausgeführt werden.  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 Um das Beispiel zu erstellen, erstellen Sie ein WPF-Anwendungsprojekt in Visual Studio, und benennen Sie es WPF_CS1 (für ein C# WPF-Projekt) oder WPF_VB1 (für ein Visual Basic WPF-Projekt). Gehen Sie wie folgt vor:  
  
1. Ziehen Sie in der Entwurfs Ansicht ein <xref:System.Windows.Controls.Image>-Steuerelement aus der **Toolbox** auf die linke obere Ecke der Entwurfs Oberfläche. Benennen Sie das Steuerelement im Textfeld **Name** des Fensters **Eigenschaften** mit dem Namen "Image".    
  
2. Ziehen Sie ein <xref:System.Windows.Controls.Button>-Steuerelement aus der **Toolbox** in den unteren linken Bereich des Anwendungsfensters. Geben Sie in der XAML-Ansicht die <xref:System.Windows.Controls.ContentControl.Content%2A>-Eigenschaft der Schaltfläche als "Make a Mosaic" an, und geben Sie die <xref:System.Windows.FrameworkElement.Width>-Eigenschaft als "100" an. Verbinden Sie das <xref:System.Windows.Controls.Primitives.ButtonBase.Click>-Ereignis mit dem `button_Click` Ereignishandler, der im Code des Beispiels definiert ist, indem Sie dem `<Button>` Element `Click="button_Click"` hinzufügen. Benennen Sie das Steuerelement im Textfeld **Name** des Fensters **Eigenschaften** mit "Schaltfläche".  
  
3. Ersetzen Sie den gesamten Inhalt der MainWindow.XAML.cs-oder MainWindow. XAML. vb-Datei durch den Code aus diesem Beispiel. Stellen Sie C# bei einem WPF-Projekt sicher, dass der Name des Arbeitsbereichs mit dem Projektnamen übereinstimmt. 
  
4. Im Beispiel werden JPEG-Bilder aus einem Verzeichnis namens c:\Users\Public\Pictures\Sample Pictures\\gelesen. Erstellen Sie das Verzeichnis, und platzieren Sie einige Bilder, oder ändern Sie den Pfad so, dass er auf ein anderes Verzeichnis verweist, das Bilder enthält. 
  
In diesem Beispiel sind einige Einschränkungen zu beachten. Beispielsweise werden nur 32 Bits pro Pixel-Bilder unterstützt. Bilder in anderen Formaten werden während des Vorgangs zum Ändern der Größe durch das <xref:System.Windows.Media.Imaging.BitmapImage> Objekt beschädigt. Außerdem müssen die Quell Images alle größer als die Kachel Größe sein. Als weitere Übung können Sie Funktionen hinzufügen, mit denen mehrere Pixel Formate und Dateigrößen behandelt werden.  
  
## Examples  
 Das folgende Beispiel stammt aus den [Beispielen für die parallele Programmierung mit dem .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) auf der MSDN Code Gallery-Website.  Es wird ein benutzerdefinierter Taskplaner erstellt, der die Anzahl der Threads einschränkt, die von der APP verwendet werden. Anschließend werden zwei Aufgaben Sätze gestartet, und es werden Informationen über die Aufgabe und den Thread angezeigt, in dem die Aufgabe ausgeführt wird.  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 Außerdem sind mehrere Beispiel Aufgabenplaner in der Code Gallery verfügbar: [Beispiele für die parallele Programmierung mit dem .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Member des abstrakten <see cref="T:System.Threading.Tasks.TaskScheduler" /> Typs sind Thread sicher und können gleichzeitig von mehreren Threads verwendet werden.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert das <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zugeordneten <see cref="T:System.Threading.Tasks.TaskScheduler" /> der derzeit ausgeführten Aufgabe ab.</summary>
        <value>Gibt den zugeordneten <see cref="T:System.Threading.Tasks.TaskScheduler" /> der momentan ausgeführten Aufgabe zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht innerhalb einer Aufgabe aufgerufen wird, gibt <xref:System.Threading.Tasks.TaskScheduler.Current%2A> den <xref:System.Threading.Tasks.TaskScheduler.Default%2A> Scheduler zurück.  
  
 Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Threading.Tasks.TaskScheduler" />-Standardinstanz ab, die von .NET Framework bereitgestellt wird.</summary>
        <value>Gibt die <see cref="T:System.Threading.Tasks.TaskScheduler" />-Standardinstanz zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle Ressourcen frei, die diesem Planer zugeordnet sind.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen <see cref="T:System.Threading.Tasks.TaskScheduler" />, der dem aktuellen <see cref="T:System.Threading.SynchronizationContext" /> zugeordnet ist.</summary>
        <returns>Ein dem aktuellen <see cref="T:System.Threading.SynchronizationContext" /> gemäß Vorgabe durch den <see cref="P:System.Threading.SynchronizationContext.Current" /> zugeordneter <see cref="T:System.Threading.Tasks.TaskScheduler" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle <xref:System.Threading.Tasks.Task> Instanzen, die für den zurückgegebenen Scheduler in die Warteschlange eingereiht werden, werden über einen aufzurufenden <xref:System.Threading.SynchronizationContext.Post%2A> Methode in diesem Kontext ausgeführt.  
  
 Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle SynchronizationContext kann nicht als TaskScheduler verwendet werden.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nur für Debuggerunterstützung: Generiert eine Enumeration von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, die sich gegenwärtig in der Warteschlange des Taskplaners befinden und auf ihre Ausführung warten.</summary>
        <returns>Eine Aufzählung, in der von einem Debugger die gegenwärtig in der Warteschlange dieses Taskplaners enthaltenen Aufgaben durchsucht werden können.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine von <xref:System.Threading.Tasks.TaskScheduler> abgeleitete Klasse implementiert diese Methode, um die Integration mit Debuggern zu unterstützen. Diese Methode wird nur vom .NET Framework aufgerufen, wenn der Debugger Zugriff auf die Daten anfordert. Die zurückgegebene Aufzählung wird durch debugginghilfsprogramme durchlaufen, um auf die derzeit in der Warteschlange befindlichen Aufgaben zuzugreifen, sodass der Debugger eine Darstellung dieser Informationen auf der Benutzeroberfläche bereitstellen kann.  
  
 Beachten Sie Folgendes: Wenn diese Methode aufgerufen wird, werden alle anderen Threads im Prozess fixiert. Daher ist es wichtig, die Synchronisierung mit anderen Threads zu vermeiden, die zu Blockierungen führen können. Wenn eine Synchronisierung erforderlich ist und Sie die Sperre in dieser Methode nicht abrufen können, sollten Sie eine Ausnahme auslösen, damit der Debugger nicht blockiert wird. Das folgende Beispiel zeigt einen möglichen Ansatz in C#:
  
```csharp
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 Außerdem dürfen diese Methode und die zurückgegebene Aufzähl Bare keinen global sichtbaren Zustand ändern.  
  
 Der zurückgegebene Aufzähl Bare darf nie NULL sein. Wenn zurzeit keine Tasks in der Warteschlange vorhanden sind, sollte stattdessen ein leeres Aufzähl bares Element zurückgegeben werden.  
  
 Entwickler, die benutzerdefinierte debuggger implementieren, sollten diese Methode nicht direkt aufrufen, sondern sollten stattdessen die interne Wrapper Methode `GetScheduledTasksForDebugger` verwenden: `internal Task[] GetScheduledTasksForDebugger()`. Diese Wrapper Methode gibt ein Array von Aufgaben anstelle eines Aufzähl baren zurück. Zum Abrufen einer Liste aktiver Planer verwenden Sie die interne Methode `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`. Diese statische Methode gibt ein Array aller aktiven <xref:System.Threading.Tasks.TaskScheduler> Instanzen zurück. Anschließend können Sie `GetScheduledTasksForDebugger` für jede Scheduler-Instanz verwenden, um die Liste der geplanten Aufgaben abzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Dieser Planer kann derzeit keine Liste in der Warteschlange stehender Aufgaben generieren.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die eindeutige ID für diesen <see cref="T:System.Threading.Tasks.TaskScheduler" /> ab.</summary>
        <value>Gibt die eindeutige ID für diesen <see cref="T:System.Threading.Tasks.TaskScheduler" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die maximale Parallelitätsebene an, die dieser <see cref="T:System.Threading.Tasks.TaskScheduler" /> unterstützt.</summary>
        <value>Gibt eine ganze Zahl zurück, die die maximale Parallelitätsebene darstellt. Der Standardplaner gibt <see cref="F:System.Int32.MaxValue" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub QueueTask (task As Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Der <see cref="T:System.Threading.Tasks.Task" />, der in die Warteschlange eingereiht werden soll.</param>
        <summary>Fügt einen <see cref="T:System.Threading.Tasks.Task" /> in die Warteschlange des Planers ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine von <xref:System.Threading.Tasks.TaskScheduler> abgeleitete Klasse implementiert diese Methode, um Aufgaben zu akzeptieren, die im Scheduler geplant werden.  
  
 Eine typische-Implementierung speichert die Aufgabe in einer internen Datenstruktur, die von Threads gewartet wird, die diese Aufgaben zu einem späteren Zeitpunkt ausführen würden.  
  
 Diese Methode soll nur vom .NET Framework aufgerufen werden und sollte nicht direkt von der abgeleiteten Klasse aufgerufen werden. Dies ist erforderlich, um die Konsistenz des Systems zu gewährleisten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="task" />-Argument ist null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function TryDequeue (task As Task) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Das <see cref="T:System.Threading.Tasks.Task" />, das aus der Warteschlange entfernt werden soll.</param>
        <summary>Versucht, einen zuvor in die Warteschlange dieses Planers eingereihten <see cref="T:System.Threading.Tasks.Task" /> aus der Warteschlange zu entfernen.</summary>
        <returns>Ein boolescher Wert, der angibt, ob das <paramref name="task" />-Argument erfolgreich aus der Warteschlange entfernt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.  
  
 Diese Methode kann in einem schließlich-Block ausgeführt werden. Daher sollte Sie so schnell wie möglich zurückgeben, damit alle Ressourcen wie <xref:System.Threading.CancellationTokenRegistration> Objekte rechtzeitig verworfen werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="task" />-Argument ist null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="VB.NET" Value="Protected Function TryExecuteTask (task As Task) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Ein auszuführendes <see cref="T:System.Threading.Tasks.Task" />-Objekt.</param>
        <summary>Versucht, den angegebenen <see cref="T:System.Threading.Tasks.Task" /> mit diesem Planer auszuführen.</summary>
        <returns>Ein boolescher Wert, der true ist, wenn <paramref name="task" /> erfolgreich ausgeführt wurde. Andernfalls ist dieser Wert false. Ein häufiger Grund für Ausführungsfehler besteht darin, dass die Aufgabe zuvor ausgeführt wurde oder gerade von einem anderen Thread ausgeführt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Scheduler-Implementierungen werden <xref:System.Threading.Tasks.Task> Instanzen bereitgestellt, die entweder über die <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A>-Methode oder die <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A>-Methode ausgeführt werden. Wenn der Scheduler es für die Durchführung der bereitgestellten Aufgabe geeignet hält, sollten Sie hierfür <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> verwenden. TryExecuteTask behandelt alle Aspekte der Ausführung einer Aufgabe, einschließlich Aktions Aufruf, Ausnahmebehandlung, Zustands Verwaltung und Lebenszyklus Steuerung.  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> darf nur für Aufgaben verwendet werden, die diesem Scheduler von der .NET Framework-Infrastruktur bereitgestellt werden. Sie sollte nicht verwendet werden, um beliebige Aufgaben auszuführen, die über benutzerdefinierte Mechanismen abgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <paramref name="task" /> ist nicht diesem Planer zugeordnet.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function TryExecuteTaskInline (task As Task, taskWasPreviouslyQueued As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">Das auszuführende <see cref="T:System.Threading.Tasks.Task" />.</param>
        <param name="taskWasPreviouslyQueued">Ein boolescher Wert, der angibt, ob die Aufgabe zuvor in die Warteschlange eingereiht wurde. Wenn dieser Parameter true ist, wurde die Aufgabe möglicherweise zuvor in die Warteschlange eingereiht (geplant). Ist er false, wurde die Aufgabe bekanntermaßen nicht in die Warteschlange eingereiht, und dieser Aufruf wird ausgeführt, um die Aufgabe inline auszuführen, ohne sie in die Warteschlange einzureihen.</param>
        <summary>Bestimmt, ob der angegebene <see cref="T:System.Threading.Tasks.Task" /> in diesem Aufruf synchron ausgeführt werden kann, und führt ihn aus, wenn dies der Fall ist.</summary>
        <returns>Ein boolescher Wert, der angibt, ob die Aufgabe inline ausgeführt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine von <xref:System.Threading.Tasks.TaskScheduler> abgeleitete Klasse implementiert diese Funktion, um die Inline Ausführung einer Aufgabe in einem Thread zu unterstützen, der einen Warte Vorgang auf dieses Aufgaben Objekt initiiert. Die Inline Ausführung ist optional, und die Anforderung kann zurückgewiesen werden, indem Sie false zurückgeben. Die mehr Aufgaben, die Inline sein können, desto besser wird der Planer skalieren. Tatsächlich kann ein Scheduler, der zu wenig Zeilen zuweist, anfällig für Deadlocks werden. Eine ordnungsgemäße Implementierung sollte sicherstellen, dass eine Anforderung, die unter den vom Planer garantierten Richtlinien ausgeführt wird, erfolgreich Inline ausgeführt werden kann. Wenn ein Planer z. b. einen dedizierten Thread zum Ausführen von Aufgaben verwendet, sollten alle inlining-Anforderungen von diesem Thread erfolgreich sein.  
  
 Wenn ein Scheduler beschließt, die Inline Ausführung auszuführen, sollte dies durch Aufrufen der <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> Methode des Basis Task Schedulers mit dem bereitgestellten Aufgaben Objekt erfolgen, wobei der Rückgabewert weitergegeben wird. Es kann auch sinnvoll sein, eine Inline Aufgabe aus den internen Datenstrukturen zu entfernen, wenn Sie die Inlining-Anforderung beachten soll. Beachten Sie jedoch, dass ein Scheduler unter bestimmten Umständen aufgefordert werden kann, eine Aufgabe Inline zu einem Task hinzuweisen, die ihm zuvor nicht mit der <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A>-Methode bereitgestellt wurde.  
  
 Der abgeleitete Scheduler ist dafür verantwortlich, sicherzustellen, dass der aufrufende Thread für die Ausführung der angegebenen Aufgabe geeignet ist, soweit es seine eigenen Planungs-und Ausführungsrichtlinien betrifft.  
  
 Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="task" />-Argument ist null.</exception>
        <exception cref="T:System.InvalidOperationException">Der <paramref name="task" /> wurde bereits ausgeführt.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, kurz bevor eine nicht überwachte Ausnahme eines Tasks, bei dem ein Fehler aufgetreten ist, eine Ausnahmeausweitungsrichtlinie auslöst, was standardmäßig den Prozess beenden würde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Anwendungs Domänen übergreifende Ereignis bietet einen Mechanismus, um zu verhindern, dass die Ausnahme Eskalations Richtlinie, die den Prozessstandard mäßig beendet, ausgelöst wird.  
  
 Um Entwicklern das Schreiben von asynchronem Code auf der Grundlage von Aufgaben zu erleichtern, ändert der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] das standardmäßige Ausnahme Verhalten bei nicht beobachteten Ausnahmen. Obwohl bei nicht beobachteten Ausnahmen weiterhin die <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> Ausnahme ausgelöst wird, wird der ProzessStandard mäßig nicht beendet. Stattdessen wird die Ausnahme von der Laufzeit behandelt, nachdem das-Ereignis ausgelöst wurde, unabhängig davon, ob ein Ereignishandler die Ausnahme beachtet. Dieses Verhalten kann konfiguriert werden. Beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)]können Sie das [`<ThrowUnobservedTaskExceptions>`](/dotnet/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element) Configuration-Element verwenden, um das Verhalten des [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] wiederherzustellen und den Prozess zu beenden:  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element">&lt;throwunobservedtaskexceptions&gt; Element</related>
      </Docs>
    </Member>
  </Members>
</Type>
