<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e5e9ad8e4ff6e702edfeb2269d73919354337525" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82319674" /></Metadata><TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading.Tasks" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="d78b4-101">Stellt ein Objekt dar, das die Einreihung von Aufgaben in Threads auf niedriger Ebene behandelt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-101">Represents an object that handles the low-level work of queuing tasks onto threads.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d78b4-102">Eine Instanz der <xref:System.Threading.Tasks.TaskScheduler>-Klasse stellt einen Aufgabenplaner dar.</span><span class="sxs-lookup"><span data-stu-id="d78b4-102">An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler.</span></span> <span data-ttu-id="d78b4-103">Durch einen Taskplaner wird sichergestellt, dass die Arbeit einer Aufgabe schließlich ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d78b4-103">A task scheduler ensures that the work of a task is eventually executed.</span></span>  
  
 <span data-ttu-id="d78b4-104">Der standardmäßige Taskplaner basiert auf dem .NET Framework 4-Threadpool, der Arbeitsübernahme für Lastenausgleich und Threadeinfügung/-deaktivierung für maximalen Durchsatz ermöglicht und für eine gute Gesamtleistung sorgt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-104">The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</span></span> <span data-ttu-id="d78b4-105">Dies ist für die meisten Szenarien in der Regel ausreichend.</span><span class="sxs-lookup"><span data-stu-id="d78b4-105">It should be sufficient for most scenarios.</span></span>  
  
 <span data-ttu-id="d78b4-106">Die <xref:System.Threading.Tasks.TaskScheduler>-Klasse dient auch als Erweiterungs Punkt für alle anpassbaren Planungslogik.</span><span class="sxs-lookup"><span data-stu-id="d78b4-106">The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.</span></span>  <span data-ttu-id="d78b4-107">Dies schließt Mechanismen ein, z. b. das Planen einer Aufgabe für die Ausführung und die Art und Weise, wie geplante Aufgaben für debuggger verfügbar gemacht werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-107">This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</span></span> <span data-ttu-id="d78b4-108">Wenn Sie spezielle Funktionen benötigen, können Sie einen benutzerdefinierten Planer erstellen und für bestimmte Tasks oder Abfragen aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d78b4-108">If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</span></span>  
  
 <span data-ttu-id="d78b4-109">In diesem Abschnitt:</span><span class="sxs-lookup"><span data-stu-id="d78b4-109">In this topic:</span></span>  
[<span data-ttu-id="d78b4-110">Der Standardaufgaben Planer und der Thread Pool</span><span class="sxs-lookup"><span data-stu-id="d78b4-110">The default task scheduler and the thread pool</span></span>](#Default)  
 [<span data-ttu-id="d78b4-111">Die globale Warteschlange im Vergleich zu lokalen Warteschlangen</span><span class="sxs-lookup"><span data-stu-id="d78b4-111">The global queue vs. local queues</span></span>](#Queues)  
 [<span data-ttu-id="d78b4-112">Arbeits Diebstahl</span><span class="sxs-lookup"><span data-stu-id="d78b4-112">Work stealing</span></span>](#Stealing)  
 [<span data-ttu-id="d78b4-113">Aufgaben mit langer Ausführungszeit</span><span class="sxs-lookup"><span data-stu-id="d78b4-113">Long-running tasks</span></span>](#LongRunning)  
 [<span data-ttu-id="d78b4-114">Task Inlining</span><span class="sxs-lookup"><span data-stu-id="d78b4-114">Task inlining</span></span>](#Inlining)  
[<span data-ttu-id="d78b4-115">Angeben eines Synchronisierungs Kontexts</span><span class="sxs-lookup"><span data-stu-id="d78b4-115">Specifying a synchronization context</span></span>](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a><span data-ttu-id="d78b4-116">Der Standardaufgaben Planer und der Thread Pool</span><span class="sxs-lookup"><span data-stu-id="d78b4-116">The default task scheduler and the thread pool</span></span>  
 <span data-ttu-id="d78b4-117">Der Standard Planer für die Task Parallel Library und PLINQ verwendet den .NET Framework Thread Pool, der durch die <xref:System.Threading.ThreadPool>-Klasse dargestellt wird, um Arbeit in die Warteschlange zu stellen und auszuführen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-117">The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work.</span></span> <span data-ttu-id="d78b4-118">Der Thread Pool verwendet die Informationen, die vom <xref:System.Threading.Tasks.Task>-Typ bereitgestellt werden, um die differenzierte Parallelität (kurzlebige Arbeitseinheiten) effizient zu unterstützen, die parallele Tasks und Abfragen häufig darstellen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-118">The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</span></span>  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a><span data-ttu-id="d78b4-119">Die globale Warteschlange im Vergleich zu lokalen Warteschlangen</span><span class="sxs-lookup"><span data-stu-id="d78b4-119">The global queue vs. local queues</span></span>  
 <span data-ttu-id="d78b4-120">Der Thread Pool verwaltet eine globale FIFO-Arbeits Warteschlange (First in, First Out) für Threads in jeder Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="d78b4-120">The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</span></span> <span data-ttu-id="d78b4-121">Wenn ein Programm die <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (oder <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>)-Methode aufruft, wird die Arbeit in diese freigegebene Warteschlange eingereiht und schließlich auf den nächsten Thread, der verfügbar wird, deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="d78b4-121">Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</span></span> <span data-ttu-id="d78b4-122">Beginnend mit der .NET Framework 4 wurde diese Warteschlange verbessert, um einen Sperr freien Algorithmus zu verwenden, der der <xref:System.Collections.Concurrent.ConcurrentQueue%601>-Klasse ähnelt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-122">Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class.</span></span> <span data-ttu-id="d78b4-123">Mit dieser sperrenfreien Implementierung verbringt der Thread Pool weniger Zeit, wenn Arbeitselemente in die Warteschlange eingereiht und aus der Warteschlange entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-123">By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</span></span> <span data-ttu-id="d78b4-124">Dieser Leistungsvorteil ist für alle Programme verfügbar, die den Thread Pool verwenden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-124">This performance benefit is available to all programs that use the thread pool.</span></span>  
  
 <span data-ttu-id="d78b4-125">Aufgaben der obersten Ebene, bei denen es sich um Aufgaben handelt, die nicht im Kontext einer anderen Aufgabe erstellt werden, werden wie jedes andere Arbeitselement in der globalen Warteschlange abgelegt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-125">Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</span></span> <span data-ttu-id="d78b4-126">Geschachtelte oder untergeordnete Aufgaben, die im Kontext einer anderen Aufgabe erstellt werden, werden hingegen anders behandelt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-126">However, nested or child tasks, which are created in the context of another task, are handled quite differently.</span></span> <span data-ttu-id="d78b4-127">Ein untergeordnetes Element oder eine geschachtelte Aufgabe wird in einer lokalen Warteschlange abgelegt, die speziell für den Thread vorgesehen ist, in dem die übergeordnete Aufgabe ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d78b4-127">A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</span></span> <span data-ttu-id="d78b4-128">Die übergeordnete Aufgabe ist möglicherweise eine Aufgabe der obersten Ebene. Es kann sich jedoch auch um das untergeordnete Element einer anderen Aufgabe handeln.</span><span class="sxs-lookup"><span data-stu-id="d78b4-128">The parent task may be a top-level task or it also may be the child of another task.</span></span> <span data-ttu-id="d78b4-129">Wenn dieser Thread für weitere Arbeitsvorgänge bereit ist, wird zuerst eine Suche in der lokalen Warteschlange ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-129">When this thread is ready for more work, it first looks in the local queue.</span></span> <span data-ttu-id="d78b4-130">Wenn darin Arbeitsaufgaben warten, kann darauf schnell zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-130">If work items are waiting there, they can be accessed quickly.</span></span> <span data-ttu-id="d78b4-131">Auf die lokalen Warteschlangen wird in der Last-in-First-Out-Reihenfolge (LIFO) zugegriffen, um die Cache Lokalität beizubehalten und Konflikte zu verringern.</span><span class="sxs-lookup"><span data-stu-id="d78b4-131">The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</span></span> <span data-ttu-id="d78b4-132">Weitere Informationen zu untergeordneten und untergeordneten Aufgaben finden Sie unter [angefügte und getrennte](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)untergeordnete Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="d78b4-132">For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
 <span data-ttu-id="d78b4-133">Durch die Verwendung lokaler Warteschlangen wird nicht nur der Druck der globalen Warteschlange verringert, sondern auch die Daten Lokalität genutzt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-133">The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</span></span> <span data-ttu-id="d78b4-134">Arbeitselemente in der lokalen Warteschlange verweisen häufig auf Datenstrukturen, die im Arbeitsspeicher physisch nahe beieinander liegen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-134">Work items in the local queue frequently reference data structures that are physically near one another in memory.</span></span> <span data-ttu-id="d78b4-135">In diesen Fällen befinden sich die Daten bereits im Cache, nachdem die erste Aufgabe ausgeführt wurde und schnell auf Sie zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="d78b4-135">In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</span></span> <span data-ttu-id="d78b4-136">Sowohl [parallele LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) als auch die <xref:System.Threading.Tasks.Parallel>-Klasse verwenden in großem Umfang geschachtelte Tasks und untergeordnete Aufgaben und erzielen mithilfe der lokalen Arbeits Warteschlangen deutliche Beschleunigung.</span><span class="sxs-lookup"><span data-stu-id="d78b4-136">Both [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</span></span>  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a><span data-ttu-id="d78b4-137">Arbeits Diebstahl</span><span class="sxs-lookup"><span data-stu-id="d78b4-137">Work stealing</span></span>  
 <span data-ttu-id="d78b4-138">Beginnend mit dem .NET Framework 4 verfügt der Thread Pool auch über einen Arbeits Übernahme-Algorithmus, um sicherzustellen, dass sich keine Threads im Leerlauf befinden, während andere weiterhin in ihren Warteschlangen arbeiten.</span><span class="sxs-lookup"><span data-stu-id="d78b4-138">Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</span></span> <span data-ttu-id="d78b4-139">Wenn ein Threadpoolthread zusätzliche Arbeit übernehmen kann, wird zuerst am Anfang der lokalen Warteschlange, anschließend in der globalen Warteschlange und zuletzt in den lokalen Warteschlangen anderer Threads gesucht.</span><span class="sxs-lookup"><span data-stu-id="d78b4-139">When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</span></span> <span data-ttu-id="d78b4-140">Wenn ein Arbeitselement in der lokalen Warteschlange eines anderen Threads gefunden wird, wird zunächst Heuristik angewendet, um sicherzustellen, dass die Arbeit effizient ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d78b4-140">If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</span></span> <span data-ttu-id="d78b4-141">Wenn dies der Fall ist, wird das Arbeits Element aus der Warteschlange entfernt (in FIFO-Reihenfolge).</span><span class="sxs-lookup"><span data-stu-id="d78b4-141">If it can, it de-queues the work item from the tail (in FIFO order).</span></span> <span data-ttu-id="d78b4-142">Dadurch werden Konflikte in jeder lokalen Warteschlange verringert und der Datenort beibehalten.</span><span class="sxs-lookup"><span data-stu-id="d78b4-142">This reduces contention on each local queue and preserves data locality.</span></span> <span data-ttu-id="d78b4-143">Diese Architektur unterstützt den Thread Pool-Lastenausgleich effizienter als in früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-143">This architecture helps the thread pool load-balance work more efficiently than past versions did.</span></span>  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a><span data-ttu-id="d78b4-144">Aufgaben mit langer Ausführungszeit</span><span class="sxs-lookup"><span data-stu-id="d78b4-144">Long-running tasks</span></span>  
 <span data-ttu-id="d78b4-145">Unter Umständen möchten Sie ausdrücklich verhindern, dass eine Aufgabe in einer lokalen Warteschlange abgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="d78b4-145">You may want to explicitly prevent a task from being put on a local queue.</span></span> <span data-ttu-id="d78b4-146">Sie wissen möglicherweise z. B., dass ein bestimmtes Arbeitselement für eine relativ lange Zeit ausgeführt wird und daher wahrscheinlich alle anderen Arbeitselemente in der lokalen Warteschlange blockiert.</span><span class="sxs-lookup"><span data-stu-id="d78b4-146">For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</span></span> <span data-ttu-id="d78b4-147">In diesem Fall können Sie die <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>-Option angeben, die den Planer darauf hinweist, dass u. U. ein weiterer Thread für die Aufgabe erforderlich ist, damit der Fortschritt anderer Threads oder Arbeitselemente in der lokalen Warteschlange nicht blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="d78b4-147">In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</span></span> <span data-ttu-id="d78b4-148">Mit dieser Option vermeiden Sie den Thread Pool vollständig, einschließlich der globalen und lokalen Warteschlangen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-148">By using this option you avoid the thread pool completely, including the global and local queues.</span></span>  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a><span data-ttu-id="d78b4-149">Task Inlining</span><span class="sxs-lookup"><span data-stu-id="d78b4-149">Task inlining</span></span>  
 <span data-ttu-id="d78b4-150">In einigen Fällen, in denen eine <xref:System.Threading.Tasks.Task> gewartet wird, wird Sie möglicherweise synchron in dem Thread ausgeführt, der den warte Vorgang ausführt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-150">In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</span></span> <span data-ttu-id="d78b4-151">Dadurch wird die Leistung verbessert, da ein zusätzlicher Thread nicht mehr benötigt wird und stattdessen der vorhandene Thread verwendet wird, der andernfalls blockiert wäre.</span><span class="sxs-lookup"><span data-stu-id="d78b4-151">This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</span></span> <span data-ttu-id="d78b4-152">Um Fehler aufgrund eines erneuten Eintretens zu vermeiden, tritt das Inlining der Aufgabe nur auf, wenn das warte Ziel in der lokalen Warteschlange des relevanten Threads gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="d78b4-152">To prevent errors due to reentrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</span></span>  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a><span data-ttu-id="d78b4-153">Angeben eines Synchronisierungs Kontexts</span><span class="sxs-lookup"><span data-stu-id="d78b4-153">Specifying a synchronization context</span></span>  
 <span data-ttu-id="d78b4-154">Sie können mit der <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType>-Methode angeben, dass eine Aufgabe für die Ausführung in einem bestimmten Thread geplant werden soll.</span><span class="sxs-lookup"><span data-stu-id="d78b4-154">You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method to specify that a task should be scheduled to run on a particular thread.</span></span> <span data-ttu-id="d78b4-155">Dies ist in Frameworks wie Windows Forms und Windows Presentation Foundation hilfreich, wo der Zugriff auf Benutzeroberflächenobjekte oftmals auf Code beschränkt ist, der in dem Thread ausgeführt wird, in dem das Benutzeroberflächenobjekt erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="d78b4-155">This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</span></span>  
  
 <span data-ttu-id="d78b4-156">Im folgenden Beispiel wird die <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType>-Methode in einer Windows Presentation Foundation (WPF)-App verwendet, um eine Aufgabe im gleichen Thread zu planen, in dem auch das Steuerelement der Benutzeroberfläche erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="d78b4-156">The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</span></span>   <span data-ttu-id="d78b4-157">Im Beispiel wird ein Mosaik von Bildern erstellt, die nach dem Zufallsprinzip aus einem angegebenen Verzeichnis ausgewählt werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-157">The example creates a mosaic of images that are randomly selected from a specified directory.</span></span> <span data-ttu-id="d78b4-158">Die WPF-Objekte werden verwendet, um die Bilder zu laden und zu ändern.</span><span class="sxs-lookup"><span data-stu-id="d78b4-158">The WPF objects are used to load and resize the images.</span></span> <span data-ttu-id="d78b4-159">Die Rohdaten werden dann an eine Aufgabe weitergegeben, die eine <xref:System.Threading.Tasks.Parallel.For%2A> Schleife verwendet, um die Pixeldaten in ein großes Einzel Byte Array zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d78b4-159">The raw pixels are then passed to a task that uses a <xref:System.Threading.Tasks.Parallel.For%2A> loop to write the pixel data into a large single-byte array.</span></span> <span data-ttu-id="d78b4-160">Es ist keine Synchronisierung erforderlich, da keine zwei Kacheln dieselben Array Elemente belegen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-160">No synchronization is required because no two tiles occupy the same array elements.</span></span> <span data-ttu-id="d78b4-161">Die Kacheln können auch in beliebiger Reihenfolge geschrieben werden, da ihre Position unabhängig von einer anderen Kachel berechnet wird.</span><span class="sxs-lookup"><span data-stu-id="d78b4-161">The tiles can also be written in any order because their position is calculated independently of any other tile.</span></span> <span data-ttu-id="d78b4-162">Das große Array wird dann an einen Task weitergeleitet, der im UI-Thread ausgeführt wird, in dem die Pixeldaten in ein Bild Steuerelement geladen werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-162">The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</span></span>  
  
 <span data-ttu-id="d78b4-163">Im Beispiel werden Daten aus dem UI-Thread verschoben, mithilfe paralleler Schleifen und <xref:System.Threading.Tasks.Task> Objekten geändert und dann an eine Aufgabe zurückgeleitet, die im UI-Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d78b4-163">The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread.</span></span> <span data-ttu-id="d78b4-164">Diese Vorgehensweise ist nützlich, wenn Sie die Task Parallel Library zum Durchführen von Vorgängen verwenden müssen, die von der WPF-API nicht unterstützt werden oder nicht ausreichend schnell sind.</span><span class="sxs-lookup"><span data-stu-id="d78b4-164">This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</span></span> <span data-ttu-id="d78b4-165">Eine weitere Möglichkeit zum Erstellen eines Bild Mosaiks in WPF ist die Verwendung eines <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> Steuer Elements und das Hinzufügen von Bildern.</span><span class="sxs-lookup"><span data-stu-id="d78b4-165">Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> control and add images to it.</span></span> <span data-ttu-id="d78b4-166">Der <xref:System.Windows.Controls.WrapPanel> behandelt die Positionierung der Kacheln.</span><span class="sxs-lookup"><span data-stu-id="d78b4-166">The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles.</span></span> <span data-ttu-id="d78b4-167">Diese Arbeit kann jedoch nur im UI-Thread ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-167">However, this work can only be performed on the UI thread.</span></span>  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 <span data-ttu-id="d78b4-168">Um das Beispiel zu erstellen, erstellen Sie ein WPF-Anwendungsprojekt in Visual Studio, und benennen Sie C# es WPF_CS1 (für ein WPF-Projekt) oder WPF_VB1 (für ein Visual Basic WPF-Projekt).</span><span class="sxs-lookup"><span data-stu-id="d78b4-168">To create the example, create a WPF application project in Visual Studio and name it WPF_CS1 (for a C# WPF project) or WPF_VB1 (for a Visual Basic WPF project).</span></span> <span data-ttu-id="d78b4-169">Führen Sie dann folgende Schritte aus:</span><span class="sxs-lookup"><span data-stu-id="d78b4-169">Then do the following:</span></span>  
  
1. <span data-ttu-id="d78b4-170">Ziehen Sie in der Entwurfs Ansicht ein <xref:System.Windows.Controls.Image>-Steuerelement aus der **Toolbox** auf die linke obere Ecke der Entwurfs Oberfläche.</span><span class="sxs-lookup"><span data-stu-id="d78b4-170">In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** onto the upper left corner of the design surface.</span></span> <span data-ttu-id="d78b4-171">Benennen Sie das Steuerelement im Textfeld **Name** des Fensters **Eigenschaften** mit dem Namen "Image".</span><span class="sxs-lookup"><span data-stu-id="d78b4-171">In the **Name** textbox of the **Properties** window, name the control "image".</span></span>    
  
2. <span data-ttu-id="d78b4-172">Ziehen Sie ein <xref:System.Windows.Controls.Button>-Steuerelement aus der **Toolbox** in den unteren linken Bereich des Anwendungsfensters.</span><span class="sxs-lookup"><span data-stu-id="d78b4-172">Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window.</span></span> <span data-ttu-id="d78b4-173">Geben Sie in der XAML-Ansicht die <xref:System.Windows.Controls.ContentControl.Content%2A>-Eigenschaft der Schaltfläche als "Make a Mosaic" an, und geben Sie die <xref:System.Windows.FrameworkElement.Width>-Eigenschaft als "100" an.</span><span class="sxs-lookup"><span data-stu-id="d78b4-173">In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as "Make a mosaic", and specify its <xref:System.Windows.FrameworkElement.Width> property as "100".</span></span> <span data-ttu-id="d78b4-174">Verbinden Sie das <xref:System.Windows.Controls.Primitives.ButtonBase.Click>-Ereignis mit dem `button_Click` Ereignishandler, der im Code des Beispiels definiert ist, indem Sie dem `<Button>` Element `Click="button_Click"` hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-174">Connect the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with the `button_Click` event handler defined in the example's code by adding `Click="button_Click"` to the `<Button>` element.</span></span> <span data-ttu-id="d78b4-175">Benennen Sie das Steuerelement im Textfeld **Name** des Fensters **Eigenschaften** mit "Schaltfläche".</span><span class="sxs-lookup"><span data-stu-id="d78b4-175">In the **Name** textbox of the **Properties** window, name the control "button".</span></span>  
  
3. <span data-ttu-id="d78b4-176">Ersetzen Sie den gesamten Inhalt der MainWindow.XAML.cs-oder MainWindow. XAML. vb-Datei durch den Code aus diesem Beispiel.</span><span class="sxs-lookup"><span data-stu-id="d78b4-176">Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</span></span> <span data-ttu-id="d78b4-177">Stellen Sie C# bei einem WPF-Projekt sicher, dass der Name des Arbeitsbereichs mit dem Projektnamen übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-177">For a C# WPF project, make sure that the name of the workspace matches the project name.</span></span> 
  
4. <span data-ttu-id="d78b4-178">Im Beispiel werden JPEG-Bilder aus einem Verzeichnis namens c:\Users\Public\Pictures\Sample Pictures\\gelesen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-178">The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures\\.</span></span> <span data-ttu-id="d78b4-179">Erstellen Sie das Verzeichnis, und platzieren Sie einige Bilder, oder ändern Sie den Pfad so, dass er auf ein anderes Verzeichnis verweist, das Bilder enthält.</span><span class="sxs-lookup"><span data-stu-id="d78b4-179">Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</span></span> 
  
<span data-ttu-id="d78b4-180">In diesem Beispiel sind einige Einschränkungen zu beachten.</span><span class="sxs-lookup"><span data-stu-id="d78b4-180">This example has some limitations.</span></span> <span data-ttu-id="d78b4-181">Beispielsweise werden nur 32 Bits pro Pixel-Bilder unterstützt. Bilder in anderen Formaten werden während des Vorgangs zum Ändern der Größe durch das <xref:System.Windows.Media.Imaging.BitmapImage> Objekt beschädigt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-181">For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation.</span></span> <span data-ttu-id="d78b4-182">Außerdem müssen die Quell Images alle größer als die Kachel Größe sein.</span><span class="sxs-lookup"><span data-stu-id="d78b4-182">Also, the source images must all be larger than the tile size.</span></span> <span data-ttu-id="d78b4-183">Als weitere Übung können Sie Funktionen hinzufügen, mit denen mehrere Pixel Formate und Dateigrößen behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-183">As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</span></span>  
  
## Examples  
 <span data-ttu-id="d78b4-184">Das folgende Beispiel stammt aus den [Beispielen für die parallele Programmierung mit dem .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) auf der MSDN Code Gallery-Website.</span><span class="sxs-lookup"><span data-stu-id="d78b4-184">The following example is taken from the [Samples for Parallel Programming with the .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) on the MSDN Code Gallery Web site.</span></span>  <span data-ttu-id="d78b4-185">Es wird ein benutzerdefinierter Taskplaner erstellt, der die Anzahl der Threads einschränkt, die von der APP verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-185">It creates a custom task scheduler that limits the number of threads used by the app.</span></span> <span data-ttu-id="d78b4-186">Anschließend werden zwei Aufgaben Sätze gestartet, und es werden Informationen über die Aufgabe und den Thread angezeigt, in dem die Aufgabe ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d78b4-186">It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</span></span>  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 <span data-ttu-id="d78b4-187">Außerdem sind mehrere Beispiel Aufgabenplaner in der Code Gallery verfügbar: [Beispiele für die parallele Programmierung mit dem .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).</span><span class="sxs-lookup"><span data-stu-id="d78b4-187">In addition, several sample task schedulers are available on Code Gallery: [Samples for Parallel Programming with the .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="d78b4-188">Alle Member des abstrakten <see cref="T:System.Threading.Tasks.TaskScheduler" /> Typs sind Thread sicher und können gleichzeitig von mehreren Threads verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-188">All members of the abstract <see cref="T:System.Threading.Tasks.TaskScheduler" /> type are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="d78b4-189">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="d78b4-189">Task Parallel Library (TPL)</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d78b4-190">Initialisiert das <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="d78b4-190">Initializes the <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="d78b4-191">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="d78b4-191">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d78b4-192">Ruft den zugeordneten <see cref="T:System.Threading.Tasks.TaskScheduler" /> der derzeit ausgeführten Aufgabe ab.</span><span class="sxs-lookup"><span data-stu-id="d78b4-192">Gets the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span></span></summary>
        <value><span data-ttu-id="d78b4-193">Gibt den zugeordneten <see cref="T:System.Threading.Tasks.TaskScheduler" /> der momentan ausgeführten Aufgabe zurück.</span><span class="sxs-lookup"><span data-stu-id="d78b4-193">Returns the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d78b4-194">Wenn Sie nicht innerhalb einer Aufgabe aufgerufen wird, gibt <xref:System.Threading.Tasks.TaskScheduler.Current%2A> den <xref:System.Threading.Tasks.TaskScheduler.Default%2A> Scheduler zurück.</span><span class="sxs-lookup"><span data-stu-id="d78b4-194">When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler.</span></span>  
  
 <span data-ttu-id="d78b4-195">Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="d78b4-195">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="d78b4-196">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="d78b4-196">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d78b4-197">Ruft die <see cref="T:System.Threading.Tasks.TaskScheduler" />-Standardinstanz ab, die von .NET Framework bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d78b4-197">Gets the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance that is provided by the .NET Framework.</span></span></summary>
        <value><span data-ttu-id="d78b4-198">Gibt die <see cref="T:System.Threading.Tasks.TaskScheduler" />-Standardinstanz zurück.</span><span class="sxs-lookup"><span data-stu-id="d78b4-198">Returns the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d78b4-199">Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="d78b4-199">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="d78b4-200">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="d78b4-200">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d78b4-201">Gibt alle Ressourcen frei, die diesem Planer zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="d78b4-201">Frees all resources associated with this scheduler.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d78b4-202">Erstellt einen <see cref="T:System.Threading.Tasks.TaskScheduler" />, der dem aktuellen <see cref="T:System.Threading.SynchronizationContext" /> zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="d78b4-202">Creates a <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />.</span></span></summary>
        <returns><span data-ttu-id="d78b4-203">Ein dem aktuellen <see cref="T:System.Threading.Tasks.TaskScheduler" /> gemäß Vorgabe durch den <see cref="T:System.Threading.SynchronizationContext" /> zugeordneter <see cref="P:System.Threading.SynchronizationContext.Current" />.</span><span class="sxs-lookup"><span data-stu-id="d78b4-203">A <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />, as determined by <see cref="P:System.Threading.SynchronizationContext.Current" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d78b4-204">Alle <xref:System.Threading.Tasks.Task> Instanzen, die für den zurückgegebenen Scheduler in die Warteschlange eingereiht werden, werden über einen aufzurufenden <xref:System.Threading.SynchronizationContext.Post%2A> Methode in diesem Kontext ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-204">All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context.</span></span>  
  
 <span data-ttu-id="d78b4-205">Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="d78b4-205">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d78b4-206">Der aktuelle SynchronizationContext kann nicht als TaskScheduler verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-206">The current SynchronizationContext may not be used as a TaskScheduler.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="d78b4-207">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="d78b4-207">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d78b4-208">Nur für Debuggerunterstützung: Generiert eine Enumeration von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, die sich gegenwärtig in der Warteschlange des Taskplaners befinden und auf ihre Ausführung warten.</span><span class="sxs-lookup"><span data-stu-id="d78b4-208">For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" /> instances currently queued to the scheduler waiting to be executed.</span></span></summary>
        <returns><span data-ttu-id="d78b4-209">Eine Aufzählung, in der von einem Debugger die gegenwärtig in der Warteschlange dieses Taskplaners enthaltenen Aufgaben durchsucht werden können.</span><span class="sxs-lookup"><span data-stu-id="d78b4-209">An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d78b4-210">Eine von <xref:System.Threading.Tasks.TaskScheduler> abgeleitete Klasse implementiert diese Methode, um die Integration mit Debuggern zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-210">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers.</span></span> <span data-ttu-id="d78b4-211">Diese Methode wird nur vom .NET Framework aufgerufen, wenn der Debugger Zugriff auf die Daten anfordert.</span><span class="sxs-lookup"><span data-stu-id="d78b4-211">This method will only be invoked by the .NET Framework when the debugger requests access to the data.</span></span> <span data-ttu-id="d78b4-212">Die zurückgegebene Aufzählung wird durch debugginghilfsprogramme durchlaufen, um auf die derzeit in der Warteschlange befindlichen Aufgaben zuzugreifen, sodass der Debugger eine Darstellung dieser Informationen auf der Benutzeroberfläche bereitstellen kann.</span><span class="sxs-lookup"><span data-stu-id="d78b4-212">The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</span></span>  
  
 <span data-ttu-id="d78b4-213">Beachten Sie Folgendes: Wenn diese Methode aufgerufen wird, werden alle anderen Threads im Prozess fixiert.</span><span class="sxs-lookup"><span data-stu-id="d78b4-213">It is important to note that, when this method is called, all other threads in the process will be frozen.</span></span> <span data-ttu-id="d78b4-214">Daher ist es wichtig, die Synchronisierung mit anderen Threads zu vermeiden, die zu Blockierungen führen können.</span><span class="sxs-lookup"><span data-stu-id="d78b4-214">Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</span></span> <span data-ttu-id="d78b4-215">Wenn eine Synchronisierung erforderlich ist und Sie die Sperre in dieser Methode nicht abrufen können, sollten Sie eine Ausnahme auslösen, damit der Debugger nicht blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="d78b4-215">If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not block.</span></span> <span data-ttu-id="d78b4-216">Das folgende Beispiel zeigt einen möglichen Ansatz in C#:</span><span class="sxs-lookup"><span data-stu-id="d78b4-216">The following example shows one possible approach in C#:</span></span>
  
```csharp
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 <span data-ttu-id="d78b4-217">Außerdem dürfen diese Methode und die zurückgegebene Aufzähl Bare keinen global sichtbaren Zustand ändern.</span><span class="sxs-lookup"><span data-stu-id="d78b4-217">Additionally, this method and the enumerable returned must not modify any globally visible state.</span></span>  
  
 <span data-ttu-id="d78b4-218">Der zurückgegebene Aufzähl Bare darf nie NULL sein.</span><span class="sxs-lookup"><span data-stu-id="d78b4-218">The returned enumerable should never be null.</span></span> <span data-ttu-id="d78b4-219">Wenn zurzeit keine Tasks in der Warteschlange vorhanden sind, sollte stattdessen ein leeres Aufzähl bares Element zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-219">If there are currently no queued tasks, an empty enumerable should be returned instead.</span></span>  
  
 <span data-ttu-id="d78b4-220">Entwickler, die benutzerdefinierte debuggger implementieren, sollten diese Methode nicht direkt aufrufen, sondern sollten stattdessen die interne Wrapper Methode `GetScheduledTasksForDebugger` verwenden: `internal Task[] GetScheduledTasksForDebugger()`.</span><span class="sxs-lookup"><span data-stu-id="d78b4-220">Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`.</span></span> <span data-ttu-id="d78b4-221">Diese Wrapper Methode gibt ein Array von Aufgaben anstelle eines Aufzähl baren zurück.</span><span class="sxs-lookup"><span data-stu-id="d78b4-221">This wrapper method returns an array of tasks instead of an enumerable.</span></span> <span data-ttu-id="d78b4-222">Zum Abrufen einer Liste aktiver Planer verwenden Sie die interne Methode `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span><span class="sxs-lookup"><span data-stu-id="d78b4-222">To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span></span> <span data-ttu-id="d78b4-223">Diese statische Methode gibt ein Array aller aktiven <xref:System.Threading.Tasks.TaskScheduler> Instanzen zurück.</span><span class="sxs-lookup"><span data-stu-id="d78b4-223">This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances.</span></span> <span data-ttu-id="d78b4-224">Anschließend können Sie `GetScheduledTasksForDebugger` für jede Scheduler-Instanz verwenden, um die Liste der geplanten Aufgaben abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-224">You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d78b4-225">Dieser Planer kann derzeit keine Liste in der Warteschlange stehender Aufgaben generieren.</span><span class="sxs-lookup"><span data-stu-id="d78b4-225">This scheduler is unable to generate a list of queued tasks at this time.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="d78b4-226">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="d78b4-226">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d78b4-227">Ruft die eindeutige ID für diesen <see cref="T:System.Threading.Tasks.TaskScheduler" /> ab.</span><span class="sxs-lookup"><span data-stu-id="d78b4-227">Gets the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <value><span data-ttu-id="d78b4-228">Gibt die eindeutige ID für diesen <see cref="T:System.Threading.Tasks.TaskScheduler" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="d78b4-228">Returns the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d78b4-229">Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="d78b4-229">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="d78b4-230">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="d78b4-230">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d78b4-231">Gibt die maximale Parallelitätsebene an, die dieser <see cref="T:System.Threading.Tasks.TaskScheduler" /> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-231">Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler" /> is able to support.</span></span></summary>
        <value><span data-ttu-id="d78b4-232">Gibt eine ganze Zahl zurück, die die maximale Parallelitätsebene darstellt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-232">Returns an integer that represents the maximum concurrency level.</span></span> <span data-ttu-id="d78b4-233">Der Standardplaner gibt <see cref="F:System.Int32.MaxValue" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="d78b4-233">The default scheduler returns <see cref="F:System.Int32.MaxValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d78b4-234">Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="d78b4-234">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="d78b4-235">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="d78b4-235">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub QueueTask (task As Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="d78b4-236">Der <see cref="T:System.Threading.Tasks.Task" />, der in die Warteschlange eingereiht werden soll.</span><span class="sxs-lookup"><span data-stu-id="d78b4-236">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</span></span></param>
        <summary><span data-ttu-id="d78b4-237">Fügt einen <see cref="T:System.Threading.Tasks.Task" /> in die Warteschlange des Planers ein.</span><span class="sxs-lookup"><span data-stu-id="d78b4-237">Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d78b4-238">Eine von <xref:System.Threading.Tasks.TaskScheduler> abgeleitete Klasse implementiert diese Methode, um Aufgaben zu akzeptieren, die im Scheduler geplant werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-238">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler.</span></span>  
  
 <span data-ttu-id="d78b4-239">Eine typische-Implementierung speichert die Aufgabe in einer internen Datenstruktur, die von Threads gewartet wird, die diese Aufgaben zu einem späteren Zeitpunkt ausführen würden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-239">A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</span></span>  
  
 <span data-ttu-id="d78b4-240">Diese Methode soll nur vom .NET Framework aufgerufen werden und sollte nicht direkt von der abgeleiteten Klasse aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-240">This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</span></span> <span data-ttu-id="d78b4-241">Dies ist erforderlich, um die Konsistenz des Systems zu gewährleisten.</span><span class="sxs-lookup"><span data-stu-id="d78b4-241">This is necessary for maintaining the consistency of the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d78b4-242">Das <paramref name="task" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="d78b4-242">The <paramref name="task" /> argument is null.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="d78b4-243">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="d78b4-243">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function TryDequeue (task As Task) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="d78b4-244">Das <see cref="T:System.Threading.Tasks.Task" />, das aus der Warteschlange entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d78b4-244">The <see cref="T:System.Threading.Tasks.Task" /> to be dequeued.</span></span></param>
        <summary><span data-ttu-id="d78b4-245">Versucht, einen zuvor in die Warteschlange dieses Planers eingereihten <see cref="T:System.Threading.Tasks.Task" /> aus der Warteschlange zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-245">Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task" /> that was previously queued to this scheduler.</span></span></summary>
        <returns><span data-ttu-id="d78b4-246">Ein boolescher Wert, der angibt, ob das <paramref name="task" />-Argument erfolgreich aus der Warteschlange entfernt wurde.</span><span class="sxs-lookup"><span data-stu-id="d78b4-246">A Boolean denoting whether the <paramref name="task" /> argument was successfully dequeued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d78b4-247">Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="d78b4-247">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 <span data-ttu-id="d78b4-248">Diese Methode kann in einem schließlich-Block ausgeführt werden. Daher sollte Sie so schnell wie möglich zurückgeben, damit alle Ressourcen wie <xref:System.Threading.CancellationTokenRegistration> Objekte rechtzeitig verworfen werden können.</span><span class="sxs-lookup"><span data-stu-id="d78b4-248">This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d78b4-249">Das <paramref name="task" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="d78b4-249">The <paramref name="task" /> argument is null.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="d78b4-250">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="d78b4-250">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="VB.NET" Value="Protected Function TryExecuteTask (task As Task) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="d78b4-251">Ein auszuführendes <see cref="T:System.Threading.Tasks.Task" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-251">A <see cref="T:System.Threading.Tasks.Task" /> object to be executed.</span></span></param>
        <summary><span data-ttu-id="d78b4-252">Versucht, den angegebenen <see cref="T:System.Threading.Tasks.Task" /> mit diesem Planer auszuführen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-252">Attempts to execute the provided <see cref="T:System.Threading.Tasks.Task" /> on this scheduler.</span></span></summary>
        <returns><span data-ttu-id="d78b4-253">Ein boolescher Wert, der true ist, wenn <paramref name="task" /> erfolgreich ausgeführt wurde. Andernfalls ist dieser Wert false.</span><span class="sxs-lookup"><span data-stu-id="d78b4-253">A Boolean that is true if <paramref name="task" /> was successfully executed, false if it was not.</span></span> <span data-ttu-id="d78b4-254">Ein häufiger Grund für Ausführungsfehler besteht darin, dass die Aufgabe zuvor ausgeführt wurde oder gerade von einem anderen Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d78b4-254">A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d78b4-255">Scheduler-Implementierungen werden <xref:System.Threading.Tasks.Task> Instanzen bereitgestellt, die entweder über die <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A>-Methode oder die <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A>-Methode ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-255">Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method.</span></span> <span data-ttu-id="d78b4-256">Wenn der Scheduler es für die Durchführung der bereitgestellten Aufgabe geeignet hält, sollten Sie hierfür <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> verwenden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-256">When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so.</span></span> <span data-ttu-id="d78b4-257">TryExecuteTask behandelt alle Aspekte der Ausführung einer Aufgabe, einschließlich Aktions Aufruf, Ausnahmebehandlung, Zustands Verwaltung und Lebenszyklus Steuerung.</span><span class="sxs-lookup"><span data-stu-id="d78b4-257">TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</span></span>  
  
 <span data-ttu-id="d78b4-258"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> darf nur für Aufgaben verwendet werden, die diesem Scheduler von der .NET Framework-Infrastruktur bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-258"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</span></span> <span data-ttu-id="d78b4-259">Sie sollte nicht verwendet werden, um beliebige Aufgaben auszuführen, die über benutzerdefinierte Mechanismen abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-259">It should not be used to execute arbitrary tasks obtained through custom mechanisms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d78b4-260">Der <paramref name="task" /> ist nicht diesem Planer zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="d78b4-260">The <paramref name="task" /> is not associated with this scheduler.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="d78b4-261">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="d78b4-261">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function TryExecuteTaskInline (task As Task, taskWasPreviouslyQueued As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="d78b4-262">Das auszuführende <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="d78b4-262">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</span></span></param>
        <param name="taskWasPreviouslyQueued"><span data-ttu-id="d78b4-263">Ein boolescher Wert, der angibt, ob die Aufgabe zuvor in die Warteschlange eingereiht wurde.</span><span class="sxs-lookup"><span data-stu-id="d78b4-263">A Boolean denoting whether or not task has previously been queued.</span></span> <span data-ttu-id="d78b4-264">Wenn dieser Parameter true ist, wurde die Aufgabe möglicherweise zuvor in die Warteschlange eingereiht (geplant). Ist er false, wurde die Aufgabe bekanntermaßen nicht in die Warteschlange eingereiht, und dieser Aufruf wird ausgeführt, um die Aufgabe inline auszuführen, ohne sie in die Warteschlange einzureihen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-264">If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</span></span></param>
        <summary><span data-ttu-id="d78b4-265">Bestimmt, ob der angegebene <see cref="T:System.Threading.Tasks.Task" /> in diesem Aufruf synchron ausgeführt werden kann, und führt ihn aus, wenn dies der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="d78b4-265">Determines whether the provided <see cref="T:System.Threading.Tasks.Task" /> can be executed synchronously in this call, and if it can, executes it.</span></span></summary>
        <returns><span data-ttu-id="d78b4-266">Ein boolescher Wert, der angibt, ob die Aufgabe inline ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="d78b4-266">A Boolean value indicating whether the task was executed inline.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d78b4-267">Eine von <xref:System.Threading.Tasks.TaskScheduler> abgeleitete Klasse implementiert diese Funktion, um die Inline Ausführung einer Aufgabe in einem Thread zu unterstützen, der einen Warte Vorgang auf dieses Aufgaben Objekt initiiert.</span><span class="sxs-lookup"><span data-stu-id="d78b4-267">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</span></span> <span data-ttu-id="d78b4-268">Die Inline Ausführung ist optional, und die Anforderung kann zurückgewiesen werden, indem Sie false zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="d78b4-268">Inline execution is optional, and the request may be rejected by returning false.</span></span> <span data-ttu-id="d78b4-269">Die mehr Aufgaben, die Inline sein können, desto besser wird der Planer skalieren.</span><span class="sxs-lookup"><span data-stu-id="d78b4-269">However, the more tasks that can be inlined, the better the scheduler will scale.</span></span> <span data-ttu-id="d78b4-270">Tatsächlich kann ein Scheduler, der zu wenig Zeilen zuweist, anfällig für Deadlocks werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-270">In fact, a scheduler that inlines too little may be prone to deadlocks.</span></span> <span data-ttu-id="d78b4-271">Eine ordnungsgemäße Implementierung sollte sicherstellen, dass eine Anforderung, die unter den vom Planer garantierten Richtlinien ausgeführt wird, erfolgreich Inline ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d78b4-271">A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</span></span> <span data-ttu-id="d78b4-272">Wenn ein Planer z. b. einen dedizierten Thread zum Ausführen von Aufgaben verwendet, sollten alle inlining-Anforderungen von diesem Thread erfolgreich sein.</span><span class="sxs-lookup"><span data-stu-id="d78b4-272">For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</span></span>  
  
 <span data-ttu-id="d78b4-273">Wenn ein Scheduler beschließt, die Inline Ausführung auszuführen, sollte dies durch Aufrufen der <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> Methode des Basis Task Schedulers mit dem bereitgestellten Aufgaben Objekt erfolgen, wobei der Rückgabewert weitergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="d78b4-273">If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value.</span></span> <span data-ttu-id="d78b4-274">Es kann auch sinnvoll sein, eine Inline Aufgabe aus den internen Datenstrukturen zu entfernen, wenn Sie die Inlining-Anforderung beachten soll.</span><span class="sxs-lookup"><span data-stu-id="d78b4-274">It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</span></span> <span data-ttu-id="d78b4-275">Beachten Sie jedoch, dass ein Scheduler unter bestimmten Umständen aufgefordert werden kann, eine Aufgabe Inline zu einem Task hinzuweisen, die ihm zuvor nicht mit der <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A>-Methode bereitgestellt wurde.</span><span class="sxs-lookup"><span data-stu-id="d78b4-275">Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.</span></span>  
  
 <span data-ttu-id="d78b4-276">Der abgeleitete Scheduler ist dafür verantwortlich, sicherzustellen, dass der aufrufende Thread für die Ausführung der angegebenen Aufgabe geeignet ist, soweit es seine eigenen Planungs-und Ausführungsrichtlinien betrifft.</span><span class="sxs-lookup"><span data-stu-id="d78b4-276">The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</span></span>  
  
 <span data-ttu-id="d78b4-277">Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="d78b4-277">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d78b4-278">Das <paramref name="task" />-Argument ist null.</span><span class="sxs-lookup"><span data-stu-id="d78b4-278">The <paramref name="task" /> argument is null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d78b4-279">Der <paramref name="task" /> wurde bereits ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d78b4-279">The <paramref name="task" /> was already executed.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="d78b4-280">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="d78b4-280">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d78b4-281">Tritt auf, kurz bevor eine nicht überwachte Ausnahme eines Tasks, bei dem ein Fehler aufgetreten ist, eine Ausnahmeausweitungsrichtlinie auslöst, was standardmäßig den Prozess beenden würde.</span><span class="sxs-lookup"><span data-stu-id="d78b4-281">Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d78b4-282">Dieses Anwendungs Domänen übergreifende Ereignis bietet einen Mechanismus, um zu verhindern, dass die Ausnahme Eskalations Richtlinie, die den Prozessstandard mäßig beendet, ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="d78b4-282">This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</span></span>  
  
 <span data-ttu-id="d78b4-283">Um Entwicklern das Schreiben von asynchronem Code auf der Grundlage von Aufgaben zu erleichtern, ändert der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] das standardmäßige Ausnahme Verhalten bei nicht beobachteten Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d78b4-283">To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions.</span></span> <span data-ttu-id="d78b4-284">Obwohl bei nicht beobachteten Ausnahmen weiterhin die <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> Ausnahme ausgelöst wird, wird der ProzessStandard mäßig nicht beendet.</span><span class="sxs-lookup"><span data-stu-id="d78b4-284">Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default.</span></span> <span data-ttu-id="d78b4-285">Stattdessen wird die Ausnahme von der Laufzeit behandelt, nachdem das-Ereignis ausgelöst wurde, unabhängig davon, ob ein Ereignishandler die Ausnahme beachtet.</span><span class="sxs-lookup"><span data-stu-id="d78b4-285">Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</span></span> <span data-ttu-id="d78b4-286">Dieses Verhalten kann konfiguriert werden.</span><span class="sxs-lookup"><span data-stu-id="d78b4-286">This behavior can be configured.</span></span> <span data-ttu-id="d78b4-287">Beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)]können Sie das [`<ThrowUnobservedTaskExceptions>`](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md) Configuration-Element verwenden, um das Verhalten des [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] wiederherzustellen und den Prozess zu beenden:</span><span class="sxs-lookup"><span data-stu-id="d78b4-287">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the [`<ThrowUnobservedTaskExceptions>`](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md) configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:</span></span>  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="d78b4-288">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="d78b4-288">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md"><span data-ttu-id="d78b4-289">&lt;throwunobservedtaskexceptions&gt; Element</span><span class="sxs-lookup"><span data-stu-id="d78b4-289">&lt;ThrowUnobservedTaskExceptions&gt; Element</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
