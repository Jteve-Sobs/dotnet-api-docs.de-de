<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b8c7170ce5ac0632458a657d3d57ad5f78a71889" /><Meta Name="ms.sourcegitcommit" Value="3f21796619d6e69ad383c958cc013ce44c0678de" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/11/2019" /><Meta Name="ms.locfileid" Value="56073078" /></Metadata><TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Objekt dar, das die Einreihung von Aufgaben in Threads auf niedriger Ebene behandelt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanz von der <xref:System.Threading.Tasks.TaskScheduler> Klasse stellt einen Aufgabenplaner. Durch einen Aufgabenplaner wird sichergestellt, dass die Arbeit einer Aufgabe schließlich ausgeführt wird.  
  
 Der standardmäßige Taskplaner basiert auf dem .NET Framework 4-Threadpool, der Arbeitsübernahme für Lastenausgleich und Threadeinfügung/-deaktivierung für maximalen Durchsatz ermöglicht und für eine gute Gesamtleistung sorgt. Dies ist für die meisten Szenarien in der Regel ausreichend.  
  
 Die <xref:System.Threading.Tasks.TaskScheduler> Klasse dient auch als den Erweiterungspunkt für alle anpassbaren Planungslogik.  Dies schließt die Mechanismen, wie z. B. eine Aufgabe für die Ausführung, und wie geplante Aufgaben planen für Debugger verfügbar gemacht werden sollen. Wenn Sie spezielle Funktionen benötigen, können Sie einen benutzerdefinierten Planer erstellen und aktivieren es für bestimmte Aufgaben oder Abfragen.  
  
 In diesem Thema:  
[Der standardmäßige Aufgabenplaner und der Threadpool der Warteschleife hinzu](#Default)  
 [Der globalen Warteschlange im Vergleich zu lokalen Warteschlangen](#Queues)  
 [Arbeitsübernahme](#Stealing)  
 [Lang ausgeführte Aufgaben](#LongRunning)  
 [Aufgabeninlining](#Inlining)  
[Angeben eines Synchronisierungskontexts](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>Der standardmäßige Aufgabenplaner und der Threadpool der Warteschleife hinzu  
 Der Standardplaner für die Task Parallel Library und PLINQ verwendet den .NET Framework-Threadpool, der durch dargestellt wird die <xref:System.Threading.ThreadPool> -Klasse, in die Warteschlange und Aufgaben. Der Threadpool verwendet, die Informationen, die von bereitgestellte der <xref:System.Threading.Tasks.Task> Typ, der den differenzierten Parallelismus (kurzlebige Arbeitseinheiten), die Aufgaben und Abfragen oft darstellen parallele effizient zu unterstützen.  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>Der globalen Warteschlange im Vergleich zu lokalen Warteschlangen  
 Der Threadpool verwaltet Warteschlangen für Threads in jeder Anwendungsdomäne eine globale FIFO (First in, First-Out) zu arbeiten. Jedes Mal, wenn ein Programm ruft die <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (oder <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) Methode, die Arbeit in dieser freigegebenen Warteschlange abgelegt und schließlich aufheben in der Warteschlange im nächsten Thread, der verfügbar wird. Ab .NET Framework 4 wird diese Warteschlange wurde verbessert, um einen sperrenfreien Algorithmus zu verwenden, die ähnelt der <xref:System.Collections.Concurrent.ConcurrentQueue%601> Klasse. Mit dieser sperrenfreien Implementierung können Zeitaufwand weniger für der Threadpool bei Aufhebung die Warteschlange gestellt und Arbeitsaufgaben. Dieser Leistungsvorteil steht auf alle Programme, die den Threadpool zu verwenden.  
  
 Aufgaben der obersten Ebene, bei denen es sich um Aufgaben handelt, die nicht im Kontext einer anderen Aufgabe erstellt werden, werden wie jedes andere Arbeitselement in der globalen Warteschlange abgelegt. Geschachtelte oder untergeordnete Aufgaben, die im Kontext einer anderen Aufgabe erstellt werden, werden hingegen anders behandelt. Ein untergeordnetes Element oder eine geschachtelte Aufgabe wird in einer lokalen Warteschlange abgelegt, die speziell für den Thread vorgesehen ist, in dem die übergeordnete Aufgabe ausgeführt wird. Die übergeordnete Aufgabe ist möglicherweise eine Aufgabe der obersten Ebene. Es kann sich jedoch auch um das untergeordnete Element einer anderen Aufgabe handeln. Wenn dieser Thread für weitere Arbeitsvorgänge bereit ist, wird zuerst eine Suche in der lokalen Warteschlange ausgeführt. Wenn darin Arbeitselemente warten, kann darauf schnell zugegriffen werden. Die lokalen Warteschlangen werden zugegriffen, in der Last in, First Out (LIFO)-Prinzip Cacheort beizubehalten und Konflikte zu minimieren. Weitere Informationen zu untergeordneten und geschachtelten Aufgaben finden Sie unter [angefügte und getrennte untergeordnete Aufgaben](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  
  
 Die Verwendung von lokalen Warteschlangen nicht nur Druck auf die globale Warteschlange reduziert, sondern nutzt auch den Ort der Daten. Arbeitsaufgaben in der lokalen Warteschlange häufig Verweis-Datenstrukturen, die im Arbeitsspeicher physisch nahe beieinander liegen. In diesen Fällen sind die Daten bereits im Cache, nachdem die erste Aufgabe ausgeführt wurde und schnell zugegriffen werden kann. Beide [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) und <xref:System.Threading.Tasks.Parallel> -Klasse geschachtelte Aufgaben und untergeordnete Aufgaben ausführlich und mit der lokalen Warteschlangen werden deutliche geschwindigkeitssteigerungen erzielt.  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>Arbeitsübernahme  
 Ab .NET Framework 4, bietet der Threadpool einen Arbeitsübernahme-Algorithmus, um sicherzustellen, dass keine Threads im Leerlauf, während die anderen noch Arbeitsvorgänge in ihre Warteschlangen. Wenn ein Threadpoolthread zusätzliche Arbeit übernehmen kann, wird zuerst am Anfang der lokalen Warteschlange, anschließend in der globalen Warteschlange und zuletzt in den lokalen Warteschlangen anderer Threads gesucht. Wenn ein Arbeitselement in der lokalen Warteschlange eines anderen Threads gefunden wird, wird zunächst Heuristik angewendet, um sicherzustellen, dass die Arbeit effizient ausgeführt werden kann. Wenn dies möglich ist, holt es das Arbeitselement aus der Tail (in FIFO-Reihenfolge). Dadurch werden Konflikte in jeder lokalen Warteschlange verringert und der Datenort beibehalten. Dank dieser Architektur kann es sich um die Thread-Pool des Lastenausgleichs für arbeiten Sie effizienter als in frühere Versionen.  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>Lang ausgeführte Aufgaben  
 Unter Umständen möchten Sie ausdrücklich verhindern, dass eine Aufgabe in einer lokalen Warteschlange abgelegt wird. Sie wissen möglicherweise z. B., dass eine bestimmte Arbeitsaufgabe für eine relativ lange Zeit ausgeführt wird und daher wahrscheinlich alle anderen Arbeitsaufgaben in der lokalen Warteschlange blockiert. In diesem Fall können Sie die <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>-Option angeben, die den Planer darauf hinweist, dass u. U. ein weiterer Thread für die Aufgabe erforderlich ist, damit der Fortschritt anderer Threads oder Arbeitsaufgaben in der lokalen Warteschlange nicht blockiert wird. Mit dieser Option vermeiden Sie den Threadpool vollständig, einschließlich der globalen und lokalen Warteschlangen.  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>Aufgabeninlining  
 In einigen Fällen, wenn eine <xref:System.Threading.Tasks.Task> wird erwartet, es kann synchron ausgeführt werden für den Thread, der den Wartevorgang ausführt. Dies verbessert die Leistung von entfällt die Notwendigkeit ein weiterer Thread aus, und verwenden Sie stattdessen die vorhandenen Threads, die andernfalls blockiert worden wäre. Um Fehler aufgrund des Wiedereintritts zu verhindern, tritt Aufgabeninlining nur auf, wenn das Wartevorgangsziel in der lokalen Warteschlange des relevanten Threads gefunden wird.  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>Angeben eines Synchronisierungskontexts  
 Sie können mit der <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType>-Methode angeben, dass eine Aufgabe für die Ausführung in einem bestimmten Thread geplant werden soll. Dies ist in Frameworks wie Windows Forms und Windows Presentation Foundation hilfreich, wo der Zugriff auf Benutzeroberflächenobjekte oftmals auf Code beschränkt ist, der in dem Thread ausgeführt wird, in dem das Benutzeroberflächenobjekt erstellt wurde.  
  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> -Methode in einer Windows Presentation Foundation (WPF)-app, um eine Aufgabe auf dem gleichen Thread zu planen, die auf die Steuerelemente der Benutzeroberfläche (UI) erstellt wurde.   Das Beispiel erstellt ein Mosaik von Bildern, die aus einem angegebenen Verzeichnis nach dem Zufallsprinzip ausgewählt werden. Die WPF-Objekte werden zum Laden und das Ändern der Bildgröße. Die unformatierten Pixel werden dann an eine Aufgabe, die verwendet übergeben eine <xref:System.Threading.Tasks.Parallel.For%2A> Schleife, um die Pixeldaten in einem großen Single-Byte-Array zu schreiben. Es ist keine Synchronisierung erforderlich, da keine zwei Kacheln, die Elemente des gleichen Arrays belegen. Die Kacheln können auch in beliebiger Reihenfolge geschrieben werden, da ihre Position unabhängig von anderen Kacheln berechnet wird. Das große Array wird anschließend an eine Aufgabe übergeben, die im UI-Thread ausgeführt wird, werden die Pixeldaten in ein Image-Steuerelement geladen.  
  
 Das Beispiel verschiebt Daten aus der UI-Thread, ändert sie mithilfe von parallelen Schleifen und <xref:System.Threading.Tasks.Task> Objekte aus, und übergibt diese an eine Aufgabe, die im UI-Thread ausgeführt wird. Dieser Ansatz ist hilfreich, wenn man die Task Parallel Library zu verwenden, um Vorgänge auszuführen, die von der WPF-API nicht unterstützt werden oder nicht schnell genug sind. Eine weitere Möglichkeit, ein Bild Mosaic in WPF zu erstellen ist die Verwendung einer <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> steuern, und fügen Sie Bilder hinzu. Die <xref:System.Windows.Controls.WrapPanel> übernimmt die Aufgabe der Positionierung der Kacheln. Diese Aufgabe kann jedoch nur im UI-Thread ausgeführt werden.  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 Um das Beispiel zu erstellen, erstellen Sie ein WPF-Anwendungsprojekt in Visual Studio, und nennen Sie sie WPF_CS1 (für eine C# WPF-Projekt) oder WPF_VB1 (für eine Visual Basic-WPF-Projekt). Klicken Sie dann folgendermaßen Sie vor:  
  
1. Ziehen Sie in der Entwurfsansicht ein <xref:System.Windows.Controls.Image> -Steuerelement aus der **Toolbox** auf der oberen linken Ecke der Entwurfsoberfläche. In der **Namen** ins Textfeld die **Eigenschaften** benennen Sie das Steuerelement "Bild".    
  
2. Ziehen Sie eine <xref:System.Windows.Controls.Button> -Steuerelement aus der **Toolbox** an der unteren linken Seite des Anwendungsfensters. Geben Sie in der XAML-Ansicht der <xref:System.Windows.Controls.ContentControl.Content%2A> -Eigenschaft der Schaltfläche als "Make Mosaiken", und geben Sie die <xref:System.Windows.FrameworkElement.Width> Eigenschaft als "100". Verbinden der <xref:System.Windows.Controls.Primitives.ButtonBase.Click> -Ereignis mit der `button_Click` Ereignishandler im Code mit dem Beispiel durch das Hinzufügen `Click="button_Click"` auf die `<Button>` Element. In der **Namen** ins Textfeld die **Eigenschaften** benennen Sie das Steuerelement "Button".  
  
3. Ersetzen Sie den gesamten Inhalt der Datei "MainWindow.Xaml.cs" oder "MainWindow.Xaml.vb" durch den Code in diesem Beispiel ein. Für eine C# WPF project, stellen Sie sicher, dass der Name des Arbeitsbereichs, den Namen des Projekts entspricht. 
  
4. Im Beispiel liest die JPEG-Bilder aus einem Verzeichnis mit dem Namen C:\Users\Public\Pictures\Sample Bilder\\. Erstellen Sie das Verzeichnis und versehen Sie einige Images, oder ändern Sie den Pfad auf einem anderen Verzeichnis verweisen, die Bilder enthält. 
  
In diesem Beispiel weist einige Einschränkungen. Beispielsweise werden nur 32-Bit-pro-Pixel-Images unterstützt. Bilder in anderen Formaten sind beschädigt, durch die <xref:System.Windows.Media.Imaging.BitmapImage> Objekts während der die Größenänderung. Darüber hinaus müssen die Source-Images. alle größer als die Größe der Kacheln sein. Als weitere Übung können Sie Funktionen zur Behandlung mehrerer Pixelformate und Dateigrößen hinzufügen.  
  
## Examples  
 Das folgende Beispiel stammt aus dem [Beispiele zur parallelen Programmierung mit .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) auf der MSDN Code Gallery-Website.  Erstellen ein benutzerdefinierten Aufgabenplaners, das die Anzahl der Threads, die von der Anwendung verwendeten einschränkt. Anschließend wird die zwei Sätze von Aufgaben gestartet und zeigt Informationen über die Aufgabe und der Thread, der auf dem die Aufgabe ausgeführt wird.  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 Darüber hinaus sind einige Beispiel-Taskplaner in der Codegalerie verfügbar: [Beispiele für die parallele Programmierung mit .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Mitglieder der abstrakten <see cref="T:System.Threading.Tasks.TaskScheduler" /> Typs sind threadsicher und können von mehreren Threads gleichzeitig verwendet werden.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert das <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zugeordneten <see cref="T:System.Threading.Tasks.TaskScheduler" /> der derzeit ausgeführten Aufgabe ab.</summary>
        <value>Gibt den zugeordneten <see cref="T:System.Threading.Tasks.TaskScheduler" /> der momentan ausgeführten Aufgabe zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird nicht von einer Aufgabe aufgerufen <xref:System.Threading.Tasks.TaskScheduler.Current%2A> gibt die <xref:System.Threading.Tasks.TaskScheduler.Default%2A> Scheduler.  
  
 Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Threading.Tasks.TaskScheduler" />-Standardinstanz ab, die von .NET Framework bereitgestellt wird.</summary>
        <value>Gibt die <see cref="T:System.Threading.Tasks.TaskScheduler" />-Standardinstanz zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle Ressourcen frei, die diesem Planer zugeordnet sind.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen <see cref="T:System.Threading.Tasks.TaskScheduler" />, der dem aktuellen <see cref="T:System.Threading.SynchronizationContext" /> zugeordnet ist.</summary>
        <returns>Ein dem aktuellen <see cref="T:System.Threading.SynchronizationContext" /> gemäß Vorgabe durch den <see cref="P:System.Threading.SynchronizationContext.Current" /> zugeordneter <see cref="T:System.Threading.Tasks.TaskScheduler" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle <xref:System.Threading.Tasks.Task> Instanzen in der Warteschlange, auf das zurückgegebene Scheduler wird ausgeführt, durch einen Aufruf der <xref:System.Threading.SynchronizationContext.Post%2A> -Methode für diesen Kontext.  
  
 Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle SynchronizationContext kann nicht als TaskScheduler verwendet werden.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nur für Debuggerunterstützung: Generiert eine Enumeration von <see cref="T:System.Threading.Tasks.Task" />-Instanzen, die sich gegenwärtig in der Warteschlange des Taskplaners befinden und auf ihre Ausführung warten.</summary>
        <returns>Eine Aufzählung, in der von einem Debugger die gegenwärtig in der Warteschlange dieses Taskplaners enthaltenen Aufgaben durchsucht werden können.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine abgeleitete Klasse <xref:System.Threading.Tasks.TaskScheduler> implementiert diese Methode, um die Unterstützung der Integration mit dem Debugger. Diese Methode wird nur von .NET Framework aufgerufen werden, wenn der Debugger Zugriff auf die Daten anfordert. Das aufzählbare Element zurückgegeben wird durchlaufen, indem Sie debugginghilfsprogramme für den Zugriff auf die Aufgaben derzeit in der Warteschlange dieses Planers, wodurch der Debugger eine Darstellung dieser Informationen in der Benutzeroberfläche bereitzustellen.  
  
 Es ist wichtig zu beachten, dass, wenn diese Methode aufgerufen wird, alle anderen Threads im Prozess eingefroren werden. Aus diesem Grund ist es wichtig, die Synchronisierung mit anderen Threads zu vermeiden, die zu einer Blockierung führen kann. Wenn die Synchronisierung ist erforderlich, und Sie nicht, die Sperre bei dieser Methode abzurufen, sollten Sie eine Ausnahme auslösen, damit der Debugger nicht hängen bleibt. Das folgende Beispiel zeigt eine mögliche Vorgehensweise in c#:  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 Darüber hinaus müssen diese Methode und das zurückgegebene aufzählbare Element global sichtbaren Zustand nicht ändern.  
  
 Das zurückgegebene auflistbare sollte nie null sein. Derzeit keine Aufgaben in der Warteschlange befinden, sollten stattdessen ein leeres aufzählbares Element zurückgegeben.  
  
 Entwickler, die benutzerdefinierte Debugger implementieren diese Methode sollte nicht direkt aufrufen, sollten aber die interne Wrappermethode `GetScheduledTasksForDebugger` stattdessen: `internal Task[] GetScheduledTasksForDebugger()`. Diese Wrappermethode gibt ein Array von Aufgaben anstatt von ein aufzählbares Element zurück. Um eine Liste der aktiven Planer abzurufen, verwenden Sie die interne Methode `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`. Diese statische Methode gibt ein Array aller aktiven <xref:System.Threading.Tasks.TaskScheduler> Instanzen. Anschließend können Sie `GetScheduledTasksForDebugger` auf jeder Instanz Scheduler, um die Liste der geplanten Tasks abzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Dieser Planer kann derzeit keine Liste in der Warteschlange stehender Aufgaben generieren.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die eindeutige ID für diesen <see cref="T:System.Threading.Tasks.TaskScheduler" /> ab.</summary>
        <value>Gibt die eindeutige ID für diesen <see cref="T:System.Threading.Tasks.TaskScheduler" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die maximale Parallelitätsebene an, die dieser <see cref="T:System.Threading.Tasks.TaskScheduler" /> unterstützt.</summary>
        <value>Gibt eine ganze Zahl zurück, die die maximale Parallelitätsebene darstellt. Der Standardplaner gibt <see cref="F:System.Int32.MaxValue" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Der <see cref="T:System.Threading.Tasks.Task" />, der in die Warteschlange eingereiht werden soll.</param>
        <summary>Fügt einen <see cref="T:System.Threading.Tasks.Task" /> in die Warteschlange des Planers ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine abgeleitete Klasse <xref:System.Threading.Tasks.TaskScheduler> implementiert diese Methode, um die Aufgaben, die auf den Planer geplant akzeptieren.  
  
 Eine typische Implementierung würde die Aufgabe in einer internen Datenstruktur, speichern, die Threads verarbeitet werden würde, die diese Aufgaben zu einem Zeitpunkt in der Zukunft ausgeführt werden würde.  
  
 Diese Methode wird nur von .NET Framework aufgerufen werden soll, und sollte nicht direkt von der abgeleiteten Klasse aufgerufen werden. Dies ist für die Aufrechterhaltung der Konsistenz des Systems erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="task" />-Argument ist null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Das <see cref="T:System.Threading.Tasks.Task" />, das aus der Warteschlange entfernt werden soll.</param>
        <summary>Versucht, einen zuvor in die Warteschlange dieses Planers eingereihten <see cref="T:System.Threading.Tasks.Task" /> aus der Warteschlange zu entfernen.</summary>
        <returns>Ein boolescher Wert, der angibt, ob das <paramref name="task" />-Argument erfolgreich aus der Warteschlange entfernt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.  
  
 Führen Sie diese Methode kann in einem finally-block, aus diesem Grund sollte zurückgegeben so schnell wie möglich so, dass alle Ressourcen, z. B. <xref:System.Threading.CancellationTokenRegistration> Objekte können von rechtzeitig freigegeben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="task" />-Argument ist null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Ein auszuführendes <see cref="T:System.Threading.Tasks.Task" />-Objekt.</param>
        <summary>Versucht, den angegebenen <see cref="T:System.Threading.Tasks.Task" /> mit diesem Planer auszuführen.</summary>
        <returns>Ein boolescher Wert, der true ist, wenn <paramref name="task" /> erfolgreich ausgeführt wurde. Andernfalls ist dieser Wert false. Ein häufiger Grund für Ausführungsfehler besteht darin, dass die Aufgabe zuvor ausgeführt wurde oder gerade von einem anderen Thread ausgeführt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Scheduler-Implementierungen sind im Lieferumfang <xref:System.Threading.Tasks.Task> -Instanzen, die entweder durch ausgeführt werden die <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> Methode oder der <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> Methode. Wenn der Planer zum Ausführen der angegebenen Aufgabe geeignet hält <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> sollte dazu verwendet werden. TryExecuteTask behandelt alle Aspekte beim Ausführen einer Aufgabe, einschließlich Aktionsaufruf, Ausnahmebehandlung, Zustandsverwaltung und Lebenszyklus-Steuerelement.  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> muss nur für diese Planer-Aufgaben von der .NET Framework-Infrastruktur verwendet werden. Es sollte nicht verwendet werden, zum Ausführen von frei wählbaren Tasks, die durch benutzerdefinierte Mechanismen abgerufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <paramref name="task" /> ist nicht diesem Planer zugeordnet.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">Das auszuführende <see cref="T:System.Threading.Tasks.Task" />.</param>
        <param name="taskWasPreviouslyQueued">Ein boolescher Wert, der angibt, ob die Aufgabe zuvor in die Warteschlange eingereiht wurde. Wenn dieser Parameter true ist, wurde die Aufgabe möglicherweise zuvor in die Warteschlange eingereiht (geplant). Ist er false, wurde die Aufgabe bekanntermaßen nicht in die Warteschlange eingereiht, und dieser Aufruf wird ausgeführt, um die Aufgabe inline auszuführen, ohne sie in die Warteschlange einzureihen.</param>
        <summary>Bestimmt, ob der angegebene <see cref="T:System.Threading.Tasks.Task" /> in diesem Aufruf synchron ausgeführt werden kann, und führt ihn aus, wenn dies der Fall ist.</summary>
        <returns>Ein boolescher Wert, der angibt, ob die Aufgabe inline ausgeführt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine abgeleitete Klasse <xref:System.Threading.Tasks.TaskScheduler> implementiert diese Funktion, um Inline-Ausführung einer Aufgabe in einem Thread zu unterstützen, eine Wartezeit, Task-Objekt initiiert. Inline-Ausführung ist optional, und die Anforderung möglicherweise abgelehnt, indem Sie "false" zurückgeben. Allerdings mehr Aufgaben können inline gesetzt werden, desto bessere das Zeitplanungsmodul wird skaliert. In der Tat kann ein Planer, Inlines zu wenig zu Deadlocks sein. Eine ordnungsgemäße Implementierung sorgen dafür, dass eine Anforderung, die unter den Richtlinien, die vom Scheduler garantiert ausgeführt Inline können. Z. B. sollten ein Planer einen dedizierten Thread zum Ausführen von Tasks verwendet wird, alle inlining Anforderungen aus diesem Thread erfolgreich.  
  
 Wenn Sie ein Planer für die Inlineausführung entscheidet, sollte dies durch den Aufruf von der Basisklasse TaskScheduler <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> Methode mit der angegebenen Aufgabe-Objekt, das Weitergeben des zurückgegeben Wert. Es kann auch sein für den Scheduler so, dass eine Inline-Aufgabe aus der internen Datenstrukturen zu entfernen, wenn er entscheidet, die inlineersetzung Anforderung berücksichtigt. Beachten Sie jedoch, dass unter bestimmten Umständen ein Planer inlineersetzung eine Aufgabe eventuell aufgefordert werden, die mit nicht zuvor bereitgestellt wurde die <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> Methode.  
  
 Der abgeleitete Planer ist dafür verantwortlich, dass Sie sicher, dass der aufrufende Thread eignet sich für die Ausführung der angegebenen Aufgabe soweit es die eigene Planung und Ausführungsrichtlinien betrifft.  
  
 Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="task" />-Argument ist null.</exception>
        <exception cref="T:System.InvalidOperationException">Der <paramref name="task" /> wurde bereits ausgeführt.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, kurz bevor eine nicht überwachte Ausnahme eines Tasks, bei dem ein Fehler aufgetreten ist, eine Ausnahmeausweitungsrichtlinie auslöst, was standardmäßig den Prozess beenden würde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ereigniszeitpunkt domänenweite Anwendung bietet einen Mechanismus, um zu verhindern, dass die Eskalationsrichtlinie Ausnahme (die Standardeinstellung der Prozess beendet wird) auslöst.  
  
 Zu erleichtern Entwicklern das Schreiben von asynchronen Codes basierend auf Aufgaben, die [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ändert das Standardverhalten für die Ausnahme für nicht überwachte Ausnahmen. Zwar immer noch nicht überwachte Ausnahmen auslösen der <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> Ausnahme, der Prozess wird standardmäßig nicht beendet. Stattdessen wird die Ausnahme von der Laufzeit behandelt, nachdem das Ereignis ausgelöst wird, unabhängig davon, ob ein Ereignishandler für die Ausnahme beobachtet. Dieses Verhalten kann konfiguriert werden. Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die [ `<ThrowUnobservedTaskExceptions>` ](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md) Konfigurationselement, um das Verhalten der wiederherzustellen die [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] und beenden den Prozess:  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md">&lt;ThrowUnobservedTaskExceptions&gt; Element</related>
      </Docs>
    </Member>
  </Members>
</Type>