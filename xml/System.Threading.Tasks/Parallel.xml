<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3bc9e66cad6fbd43b47a73101481830fb8e6228a" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78783259" /></Metadata><TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading.Tasks.Parallel" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="ece51-101">Stellt Unterstützung für parallele Schleifen und Bereiche bereit.</span><span class="sxs-lookup"><span data-stu-id="ece51-101">Provides support for parallel loops and regions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-102">Die <xref:System.Threading.Tasks.Parallel>-Klasse stellt Bibliotheks basierte Daten parallele Ersetzungen für allgemeine Vorgänge bereit, z. b. for-Schleifen, for Each-Schleifen und die Ausführung eines Satzes von-Anweisungen.</span><span class="sxs-lookup"><span data-stu-id="ece51-102">The <xref:System.Threading.Tasks.Parallel> class provides library-based data parallel replacements for common operations such as for loops, for each loops, and execution of a set of statements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ece51-103">In diesem Beispiel werden mehrere Ansätze zum Implementieren einer parallelen Schleife mithilfe mehrerer Sprachkonstrukte veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="ece51-103">This example demonstrates several approaches to implementing a parallel loop using multiple language constructs.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="ece51-104">Alle öffentlichen und geschützten Member von <see cref="T:System.Threading.Tasks.Parallel" /> sind Thread sicher und können gleichzeitig von mehreren Threads verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-104">All public and protected members of <see cref="T:System.Threading.Tasks.Parallel" /> are thread-safe and may be used concurrently from multiple threads.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md"><span data-ttu-id="ece51-105">Datenparallelität (Task Parallel Library)</span><span class="sxs-lookup"><span data-stu-id="ece51-105">Data Parallelism (Task Parallel Library)</span></span></related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364"><span data-ttu-id="ece51-106">Beispiele für die parallele Programmierung mit dem .NET Framework</span><span class="sxs-lookup"><span data-stu-id="ece51-106">Samples for Parallel Programming with the .NET Framework</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ece51-107">Führt eine <see langword="for" />-Schleife aus, in der Iterationen parallel ausgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="ece51-107">Executes a <see langword="for" /> loop in which iterations may run in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ece51-108">Der Startindex, einschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-108">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ece51-109">Der Endindex, ausschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-109">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-110">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-110">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-111">Führt eine <see langword="for" />-Schleife aus, in der Iterationen parallel ausgeführt werden können und der Status der Schleife beobachtet und bearbeitet werden kann.</span><span class="sxs-lookup"><span data-stu-id="ece51-111">Executes a <see langword="for" /> loop in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-112">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-112">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-113">Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-113">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ece51-114">Sie wird mit zwei Argumenten bereitgestellt:</span><span class="sxs-lookup"><span data-stu-id="ece51-114">It is provided with two arguments:</span></span>  
  
-   <span data-ttu-id="ece51-115">Ein <xref:System.Int32> Wert, der die Anzahl der Iterationen darstellt.</span><span class="sxs-lookup"><span data-stu-id="ece51-115">An <xref:System.Int32> value that represents the iteration count.</span></span>  
  
-   <span data-ttu-id="ece51-116">Eine <xref:System.Threading.Tasks.ParallelLoopState>-Instanz, die verwendet werden kann, um die Schleife vorzeitig abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="ece51-116">A <xref:System.Threading.Tasks.ParallelLoopState> instance that can be used to break out of the loop prematurely.</span></span> <span data-ttu-id="ece51-117">Das <xref:System.Threading.Tasks.ParallelLoopState> Objekt wird vom Compiler erstellt. Sie kann nicht im Benutzercode instanziiert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-117">The <xref:System.Threading.Tasks.ParallelLoopState> object is created by the compiler; it cannot be instantiated in user code.</span></span>  
  
 <span data-ttu-id="ece51-118">Wenn Sie die <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>-Methode aufrufen, wird der `for` Vorgang informiert, dass Iterationen nach dem aktuellen nicht ausgeführt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="ece51-118">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method informs the `for` operation that iterations after the current one don't have to execute.</span></span> <span data-ttu-id="ece51-119">Allerdings müssen alle Iterationen vor dem aktuellen noch ausgeführt werden, sofern Sie noch nicht vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="ece51-119">However, all iterations before the current one will still have to be executed if they haven't already.</span></span>  
  
 <span data-ttu-id="ece51-120">Daher ist das Aufrufen von <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> vergleichbar mit der Verwendung eines Break-Vorgangs in einer herkömmlichen `for`-Schleife C#in einer Sprache wie, aber es ist kein perfekter Ersatz: beispielsweise gibt es keine Garantie dafür, dass Iterationen nach der aktuellen-Schleife definitiv nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-120">Therefore, calling <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> is similar to using a break operation within a conventional `for` loop in a language like C#, but it is not a perfect substitute: For example, there is no guarantee that iterations after the current one will definitely not execute.</span></span>  
  
 <span data-ttu-id="ece51-121">Wenn Sie alle Iterationen vor dem aktuellen ausführen müssen, verwenden Sie die <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>-Methode anstelle von <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span><span class="sxs-lookup"><span data-stu-id="ece51-121">If executing all iterations before the current one is not necessary, use the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method instead of using <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span></span> <span data-ttu-id="ece51-122">Durch Aufrufen von <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> wird die `for` Schleife darüber informiert, dass alle verbleibenden Iterationen abgebrochen werden können, unabhängig davon, ob Sie vor oder nach der aktuellen Iteration liegen, da alle erforderlichen Aufgaben bereits abgeschlossen wurden.</span><span class="sxs-lookup"><span data-stu-id="ece51-122">Calling <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informs the `for` loop that it may abandon all remaining iterations, regardless of whether they're before or after the current iteration, because all required work will have already been completed.</span></span> <span data-ttu-id="ece51-123">Wie bei <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>gibt es jedoch keine Garantie, welche anderen Iterationen nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-123">However, as with <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, there are no guarantees regarding which other iterations will not execute.</span></span>  
  
 <span data-ttu-id="ece51-124">Wenn eine Schleife vorzeitig beendet wird, enthält die <xref:System.Threading.Tasks.ParallelLoopResult> Struktur, die zurückgegeben wird, relevante Informationen zum Abschluss der Schleife.</span><span class="sxs-lookup"><span data-stu-id="ece51-124">If a loop is ended prematurely, the <xref:System.Threading.Tasks.ParallelLoopResult> structure that is returned will contain relevant information about the loop's completion.</span></span>  
  
 <span data-ttu-id="ece51-125">Wenn `fromInclusive` größer oder gleich `toExclusive`ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-125">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ece51-126">Im folgenden Beispiel werden bis zu 100 Iterationen einer Schleife parallel ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="ece51-126">The following example executes up to 100 iterations of a loop in parallel.</span></span> <span data-ttu-id="ece51-127">Jede Iterations Pause wird für ein zufälliges Intervall von 1 bis 1.000 Millisekunden angehalten.</span><span class="sxs-lookup"><span data-stu-id="ece51-127">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="ece51-128">Ein zufällig generierter Wert bestimmt, bei welcher Iterations Schleife die <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-128">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="ece51-129">Wie die Ausgabe des Beispiels zeigt, werden keine Iterationen, deren Index größer ist als der <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType>-Eigenschafts Wert, nach dem aufrufungs <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> Methode gestartet.</span><span class="sxs-lookup"><span data-stu-id="ece51-129">As the output from the example shows, no iterations whose index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> property value start after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 <span data-ttu-id="ece51-130">Da Iterationen der Schleife wahrscheinlich beim Aufrufen der <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType>-Methode ausgeführt werden, ruft jede Iteration die <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType>-Eigenschaft auf, um zu überprüfen, ob die <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType>-Methode von einer anderen Iteration aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="ece51-130">Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> property to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ece51-131">Wenn der-Eigenschafts Wert `true`ist, wird der Wert der <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType>-Eigenschaft von der Iterations Prüfung überprüft. wenn der Wert größer als der Indexwert der aktuellen Iterations ist, wird sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="ece51-131">If  the property value is `true`, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> property and, if it is greater than the current iteration's index value, returns immediately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-132">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-132">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-133">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-133">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-134">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-134">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ece51-135">Der Startindex, einschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-135">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ece51-136">Der Endindex, ausschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-136">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-137">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-137">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-138">Führt eine <see langword="for" />-Schleife aus, in der Iterationen parallel ausgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="ece51-138">Executes a <see langword="for" /> loop in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="ece51-139">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-139">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-140">Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-140">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ece51-141">Sie wird mit der Iterations Anzahl (<xref:System.Int32>) als Parameter bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="ece51-141">It is provided with the iteration count (<xref:System.Int32>) as a parameter.</span></span>  
  
 <span data-ttu-id="ece51-142">Wenn `fromInclusive` größer oder gleich `toExclusive`ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-142">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ece51-143">Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Parallel.For%2A>-Methode für 100-Aufrufe eines Delegaten verwendet, der zufällige Byte Werte generiert und die Summe berechnet.</span><span class="sxs-lookup"><span data-stu-id="ece51-143">The following example uses the <xref:System.Threading.Tasks.Parallel.For%2A> method for 100 invocations of a delegate that generates random byte values and computes their sum.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-144">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-144">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-145">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-145">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-146">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-146">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ece51-147">Der Startindex, einschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-147">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ece51-148">Der Endindex, ausschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-148">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-149">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-149">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-150">Führt eine <see langword="for" />-Schleife mit 64-Bit-Indizes aus, in der Iterationen parallel ausgeführt werden können und der Zustand der Schleife überwacht und bearbeitet werden kann.</span><span class="sxs-lookup"><span data-stu-id="ece51-150">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-151">Eine <see cref="T:System.Threading.Tasks.ParallelLoopResult" />-Struktur, die Informationen darüber enthält, welcher Teil der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-151">A <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> structure that contains information on what portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-152">Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-152">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ece51-153">Sie wird mit den folgenden Parametern bereitgestellt: die Iterations Anzahl (<xref:System.Int64>) und eine <xref:System.Threading.Tasks.ParallelLoopState>-Instanz, mit der die Schleife vorzeitig abgebrochen werden kann.</span><span class="sxs-lookup"><span data-stu-id="ece51-153">It is provided with the following parameters: the iteration count (<xref:System.Int64>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="ece51-154">Wenn Sie die <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>-Methode aufrufen, wird der `for` Vorgang informiert, dass Iterationen nach dem aktuellen nicht ausgeführt werden müssen, sondern alle Iterationen vor dem aktuellen Vorgang.</span><span class="sxs-lookup"><span data-stu-id="ece51-154">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method informs the `for` operation that iterations after the current one don't have to be executed, but all iterations before the current one do.</span></span>  
  
 <span data-ttu-id="ece51-155">Daher ist das Aufrufen von Break vergleichbar mit der Verwendung eines Break-Vorgangs in einer konventionellen `for`-Schleife C#in einer Sprache wie, aber es ist kein perfekter Ersatz: beispielsweise gibt es keine Garantie dafür, dass Iterationen nach der aktuellen-Schleife definitiv nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-155">Therefore, calling Break is similar to using a break operation within a conventional `for` loop in a language like C#, but it is not a perfect substitute: For example, there is no guarantee that iterations after the current one will definitely not execute.</span></span>  
  
 <span data-ttu-id="ece51-156">Wenn Sie alle Iterationen vor dem aktuellen ausführen müssen, verwenden Sie die <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>-Methode anstelle von <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span><span class="sxs-lookup"><span data-stu-id="ece51-156">If executing all iterations before the current one is not necessary, use the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method instead of using <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span></span> <span data-ttu-id="ece51-157">Durch Aufrufen von <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> wird die `for` Schleife darüber informiert, dass alle verbleibenden Iterationen abgebrochen werden können, unabhängig davon, ob Sie vor oder nach der aktuellen Iteration liegen, da alle erforderlichen Aufgaben bereits abgeschlossen wurden.</span><span class="sxs-lookup"><span data-stu-id="ece51-157">Calling <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informs the `for` loop that it may abandon all remaining iterations, regardless of whether they're before or after the current iteration, because all required work will have already been completed.</span></span> <span data-ttu-id="ece51-158">Wie bei <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>gibt es jedoch keine Garantie, welche anderen Iterationen nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-158">However, as with <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, there are no guarantees regarding which other iterations will not execute.</span></span>  
  
 <span data-ttu-id="ece51-159">Wenn eine Schleife vorzeitig beendet wird, enthält die <xref:System.Threading.Tasks.ParallelLoopResult> Struktur, die zurückgegeben wird, relevante Informationen zum Abschluss der Schleife.</span><span class="sxs-lookup"><span data-stu-id="ece51-159">If a loop is ended prematurely, the <xref:System.Threading.Tasks.ParallelLoopResult> structure that is returned will contain relevant information about the loop's completion.</span></span>  
  
 <span data-ttu-id="ece51-160">Wenn `fromInclusive` größer oder gleich `toExclusive`ist, wird die Methode sofort zurückgegeben, ohne dass Iterationen durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-160">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-161">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-161">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-162">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-162">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-163">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-163">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ece51-164">Der Startindex, einschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-164">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ece51-165">Der Endindex, ausschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-165">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-166">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-166">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-167">Führt eine <see langword="for" />-Schleife mit 64-Bit-Indizes aus, in der Iterationen parallel ausgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="ece51-167">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="ece51-168">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-168">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-169">Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-169">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ece51-170">Sie wird mit der Iterations Anzahl (<xref:System.Int64>) als Parameter bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="ece51-170">It is provided with the iteration count (<xref:System.Int64>) as a parameter.</span></span>  
  
 <span data-ttu-id="ece51-171">Wenn `fromInclusive` größer oder gleich `toExclusive`ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-171">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-172">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-172">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-173">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-173">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-174">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-174">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, parallelOptions As ParallelOptions, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ece51-175">Der Startindex, einschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-175">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ece51-176">Der Endindex, ausschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-176">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-177">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-177">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-178">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-178">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-179">Führt eine <see langword="for" />-Schleife aus, in der Iterationen parallel ausgeführt und Schleifenoptionen konfiguriert werden können und wo der Status der Schleife beobachtet und bearbeitet werden kann.</span><span class="sxs-lookup"><span data-stu-id="ece51-179">Executes a <see langword="for" /> loop in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-180">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-180">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-181">Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-181">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ece51-182">Sie wird mit den folgenden Parametern bereitgestellt: die Iterations Anzahl (<xref:System.Int32>) und eine <xref:System.Threading.Tasks.ParallelLoopState>-Instanz, mit der die Schleife vorzeitig abgebrochen werden kann.</span><span class="sxs-lookup"><span data-stu-id="ece51-182">It is provided with the following parameters: the iteration count (<xref:System.Int32>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="ece51-183">Wenn `fromInclusive` größer oder gleich `toExclusive`ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-183">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-184">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-184">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-185">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-185">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-186">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-186">-or-</span></span> 
<span data-ttu-id="ece51-187">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-187">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-188">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-188">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-189">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-189">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-190">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-190">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, parallelOptions As ParallelOptions, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ece51-191">Der Startindex, einschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-191">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ece51-192">Der Endindex, ausschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-192">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-193">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-193">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-194">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-194">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-195">Führt eine <see langword="for" />-Schleife aus, in der Iterationen parallel ausgeführt und Schleifenoptionen konfiguriert werden können.</span><span class="sxs-lookup"><span data-stu-id="ece51-195">Executes a <see langword="for" /> loop in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="ece51-196">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-196">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-197">Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-197">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ece51-198">Sie wird mit der Iterations Anzahl (<xref:System.Int32>) als Parameter bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="ece51-198">It is provided with the iteration count (<xref:System.Int32>) as a parameter.</span></span>  
  
 <span data-ttu-id="ece51-199">Wenn `fromInclusive` größer oder gleich `toExclusive`ist, wird die Methode sofort zurückgegeben, ohne dass Iterationen durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-199">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ece51-200">Im folgenden Beispiel wird gezeigt, wie eine parallele Schleife abgebrochen wird:</span><span class="sxs-lookup"><span data-stu-id="ece51-200">The following example shows how to cancel a parallel loop:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-201">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-201">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-202">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-202">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-203">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-203">-or-</span></span> 
<span data-ttu-id="ece51-204">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-204">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-205">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-205">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-206">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-206">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-207">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-207">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, parallelOptions As ParallelOptions, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ece51-208">Der Startindex, einschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-208">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ece51-209">Der Endindex, ausschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-209">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-210">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-210">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-211">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-211">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-212">Führt eine <see langword="for" />-Schleife mit 64-Bit-Indizes aus, in der Iterationen parallel ausgeführt und Schleifenoptionen konfiguriert werden können, und der Status der Schleife kann beobachtet und bearbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-212">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-213">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-213">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-214">Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-214">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ece51-215">Sie wird mit den folgenden Parametern bereitgestellt: die Iterations Anzahl (<xref:System.Int64>) und eine <xref:System.Threading.Tasks.ParallelLoopState>-Instanz, mit der die Schleife vorzeitig abgebrochen werden kann.</span><span class="sxs-lookup"><span data-stu-id="ece51-215">It is provided with the following parameters: the iteration count (<xref:System.Int64>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="ece51-216">Wenn `fromInclusive` größer oder gleich `toExclusive`ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-216">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ece51-217">Im folgenden Beispiel wird gezeigt, wie die <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>-Methode mit einem <xref:System.Threading.Tasks.ParallelOptions>-Objekt verwendet wird:</span><span class="sxs-lookup"><span data-stu-id="ece51-217">The following example shows how to use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method with a <xref:System.Threading.Tasks.ParallelOptions> object:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-218">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-218">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-219">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-219">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-220">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-220">-or-</span></span> 
<span data-ttu-id="ece51-221">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-221">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-222">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-222">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-223">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-223">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-224">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-224">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, parallelOptions As ParallelOptions, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ece51-225">Der Startindex, einschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-225">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ece51-226">Der Endindex, ausschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-226">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-227">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-227">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-228">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-228">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-229">Führt eine <see langword="for" />-Schleife mit 64-Bit-Indizes aus, in der Iterationen parallel ausgeführt und Schleifenoptionen konfiguriert werden können.</span><span class="sxs-lookup"><span data-stu-id="ece51-229">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="ece51-230">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-230">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-231">Unterstützt 64-Bit-Indizes.</span><span class="sxs-lookup"><span data-stu-id="ece51-231">Supports 64-bit indexes.</span></span> <span data-ttu-id="ece51-232">Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-232">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ece51-233">Sie wird mit der Iterations Anzahl (<xref:System.Int64>) als Parameter bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="ece51-233">It is provided with the iteration count (<xref:System.Int64>) as a parameter.</span></span>  
  
 <span data-ttu-id="ece51-234">Wenn `fromInclusive` größer oder gleich `toExclusive`ist, wird die Methode sofort zurückgegeben, ohne dass Iterationen durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-234">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ece51-235">Im folgenden Beispiel wird gezeigt, wie <xref:System.Threading.Tasks.ParallelOptions> verwendet wird, um einen benutzerdefinierten Taskplaner anzugeben:</span><span class="sxs-lookup"><span data-stu-id="ece51-235">The following example shows how to use <xref:System.Threading.Tasks.ParallelOptions> to specify a custom task scheduler:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-236">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-236">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-237">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-237">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-238">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-238">-or-</span></span> 
<span data-ttu-id="ece51-239">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-239">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-240">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-240">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-241">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-241">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-242">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-242">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="ece51-243">Der Typ der threadlokalen Daten.</span><span class="sxs-lookup"><span data-stu-id="ece51-243">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="ece51-244">Der Startindex, einschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-244">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ece51-245">Der Endindex, ausschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-245">The end index, exclusive.</span></span></param>
        <param name="localInit"><span data-ttu-id="ece51-246">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-246">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-247">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-247">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ece51-248">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</span><span class="sxs-lookup"><span data-stu-id="ece51-248">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ece51-249">Führt eine <see langword="for" />-Schleife mit lokalen Threaddaten aus, in der Iterationen parallel ausgeführt und der Status der Schleife beobachtet und bearbeitet werden können.</span><span class="sxs-lookup"><span data-stu-id="ece51-249">Executes a <see langword="for" /> loop with thread-local data in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-250">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-250">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-251">Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-251">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ece51-252">Sie wird mit den folgenden Parametern bereitgestellt: die Iterationen Anzahl (<xref:System.Int32>), eine <xref:System.Threading.Tasks.ParallelLoopState> Instanz, die verwendet werden kann, um die Schleife vorzeitig zu verlassen, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die im selben Thread ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-252">It is provided with the following parameters: the iteration count (<xref:System.Int32>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="ece51-253">Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-253">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ece51-254">Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="ece51-254">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ece51-255">Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-255">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ece51-256">Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally`-Delegaten weitergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-256">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ece51-257">Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-257">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ece51-258">Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-258">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ece51-259">Die <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>-Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-259">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ece51-260">Dadurch erhält das zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.</span><span class="sxs-lookup"><span data-stu-id="ece51-260">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="ece51-261">Wenn `fromInclusive` größer oder gleich `toExclusive`ist, wird die Methode sofort zurückgegeben, ohne dass Iterationen durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-261">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 <span data-ttu-id="ece51-262">Ein Beispiel, in dem diese Methode verwendet wird, finden Sie unter Gewusst [wie: Schreiben einer parallel. for-Schleife mit Thread lokalen Variablen](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-262">For an example that uses this method, see [How to: Write a Parallel.For Loop with Thread-Local Variables](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-263">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-263">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-264">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-264">-or-</span></span> 
<span data-ttu-id="ece51-265">Das <paramref name="localInit" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-265">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-266">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-266">-or-</span></span> 
<span data-ttu-id="ece51-267">Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-267">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-268">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-268">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-269">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-269">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="ece51-270">Der Typ der threadlokalen Daten.</span><span class="sxs-lookup"><span data-stu-id="ece51-270">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="ece51-271">Der Startindex, einschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-271">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ece51-272">Der Endindex, ausschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-272">The end index, exclusive.</span></span></param>
        <param name="localInit"><span data-ttu-id="ece51-273">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-273">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-274">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-274">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ece51-275">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</span><span class="sxs-lookup"><span data-stu-id="ece51-275">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ece51-276">Führt eine <see langword="for" />-Schleife mit 64-Bit-Indizes sowie lokalen Threaddaten aus, in denen Iterationen parallel ausgeführt werden können, und der Status der Schleife kann beobachtet und bearbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-276">Executes a <see langword="for" /> loop with 64-bit indexes and thread-local data in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-277">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-277">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-278">Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-278">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ece51-279">Sie wird mit den folgenden Parametern bereitgestellt: die Iterationen Anzahl (<xref:System.Int64>), eine <xref:System.Threading.Tasks.ParallelLoopState> Instanz, die verwendet werden kann, um die Schleife vorzeitig abzubrechen, sowie einen lokalen Zustand, der von Iterationen gemeinsam genutzt werden kann, die für dieselbe Aufgabe ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-279">It is provided with the following parameters: the iteration count (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same task.</span></span>  
  
 <span data-ttu-id="ece51-280">Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-280">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ece51-281">Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="ece51-281">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ece51-282">Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-282">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ece51-283">Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally`-Delegaten weitergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-283">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ece51-284">Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-284">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ece51-285">Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-285">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ece51-286">Die <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>-Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-286">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ece51-287">Dadurch erhält das zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.</span><span class="sxs-lookup"><span data-stu-id="ece51-287">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="ece51-288">Wenn `fromInclusive` größer oder gleich `toExclusive`ist, wird die Methode sofort zurückgegeben, ohne dass Iterationen durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-288">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 <span data-ttu-id="ece51-289">Ein Beispiel, in dem diese Methode verwendet wird, finden Sie unter Gewusst [wie: Schreiben einer parallel. for-Schleife mit Thread lokalen Variablen](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-289">For an example that uses this method, see [How to: Write a Parallel.For Loop with Thread-Local Variables](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-290">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-290">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-291">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-291">-or-</span></span> 
<span data-ttu-id="ece51-292">Das <paramref name="localInit" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-292">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-293">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-293">-or-</span></span> 
<span data-ttu-id="ece51-294">Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-294">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-295">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-295">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-296">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-296">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, parallelOptions As ParallelOptions, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="ece51-297">Der Typ der threadlokalen Daten.</span><span class="sxs-lookup"><span data-stu-id="ece51-297">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="ece51-298">Der Startindex, einschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-298">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ece51-299">Der Endindex, ausschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-299">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-300">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-300">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="ece51-301">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-301">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-302">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-302">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ece51-303">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</span><span class="sxs-lookup"><span data-stu-id="ece51-303">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ece51-304">Führt eine <see langword="for" />-Schleife mit lokalen Threaddaten aus, in der Iterationen parallel ausgeführt, Schleifenoptionen konfiguriert und der Status der Schleife beobachtet und bearbeitet werden können.</span><span class="sxs-lookup"><span data-stu-id="ece51-304">Executes a <see langword="for" /> loop with thread-local data in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-305">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-305">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-306">Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-306">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ece51-307">Sie wird mit den folgenden Parametern bereitgestellt: die Iterationen Anzahl (<xref:System.Int32>), eine <xref:System.Threading.Tasks.ParallelLoopState> Instanz, die verwendet werden kann, um die Schleife vorzeitig abzubrechen, sowie einen lokalen Zustand, der von Iterationen gemeinsam genutzt werden kann, die für dieselbe Aufgabe ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-307">It is provided with the following parameters: the iteration count (<xref:System.Int32>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same task.</span></span>  
  
 <span data-ttu-id="ece51-308">Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-308">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ece51-309">Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="ece51-309">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ece51-310">Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-310">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ece51-311">Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally`-Delegaten weitergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-311">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ece51-312">Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-312">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ece51-313">Dieser Delegat kann gleichzeitig für mehrere Threads aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-313">This delegate might be invoked concurrently on multiple threads; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ece51-314">Die <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>-Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-314">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ece51-315">Dadurch erhält das zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.</span><span class="sxs-lookup"><span data-stu-id="ece51-315">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="ece51-316">Wenn `fromInclusive` größer oder gleich `toExclusive`ist, wird die Methode sofort zurückgegeben, ohne dass Iterationen durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-316">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ece51-317">Im folgenden Beispiel werden lokale Thread Variablen verwendet, um die Summe der Ergebnisse vieler langwieriger Vorgänge zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="ece51-317">The following example uses thread-local variables to compute the sum of the results of many lengthy operations.</span></span> <span data-ttu-id="ece51-318">In diesem Beispiel wird der Grad der Parallelität auf vier beschränkt.</span><span class="sxs-lookup"><span data-stu-id="ece51-318">This example limits the degree of parallelism to four.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-319">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-319">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-320">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-320">-or-</span></span> 
<span data-ttu-id="ece51-321">Das <paramref name="localInit" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-321">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-322">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-322">-or-</span></span> 
<span data-ttu-id="ece51-323">Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-323">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-324">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-324">-or-</span></span> 
<span data-ttu-id="ece51-325">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-325">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-326">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-326">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-327">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-327">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-328">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-328">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-329">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-329">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, parallelOptions As ParallelOptions, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="ece51-330">Der Typ der threadlokalen Daten.</span><span class="sxs-lookup"><span data-stu-id="ece51-330">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="ece51-331">Der Startindex, einschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-331">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ece51-332">Der Endindex, ausschließend.</span><span class="sxs-lookup"><span data-stu-id="ece51-332">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-333">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-333">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="ece51-334">Der Funktionsdelegat, der den Ausgangszustand der lokalen Daten für jeden Thread zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-334">The function delegate that returns the initial state of the local data for each thread.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-335">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-335">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ece51-336">Der Delegat, der eine abschließende Aktion für den lokalen Zustand jedes Threads ausführt.</span><span class="sxs-lookup"><span data-stu-id="ece51-336">The delegate that performs a final action on the local state of each thread.</span></span></param>
        <summary><span data-ttu-id="ece51-337">Führt eine <see langword="for" />-Schleife mit 64-Bit Indizes und Thread-lokalen Daten aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar, und der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-337">Executes a <see langword="for" /> loop with 64-bit indexes and thread-local data in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-338">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-338">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-339">Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-339">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ece51-340">Sie wird mit den folgenden Parametern bereitgestellt: die Iterationen Anzahl (<xref:System.Int64>), eine <xref:System.Threading.Tasks.ParallelLoopState> Instanz, die verwendet werden kann, um die Schleife vorzeitig zu verlassen, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die im selben Thread ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-340">It is provided with the following parameters: the iteration count (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="ece51-341">Der `localInit` Delegat wird für jeden Thread, der an der Ausführung der Schleife teilnimmt, einmal aufgerufen und gibt den anfänglichen lokalen Zustand für jeden dieser Threads zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-341">The `localInit` delegate is invoked once for each thread that participates in the loop's execution and returns the initial local state for each of those threads.</span></span> <span data-ttu-id="ece51-342">Diese Ausgangszustände werden an die ersten `body` Aufrufe in jedem Thread weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="ece51-342">These initial states are passed to the first `body` invocations on each thread.</span></span> <span data-ttu-id="ece51-343">Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-343">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ece51-344">Schließlich gibt der letzte Text Aufruf für jeden Thread einen Zustandswert zurück, der an den `localFinally`-Delegaten weitergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-344">Finally, the last body invocation on each thread returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ece51-345">Der `localFinally` Delegat wird einmal pro Thread aufgerufen, um eine abschließende Aktion für den lokalen Zustand jedes Threads auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-345">The `localFinally` delegate is invoked once per thread to perform a final action on each thread's local state.</span></span> <span data-ttu-id="ece51-346">Dieser Delegat kann gleichzeitig für mehrere Threads aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-346">This delegate might be invoked concurrently on multiple threads; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ece51-347">Die <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>-Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-347">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ece51-348">Dadurch erhält das zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.</span><span class="sxs-lookup"><span data-stu-id="ece51-348">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="ece51-349">Wenn `fromInclusive` größer oder gleich `toExclusive`ist, wird die Methode sofort zurückgegeben, ohne dass Iterationen durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-349">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-350">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-350">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-351">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-351">-or-</span></span> 
<span data-ttu-id="ece51-352">Das <paramref name="localInit" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-352">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-353">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-353">-or-</span></span> 
<span data-ttu-id="ece51-354">Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-354">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-355">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-355">-or-</span></span> 
<span data-ttu-id="ece51-356">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-356">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-357">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-357">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-358">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-358">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-359">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-359">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-360">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-360">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ece51-361">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each " /> in Visual Basic) aus, bei dem Iterationen parallel ausgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="ece51-361">Executes a <see langword="foreach" /> (<see langword="For Each " /> in Visual Basic) operation in which iterations may run in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-362">Der Typ der Elemente in <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-362">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-363">Der sortierbare Partitionierer, der die ursprüngliche Datenquelle enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-363">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-364">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-364">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-365">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> aus. Iterationen können parallel ablaufen, und der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-365">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-366">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-366">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-367">Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten.</span><span class="sxs-lookup"><span data-stu-id="ece51-367">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ece51-368">Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-368">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ece51-369">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>-Methode erwartet, dass benutzerdefinierte Partitionierer die dynamische Partitionierung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ece51-369">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ece51-370">Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und Gewusst [wie: Implementieren dynamischer Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-370">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-371">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-371">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-372">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-372">-or-</span></span> 
<span data-ttu-id="ece51-373">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-373">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ece51-374">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /> sortierbaren Partitionierer gibt <see langword="false" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-374">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ece51-375">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-375">-or-</span></span> 
<span data-ttu-id="ece51-376">Die <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" />-Eigenschaft im nach Quelle sortierbaren Partitionierer gibt <see langword="false" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-376">The <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> property in the source orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ece51-377">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-377">-or-</span></span> 
<span data-ttu-id="ece51-378">Sämtliche Methoden im sortierbaren Quellpartitionierer geben <see langword="null" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-378">Any methods in the source orderable partitioner return <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-379">Die Ausnahme, die von einem der angegebenen Delegaten ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="ece51-379">The exception thrown from one of the specified delegates.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-380">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-380">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-381">Der Typ der Elemente in <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-381">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-382">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-382">The partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-383">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-383">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-384">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ablaufen, und der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-384">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-385">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-385">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-386">Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten.</span><span class="sxs-lookup"><span data-stu-id="ece51-386">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ece51-387">Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-387">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ece51-388">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>-Methode erwartet, dass benutzerdefinierte Partitionierer die dynamische Partitionierung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ece51-388">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ece51-389">Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und Gewusst [wie: Implementieren dynamischer Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-389">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-390">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-390">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-391">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-391">-or-</span></span> 
<span data-ttu-id="ece51-392">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-392">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ece51-393">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" />-Partitioner gibt <see langword="false" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-393">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ece51-394">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-394">-or-</span></span> 
<span data-ttu-id="ece51-395">Eine Methode im <paramref name="source" />-Partitioner gibt <see langword="null" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-395">A method in the <paramref name="source" /> partitioner returns <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-396">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-396">-or-</span></span> 
<span data-ttu-id="ece51-397">Die <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" />-Methode im <paramref name="source" />-Partitioner gibt nicht die korrekte Anzahl von Partitionen zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-397">The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> method in the <paramref name="source" /> partitioner does not return the correct number of partitions.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-398">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-398">Parallel Loops</span></span></related>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-399">Die Ausnahme, die ausgelöst wird, um eine Ausnahme zu enthalten, die von einem der angegebenen Delegaten ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="ece51-399">The exception that is thrown to contain an exception thrown from one of the specified delegates.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-400">Der Typ der Elemente in <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-400">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-401">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-401">The partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-402">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-402">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-403">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) für ein <see cref="T:System.Collections.Concurrent.Partitioner" />-Objekt aus, in dem Iterationen parallel ausgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="ece51-403">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="ece51-404">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-404">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-405">Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten.</span><span class="sxs-lookup"><span data-stu-id="ece51-405">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ece51-406">Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-406">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ece51-407">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>-Methode erwartet, dass benutzerdefinierte Partitionierer die dynamische Partitionierung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ece51-407">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ece51-408">Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und Gewusst [wie: Implementieren dynamischer Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-408">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ece51-409">Im folgenden Beispiel wird gezeigt, wie ein Bereichs Partitionierer für die Verwendung mit <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>implementiert wird:</span><span class="sxs-lookup"><span data-stu-id="ece51-409">The following example shows how to implement a range partitioner for use with <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-410">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-410">The <paramref name="source" /> argument is  <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-411">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-411">-or-</span></span> 
<span data-ttu-id="ece51-412">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-412">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ece51-413">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" />-Partitioner gibt <see langword="false" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-413">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ece51-414">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-414">-or-</span></span> 
<span data-ttu-id="ece51-415">Die Ausnahme, die ausgelöst wird, wenn irgendeine Methode im <paramref name="source" />-Partitionierer <see langword="null" /> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-415">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-416">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-416">-or-</span></span> 
<span data-ttu-id="ece51-417">Die <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" />-Methode im <paramref name="source" />-Partitioner gibt nicht die korrekte Anzahl von Partitionen zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-417">The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> method in the <paramref name="source" /> partitioner does not return the correct number of partitions.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-418">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-418">Parallel Loops</span></span></related>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-419">Die Ausnahme, die ausgelöst wird, um eine Ausnahme zu enthalten, die von einem der angegebenen Delegaten ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="ece51-419">The exception that is thrown to contain an exception thrown from one of the specified delegates.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-420">Der Typ der Daten in der Quelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-420">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-421">Eine auflistbare Datenquelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-421">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-422">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-422">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-423">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit 64-Bit-Indizes für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ausgeführt werden. Der Schleifenzustand kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-423">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-424">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-424">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-425">Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-425">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ece51-426">Sie wird mit den folgenden Parametern bereitgestellt: das aktuelle Element, eine <xref:System.Threading.Tasks.ParallelLoopState>-Instanz, die verwendet werden kann, um die Schleife vorzeitig zu verlassen, und der Index des aktuellen Elements (<xref:System.Int64>).</span><span class="sxs-lookup"><span data-stu-id="ece51-426">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and the current element's index (<xref:System.Int64>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-427">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-427">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-428">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-428">-or-</span></span> 
<span data-ttu-id="ece51-429">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-429">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-430">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-430">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-431">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-431">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-432">Der Typ der Daten in der Quelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-432">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-433">Eine auflistbare Datenquelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-433">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-434">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-434">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-435">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-435">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-436">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-436">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-437">Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-437">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ece51-438">Sie wird mit den folgenden Parametern bereitgestellt: dem aktuellen Element und einer <xref:System.Threading.Tasks.ParallelLoopState>-Instanz, die verwendet werden kann, um die Schleife vorzeitig abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="ece51-438">It is provided with the following parameters: the current element, and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-439">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-439">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-440">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-440">-or-</span></span> 
<span data-ttu-id="ece51-441">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-441">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-442">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-442">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-443">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-443">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-444">Der Typ der Daten in der Quelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-444">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-445">Eine auflistbare Datenquelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-445">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-446">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-446">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-447">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-447">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="ece51-448">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-448">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-449">Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-449">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ece51-450">Sie wird mit dem aktuellen Element als Parameter bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="ece51-450">It is provided with the current element as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ece51-451">Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29>-Methode verwendet, um die Anzahl der Vokale und der Zeichen, die keine Leerzeichen sind, in einer Textdatei zu zählen.</span><span class="sxs-lookup"><span data-stu-id="ece51-451">The following example uses the <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> method to count the number of vowels and non-white-space characters in a text file.</span></span> <span data-ttu-id="ece51-452">In diesem Fall wird der von der-Methode zurückgegebene <xref:System.Threading.Tasks.ParallelLoopResult> Wert ignoriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-452">In this case, the <xref:System.Threading.Tasks.ParallelLoopResult> value returned by the method is ignored.</span></span> <span data-ttu-id="ece51-453">Da Vorgänge parallel ausgeführt werden können, müssen Sie sicherstellen, dass das Inkrementieren der gegen Variablen eine atomarische Operation ist, und dass mehrere Threads nicht versuchen, gleichzeitig auf die Counter-Variablen zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="ece51-453">Note that, because operations can run in parallel, you must ensure that incrementing the counter variables is an atomic operation, and that multiple threads do not attempt to access the counter variables simultaneously.</span></span> <span data-ttu-id="ece51-454">Zu diesem Zweck verwendet das Beispiel die `lock`-Anweisung (in C#) und die `SyncLock`-Anweisung (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ece51-454">For this purpose, the example uses the `lock` statement (in C#) and the `SyncLock` statement (in Visual Basic).</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-455">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-455">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-456">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-456">-or-</span></span> 
<span data-ttu-id="ece51-457">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-457">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-458">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-458">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-459">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-459">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), parallelOptions As ParallelOptions, body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-460">Der Typ der Elemente in <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-460">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-461">Der sortierbare Partitionierer, der die ursprüngliche Datenquelle enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-461">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-462">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-462">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-463">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-463">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-464">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> aus. Iterationen können parallel ablaufen, Schleifenoptionen sind konfigurierbar, und der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-464">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-465">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-465">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-466">Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten.</span><span class="sxs-lookup"><span data-stu-id="ece51-466">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ece51-467">Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-467">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ece51-468">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>-Methode erwartet, dass benutzerdefinierte Partitionierer die dynamische Partitionierung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ece51-468">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ece51-469">Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und Gewusst [wie: Implementieren dynamischer Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-469">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-470">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-470">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-471">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-471">The <paramref name="source" /> argument is  <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-472">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-472">-or-</span></span> 
<span data-ttu-id="ece51-473">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-473">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-474">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-474">-or-</span></span> 
<span data-ttu-id="ece51-475">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-475">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-476">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-476">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ece51-477">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /> sortierbaren Partitionierer gibt <see langword="false" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-477">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ece51-478">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-478">-or-</span></span> 
<span data-ttu-id="ece51-479">Die <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" />-Eigenschaft im <paramref name="source" /> sortierbaren Partitionierer gibt <see langword="false" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-479">The <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ece51-480">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-480">-or-</span></span> 
<span data-ttu-id="ece51-481">Die Ausnahme, die ausgelöst wird, wenn irgendwelche Methoden im <paramref name="source" /> sortierbaren Partitionierer <see langword="null" /> zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="ece51-481">The exception that is thrown when any methods in the <paramref name="source" /> orderable partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-482">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-482">Parallel Loops</span></span></related>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-483">Die Ausnahme, die ausgelöst wird, um eine Ausnahme zu enthalten, die von einem der angegebenen Delegaten ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="ece51-483">The exception that is thrown to contain an exception thrown from one of the specified delegates.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), parallelOptions As ParallelOptions, body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-484">Der Typ der Elemente in <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-484">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-485">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-485">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-486">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-486">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-487">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-487">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-488">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ablaufen, Schleifenoptionen sind konfigurierbar, und der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-488">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-489">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-489">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-490">Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten.</span><span class="sxs-lookup"><span data-stu-id="ece51-490">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ece51-491">Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-491">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ece51-492">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>-Methode erwartet, dass benutzerdefinierte Partitionierer die dynamische Partitionierung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ece51-492">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ece51-493">Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und Gewusst [wie: Implementieren dynamischer Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-493">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-494">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-494">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-495">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-495">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-496">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-496">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-497">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-497">-or-</span></span> 
<span data-ttu-id="ece51-498">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-498">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-499">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-499">-or-</span></span> 
<span data-ttu-id="ece51-500">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-500">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ece51-501">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" />-Partitioner gibt <see langword="false" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-501">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ece51-502">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-502">-or-</span></span> 
<span data-ttu-id="ece51-503">Die Ausnahme, die ausgelöst wird, wenn irgendeine Methode im <paramref name="source" />-Partitionierer <see langword="null" /> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-503">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-504">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-504">Parallel Loops</span></span></related>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-505">Die Ausnahme, die ausgelöst wird, um eine Ausnahme zu enthalten, die von einem der angegebenen Delegaten ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="ece51-505">The exception that is thrown to contain an exception thrown from one of the specified delegates.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), parallelOptions As ParallelOptions, body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-506">Der Typ der Elemente in <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-506">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-507">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-507">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-508">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-508">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-509">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-509">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-510">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ausgeführt werden, Schleifenoptionen sind konfigurierbar.</span><span class="sxs-lookup"><span data-stu-id="ece51-510">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="ece51-511">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-511">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-512">Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten.</span><span class="sxs-lookup"><span data-stu-id="ece51-512">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ece51-513">Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-513">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ece51-514">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>-Methode erwartet, dass benutzerdefinierte Partitionierer die dynamische Partitionierung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ece51-514">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ece51-515">Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und Gewusst [wie: Implementieren dynamischer Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-515">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-516">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-516">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-517">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-517">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-518">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-518">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-519">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-519">-or-</span></span> 
<span data-ttu-id="ece51-520">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-520">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-521">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-521">-or-</span></span> 
<span data-ttu-id="ece51-522">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-522">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ece51-523">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" />-Partitioner gibt <see langword="false" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-523">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ece51-524">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-524">-or-</span></span> 
<span data-ttu-id="ece51-525">Die Ausnahme, die ausgelöst wird, wenn irgendeine Methode im <paramref name="source" />-Partitionierer <see langword="null" /> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-525">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-526">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-526">Parallel Loops</span></span></related>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-527">Die Ausnahme, die ausgelöst wird, um eine Ausnahme zu enthalten, die von einem der angegebenen Delegaten ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="ece51-527">The exception that is thrown to contain an exception thrown from one of the specified delegates.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), parallelOptions As ParallelOptions, body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-528">Der Typ der Daten in der Quelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-528">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-529">Eine auflistbare Datenquelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-529">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-530">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-530">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-531">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-531">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-532">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit 64-Bit-Indizes für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-532">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-533">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-533">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-534">Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-534">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ece51-535">Sie wird mit den folgenden Parametern bereitgestellt: das aktuelle Element, eine <xref:System.Threading.Tasks.ParallelLoopState>-Instanz, die verwendet werden kann, um die Schleife vorzeitig zu verlassen, und der Index des aktuellen Elements (<xref:System.Int64>).</span><span class="sxs-lookup"><span data-stu-id="ece51-535">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and the current element's index (<xref:System.Int64>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-536">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-536">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-537">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-537">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-538">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-538">-or-</span></span> 
<span data-ttu-id="ece51-539">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-539">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-540">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-540">-or-</span></span> 
<span data-ttu-id="ece51-541">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-541">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-542">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-542">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-543">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-543">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-544">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-544">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), parallelOptions As ParallelOptions, body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-545">Der Typ der Daten in der Quelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-545">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-546">Eine auflistbare Datenquelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-546">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-547">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-547">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-548">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-548">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-549">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) für ein <see cref="T:System.Collections.IEnumerable" />-Objekt aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-549">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-550">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-550">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-551">Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-551">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ece51-552">Sie wird mit den folgenden Parametern bereitgestellt: dem aktuellen Element und einer <xref:System.Threading.Tasks.ParallelLoopState>-Instanz, die verwendet werden kann, um die Schleife vorzeitig abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="ece51-552">It is provided with the following parameters: the current element, and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-553">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-553">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-554">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-554">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-555">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-555">-or-</span></span> 
<span data-ttu-id="ece51-556">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-556">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-557">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-557">-or-</span></span> 
<span data-ttu-id="ece51-558">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-558">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-559">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-559">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-560">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-560">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-561">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-561">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), parallelOptions As ParallelOptions, body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-562">Der Typ der Daten in der Quelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-562">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-563">Eine auflistbare Datenquelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-563">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-564">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-564">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-565">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-565">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ece51-566">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) für ein <see cref="T:System.Collections.IEnumerable" />-Objekt aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar.</span><span class="sxs-lookup"><span data-stu-id="ece51-566">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="ece51-567">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-567">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-568">Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-568">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ece51-569">Sie wird mit dem aktuellen Element als Parameter bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="ece51-569">It is provided with the current element as a parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-570">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-570">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-571">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-571">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-572">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-572">-or-</span></span> 
<span data-ttu-id="ece51-573">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-573">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-574">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-574">-or-</span></span> 
<span data-ttu-id="ece51-575">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-575">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-576">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-576">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-577">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-577">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-578">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-578">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-579">Der Typ der Elemente in <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-579">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ece51-580">Der Typ der threadlokalen Daten.</span><span class="sxs-lookup"><span data-stu-id="ece51-580">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-581">Der sortierbare Partitionierer, der die ursprüngliche Datenquelle enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-581">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="ece51-582">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-582">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-583">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-583">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ece51-584">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</span><span class="sxs-lookup"><span data-stu-id="ece51-584">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ece51-585">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten für einen <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-585">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-586">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-586">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-587">Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten.</span><span class="sxs-lookup"><span data-stu-id="ece51-587">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ece51-588">Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-588">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ece51-589">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A>-Methode erwartet, dass benutzerdefinierte Partitionierer die dynamische Partitionierung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ece51-589">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ece51-590">Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und Gewusst [wie: Implementieren dynamischer Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-590">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="ece51-591">Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-591">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ece51-592">Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="ece51-592">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ece51-593">Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-593">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ece51-594">Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally`-Delegaten weitergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-594">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ece51-595">Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-595">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ece51-596">Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-596">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ece51-597">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>-Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-597">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ece51-598">Dadurch erhält das zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.</span><span class="sxs-lookup"><span data-stu-id="ece51-598">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-599">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-599">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-600">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-600">-or-</span></span> 
<span data-ttu-id="ece51-601">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-601">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-602">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-602">-or-</span></span> 
<span data-ttu-id="ece51-603">Das <paramref name="localInit" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-603">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-604">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-604">-or-</span></span> 
<span data-ttu-id="ece51-605">Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-605">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ece51-606">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> gibt <see langword="false" /> zurück, oder der Partitionierer gibt die <see langword="null" />-Partitionen zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-606">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-607">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-607">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-608">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-608">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-609">Der Typ der Elemente in <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-609">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ece51-610">Der Typ der threadlokalen Daten.</span><span class="sxs-lookup"><span data-stu-id="ece51-610">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-611">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-611">The partitioner that contains the original data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="ece51-612">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-612">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-613">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-613">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ece51-614">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</span><span class="sxs-lookup"><span data-stu-id="ece51-614">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ece51-615">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten für einen <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ablaufen. Der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-615">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-616">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-616">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-617">Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten.</span><span class="sxs-lookup"><span data-stu-id="ece51-617">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ece51-618">Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-618">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ece51-619">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A>-Methode erwartet, dass benutzerdefinierte Partitionierer die dynamische Partitionierung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ece51-619">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ece51-620">Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und Gewusst [wie: Implementieren dynamischer Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-620">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="ece51-621">Der `localInit` Delegat wird für jeden Thread, der an der Ausführung der Schleife teilnimmt, einmal aufgerufen und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-621">The `localInit` delegate is invoked once for each thread that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ece51-622">Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="ece51-622">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ece51-623">Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-623">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ece51-624">Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally`-Delegaten weitergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-624">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ece51-625">Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-625">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ece51-626">Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-626">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ece51-627">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>-Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-627">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ece51-628">Dadurch erhält das zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.</span><span class="sxs-lookup"><span data-stu-id="ece51-628">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-629">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-629">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-630">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-630">-or-</span></span> 
<span data-ttu-id="ece51-631">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-631">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-632">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-632">-or-</span></span> 
<span data-ttu-id="ece51-633">Das <paramref name="localInit" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-633">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-634">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-634">-or-</span></span> 
<span data-ttu-id="ece51-635">Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-635">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ece51-636">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> gibt <see langword="false" /> zurück, oder der Partitionierer gibt die <see langword="null" />-Partitionen zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-636">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-637">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-637">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-638">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-638">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-639">Der Typ der Daten in der Quelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-639">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ece51-640">Der Typ der threadlokalen Daten.</span><span class="sxs-lookup"><span data-stu-id="ece51-640">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-641">Eine auflistbare Datenquelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-641">An enumerable data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="ece51-642">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-642">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-643">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-643">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ece51-644">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</span><span class="sxs-lookup"><span data-stu-id="ece51-644">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ece51-645">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-645">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-646">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-646">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-647">Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-647">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ece51-648">Sie wird mit den folgenden Parametern bereitgestellt: das aktuelle Element, eine <xref:System.Threading.Tasks.ParallelLoopState>-Instanz, die verwendet werden kann, um die Schleife vorzeitig auszubrechen, den Index des aktuellen Elements (<xref:System.Int64>) und einen lokalen Zustand, der von Iterationen gemeinsam genutzt werden kann, die im selben Thread ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-648">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, the current element's index (<xref:System.Int64>), and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="ece51-649">Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-649">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ece51-650">Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="ece51-650">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ece51-651">Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-651">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ece51-652">Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally`-Delegaten weitergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-652">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ece51-653">Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-653">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ece51-654">Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-654">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ece51-655">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>-Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-655">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ece51-656">Dadurch erhält das zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.</span><span class="sxs-lookup"><span data-stu-id="ece51-656">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-657">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-657">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-658">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-658">-or-</span></span> 
<span data-ttu-id="ece51-659">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-659">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-660">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-660">-or-</span></span> 
<span data-ttu-id="ece51-661">Das <paramref name="localInit" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-661">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-662">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-662">-or-</span></span> 
<span data-ttu-id="ece51-663">Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-663">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-664">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-664">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-665">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-665">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-666">Der Typ der Daten in der Quelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-666">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ece51-667">Der Typ der threadlokalen Daten.</span><span class="sxs-lookup"><span data-stu-id="ece51-667">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-668">Eine auflistbare Datenquelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-668">An enumerable data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="ece51-669">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-669">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-670">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-670">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ece51-671">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</span><span class="sxs-lookup"><span data-stu-id="ece51-671">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ece51-672">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-672">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-673">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-673">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-674">Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-674">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ece51-675">Sie wird mit den folgenden Parametern bereitgestellt: das aktuelle Element, eine <xref:System.Threading.Tasks.ParallelLoopState>-Instanz, die verwendet werden kann, um die Schleife vorzeitig zu verlassen, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die im selben Thread ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-675">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="ece51-676">Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-676">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ece51-677">Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="ece51-677">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ece51-678">Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-678">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ece51-679">Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally`-Delegaten weitergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-679">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ece51-680">Der `localFinally` Delegat wird einmal pro Thread aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-680">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="ece51-681">Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-681">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ece51-682">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>-Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-682">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ece51-683">Dadurch erhält das zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.</span><span class="sxs-lookup"><span data-stu-id="ece51-683">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ece51-684">Im folgenden Beispiel wird gezeigt, wie eine <xref:System.Threading.Tasks.Parallel.ForEach%2A> Methode mit lokalem Zustand verwendet wird:</span><span class="sxs-lookup"><span data-stu-id="ece51-684">The following example shows how to use a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method with local state:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-685">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-685">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-686">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-686">-or-</span></span> 
<span data-ttu-id="ece51-687">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-687">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-688">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-688">-or-</span></span> 
<span data-ttu-id="ece51-689">Das <paramref name="localInit" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-689">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-690">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-690">-or-</span></span> 
<span data-ttu-id="ece51-691">Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-691">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-692">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-692">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-693">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-693">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), parallelOptions As ParallelOptions, localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-694">Der Typ der Elemente in <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-694">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ece51-695">Der Typ der threadlokalen Daten.</span><span class="sxs-lookup"><span data-stu-id="ece51-695">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-696">Der sortierbare Partitionierer, der die ursprüngliche Datenquelle enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-696">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-697">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-697">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="ece51-698">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-698">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-699">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-699">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ece51-700">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</span><span class="sxs-lookup"><span data-stu-id="ece51-700">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ece51-701">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit 64-Bit-Indizes und threadlokalen Daten für einen <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-701">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes and  with thread-local data on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel , loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-702">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-702">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-703">Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten.</span><span class="sxs-lookup"><span data-stu-id="ece51-703">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ece51-704">Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-704">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ece51-705">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A>-Methode erwartet, dass benutzerdefinierte Partitionierer die dynamische Partitionierung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ece51-705">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ece51-706">Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und Gewusst [wie: Implementieren dynamischer Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-706">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="ece51-707">Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-707">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ece51-708">Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="ece51-708">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ece51-709">Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-709">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ece51-710">Schließlich gibt der letzte Text Aufruf für jeden Thread einen Zustandswert zurück, der an den `localFinally`-Delegaten weitergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-710">Finally, the last body invocation on each thread returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ece51-711">Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-711">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ece51-712">Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-712">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ece51-713">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>-Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-713">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ece51-714">Dadurch erhält das zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.</span><span class="sxs-lookup"><span data-stu-id="ece51-714">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-715">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-715">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-716">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-716">-or-</span></span> 
<span data-ttu-id="ece51-717">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-717">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-718">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-718">-or-</span></span> 
<span data-ttu-id="ece51-719">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-719">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-720">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-720">-or-</span></span> 
<span data-ttu-id="ece51-721">Der <paramref name="localInit" /> oder das <paramref name="localFinally" />-Argument ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-721">The <paramref name="localInit" /> or <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ece51-722">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> gibt <see langword="false" /> zurück, oder der Partitionierer gibt die <see langword="null" />-Partitionen zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-722">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-723">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-723">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-724">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-724">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-725">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-725">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-726">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-726">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), parallelOptions As ParallelOptions, localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-727">Der Typ der Elemente in <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-727">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ece51-728">Der Typ der threadlokalen Daten.</span><span class="sxs-lookup"><span data-stu-id="ece51-728">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-729">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-729">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-730">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-730">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="ece51-731">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-731">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-732">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-732">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ece51-733">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</span><span class="sxs-lookup"><span data-stu-id="ece51-733">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ece51-734">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten für einen <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-734">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation  with thread-local data on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-735">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-735">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-736">Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten.</span><span class="sxs-lookup"><span data-stu-id="ece51-736">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ece51-737">Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-737">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ece51-738">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A>-Methode erwartet, dass benutzerdefinierte Partitionierer die dynamische Partitionierung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ece51-738">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ece51-739">Diese Überladung wird für Szenarien mit kleinen Schleifen Körpern bereitgestellt, die von der statischen Bereichs Partitionierung profitieren können.</span><span class="sxs-lookup"><span data-stu-id="ece51-739">This overload is provided for scenarios with small loop bodies that might benefit from static range partitioning.</span></span> <span data-ttu-id="ece51-740">Partitionierer müssen dynamische Partitionen unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ece51-740">Partitioners must support dynamic partitions.</span></span>  <span data-ttu-id="ece51-741">Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und Gewusst [wie: Implementieren dynamischer Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-741">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="ece51-742">Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-742">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ece51-743">Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="ece51-743">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ece51-744">Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-744">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ece51-745">Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally`-Delegaten weitergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-745">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ece51-746">Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-746">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ece51-747">Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-747">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ece51-748">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>-Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-748">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ece51-749">Dadurch erhält das zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.</span><span class="sxs-lookup"><span data-stu-id="ece51-749">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-750">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-750">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-751">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-751">-or-</span></span> 
<span data-ttu-id="ece51-752">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-752">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-753">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-753">-or-</span></span> 
<span data-ttu-id="ece51-754">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-754">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-755">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-755">-or-</span></span> 
<span data-ttu-id="ece51-756">Das <paramref name="localInit" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-756">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-757">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-757">-or-</span></span> 
<span data-ttu-id="ece51-758">Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-758">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ece51-759">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> gibt <see langword="false" /> zurück, oder der Partitionierer gibt die <see langword="null" />-Partitionen zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-759">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-760">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-760">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-761">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-761">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-762">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-762">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-763">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-763">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), parallelOptions As ParallelOptions, localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-764">Der Typ der Daten in der Quelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-764">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ece51-765">Der Typ der threadlokalen Daten.</span><span class="sxs-lookup"><span data-stu-id="ece51-765">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-766">Eine auflistbare Datenquelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-766">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-767">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-767">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="ece51-768">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-768">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-769">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-769">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ece51-770">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</span><span class="sxs-lookup"><span data-stu-id="ece51-770">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ece51-771">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten und 64-Bit-Indizes für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-771">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data and 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-772">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-772">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-773">Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-773">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ece51-774">Sie wird mit den folgenden Parametern bereitgestellt: das aktuelle Element, eine <xref:System.Threading.Tasks.ParallelLoopState>-Instanz, die verwendet werden kann, um die Schleife vorzeitig auszubrechen, den Index des aktuellen Elements (<xref:System.Int64>) und einen lokalen Zustand, der von Iterationen gemeinsam genutzt werden kann, die im selben Thread ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-774">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, the current element's index (<xref:System.Int64>), and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="ece51-775">Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-775">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ece51-776">Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="ece51-776">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ece51-777">Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-777">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ece51-778">Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally`-Delegaten weitergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-778">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ece51-779">Der `localFinally` Delegat wird einmal pro Thread aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-779">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="ece51-780">Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-780">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ece51-781">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>-Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-781">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ece51-782">Dadurch erhält das zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.</span><span class="sxs-lookup"><span data-stu-id="ece51-782">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-783">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-783">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-784">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-784">-or-</span></span> 
<span data-ttu-id="ece51-785">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-785">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-786">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-786">-or-</span></span> 
<span data-ttu-id="ece51-787">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-787">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-788">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-788">-or-</span></span> 
<span data-ttu-id="ece51-789">Das <paramref name="localInit" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-789">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-790">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-790">-or-</span></span> 
<span data-ttu-id="ece51-791">Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-791">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-792">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-792">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-793">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-793">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-794">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-794">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-795">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-795">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), parallelOptions As ParallelOptions, localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ece51-796">Der Typ der Daten in der Quelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-796">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ece51-797">Der Typ der threadlokalen Daten.</span><span class="sxs-lookup"><span data-stu-id="ece51-797">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ece51-798">Eine auflistbare Datenquelle.</span><span class="sxs-lookup"><span data-stu-id="ece51-798">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ece51-799">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-799">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="ece51-800">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ece51-800">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ece51-801">Der Delegat, der einmal pro Iteration aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-801">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ece51-802">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</span><span class="sxs-lookup"><span data-stu-id="ece51-802">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ece51-803">Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann überwacht und angepasst werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-803">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ece51-804">Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ece51-804">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-805">Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ece51-805">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ece51-806">Sie wird mit den folgenden Parametern bereitgestellt: das aktuelle Element, eine <xref:System.Threading.Tasks.ParallelLoopState>-Instanz, die verwendet werden kann, um die Schleife vorzeitig zu verlassen, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die im selben Thread ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-806">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="ece51-807">Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück.</span><span class="sxs-lookup"><span data-stu-id="ece51-807">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ece51-808">Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="ece51-808">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ece51-809">Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-809">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ece51-810">Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally`-Delegaten weitergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-810">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ece51-811">Der `localFinally` Delegat wird einmal pro Thread aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-811">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="ece51-812">Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="ece51-812">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ece51-813">Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>-Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="ece51-813">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ece51-814">Dadurch erhält das zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.</span><span class="sxs-lookup"><span data-stu-id="ece51-814">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-815">Das <paramref name="source" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-815">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-816">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-816">-or-</span></span> 
<span data-ttu-id="ece51-817">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-817">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-818">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-818">-or-</span></span> 
<span data-ttu-id="ece51-819">Das <paramref name="body" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-819">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-820">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-820">-or-</span></span> 
<span data-ttu-id="ece51-821">Das <paramref name="localInit" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-821">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-822">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-822">-or-</span></span> 
<span data-ttu-id="ece51-823">Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-823">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-824">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-824">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-825">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-825">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-826">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</span><span class="sxs-lookup"><span data-stu-id="ece51-826">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ece51-827">Parallele Schleifen</span><span class="sxs-lookup"><span data-stu-id="ece51-827">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ece51-828">Führt jede der bereitgestellten Aktionen aus (möglicherweise parallel).</span><span class="sxs-lookup"><span data-stu-id="ece51-828">Executes each of the provided actions, possibly in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions"><span data-ttu-id="ece51-829">Ein Array auszuführender <see cref="T:System.Action" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-829">An array of <see cref="T:System.Action" /> to execute.</span></span></param>
        <summary><span data-ttu-id="ece51-830">Führt jede der bereitgestellten Aktionen aus (möglicherweise parallel).</span><span class="sxs-lookup"><span data-stu-id="ece51-830">Executes each of the provided actions, possibly in parallel.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-831">Diese Methode kann verwendet werden, um eine Reihe von Vorgängen (möglicherweise parallel) auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-831">This method can be used to execute a set of operations, potentially in parallel.</span></span>  
  
 <span data-ttu-id="ece51-832">Die Reihenfolge, in der die Vorgänge ausgeführt werden, oder ob Sie parallel ausgeführt werden, wird nicht garantiert.</span><span class="sxs-lookup"><span data-stu-id="ece51-832">No guarantees are made about the order in which the operations execute or whether they execute in parallel.</span></span> <span data-ttu-id="ece51-833">Diese Methode gibt nicht zurück, bis alle bereitgestellten Vorgänge abgeschlossen sind, unabhängig davon, ob die Beendigung aufgrund der normalen oder außergewöhnlichen Beendigung erfolgt.</span><span class="sxs-lookup"><span data-stu-id="ece51-833">This method does not return until each of the provided operations has completed, regardless of whether completion occurs due to normal or exceptional termination.</span></span>  
  
 <span data-ttu-id="ece51-834">Weitere Informationen finden Sie unter [Gewusst wie: Ausführen von parallelen Aufgaben mithilfe von Parallel.Invoke](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-834">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ece51-835">In diesem Beispiel wird veranschaulicht, wie die <xref:System.Threading.Tasks.Parallel.Invoke%2A>-Methode mit anderen Methoden, anonymen Delegaten und Lambda-Ausdrücken verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="ece51-835">This example demonstrates how to use the <xref:System.Threading.Tasks.Parallel.Invoke%2A> method with other methods, anonymous delegates, and lambda expressions.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-836">Das <paramref name="actions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-836">The <paramref name="actions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-837">Diese Ausnahme wird ausgelöst, wenn eine beliebige Aktion im <paramref name="actions" />-Array eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="ece51-837">The exception that is thrown when any action in the <paramref name="actions" /> array throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ece51-838">Ein <paramref name="actions" />-Array enthält ein <see langword="null" />-Element.</span><span class="sxs-lookup"><span data-stu-id="ece51-838">The <paramref name="actions" /> array contains a <see langword="null" /> element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (parallelOptions As ParallelOptions, ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions"><span data-ttu-id="ece51-839">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="ece51-839">An object that configures the behavior of this operation.</span></span></param>
        <param name="actions"><span data-ttu-id="ece51-840">Ein Array auszuführender Aktionen.</span><span class="sxs-lookup"><span data-stu-id="ece51-840">An array of actions to execute.</span></span></param>
        <summary><span data-ttu-id="ece51-841">Führt die einzelnen bereitgestellten Aktionen (nach Möglichkeit parallel) aus, es sei denn, der Vorgang wird vom Benutzer abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="ece51-841">Executes each of the provided actions, possibly in parallel, unless the operation is cancelled by the user.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ece51-842">Diese Methode kann verwendet werden, um eine Reihe von Vorgängen (möglicherweise parallel) auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ece51-842">This method can be used to execute a set of operations, potentially in parallel.</span></span> <span data-ttu-id="ece51-843">Das mit der <xref:System.Threading.Tasks.ParallelOptions>-Struktur übergebenen Abbruch Token ermöglicht dem Aufrufer, den gesamten Vorgang abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="ece51-843">The cancellation token passed in with the <xref:System.Threading.Tasks.ParallelOptions> structure enables the caller to cancel the entire operation.</span></span> <span data-ttu-id="ece51-844">Weitere Informationen finden Sie unter [Abbruch in verwalteten Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-844">For more information, see [Cancellation in Managed Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).</span></span>  
  
 <span data-ttu-id="ece51-845">Die Reihenfolge, in der die Vorgänge ausgeführt werden, oder ob Sie parallel ausgeführt werden, wird nicht garantiert.</span><span class="sxs-lookup"><span data-stu-id="ece51-845">No guarantees are made about the order in which the operations execute or whether they execute in parallel.</span></span> <span data-ttu-id="ece51-846">Diese Methode gibt nicht zurück, bis alle bereitgestellten Vorgänge abgeschlossen sind, unabhängig davon, ob die Beendigung aufgrund der normalen oder außergewöhnlichen Beendigung erfolgt.</span><span class="sxs-lookup"><span data-stu-id="ece51-846">This method does not return until each of the provided operations has completed, regardless of whether completion occurs due to normal or exceptional termination.</span></span>  
  
 <span data-ttu-id="ece51-847">Weitere Informationen finden Sie unter [Gewusst wie: Ausführen von parallelen Aufgaben mithilfe von Parallel.Invoke](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span><span class="sxs-lookup"><span data-stu-id="ece51-847">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ece51-848">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> ist festgelegt.</span><span class="sxs-lookup"><span data-stu-id="ece51-848">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> is set.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ece51-849">Das <paramref name="actions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-849">The <paramref name="actions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ece51-850">Oder</span><span class="sxs-lookup"><span data-stu-id="ece51-850">-or-</span></span> 
<span data-ttu-id="ece51-851">Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ece51-851">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ece51-852">Diese Ausnahme wird ausgelöst, wenn eine beliebige Aktion im <paramref name="actions" />-Array eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="ece51-852">The exception that is thrown when any action in the <paramref name="actions" /> array throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ece51-853">Ein <paramref name="actions" />-Array enthält ein <see langword="null" />-Element.</span><span class="sxs-lookup"><span data-stu-id="ece51-853">The <paramref name="actions" /> array contains a <see langword="null" /> element.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ece51-854">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</span><span class="sxs-lookup"><span data-stu-id="ece51-854">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
