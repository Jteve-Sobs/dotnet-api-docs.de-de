<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2e5877b668a67baf4ed3de602d3e7d81869f3db6" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53297176" /></Metadata><TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Unterstützung für parallele Schleifen und Bereiche bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Parallel> Klasse stellt die Bibliothek-basierten Daten parallel Ersetzungen für z. B. für Schleifen und allgemeine Vorgänge für jede Schleifen und die Ausführung einer Reihe von Anweisungen bereit.  
  
   
  
## Examples  
 Dieses Beispiel zeigt verschiedene Ansätze zum Implementieren einer parallelen Schleife mehrere Konstrukte.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle öffentlichen und geschützten Member der <see cref="T:System.Threading.Tasks.Parallel" /> sind threadsicher und können von mehreren Threads gleichzeitig verwendet werden.</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md">Datenparallelität (Task Parallel Library)</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Beispiele für die parallele Programmierung mit .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine <see langword="for" />-Schleife (<see langword="For" /> in Visual Basic) aus, in der Iterationen parallel ausgeführt werden können.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" /> (<see langword="For" /> in Visual Basic)-Schleife aus, in der Iterationen parallel ausgeführt werden können und der Status der Schleife beobachtet und bearbeitet werden kann.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal für jeden Wert im Iterationsbereich von aufgerufen (`fromInclusive`, `toExclusive`). Er wird mit zwei Argumenten bereitgestellt:  
  
-   Ein <xref:System.Int32> Wert, der die Anzahl der Iterationen darstellt.  
  
-   Ein <xref:System.Threading.Tasks.ParallelLoopState> -Instanz, die mit die Schleife vorzeitig unterbrochen werden kann. Die <xref:System.Threading.Tasks.ParallelLoopState> Objekt wird vom Compiler erstellt; in Benutzercode nicht instanziiert werden.  
  
 Aufrufen der <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> -Methode informiert die `for` Vorgang, der keine Iterationen nach der aktuellen ausführen. Allerdings muss alle Iterationen vor der aktuellen eine noch ausgeführt werden, sofern sie noch nicht geschehen.  
  
 Aus diesem Grund Aufrufen <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> funktioniert ähnlich wie einen Break-Vorgang innerhalb einer herkömmlichen `for` Schleife in einer Sprache wie C#, aber es ist nicht perfekter Ersatz: Beispielsweise besteht keine Garantie, dass Iterationen nach der aktuellen Aktivität auf jeden Fall nicht ausgeführt werden.  
  
 Wenn alle Iterationen ausgeführt, bevor der aktuellen Aktivität nicht erforderlich ist, verwenden die <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> Methode anstelle von <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Aufrufen von <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informiert die `for` Schleife können sie alle verbleibende Iterationen, unabhängig davon, ob sie vor oder nach der aktuellen Iteration, da alle verwerfen erforderlichen Arbeit ist bereits abgeschlossen. Da jedoch mit <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, es gibt keine Garantie im Hinblick auf die anderen Iterationen nicht ausgeführt werden.  
  
 Wenn eine Schleife vorzeitig beendet wird die <xref:System.Threading.Tasks.ParallelLoopResult> -Struktur, die zurückgegeben werden relevante Informationen über den Abschluss der Schleife enthält.  
  
 Wenn `fromInclusive` ist größer als oder gleich `toExclusive`, die Methode sofort zurückgegeben, ohne dass alle Iterationen ausgeführt.  
  
   
  
## Examples  
 Im folgende Beispiel wird bis zu 100 Iterationen einer Schleife parallel ausgeführt. Jede Iteration hält für einen zufälligen Intervallen von 1 auf 1000 Millisekunden. Ein zufällig generierter Wert wird bestimmt, auf die Iteration der Schleife die <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> Methode wird aufgerufen. Wie die Ausgabe des Beispiels zeigt, die keine Iterationen, deren Index größer als ist, die <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> Anfang des Wertes Eigenschaft nach dem Aufruf der <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> Methode.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Da Iterationen der Schleife wahrscheinlich weiterhin ausgeführt wird, wenn sind die <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> -Methode aufgerufen wird, ruft jede Iteration der <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> Eigenschaft zu überprüfen, ob eine andere Iteration aufgerufen hat die <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> Methode. Wenn der Eigenschaftswert ist `true`, die Iteration überprüft den Wert des der <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> Eigenschaft und, wenn er größer als die aktuelle Iteration Indexwert ist, wird sofort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" />-Schleife (<see langword="For" /> in Visual Basic) aus, in der Iterationen parallel ausgeführt werden können.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal für jeden Wert im Iterationsbereich von aufgerufen (`fromInclusive`, `toExclusive`). Er wird bereitgestellt, mit die Anzahl der Iterationen (<xref:System.Int32>) als Parameter.  
  
 Wenn `fromInclusive` ist größer als oder gleich `toExclusive`, die Methode sofort zurückgegeben, ohne dass alle Iterationen ausgeführt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Parallel.For%2A> -Methode für 100 Aufrufe eines Delegaten, die zufällige Bytes generiert Werte und deren Summe berechnet.  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" />-Schleife (<see langword="For" /> in Visual Basic) mit 64-Bit-Indizes aus, in der Iterationen parallel ausgeführt werden können und der Zustand der Schleife überwacht und bearbeitet werden kann.</summary>
        <returns>Eine <see cref="T:System.Threading.Tasks.ParallelLoopResult" />-Struktur, die Informationen darüber enthält, welcher Teil der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal für jeden Wert im Iterationsbereich von aufgerufen (`fromInclusive`, `toExclusive`). Er wird bereitgestellt, mit den folgenden Parametern: die Anzahl der Iterationen (<xref:System.Int64>), und ein <xref:System.Threading.Tasks.ParallelLoopState> -Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen.  
  
 Aufrufen der <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> -Methode informiert die `for` Vorgang, der Iterationen nach der aktuellen Aktivität nicht ausgeführt werden, aber alle Iterationen, die vor dem aktuellen Knoten führen.  
  
 Aus diesem Grund aufrufen Unterbrechung funktioniert ähnlich wie einen Break-Vorgang innerhalb einer herkömmlichen `for` Schleife in einer Sprache wie C#, aber es ist nicht perfekter Ersatz: Beispielsweise besteht keine Garantie, dass Iterationen nach der aktuellen Aktivität auf jeden Fall nicht ausgeführt werden.  
  
 Wenn alle Iterationen ausgeführt, bevor der aktuellen Aktivität nicht erforderlich ist, verwenden die <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> Methode anstelle von <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Aufrufen von <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informiert die `for` Schleife können sie alle verbleibende Iterationen, unabhängig davon, ob sie vor oder nach der aktuellen Iteration, da alle verwerfen erforderlichen Arbeit ist bereits abgeschlossen. Da jedoch mit <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, es gibt keine Garantie im Hinblick auf die anderen Iterationen nicht ausgeführt werden.  
  
 Wenn eine Schleife vorzeitig beendet wird die <xref:System.Threading.Tasks.ParallelLoopResult> -Struktur, die zurückgegeben werden relevante Informationen über den Abschluss der Schleife enthält.  
  
 Wenn `fromInclusive` ist größer als oder gleich `toExclusive`, und klicken Sie dann die Methode sofort zurückgegeben, ohne dass alle Iterationen ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" />-Schleife (<see langword="For" /> in Visual Basic) mit 64-Bit-Indizes aus, in der Iterationen parallel ausgeführt werden können.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal für jeden Wert im Iterationsbereich von aufgerufen (`fromInclusive`, `toExclusive`). Er wird bereitgestellt, mit die Anzahl der Iterationen (<xref:System.Int64>) als Parameter.  
  
 Wenn `fromInclusive` ist größer als oder gleich `toExclusive`, die Methode sofort zurückgegeben, ohne dass alle Iterationen ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" /> (<see langword="For" /> in Visual Basic)-Schleife aus, in der Iterationen parallel ausgeführt und Schleifenoptionen konfiguriert werden können und wo der Status der Schleife beobachtet und bearbeitet werden kann.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal für jeden Wert im Iterationsbereich von aufgerufen (`fromInclusive`, `toExclusive`). Er wird bereitgestellt, mit den folgenden Parametern: die Anzahl der Iterationen (<xref:System.Int32>), und ein <xref:System.Threading.Tasks.ParallelLoopState> -Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen.  
  
 Wenn `fromInclusive` ist größer als oder gleich `toExclusive`, die Methode sofort zurückgegeben, ohne dass alle Iterationen ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" /> (<see langword="For" /> in Visual Basic)-Schleife aus, in der Iterationen parallel ausgeführt und Schleifenoptionen konfiguriert werden können.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal für jeden Wert im Iterationsbereich von aufgerufen (`fromInclusive`, `toExclusive`). Er wird bereitgestellt, mit die Anzahl der Iterationen (<xref:System.Int32>) als Parameter.  
  
 Wenn `fromInclusive` ist größer als oder gleich `toExclusive`, und klicken Sie dann die Methode sofort zurückgegeben, ohne dass alle Iterationen ausgeführt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine parallele Schleife:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" /> (<see langword="For" /> in Visual Basic)-Schleife mit 64-Bit-Indizes aus, in der Iterationen parallel ausgeführt und Schleifenoptionen konfiguriert werden können, und der Status der Schleife kann beobachtet und bearbeitet werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal für jeden Wert im Iterationsbereich von aufgerufen (`fromInclusive`, `toExclusive`). Er wird bereitgestellt, mit den folgenden Parametern: die Anzahl der Iterationen (<xref:System.Int64>), und ein <xref:System.Threading.Tasks.ParallelLoopState> -Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen.  
  
 Wenn `fromInclusive` ist größer als oder gleich `toExclusive`, die Methode sofort zurückgegeben, ohne dass alle Iterationen ausgeführt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> -Methode mit einem <xref:System.Threading.Tasks.ParallelOptions> Objekt:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" /> (<see langword="For" /> in Visual Basic)-Schleife mit 64-Bit-Indizes aus, in der Iterationen parallel ausgeführt und Schleifenoptionen konfiguriert werden können.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unterstützt 64-Bit-Indizes. Die `body` Delegat wird einmal für jeden Wert im Iterationsbereich von aufgerufen (`fromInclusive`, `toExclusive`). Er wird bereitgestellt, mit die Anzahl der Iterationen (<xref:System.Int64>) als Parameter.  
  
 Wenn `fromInclusive` ist größer als oder gleich `toExclusive`, und klicken Sie dann die Methode sofort zurückgegeben, ohne dass alle Iterationen ausgeführt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit <xref:System.Threading.Tasks.ParallelOptions> ein benutzerdefinierten Aufgabenplaners angeben:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Der Typ der threadlokalen Daten.</typeparam>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt eine <see langword="for" />-Schleife (<see langword="For" /> in Visual Basic) mit lokalen Threaddaten aus, in der Iterationen parallel ausgeführt und der Status der Schleife beobachtet und bearbeitet werden können.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal für jeden Wert im Iterationsbereich von aufgerufen (`fromInclusive`, `toExclusive`). Er wird bereitgestellt, mit den folgenden Parametern: die Anzahl der Iterationen (<xref:System.Int32>), ein <xref:System.Threading.Tasks.ParallelLoopState> Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die auf dem gleichen Thread ausgeführt werden.  
  
 Die `localInit` Delegat wird einmal für jede Aufgabe, die der Ausführung der Schleife beteiligt ist und gibt den ursprünglichen lokalen Zustand für jeden dieser Vorgänge aufgerufen. Diese Anfangszustände übergeben werden, mit dem ersten `body` Aufrufe für die einzelnen Tasks. Alle nachfolgenden Textaufruf einen möglicherweise Zustandsänderungen Wert zurück, der für den nächsten Textaufruf übergeben wird. Schließlich gibt der letzte Textaufruf für die einzelnen Tasks einen Statuswert, der an die `localFinally` delegieren. Die `localFinally` Delegat wird einmal pro Aufgabe eine abschließende Aktion ausführt, im lokalen Zustand jedes einzelnen Vorgangs aufgerufen. Dieser Delegat kann auf mehrere Aufgaben gleichzeitig aufgerufen werden; aus diesem Grund müssen Sie den Zugriff auf freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Methode können Sie mehr Aufgaben als Threads während der Lebensdauer der Ausführung vorhandener Aufgaben abgeschlossen, und durch neue Vorgänge ersetzt werden. Dadurch wird die zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit zum Hinzufügen, ändern oder Entfernen von Threads, die die Schleife zu verarbeiten.  
  
 Wenn `fromInclusive` ist größer als oder gleich `toExclusive`, und klicken Sie dann die Methode sofort zurückgegeben, ohne dass alle Iterationen ausgeführt.  
  
 Ein Beispiel, diese Methode verwendet, finden Sie unter [Vorgehensweise: Schreiben einer Parallel.For-Schleife mit Thread-lokalen Variablen](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Der Typ der threadlokalen Daten.</typeparam>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt eine <see langword="for" /> (<see langword="For" /> in Visual Basic)-Schleife mit 64-Bit-Indizes sowie lokalen Threaddaten aus, in denen Iterationen parallel ausgeführt werden können, und der Status der Schleife kann beobachtet und bearbeitet werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal für jeden Wert im Iterationsbereich von aufgerufen (`fromInclusive`, `toExclusive`). Er wird bereitgestellt, mit den folgenden Parametern: die Anzahl der Iterationen (<xref:System.Int64>), ein <xref:System.Threading.Tasks.ParallelLoopState> Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die auf die gleiche Aufgabe ausgeführt.  
  
 Die `localInit` Delegat wird einmal für jede Aufgabe, die der Ausführung der Schleife beteiligt ist und gibt den ursprünglichen lokalen Zustand für jeden dieser Vorgänge aufgerufen. Diese Anfangszustände übergeben werden, mit dem ersten `body` Aufrufe für die einzelnen Tasks. Alle nachfolgenden Textaufruf einen möglicherweise Zustandsänderungen Wert zurück, der für den nächsten Textaufruf übergeben wird. Schließlich gibt der letzte Textaufruf für die einzelnen Tasks einen Statuswert, der an die `localFinally` delegieren. Die `localFinally` Delegat wird einmal pro Aufgabe eine abschließende Aktion ausführt, im lokalen Zustand jedes einzelnen Vorgangs aufgerufen. Dieser Delegat kann auf mehrere Aufgaben gleichzeitig aufgerufen werden; aus diesem Grund müssen Sie den Zugriff auf freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Methode können Sie mehr Aufgaben als Threads während der Lebensdauer der Ausführung vorhandener Aufgaben abgeschlossen, und durch neue Vorgänge ersetzt werden. Dadurch wird die zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit zum Hinzufügen, ändern oder Entfernen von Threads, die die Schleife zu verarbeiten.  
  
 Wenn `fromInclusive` ist größer als oder gleich `toExclusive`, und klicken Sie dann die Methode sofort zurückgegeben, ohne dass alle Iterationen ausgeführt.  
  
 Ein Beispiel, diese Methode verwendet, finden Sie unter [Vorgehensweise: Schreiben einer Parallel.For-Schleife mit Thread-lokalen Variablen](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Der Typ der threadlokalen Daten.</typeparam>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt eine <see langword="for" /> (<see langword="For" /> in Visual Basic)-Schleife mit lokalen Threaddaten aus, in der Iterationen parallel ausgeführt, Schleifenoptionen konfiguriert und der Status der Schleife beobachtet und bearbeitet werden können.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal für jeden Wert im Iterationsbereich von aufgerufen (`fromInclusive`, `toExclusive`). Er wird bereitgestellt, mit den folgenden Parametern: die Anzahl der Iterationen (<xref:System.Int32>), ein <xref:System.Threading.Tasks.ParallelLoopState> Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die auf die gleiche Aufgabe ausgeführt.  
  
 Die `localInit` Delegat wird einmal für jede Aufgabe, die der Ausführung der Schleife beteiligt ist und gibt den ursprünglichen lokalen Zustand für jeden dieser Vorgänge aufgerufen. Diese Anfangszustände übergeben werden, mit dem ersten `body` Aufrufe für die einzelnen Tasks. Alle nachfolgenden Textaufruf einen möglicherweise Zustandsänderungen Wert zurück, der für den nächsten Textaufruf übergeben wird. Schließlich gibt der letzte Textaufruf für die einzelnen Tasks einen Statuswert, der an die `localFinally` delegieren. Die `localFinally` Delegat wird einmal pro Aufgabe eine abschließende Aktion ausführt, im lokalen Zustand jedes einzelnen Vorgangs aufgerufen. Dieser Delegat kann in mehreren Threads gleichzeitig aufgerufen werden; aus diesem Grund müssen Sie den Zugriff auf freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Methode können Sie mehr Aufgaben als Threads während der Lebensdauer der Ausführung vorhandener Aufgaben abgeschlossen, und durch neue Vorgänge ersetzt werden. Dadurch wird die zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit zum Hinzufügen, ändern oder Entfernen von Threads, die die Schleife zu verarbeiten.  
  
 Wenn `fromInclusive` ist größer als oder gleich `toExclusive`, und klicken Sie dann die Methode sofort zurückgegeben, ohne dass alle Iterationen ausgeführt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Thread-lokalen Variablen zum Berechnen der Summe der Ergebnisse des viele Vorgänge mit langer Ausführungsdauer. In diesem Beispiel schränkt den Grad an Parallelität 4.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Der Typ der threadlokalen Daten.</typeparam>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="localInit">Der Funktionsdelegat, der den Ausgangszustand der lokalen Daten für jeden Thread zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der eine abschließende Aktion für den lokalen Zustand jedes Threads ausführt.</param>
        <summary>Führt eine <see langword="for" />-Schleife (<see langword="For" /> in Visual Basic) mit 64-Bit Indizes und threadlokalen Daten aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar, und der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal für jeden Wert im Iterationsbereich von aufgerufen (`fromInclusive`, `toExclusive`). Er wird bereitgestellt, mit den folgenden Parametern: die Anzahl der Iterationen (<xref:System.Int64>), ein <xref:System.Threading.Tasks.ParallelLoopState> Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die auf dem gleichen Thread ausgeführt werden.  
  
 Die `localInit` Delegat wird einmal für jeden Thread, die der Ausführung der Schleife beteiligt ist und gibt den ursprünglichen lokalen Zustand für jeden dieser Threads aufgerufen. Diese Anfangszustände übergeben werden, mit dem ersten `body` Aufrufe für jeden Thread. Alle nachfolgenden Textaufruf einen möglicherweise Zustandsänderungen Wert zurück, der für den nächsten Textaufruf übergeben wird. Schließlich gibt der letzte Textaufruf in jedem Thread einen Statuswert, der an die `localFinally` delegieren. Die `localFinally` Delegat wird einmal pro Thread eine abschließende Aktion ausführt, im lokalen Zustand jedes Threads aufgerufen. Dieser Delegat kann in mehreren Threads gleichzeitig aufgerufen werden; aus diesem Grund müssen Sie den Zugriff auf freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Methode können Sie mehr Aufgaben als Threads während der Lebensdauer der Ausführung vorhandener Aufgaben abgeschlossen, und durch neue Vorgänge ersetzt werden. Dadurch wird die zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit zum Hinzufügen, ändern oder Entfernen von Threads, die die Schleife zu verarbeiten.  
  
 Wenn `fromInclusive` ist größer als oder gleich `toExclusive`, und klicken Sie dann die Methode sofort zurückgegeben, ohne dass alle Iterationen ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each " /> in Visual Basic) aus, bei dem Iterationen parallel ausgeführt werden können.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <param name="source">Der sortierbare Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> aus. Iterationen können parallel ablaufen, und der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, wo Sie das Partitionierungsschema überschreiben möchten. Beispielsweise könnte kurzen Schleifenkörpern profitieren Partitionierung des Bereichs. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode erwartet, dass benutzerdefinierte Partitionierer unterstützen dynamische Partitionierung. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Vorgehensweise: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /> sortierbaren Partitionierer gibt <see langword="false" /> zurück.  
  
- oder -  
Die <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" />-Eigenschaft im nach Quelle sortierbaren Partitionierer gibt <see langword="false" /> zurück.  
  
- oder -  
Sämtliche Methoden im sortierbaren Quellpartitionierer geben <see langword="null" /> zurück.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <param name="source">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ablaufen, und der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, wo Sie das Partitionierungsschema überschreiben möchten. Beispielsweise könnte kurzen Schleifenkörpern profitieren Partitionierung des Bereichs. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode erwartet, dass benutzerdefinierte Partitionierer unterstützen dynamische Partitionierung. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Vorgehensweise: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" />-Partitioner gibt <see langword="false" /> zurück.  
  
- oder -  
Eine Methode im <paramref name="source" />-Partitioner gibt <see langword="null" /> zurück.  
  
- oder -  
Die <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" />-Methode im <paramref name="source" />-Partitioner gibt nicht die korrekte Anzahl von Partitionen zurück.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <param name="source">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) für ein <see cref="T:System.Collections.Concurrent.Partitioner" />-Objekt aus, in dem Iterationen parallel ausgeführt werden können.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, wo Sie das Partitionierungsschema überschreiben möchten. Beispielsweise könnte kurzen Schleifenkörpern profitieren Partitionierung des Bereichs. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode erwartet, dass benutzerdefinierte Partitionierer unterstützen dynamische Partitionierung. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Vorgehensweise: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie implementieren eine Bereichspartitionierung für die Verwendung mit <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" />-Partitioner gibt <see langword="false" /> zurück.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn irgendeine Methode im <paramref name="source" />-Partitionierer <see langword="null" /> zurückgibt.  
  
- oder -  
Die <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" />-Methode im <paramref name="source" />-Partitioner gibt nicht die korrekte Anzahl von Partitionen zurück.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Daten in der Quelle.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit 64-Bit-Indizes für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ausgeführt werden. Der Schleifenzustand kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal aufgerufen, für jedes Element in der `source` aufzählbare. Er wird bereitgestellt, mit den folgenden Parametern: das aktuelle Element, ein <xref:System.Threading.Tasks.ParallelLoopState> Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen, und der aktuelle Index des Elements (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Daten in der Quelle.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal aufgerufen, für jedes Element in der `source` aufzählbare. Er wird bereitgestellt, mit den folgenden Parametern: das aktuelle Element, und ein <xref:System.Threading.Tasks.ParallelLoopState> -Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Daten in der Quelle.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal aufgerufen, für jedes Element in der `source` aufzählbare. Sie wird mit dem aktuellen Element als Parameter bereitgestellt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> Methode, um die Anzahl der Vokale und nicht-Leerzeichen in einer Textdatei ermittelt. In diesem Fall die <xref:System.Threading.Tasks.ParallelLoopResult> von der Methode zurückgegebene Wert wird ignoriert. Beachten Sie, dass da Vorgänge parallel ausgeführt werden können, Sie sicherstellen müssen, dass die Zählervariablen besitzt eine Schrittweite atomischer Vorgang ist und mehrere Threads versuchen nicht zu den Variablen für Leistungsindikatoren gleichzeitig zugreifen. Zu diesem Zweck das Beispiel verwendet die `lock` -Anweisung (in c#) und die `SyncLock` -Anweisung (in Visual Basic).  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <param name="source">Der sortierbare Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> aus. Iterationen können parallel ablaufen, Schleifenoptionen sind konfigurierbar, und der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, wo Sie das Partitionierungsschema überschreiben möchten. Beispielsweise könnte kurzen Schleifenkörpern profitieren Partitionierung des Bereichs. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode erwartet, dass benutzerdefinierte Partitionierer unterstützen dynamische Partitionierung. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Vorgehensweise: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /> sortierbaren Partitionierer gibt <see langword="false" /> zurück.  
  
- oder -  
Die <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" />-Eigenschaft im <paramref name="source" /> sortierbaren Partitionierer gibt <see langword="false" /> zurück.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn irgendwelche Methoden im <paramref name="source" /> sortierbaren Partitionierer <see langword="null" /> zurückgeben.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <param name="source">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ablaufen, Schleifenoptionen sind konfigurierbar, und der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, wo Sie das Partitionierungsschema überschreiben möchten. Beispielsweise könnte kurzen Schleifenkörpern profitieren Partitionierung des Bereichs. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode erwartet, dass benutzerdefinierte Partitionierer unterstützen dynamische Partitionierung. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Vorgehensweise: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" />-Partitioner gibt <see langword="false" /> zurück.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn irgendeine Methode im <paramref name="source" />-Partitionierer <see langword="null" /> zurückgibt.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <param name="source">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ausgeführt werden, Schleifenoptionen sind konfigurierbar.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, wo Sie das Partitionierungsschema überschreiben möchten. Beispielsweise könnte kurzen Schleifenkörpern profitieren Partitionierung des Bereichs. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode erwartet, dass benutzerdefinierte Partitionierer unterstützen dynamische Partitionierung. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Vorgehensweise: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" />-Partitioner gibt <see langword="false" /> zurück.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn irgendeine Methode im <paramref name="source" />-Partitionierer <see langword="null" /> zurückgibt.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Daten in der Quelle.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit 64-Bit-Indizes für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal aufgerufen, für jedes Element in der `source` aufzählbare. Er wird bereitgestellt, mit den folgenden Parametern: das aktuelle Element, ein <xref:System.Threading.Tasks.ParallelLoopState> Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen, und der aktuelle Index des Elements (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Daten in der Quelle.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) für ein <see cref="T:System.Collections.IEnumerable" />-Objekt aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal aufgerufen, für jedes Element in der `source` aufzählbare. Er wird bereitgestellt, mit den folgenden Parametern: das aktuelle Element, und ein <xref:System.Threading.Tasks.ParallelLoopState> -Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Daten in der Quelle.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) für ein <see cref="T:System.Collections.IEnumerable" />-Objekt aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal aufgerufen, für jedes Element in der `source` aufzählbare. Sie wird mit dem aktuellen Element als Parameter bereitgestellt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Der Typ der threadlokalen Daten.</typeparam>
        <param name="source">Der sortierbare Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten für einen <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, wo Sie das Partitionierungsschema überschreiben möchten. Beispielsweise könnte kurzen Schleifenkörpern profitieren Partitionierung des Bereichs. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A> Methode erwartet, dass benutzerdefinierte Partitionierer unterstützen dynamische Partitionierung. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Vorgehensweise: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Die `localInit` Delegat wird einmal für jede Aufgabe, die der Ausführung der Schleife beteiligt ist und gibt den ursprünglichen lokalen Zustand für jeden dieser Vorgänge aufgerufen. Diese Anfangszustände übergeben werden, mit dem ersten `body` Aufrufe für die einzelnen Tasks. Alle nachfolgenden Textaufruf einen möglicherweise Zustandsänderungen Wert zurück, der für den nächsten Textaufruf übergeben wird. Schließlich gibt der letzte Textaufruf für die einzelnen Tasks einen Statuswert, der an die `localFinally` delegieren. Die `localFinally` Delegat wird einmal pro Aufgabe eine abschließende Aktion ausführt, im lokalen Zustand jedes einzelnen Vorgangs aufgerufen. Dieser Delegat kann auf mehrere Aufgaben gleichzeitig aufgerufen werden; aus diesem Grund müssen Sie den Zugriff auf freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode können Sie mehr Aufgaben als Threads während der Lebensdauer der Ausführung vorhandener Aufgaben abgeschlossen, und durch neue Vorgänge ersetzt werden. Dadurch wird die zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit zum Hinzufügen, ändern oder Entfernen von Threads, die die Schleife zu verarbeiten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> gibt <see langword="false" /> zurück, oder der Partitionierer gibt die <see langword="null" />-Partitionen zurück.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Der Typ der threadlokalen Daten.</typeparam>
        <param name="source">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten für einen <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ablaufen. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, wo Sie das Partitionierungsschema überschreiben möchten. Beispielsweise könnte kurzen Schleifenkörpern profitieren Partitionierung des Bereichs. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A> Methode erwartet, dass benutzerdefinierte Partitionierer unterstützen dynamische Partitionierung. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Vorgehensweise: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Die `localInit` Delegat wird einmal für jeden Thread, die der Ausführung der Schleife beteiligt ist und gibt den ursprünglichen lokalen Zustand für jeden dieser Vorgänge aufgerufen. Diese Anfangszustände übergeben werden, mit dem ersten `body` Aufrufe für die einzelnen Tasks. Alle nachfolgenden Textaufruf einen möglicherweise Zustandsänderungen Wert zurück, der für den nächsten Textaufruf übergeben wird. Schließlich gibt der letzte Textaufruf für die einzelnen Tasks einen Statuswert, der an die `localFinally` delegieren. Die `localFinally` Delegat wird einmal pro Aufgabe eine abschließende Aktion ausführt, im lokalen Zustand jedes einzelnen Vorgangs aufgerufen. Dieser Delegat kann auf mehrere Aufgaben gleichzeitig aufgerufen werden; aus diesem Grund müssen Sie den Zugriff auf freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode können Sie mehr Aufgaben als Threads während der Lebensdauer der Ausführung vorhandener Aufgaben abgeschlossen, und durch neue Vorgänge ersetzt werden. Dadurch wird die zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit zum Hinzufügen, ändern oder Entfernen von Threads, die die Schleife zu verarbeiten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> gibt <see langword="false" /> zurück, oder der Partitionierer gibt die <see langword="null" />-Partitionen zurück.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Daten in der Quelle.</typeparam>
        <typeparam name="TLocal">Der Typ der threadlokalen Daten.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal aufgerufen, für jedes Element in der `source` aufzählbare. Er wird bereitgestellt, mit den folgenden Parametern: das aktuelle Element, ein <xref:System.Threading.Tasks.ParallelLoopState> -Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen, der Index des aktuellen Elements (<xref:System.Int64>), und einige lokale Zustand, der von Iterationen gemeinsam genutzt werden kann, die ausgeführt werden auf dem gleichen Thread.  
  
 Die `localInit` Delegat wird einmal für jede Aufgabe, die der Ausführung der Schleife beteiligt ist und gibt den ursprünglichen lokalen Zustand für jeden dieser Vorgänge aufgerufen. Diese Anfangszustände übergeben werden, mit dem ersten `body` Aufrufe für die einzelnen Tasks. Alle nachfolgenden Textaufruf einen möglicherweise Zustandsänderungen Wert zurück, der für den nächsten Textaufruf übergeben wird. Schließlich gibt der letzte Textaufruf für die einzelnen Tasks einen Statuswert, der an die `localFinally` delegieren. Die `localFinally` Delegat wird einmal pro Aufgabe eine abschließende Aktion ausführt, im lokalen Zustand jedes einzelnen Vorgangs aufgerufen. Dieser Delegat kann auf mehrere Aufgaben gleichzeitig aufgerufen werden; aus diesem Grund müssen Sie den Zugriff auf freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode können Sie mehr Aufgaben als Threads während der Lebensdauer der Ausführung vorhandener Aufgaben abgeschlossen, und durch neue Vorgänge ersetzt werden. Dadurch wird die zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit zum Hinzufügen, ändern oder Entfernen von Threads, die die Schleife zu verarbeiten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Daten in der Quelle.</typeparam>
        <typeparam name="TLocal">Der Typ der threadlokalen Daten.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal aufgerufen, für jedes Element in der `source` aufzählbare. Er wird bereitgestellt, mit den folgenden Parametern: das aktuelle Element, ein <xref:System.Threading.Tasks.ParallelLoopState> Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die auf dem gleichen Thread ausgeführt werden.  
  
 Die `localInit` Delegat wird einmal für jede Aufgabe, die der Ausführung der Schleife beteiligt ist und gibt den ursprünglichen lokalen Zustand für jeden dieser Vorgänge aufgerufen. Diese Anfangszustände übergeben werden, mit dem ersten `body` Aufrufe für die einzelnen Tasks. Alle nachfolgenden Textaufruf einen möglicherweise Zustandsänderungen Wert zurück, der für den nächsten Textaufruf übergeben wird. Schließlich gibt der letzte Textaufruf für die einzelnen Tasks einen Statuswert, der an die `localFinally` delegieren. Die `localFinally` Delegat wird einmal pro Thread eine abschließende Aktion ausführt, im lokalen Zustand jedes einzelnen Vorgangs aufgerufen. Dieser Delegat kann auf mehrere Aufgaben gleichzeitig aufgerufen werden; aus diesem Grund müssen Sie den Zugriff auf freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode können Sie mehr Aufgaben als Threads während der Lebensdauer der Ausführung vorhandener Aufgaben abgeschlossen, und durch neue Vorgänge ersetzt werden. Dadurch wird die zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit zum Hinzufügen, ändern oder Entfernen von Threads, die die Schleife zu verarbeiten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit einem <xref:System.Threading.Tasks.Parallel.ForEach%2A> Methode mit dem lokalen Status:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Der Typ der threadlokalen Daten.</typeparam>
        <param name="source">Der sortierbare Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit 64-Bit-Indizes und threadlokalen Daten für einen <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, wo Sie das Partitionierungsschema überschreiben möchten. Beispielsweise könnte kurzen Schleifenkörpern profitieren Partitionierung des Bereichs. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A> Methode erwartet, dass benutzerdefinierte Partitionierer unterstützen dynamische Partitionierung. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Vorgehensweise: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Die `localInit` Delegat wird einmal für jede Aufgabe, die der Ausführung der Schleife beteiligt ist und gibt den ursprünglichen lokalen Zustand für jeden dieser Vorgänge aufgerufen. Diese Anfangszustände übergeben werden, mit dem ersten `body` Aufrufe für die einzelnen Tasks. Alle nachfolgenden Textaufruf einen möglicherweise Zustandsänderungen Wert zurück, der für den nächsten Textaufruf übergeben wird. Schließlich gibt der letzte Textaufruf in jedem Thread einen Statuswert, der an die `localFinally` delegieren. Die `localFinally` Delegat wird einmal pro Aufgabe eine abschließende Aktion ausführt, im lokalen Zustand jedes einzelnen Vorgangs aufgerufen. Dieser Delegat kann auf mehrere Aufgaben gleichzeitig aufgerufen werden; aus diesem Grund müssen Sie den Zugriff auf freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode können Sie mehr Aufgaben als Threads während der Lebensdauer der Ausführung vorhandener Aufgaben abgeschlossen, und durch neue Vorgänge ersetzt werden. Dadurch wird die zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit zum Hinzufügen, ändern oder Entfernen von Threads, die die Schleife zu verarbeiten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Der <paramref name="localInit" /> oder das <paramref name="localFinally" />-Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> gibt <see langword="false" /> zurück, oder der Partitionierer gibt die <see langword="null" />-Partitionen zurück.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Der Typ der threadlokalen Daten.</typeparam>
        <param name="source">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten für einen <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, wo Sie das Partitionierungsschema überschreiben möchten. Beispielsweise könnte kurzen Schleifenkörpern profitieren Partitionierung des Bereichs. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A> Methode erwartet, dass benutzerdefinierte Partitionierer unterstützen dynamische Partitionierung. Diese Überladung wird für Szenarien mit kurzen Schleifenkörpern bereitgestellt, die die statische Range-Partitionierung von Vorteil sein könnte. Partitionierer müssen es sich um dynamische Partitionen unterstützen.  Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Vorgehensweise: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Die `localInit` Delegat wird einmal für jede Aufgabe, die der Ausführung der Schleife beteiligt ist und gibt den ursprünglichen lokalen Zustand für jeden dieser Vorgänge aufgerufen. Diese Anfangszustände übergeben werden, mit dem ersten `body` Aufrufe für die einzelnen Tasks. Alle nachfolgenden Textaufruf einen möglicherweise Zustandsänderungen Wert zurück, der für den nächsten Textaufruf übergeben wird. Schließlich gibt der letzte Textaufruf für die einzelnen Tasks einen Statuswert, der an die `localFinally` delegieren. Die `localFinally` Delegat wird einmal pro Aufgabe eine abschließende Aktion ausführt, im lokalen Zustand jedes einzelnen Vorgangs aufgerufen. Dieser Delegat kann auf mehrere Aufgaben gleichzeitig aufgerufen werden; aus diesem Grund müssen Sie den Zugriff auf freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode können Sie mehr Aufgaben als Threads während der Lebensdauer der Ausführung vorhandener Aufgaben abgeschlossen, und durch neue Vorgänge ersetzt werden. Dadurch wird die zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit zum Hinzufügen, ändern oder Entfernen von Threads, die die Schleife zu verarbeiten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> gibt <see langword="false" /> zurück, oder der Partitionierer gibt die <see langword="null" />-Partitionen zurück.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Daten in der Quelle.</typeparam>
        <typeparam name="TLocal">Der Typ der threadlokalen Daten.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten und 64-Bit-Indizes für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal aufgerufen, für jedes Element in der `source` aufzählbare. Er wird bereitgestellt, mit den folgenden Parametern: das aktuelle Element, ein <xref:System.Threading.Tasks.ParallelLoopState> -Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen, der Index des aktuellen Elements (<xref:System.Int64>), und einige lokale Zustand, der von Iterationen gemeinsam genutzt werden kann, die ausgeführt werden auf dem gleichen Thread.  
  
 Die `localInit` Delegat wird einmal für jede Aufgabe, die der Ausführung der Schleife beteiligt ist und gibt den ursprünglichen lokalen Zustand für jeden dieser Vorgänge aufgerufen. Diese Anfangszustände übergeben werden, mit dem ersten `body` Aufrufe für die einzelnen Tasks. Alle nachfolgenden Textaufruf einen möglicherweise Zustandsänderungen Wert zurück, der für den nächsten Textaufruf übergeben wird. Schließlich gibt der letzte Textaufruf für die einzelnen Tasks einen Statuswert, der an die `localFinally` delegieren. Die `localFinally` Delegat wird einmal pro Thread eine abschließende Aktion ausführt, im lokalen Zustand jedes einzelnen Vorgangs aufgerufen. Dieser Delegat kann auf mehrere Aufgaben gleichzeitig aufgerufen werden; aus diesem Grund müssen Sie den Zugriff auf freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode können Sie mehr Aufgaben als Threads während der Lebensdauer der Ausführung vorhandener Aufgaben abgeschlossen, und durch neue Vorgänge ersetzt werden. Dadurch wird die zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit zum Hinzufügen, ändern oder Entfernen von Threads, die die Schleife zu verarbeiten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Daten in der Quelle.</typeparam>
        <typeparam name="TLocal">Der Typ der threadlokalen Daten.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann überwacht und angepasst werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `body` Delegat wird einmal aufgerufen, für jedes Element in der `source` aufzählbare. Er wird bereitgestellt, mit den folgenden Parametern: das aktuelle Element, ein <xref:System.Threading.Tasks.ParallelLoopState> Instanz, die verwendet werden kann, um die Schleife vorzeitig unterbrochen, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die auf dem gleichen Thread ausgeführt werden.  
  
 Die `localInit` Delegat wird einmal für jede Aufgabe, die der Ausführung der Schleife beteiligt ist und gibt den ursprünglichen lokalen Zustand für jeden dieser Vorgänge aufgerufen. Diese Anfangszustände übergeben werden, mit dem ersten `body` Aufrufe für die einzelnen Tasks. Alle nachfolgenden Textaufruf einen möglicherweise Zustandsänderungen Wert zurück, der für den nächsten Textaufruf übergeben wird. Schließlich gibt der letzte Textaufruf für die einzelnen Tasks einen Statuswert, der an die `localFinally` delegieren. Die `localFinally` Delegat wird einmal pro Thread eine abschließende Aktion ausführt, im lokalen Zustand jedes einzelnen Vorgangs aufgerufen. Dieser Delegat kann auf mehrere Aufgaben gleichzeitig aufgerufen werden; aus diesem Grund müssen Sie den Zugriff auf freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode können Sie mehr Aufgaben als Threads während der Lebensdauer der Ausführung vorhandener Aufgaben abgeschlossen, und durch neue Vorgänge ersetzt werden. Dadurch wird die zugrunde liegende <xref:System.Threading.Tasks.TaskScheduler> Objekt die Möglichkeit zum Hinzufügen, ändern oder Entfernen von Threads, die die Schleife zu verarbeiten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt jede der bereitgestellten Aktionen aus (möglicherweise parallel).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">Ein Array auszuführender <see cref="T:System.Action" />.</param>
        <summary>Führt jede der bereitgestellten Aktionen aus (möglicherweise parallel).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, eine Reihe von Vorgängen, potenziell parallel ausgeführt.  
  
 Keine Garantien werden über die Reihenfolge, in der die Operationen ausgeführt werden sollen, oder gibt an, ob sie parallel ausgeführt werden. Diese Methode gibt keine zurück, bis jeden der angegebenen Vorgänge abgeschlossen ist, unabhängig davon, ob der Abschluss aufgrund von gewöhnlichen oder Beendigung auftritt.  
  
 Weitere Informationen finden Sie unter [Gewusst wie: Ausführen von parallelen Aufgaben mithilfe von Parallel.Invoke](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
   
  
## Examples  
 In diesem Beispiel wird veranschaulicht, wie die <xref:System.Threading.Tasks.Parallel.Invoke%2A> -Methode mit anderen Methoden, anonyme Delegaten und Lambda-Ausdrücke.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="actions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Diese Ausnahme wird ausgelöst, wenn eine beliebige Aktion im <paramref name="actions" />-Array eine Ausnahme auslöst.</exception>
        <exception cref="T:System.ArgumentException">Ein <paramref name="actions" />-Array enthält ein <see langword="null" />-Element.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="actions">Ein Array auszuführender Aktionen.</param>
        <summary>Führt die einzelnen bereitgestellten Aktionen (nach Möglichkeit parallel) aus, es sei denn, der Vorgang wird vom Benutzer abgebrochen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, eine Reihe von Vorgängen, potenziell parallel ausgeführt. Das Abbruchtoken zu übergeben, mit der <xref:System.Threading.Tasks.ParallelOptions> Struktur ermöglicht dem Aufrufer, den gesamten Vorgang abzubrechen. Weitere Informationen finden Sie unter [Abbruch in verwalteten Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
 Keine Garantien werden über die Reihenfolge, in der die Operationen ausgeführt werden sollen, oder gibt an, ob sie parallel ausgeführt werden. Diese Methode gibt keine zurück, bis jeden der angegebenen Vorgänge abgeschlossen ist, unabhängig davon, ob der Abschluss aufgrund von gewöhnlichen oder Beendigung auftritt.  
  
 Weitere Informationen finden Sie unter [Gewusst wie: Ausführen von parallelen Aufgaben mithilfe von Parallel.Invoke](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> ist festgelegt.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="actions" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Diese Ausnahme wird ausgelöst, wenn eine beliebige Aktion im <paramref name="actions" />-Array eine Ausnahme auslöst.</exception>
        <exception cref="T:System.ArgumentException">Ein <paramref name="actions" />-Array enthält ein <see langword="null" />-Element.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
      </Docs>
    </Member>
  </Members>
</Type>