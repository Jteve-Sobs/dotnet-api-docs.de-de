<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="406a63db29c684944f5584131f72a1864f945083" /><Meta Name="ms.sourcegitcommit" Value="634678f7ccd2928c6b2cf792a301b079b63639af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/26/2019" /><Meta Name="ms.locfileid" Value="68542770" /></Metadata><TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Unterstützt parallele Schleifen und Bereiche.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Parallel> -Klasse stellt Bibliotheks basierte Daten parallele Ersetzungen für allgemeine Vorgänge bereit, z. b. for-Schleifen, for Each-Schleifen und die Ausführung eines Satzes von-Anweisungen.  
  
   
  
## Examples  
 In diesem Beispiel werden mehrere Ansätze zum Implementieren einer parallelen Schleife mithilfe mehrerer Sprachkonstrukte veranschaulicht.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle öffentlichen und geschützten Member von <see cref="T:System.Threading.Tasks.Parallel" /> sind Thread sicher und können gleichzeitig von mehreren Threads verwendet werden.</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md">Datenparallelität (Task Parallel Library)</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Beispiele für die parallele Programmierung mit dem .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine <see langword="for" />-Schleife aus, in der Iterationen parallel ausgeführt werden können.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" />-Schleife aus, in der Iterationen parallel ausgeführt werden können und der Status der Schleife beobachtet und bearbeitet werden kann.</summary>
        <returns>Eine Struktur, die Informationen über den Abschnitt der Schleife enthält, der abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen. Sie wird mit zwei Argumenten bereitgestellt:  
  
-   Ein <xref:System.Int32> -Wert, der die Anzahl der Iterationen darstellt.  
  
-   Eine <xref:System.Threading.Tasks.ParallelLoopState> -Instanz, die verwendet werden kann, um die Schleife vorzeitig abzubrechen. Das <xref:System.Threading.Tasks.ParallelLoopState> Objekt wird vom Compiler erstellt; es kann nicht im Benutzercode instanziiert werden.  
  
 Durch Aufrufen <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> der-Methode `for` wird der-Vorgang informiert, dass Iterationen nach dem aktuellen nicht ausgeführt werden müssen. Allerdings müssen alle Iterationen vor dem aktuellen noch ausgeführt werden, sofern Sie noch nicht vorhanden sind.  
  
 Daher ist das <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> Aufrufen von vergleichbar mit der Verwendung eines Break-Vorgangs `for` in einer herkömmlichen Schleife in C#einer Sprache wie, aber es ist kein perfekter Ersatz: Beispielsweise gibt es keine Garantie dafür, dass Iterationen nach dem aktuellen-Vorgang definitiv nicht ausgeführt werden.  
  
 Wenn alle Iterationen vor der aktuellen Ausführung nicht erforderlich sind, verwenden Sie <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>die-Methode anstelle von. Durch <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> Aufrufen von `for` wird die-Schleife informiert, dass alle verbleibenden Iterationen abgebrochen werden können, unabhängig davon, ob Sie vor oder nach der aktuellen Iteration liegen, da alle erforderlichen Aufgaben bereits abgeschlossen wurden. Wie bei <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>gibt es jedoch keine Garantie, welche anderen Iterationen nicht ausgeführt werden.  
  
 Wenn eine Schleife vorzeitig beendet wird, enthält <xref:System.Threading.Tasks.ParallelLoopResult> die zurückgegebene Struktur relevante Informationen zum Abschluss der Schleife.  
  
 Wenn `fromInclusive` größer oder `toExclusive`gleich ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.  
  
   
  
## Examples  
 Im folgenden Beispiel werden bis zu 100 Iterationen einer Schleife parallel ausgeführt. Jede Iterations Pause wird für ein zufälliges Intervall von 1 bis 1.000 Millisekunden angehalten. Ein zufällig generierter Wert bestimmt, in welcher Iterations Schleife die <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> Methode aufgerufen wird. Wie die Ausgabe des Beispiels zeigt, werden keine Iterationen, deren Index größer ist als <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> der-Eigenschafts Wert, nach dem <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> aufrufungs aufrufungs Methode gestartet.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Da Iterationen der Schleife wahrscheinlich beim Aufrufen der <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> -Methode ausgeführt werden, ruft jede Iteration die <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> -Eigenschaft auf, um zu überprüfen, ob die <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> -Methode von einer anderen Iteration aufgerufen wurde. Wenn der-Eigenschafts `true`Wert ist, überprüft die Iterations Werte den <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> Wert der-Eigenschaft, und wenn dieser größer als der Indexwert der aktuellen Iterations ist, wird sofort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" />-Schleife aus, in der Iterationen parallel ausgeführt werden können.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen. Sie wird mit der Iterations Anzahl (<xref:System.Int32>) als Parameter bereitgestellt.  
  
 Wenn `fromInclusive` größer oder `toExclusive`gleich ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Parallel.For%2A> -Methode für 100-Aufrufe eines Delegaten verwendet, der zufällige Byte Werte generiert und seine Summe berechnet.  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" />-Schleife mit 64-Bit-Indizes aus, in der Iterationen parallel ausgeführt werden können und der Zustand der Schleife überwacht und bearbeitet werden kann.</summary>
        <returns>Eine <see cref="T:System.Threading.Tasks.ParallelLoopResult" />-Struktur, die Informationen darüber enthält, welcher Teil der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: die Iterations<xref:System.Int64>Anzahl () und <xref:System.Threading.Tasks.ParallelLoopState> eine-Instanz, die verwendet werden kann, um die Schleife vorzeitig auszubrechen.  
  
 Durch Aufrufen <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> der-Methode `for` wird der-Vorgang informiert, dass Iterationen nach dem aktuellen nicht ausgeführt werden müssen, sondern alle Iterationen vor dem aktuellen.  
  
 Daher ist das Aufrufen von Break ähnlich wie die Verwendung eines Break-Vorgangs `for` in einer herkömmlichen Schleife in C#einer Sprache wie, aber es ist kein perfekter Ersatz: Beispielsweise gibt es keine Garantie dafür, dass Iterationen nach dem aktuellen-Vorgang definitiv nicht ausgeführt werden.  
  
 Wenn alle Iterationen vor der aktuellen Ausführung nicht erforderlich sind, verwenden Sie <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>die-Methode anstelle von. Durch <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> Aufrufen von `for` wird die-Schleife informiert, dass alle verbleibenden Iterationen abgebrochen werden können, unabhängig davon, ob Sie vor oder nach der aktuellen Iteration liegen, da alle erforderlichen Aufgaben bereits abgeschlossen wurden. Wie bei <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>gibt es jedoch keine Garantie, welche anderen Iterationen nicht ausgeführt werden.  
  
 Wenn eine Schleife vorzeitig beendet wird, enthält <xref:System.Threading.Tasks.ParallelLoopResult> die zurückgegebene Struktur relevante Informationen zum Abschluss der Schleife.  
  
 Wenn `fromInclusive` größer oder `toExclusive`gleich ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" />-Schleife mit 64-Bit-Indizes aus, in der Iterationen parallel ausgeführt werden können.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen. Sie wird mit der Iterations Anzahl (<xref:System.Int64>) als Parameter bereitgestellt.  
  
 Wenn `fromInclusive` größer oder `toExclusive`gleich ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" />-Schleife aus, in der Iterationen parallel ausgeführt und Schleifenoptionen konfiguriert werden können und wo der Status der Schleife beobachtet und bearbeitet werden kann.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: die Iterations<xref:System.Int32>Anzahl () und <xref:System.Threading.Tasks.ParallelLoopState> eine-Instanz, die verwendet werden kann, um die Schleife vorzeitig auszubrechen.  
  
 Wenn `fromInclusive` größer oder `toExclusive`gleich ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" />-Schleife aus, in der Iterationen parallel ausgeführt und Schleifenoptionen konfiguriert werden können.</summary>
        <returns>Eine Struktur, die Informationen über den Abschnitt der Schleife enthält, der abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen. Sie wird mit der Iterations Anzahl (<xref:System.Int32>) als Parameter bereitgestellt.  
  
 Wenn `fromInclusive` größer oder `toExclusive`gleich ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine parallele Schleife abgebrochen wird:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" />-Schleife mit 64-Bit-Indizes aus, in der Iterationen parallel ausgeführt und Schleifenoptionen konfiguriert werden können, und der Status der Schleife kann beobachtet und bearbeitet werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: die Iterations<xref:System.Int64>Anzahl () und <xref:System.Threading.Tasks.ParallelLoopState> eine-Instanz, die verwendet werden kann, um die Schleife vorzeitig auszubrechen.  
  
 Wenn `fromInclusive` größer oder `toExclusive`gleich ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> -Methode mit <xref:System.Threading.Tasks.ParallelOptions> einem-Objekt verwendet wird:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt eine <see langword="for" />-Schleife mit 64-Bit-Indizes aus, in der Iterationen parallel ausgeführt und Schleifenoptionen konfiguriert werden können.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unterstützt 64-Bit-Indizes. Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen. Sie wird mit der Iterations Anzahl (<xref:System.Int64>) als Parameter bereitgestellt.  
  
 Wenn `fromInclusive` größer oder `toExclusive`gleich ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Threading.Tasks.ParallelOptions> verwendet wird, um einen benutzerdefinierten Taskplaner anzugeben:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Der Typ der lokalen Thread-Daten.</typeparam>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt eine <see langword="for" />-Schleife mit lokalen Threaddaten aus, in der Iterationen parallel ausgeführt und der Status der Schleife beobachtet und bearbeitet werden können.</summary>
        <returns>Eine Struktur, die Informationen über den Abschnitt der Schleife enthält, der abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: die Iterationen<xref:System.Int32>Anzahl () <xref:System.Threading.Tasks.ParallelLoopState> , eine-Instanz, die zum vorzeitigen Abbrechen der Schleife verwendet werden kann, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die im selben Thread ausgeführt werden.  
  
 Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück. Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet. Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird. Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally` Delegaten weitergegeben wird. Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen. Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> -Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden. Dadurch erhält das zugrunde <xref:System.Threading.Tasks.TaskScheduler> liegende Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.  
  
 Wenn `fromInclusive` größer oder `toExclusive`gleich ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.  
  
 Ein Beispiel für die Verwendung dieser Methode finden [Sie unter Gewusst wie: Schreiben einer Parallel.For-Schleife mit threadlokalen Variablen](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Der Typ der lokalen Thread-Daten.</typeparam>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt eine <see langword="for" />-Schleife mit 64-Bit-Indizes sowie lokalen Threaddaten aus, in denen Iterationen parallel ausgeführt werden können, und der Status der Schleife kann beobachtet und bearbeitet werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: die Iterationen<xref:System.Int64>Anzahl () <xref:System.Threading.Tasks.ParallelLoopState> , eine-Instanz, die zum vorzeitigen Abbrechen der Schleife verwendet werden kann, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die für dieselbe Aufgabe ausgeführt werden.  
  
 Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück. Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet. Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird. Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally` Delegaten weitergegeben wird. Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen. Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> -Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden. Dadurch erhält das zugrunde <xref:System.Threading.Tasks.TaskScheduler> liegende Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.  
  
 Wenn `fromInclusive` größer oder `toExclusive`gleich ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.  
  
 Ein Beispiel für die Verwendung dieser Methode finden [Sie unter Gewusst wie: Schreiben einer Parallel.For-Schleife mit threadlokalen Variablen](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Der Typ der lokalen Thread-Daten.</typeparam>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt eine <see langword="for" />-Schleife mit lokalen Threaddaten aus, in der Iterationen parallel ausgeführt, Schleifenoptionen konfiguriert und der Status der Schleife beobachtet und bearbeitet werden können.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: die Iterationen<xref:System.Int32>Anzahl () <xref:System.Threading.Tasks.ParallelLoopState> , eine-Instanz, die zum vorzeitigen Abbrechen der Schleife verwendet werden kann, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die für dieselbe Aufgabe ausgeführt werden.  
  
 Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück. Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet. Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird. Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally` Delegaten weitergegeben wird. Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen. Dieser Delegat kann gleichzeitig für mehrere Threads aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> -Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden. Dadurch erhält das zugrunde <xref:System.Threading.Tasks.TaskScheduler> liegende Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.  
  
 Wenn `fromInclusive` größer oder `toExclusive`gleich ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.  
  
   
  
## Examples  
 Im folgenden Beispiel werden lokale Thread Variablen verwendet, um die Summe der Ergebnisse vieler langwieriger Vorgänge zu berechnen. In diesem Beispiel wird der Grad der Parallelität auf vier beschränkt.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Der Typ der lokalen Thread-Daten.</typeparam>
        <param name="fromInclusive">Der Startindex, einschließend.</param>
        <param name="toExclusive">Der Endindex, ausschließend.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="localInit">Der Funktionsdelegat, der den Ausgangszustand der lokalen Daten für jeden Thread zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der eine abschließende Aktion für den lokalen Zustand jedes Threads ausführt.</param>
        <summary>Führt eine <see langword="for" />-Schleife mit 64-Bit Indizes und Thread-lokalen Daten aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar, und der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird für jeden Wert im Iterations Bereich (`fromInclusive`, `toExclusive`) einmal aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: die Iterationen<xref:System.Int64>Anzahl () <xref:System.Threading.Tasks.ParallelLoopState> , eine-Instanz, die zum vorzeitigen Abbrechen der Schleife verwendet werden kann, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die im selben Thread ausgeführt werden.  
  
 Der `localInit` Delegat wird für jeden Thread, der an der Ausführung der Schleife teilnimmt, einmal aufgerufen und gibt den anfänglichen lokalen Zustand für jeden dieser Threads zurück. Diese anfänglichen Zustände werden an die ersten `body` Aufrufe in jedem Thread weitergegeben. Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird. Schließlich gibt der letzte Text Aufruf für jeden Thread einen Zustandswert zurück, der an den `localFinally` Delegaten weitergegeben wird. Der `localFinally` Delegat wird einmal pro Thread aufgerufen, um eine abschließende Aktion für den lokalen Zustand jedes Threads auszuführen. Dieser Delegat kann gleichzeitig für mehrere Threads aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> -Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden. Dadurch erhält das zugrunde <xref:System.Threading.Tasks.TaskScheduler> liegende Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.  
  
 Wenn `fromInclusive` größer oder `toExclusive`gleich ist, gibt die Methode sofort zurück, ohne Iterationen auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt einen <see langword="foreach" /> (<see langword="For Each " /> in Visual Basic)-Vorgang aus, bei dem Iterationen parallel ausgeführt werden können.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <param name="source">Der sortierbare Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> aus. Iterationen können parallel ablaufen, und der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten. Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode erwartet, dass benutzerdefinierte Partitionierer dynamische Partitionierung unterstützen. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Gewusst wie: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /> sortierbaren Partitionierer gibt <see langword="false" /> zurück.  
  
- oder - 
Die <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" />-Eigenschaft im nach Quelle sortierbaren Partitionierer gibt <see langword="false" /> zurück.  
  
- oder - 
Sämtliche Methoden im sortierbaren Quellpartitionierer geben <see langword="null" /> zurück.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die von einem der angegebenen Delegaten ausgelöst wurde.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <param name="source">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ablaufen, und der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten. Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode erwartet, dass benutzerdefinierte Partitionierer dynamische Partitionierung unterstützen. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Gewusst wie: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" />-Partitioner gibt <see langword="false" /> zurück.  
  
- oder - 
Eine Methode im <paramref name="source" />-Partitioner gibt <see langword="null" /> zurück.  
  
- oder - 
Die <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" />-Methode im <paramref name="source" />-Partitioner gibt nicht die korrekte Anzahl von Partitionen zurück.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
        <exception cref="T:System.AggregateException">Die Ausnahme, die ausgelöst wird, um eine Ausnahme zu enthalten, die von einem der angegebenen Delegaten ausgelöst wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <param name="source">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) für ein <see cref="T:System.Collections.Concurrent.Partitioner" />-Objekt aus, in dem Iterationen parallel ausgeführt werden können.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten. Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode erwartet, dass benutzerdefinierte Partitionierer dynamische Partitionierung unterstützen. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Gewusst wie: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein Bereichs Partitionierer für die Verwendung <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>mit implementiert wird:  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" />-Partitioner gibt <see langword="false" /> zurück.  
  
- oder - 
Die Ausnahme, die ausgelöst wird, wenn irgendeine Methode im <paramref name="source" />-Partitionierer <see langword="null" /> zurückgibt.  
  
- oder - 
Die <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" />-Methode im <paramref name="source" />-Partitioner gibt nicht die korrekte Anzahl von Partitionen zurück.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
        <exception cref="T:System.AggregateException">Die Ausnahme, die ausgelöst wird, um eine Ausnahme zu enthalten, die von einem der angegebenen Delegaten ausgelöst wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Datentyp in der Quelle.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit 64-Bit-Indizes für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ausgeführt werden. Der Schleifenzustand kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: das aktuelle Element <xref:System.Threading.Tasks.ParallelLoopState> , eine-Instanz, die verwendet werden kann, um die Schleife vorzeitig zu verlassen, und der Index<xref:System.Int64>des aktuellen Elements ().  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Datentyp in der Quelle.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: das aktuelle Element und <xref:System.Threading.Tasks.ParallelLoopState> eine-Instanz, die verwendet werden kann, um die Schleife vorzeitig abzubrechen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Datentyp in der Quelle.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen. Sie wird mit dem aktuellen Element als Parameter bereitgestellt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> -Methode verwendet, um die Anzahl der Vokale und der Zeichen, die keine Leerzeichen sind, in einer Textdatei zu zählen. In diesem Fall wird der <xref:System.Threading.Tasks.ParallelLoopResult> Wert, der von der-Methode zurückgegeben wird, ignoriert. Da Vorgänge parallel ausgeführt werden können, müssen Sie sicherstellen, dass das Inkrementieren der gegen Variablen eine atomarische Operation ist, und dass mehrere Threads nicht versuchen, gleichzeitig auf die Counter-Variablen zuzugreifen. Zu diesem Zweck verwendet das Beispiel die `lock` -Anweisung (in C#) und die `SyncLock` -Anweisung (in Visual Basic).  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <param name="source">Der sortierbare Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> aus. Iterationen können parallel ablaufen, Schleifenoptionen sind konfigurierbar, und der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten. Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode erwartet, dass benutzerdefinierte Partitionierer dynamische Partitionierung unterstützen. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Gewusst wie: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /> sortierbaren Partitionierer gibt <see langword="false" /> zurück.  
  
- oder - 
Die <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" />-Eigenschaft im <paramref name="source" /> sortierbaren Partitionierer gibt <see langword="false" /> zurück.  
  
- oder - 
Die Ausnahme, die ausgelöst wird, wenn irgendwelche Methoden im <paramref name="source" /> sortierbaren Partitionierer <see langword="null" /> zurückgeben.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
        <exception cref="T:System.AggregateException">Die Ausnahme, die ausgelöst wird, um eine Ausnahme zu enthalten, die von einem der angegebenen Delegaten ausgelöst wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <param name="source">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ablaufen, Schleifenoptionen sind konfigurierbar, und der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen über den Abschnitt der Schleife enthält, der abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten. Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode erwartet, dass benutzerdefinierte Partitionierer dynamische Partitionierung unterstützen. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Gewusst wie: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" />-Partitioner gibt <see langword="false" /> zurück.  
  
- oder - 
Die Ausnahme, die ausgelöst wird, wenn irgendeine Methode im <paramref name="source" />-Partitionierer <see langword="null" /> zurückgibt.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
        <exception cref="T:System.AggregateException">Die Ausnahme, die ausgelöst wird, um eine Ausnahme zu enthalten, die von einem der angegebenen Delegaten ausgelöst wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <param name="source">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ausgeführt werden, Schleifenoptionen sind konfigurierbar.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten. Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode erwartet, dass benutzerdefinierte Partitionierer dynamische Partitionierung unterstützen. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Gewusst wie: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" />-Partitioner gibt <see langword="false" /> zurück.  
  
- oder - 
Die Ausnahme, die ausgelöst wird, wenn irgendeine Methode im <paramref name="source" />-Partitionierer <see langword="null" /> zurückgibt.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
        <exception cref="T:System.AggregateException">Die Ausnahme, die ausgelöst wird, um eine Ausnahme zu enthalten, die von einem der angegebenen Delegaten ausgelöst wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Datentyp in der Quelle.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit 64-Bit-Indizes für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: das aktuelle Element <xref:System.Threading.Tasks.ParallelLoopState> , eine-Instanz, die verwendet werden kann, um die Schleife vorzeitig zu verlassen, und der Index<xref:System.Int64>des aktuellen Elements ().  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Datentyp in der Quelle.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: das aktuelle Element und <xref:System.Threading.Tasks.ParallelLoopState> eine-Instanz, die verwendet werden kann, um die Schleife vorzeitig abzubrechen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Datentyp in der Quelle.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit einem <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen. Sie wird mit dem aktuellen Element als Parameter bereitgestellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Der Typ der lokalen Thread-Daten.</typeparam>
        <param name="source">Der sortierbare Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit Thread-lokalen Daten für einen <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten. Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A> -Methode erwartet, dass benutzerdefinierte Partitionierer dynamische Partitionierung unterstützen. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Gewusst wie: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück. Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet. Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird. Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally` Delegaten weitergegeben wird. Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen. Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden. Dadurch erhält das zugrunde <xref:System.Threading.Tasks.TaskScheduler> liegende Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> gibt <see langword="false" /> zurück, oder der Partitionierer gibt die <see langword="null" />-Partitionen zurück.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Der Typ der lokalen Thread-Daten.</typeparam>
        <param name="source">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit Thread-lokalen Daten für einen <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ablaufen. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten. Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A> -Methode erwartet, dass benutzerdefinierte Partitionierer dynamische Partitionierung unterstützen. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Gewusst wie: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Der `localInit` Delegat wird für jeden Thread, der an der Ausführung der Schleife teilnimmt, einmal aufgerufen und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück. Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet. Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird. Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally` Delegaten weitergegeben wird. Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen. Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden. Dadurch erhält das zugrunde <xref:System.Threading.Tasks.TaskScheduler> liegende Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> gibt <see langword="false" /> zurück, oder der Partitionierer gibt die <see langword="null" />-Partitionen zurück.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Datentyp in der Quelle.</typeparam>
        <typeparam name="TLocal">Der Typ der lokalen Thread-Daten.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit Thread-lokalen Daten für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: das aktuelle Element <xref:System.Threading.Tasks.ParallelLoopState> , eine-Instanz, die verwendet werden kann, um die Schleife vorzeitig abzubrechen, den Index<xref:System.Int64>des aktuellen Elements () und einen lokalen Zustand, der von Iterationen gemeinsam genutzt werden kann, die ausführen. im gleichen Thread.  
  
 Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück. Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet. Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird. Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally` Delegaten weitergegeben wird. Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen. Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden. Dadurch erhält das zugrunde <xref:System.Threading.Tasks.TaskScheduler> liegende Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Datentyp in der Quelle.</typeparam>
        <typeparam name="TLocal">Der Typ der lokalen Thread-Daten.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit Thread-lokalen Daten für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: das aktuelle Element <xref:System.Threading.Tasks.ParallelLoopState> , eine-Instanz, die verwendet werden kann, um die Schleife vorzeitig zu verlassen, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die im selben Thread ausgeführt werden.  
  
 Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück. Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet. Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird. Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally` Delegaten weitergegeben wird. Der `localFinally` Delegat wird einmal pro Thread aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen. Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden. Dadurch erhält das zugrunde <xref:System.Threading.Tasks.TaskScheduler> liegende Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine <xref:System.Threading.Tasks.Parallel.ForEach%2A> Methode mit lokalem Zustand verwendet wird:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Der Typ der lokalen Thread-Daten.</typeparam>
        <param name="source">Der sortierbare Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit 64-Bit-Indizes und Thread-lokalen Daten für einen <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten. Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A> -Methode erwartet, dass benutzerdefinierte Partitionierer dynamische Partitionierung unterstützen. Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Gewusst wie: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück. Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet. Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird. Schließlich gibt der letzte Text Aufruf für jeden Thread einen Zustandswert zurück, der an den `localFinally` Delegaten weitergegeben wird. Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen. Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden. Dadurch erhält das zugrunde <xref:System.Threading.Tasks.TaskScheduler> liegende Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Der <paramref name="localInit" /> oder das <paramref name="localFinally" />-Argument ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> gibt <see langword="false" /> zurück, oder der Partitionierer gibt die <see langword="null" />-Partitionen zurück.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Der Typ der lokalen Thread-Daten.</typeparam>
        <param name="source">Der Partitionierer, der die ursprüngliche Datenquelle enthält.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit Thread-lokalen Daten für einen <see cref="T:System.Collections.Concurrent.Partitioner" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird für Szenarien bereitgestellt, in denen Sie das Standard Partitionierungsschema außer Kraft setzen möchten. Kleine Schleifen Texte können z. b. von der Partitionierung des Bereichs profitieren. Die <xref:System.Threading.Tasks.Parallel.ForEach%2A> -Methode erwartet, dass benutzerdefinierte Partitionierer dynamische Partitionierung unterstützen. Diese Überladung wird für Szenarien mit kleinen Schleifen Körpern bereitgestellt, die von der statischen Bereichs Partitionierung profitieren können. Partitionierer müssen dynamische Partitionen unterstützen.  Weitere Informationen finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) und [Gewusst wie: Implementieren von dynamischen Partitionen](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück. Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet. Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird. Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally` Delegaten weitergegeben wird. Der `localFinally` Delegat wird einmal pro Aufgabe aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen. Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden. Dadurch erhält das zugrunde <xref:System.Threading.Tasks.TaskScheduler> liegende Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />-Eigenschaft im <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> gibt <see langword="false" /> zurück, oder der Partitionierer gibt die <see langword="null" />-Partitionen zurück.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Datentyp in der Quelle.</typeparam>
        <typeparam name="TLocal">Der Typ der lokalen Thread-Daten.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit Thread-lokalen Daten und 64-Bit-Indizes für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann beobachtet und manipuliert werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: das aktuelle Element <xref:System.Threading.Tasks.ParallelLoopState> , eine-Instanz, die verwendet werden kann, um die Schleife vorzeitig abzubrechen, den Index<xref:System.Int64>des aktuellen Elements () und einen lokalen Zustand, der von Iterationen gemeinsam genutzt werden kann, die ausführen. im gleichen Thread.  
  
 Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück. Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet. Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird. Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally` Delegaten weitergegeben wird. Der `localFinally` Delegat wird einmal pro Thread aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen. Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden. Dadurch erhält das zugrunde <xref:System.Threading.Tasks.TaskScheduler> liegende Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Datentyp in der Quelle.</typeparam>
        <typeparam name="TLocal">Der Typ der lokalen Thread-Daten.</typeparam>
        <param name="source">Eine auflistbare Datenquelle.</param>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="localInit">Der Funktionsdelegat, der den ursprünglichen Zustand der lokalen Daten für jede Aufgabe zurückgibt.</param>
        <param name="body">Der Delegat, der einmal pro Iteration aufgerufen wird.</param>
        <param name="localFinally">Der Delegat, der die endgültige Aktion beim lokalen Status jeder Aufgabe ausführt.</param>
        <summary>Führt einen <see langword="foreach" />-Vorgang (<see langword="For Each" /> in Visual Basic) mit threadlokalen Daten für einen <see cref="T:System.Collections.IEnumerable" /> aus. Iterationen können parallel ablaufen. Schleifenoptionen sind konfigurierbar. Der Schleifenstatus kann überwacht und angepasst werden.</summary>
        <returns>Eine Struktur, die Informationen darüber enthält, welcher Abschnitt der Schleife abgeschlossen ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `body` Delegat wird einmal für jedes Element in der `source` Enumerable aufgerufen. Sie wird mit den folgenden Parametern bereitgestellt: das aktuelle Element <xref:System.Threading.Tasks.ParallelLoopState> , eine-Instanz, die verwendet werden kann, um die Schleife vorzeitig zu verlassen, und ein lokaler Zustand, der von Iterationen gemeinsam genutzt werden kann, die im selben Thread ausgeführt werden.  
  
 Der `localInit` Delegat wird einmal für jede Aufgabe aufgerufen, die an der Ausführung der Schleife beteiligt ist, und gibt den anfänglichen lokalen Zustand für jede dieser Aufgaben zurück. Diese anfänglichen Zustände werden an die ersten `body` Aufrufe der einzelnen Aufgaben weitergeleitet. Anschließend gibt jeder nachfolgende Text Aufruf einen möglicherweise geänderten Zustandswert zurück, der an den nächsten Text Aufruf weitergeleitet wird. Schließlich gibt der letzte Text Aufruf für jede Aufgabe einen Zustandswert zurück, der an den `localFinally` Delegaten weitergegeben wird. Der `localFinally` Delegat wird einmal pro Thread aufgerufen, um eine abschließende Aktion für den lokalen Zustand jeder Aufgabe auszuführen. Dieser Delegat kann gleichzeitig für mehrere Aufgaben aufgerufen werden. Daher müssen Sie den Zugriff auf alle freigegebenen Variablen synchronisieren.  
  
 Die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> -Methode verwendet möglicherweise mehr Tasks als Threads im Laufe der Lebensdauer ihrer Ausführung, da vorhandene Aufgaben vollständig ausgeführt werden und durch neue Aufgaben ersetzt werden. Dadurch erhält das zugrunde <xref:System.Threading.Tasks.TaskScheduler> liegende Objekt die Möglichkeit, Threads hinzuzufügen, zu ändern oder zu entfernen, die die Schleife bedienen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="source" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="body" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localInit" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="localFinally" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" />-Argument wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
        <exception cref="T:System.AggregateException">Die Ausnahme, die alle einzelnen, auf allen Threads ausgelösten Ausnahmen enthält.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Parallele Schleifen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt jede der bereitgestellten Aktionen aus (möglicherweise parallel).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">Ein Array auszuführender <see cref="T:System.Action" />.</param>
        <summary>Führt jede der bereitgestellten Aktionen aus (möglicherweise parallel).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um eine Reihe von Vorgängen (möglicherweise parallel) auszuführen.  
  
 Die Reihenfolge, in der die Vorgänge ausgeführt werden, oder ob Sie parallel ausgeführt werden, wird nicht garantiert. Diese Methode gibt nicht zurück, bis alle bereitgestellten Vorgänge abgeschlossen sind, unabhängig davon, ob die Beendigung aufgrund der normalen oder außergewöhnlichen Beendigung erfolgt.  
  
 Weitere Informationen finden Sie unter [Gewusst wie: Ausführen von parallelen Aufgaben mithilfe von Parallel.Invoke](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
   
  
## Examples  
 In diesem Beispiel wird veranschaulicht, wie <xref:System.Threading.Tasks.Parallel.Invoke%2A> die-Methode mit anderen Methoden, anonymen Delegaten und Lambda-Ausdrücken verwendet wird.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="actions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Diese Ausnahme wird ausgelöst, wenn eine beliebige Aktion im <paramref name="actions" />-Array eine Ausnahme auslöst.</exception>
        <exception cref="T:System.ArgumentException">Ein <paramref name="actions" />-Array enthält ein <see langword="null" />-Element.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">Ein Objekt, das das Verhalten dieses Vorgangs konfiguriert.</param>
        <param name="actions">Ein Array auszuführender Aktionen.</param>
        <summary>Führt die einzelnen bereitgestellten Aktionen (nach Möglichkeit parallel) aus, es sei denn, der Vorgang wird vom Benutzer abgebrochen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um eine Reihe von Vorgängen (möglicherweise parallel) auszuführen. Das mit der <xref:System.Threading.Tasks.ParallelOptions> -Struktur übergebenen Abbruch Token ermöglicht dem Aufrufer, den gesamten Vorgang abzubrechen. Weitere Informationen finden Sie unter [Abbruch in verwalteten Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
 Die Reihenfolge, in der die Vorgänge ausgeführt werden, oder ob Sie parallel ausgeführt werden, wird nicht garantiert. Diese Methode gibt nicht zurück, bis alle bereitgestellten Vorgänge abgeschlossen sind, unabhängig davon, ob die Beendigung aufgrund der normalen oder außergewöhnlichen Beendigung erfolgt.  
  
 Weitere Informationen finden Sie unter [Gewusst wie: Ausführen von parallelen Aufgaben mithilfe von Parallel.Invoke](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> ist festgelegt.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="actions" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="parallelOptions" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Diese Ausnahme wird ausgelöst, wenn eine beliebige Aktion im <paramref name="actions" />-Array eine Ausnahme auslöst.</exception>
        <exception cref="T:System.ArgumentException">Ein <paramref name="actions" />-Array enthält ein <see langword="null" />-Element.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die der <see cref="T:System.Threading.CancellationToken" /> im <paramref name="parallelOptions" /> zugeordnet ist, ist gelöscht worden.</exception>
      </Docs>
    </Member>
  </Members>
</Type>