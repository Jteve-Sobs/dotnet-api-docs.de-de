<Type Name="TaskFactory" FullName="System.Threading.Tasks.TaskFactory">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="402ad4b1368c41a518e7e38c17b5d7c52d4ffc48" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51868284" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TaskFactory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TaskFactory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskFactory" />
  <TypeSignature Language="VB.NET" Value="Public Class TaskFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskFactory" />
  <TypeSignature Language="F#" Value="type TaskFactory = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Bietet Unterstützung für das Erstellen und Planen von <see cref="T:System.Threading.Tasks.Task" />-Objekten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework bietet zwei Factorys zum Erstellen und Planen von Aufgaben:  
  
-   Die <xref:System.Threading.Tasks.TaskFactory> -Klasse, die erstellt <xref:System.Threading.Tasks.Task> und <xref:System.Threading.Tasks.Task%601> Objekte. Sie können die Überladungen dieser Methode zum Erstellen und Ausführen einer Aufgabe, die nicht standardmäßige Argumente erfordert aufrufen.  
  
    > [!WARNING]
    >  Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode bietet die einfachste Möglichkeit zum Erstellen Sie einer Aufgabe mit den Werten, und starten Sie ihn sofort.  
  
-   Die <xref:System.Threading.Tasks.TaskFactory%601> -Klasse, die erstellt <xref:System.Threading.Tasks.Task%601> Objekte.  
  
 Die <xref:System.Threading.Tasks.TaskFactory> Klasse können Sie die folgenden Aktionen ausführen:  
  
-   Erstellen Sie eine Aufgabe, und starten Sie ihn sofort durch Aufrufen der <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Methode.  
  
    > [!WARNING]
    >  Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode bietet die einfachste Möglichkeit zum Erstellen Sie einer Aufgabe mit den Werten, und starten Sie ihn sofort.  
  
-   Erstellen Sie eine Aufgabe, die gestartet wird, wenn eine der Aufgaben in einem Array, durch den Aufruf abgeschlossen wurde der <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> Methode.  
  
-   Erstellen Sie eine Aufgabe, die gestartet wird, wenn alle Aufgaben in einem Array, durch den Aufruf abgeschlossen wurden der <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> Methode.  
  
 Die statische <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> Eigenschaft gibt den Standardwert <xref:System.Threading.Tasks.TaskFactory%601> Objekt. Können Sie auch eine Aufrufen der <xref:System.Threading.Tasks.TaskFactory> Klassenkonstruktoren so konfigurieren Sie die <xref:System.Threading.Tasks.Task> Objekte, die <xref:System.Threading.Tasks.TaskFactory> -Klasse erstellt. Im folgenden Beispiel wird ein neues <xref:System.Threading.Tasks.TaskFactory> Objekt, das Aufgaben zu erstellen, die einem angegebenen Abbruchtoken, Aufgabenerstellungsoptionen, Optionen für die Fortsetzung und eines benutzerdefinierten Aufgabenplaners verfügen.  
  
 [!code-csharp[TPL_Factories#1](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_factories/cs/program.cs#1)]
 [!code-vb[TPL_Factories#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_factories/vb/factories_vb.vb#1)]  
  
 In den meisten Fällen, Sie müssen keine zum Instanziieren einer neuen <xref:System.Threading.Tasks.TaskFactory> Instanz. Sie können stattdessen die <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> -Eigenschaft, die ein Factoryobjekt zurückgibt, die Standardwerte verwendet. Sie können dann ihre Methoden, um neue Vorgänge starten, oder Definieren von aufgabenfortsetzungen aufrufen. Eine Veranschaulichung finden Sie im Beispiel.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die statische <xref:System.Threading.Tasks.Task.Factory%2A> Eigenschaft zwei Aufrufe an die <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Methode. Die erste füllt ein Array mit den Namen der Dateien im Verzeichnis Eigene Dateien des Benutzers, während das zweite ein Array mit den Namen der Unterverzeichnisse des MyDocuments-Verzeichnis des Benutzers aufgefüllt. Es ruft dann die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> -Methode, die Informationen über die Anzahl von Dateien und Verzeichnissen in die beiden Arrays angezeigt, nachdem die ersten beiden Aufgaben ausgeführt.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle öffentlichen und geschützten Member der <see cref="T:System.Threading.Tasks.TaskFactory" /> sind threadsicher und können von mehreren Threads gleichzeitig verwendet werden.</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Beispiele für die parallele Programmierung mit .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Tasks.TaskFactory" />-Klasse.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der Standardkonfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.Threading.Tasks.TaskFactory> Instanz mit einer Standardkonfiguration. Die <xref:System.Threading.Tasks.TaskCreationOptions> Eigenschaft wird initialisiert, um <xref:System.Threading.Tasks.TaskCreationOptions.None>, <xref:System.Threading.Tasks.TaskContinuationOptions> Eigenschaft wird initialisiert, um <xref:System.Threading.Tasks.TaskContinuationOptions.None>, und die <xref:System.Threading.Tasks.TaskScheduler> Eigenschaft mit dem aktuellen Planer initialisiert wird (finden Sie unter <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.CancellationToken -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory cancellationToken" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das Aufgaben zugewiesen wird, die von dieser <see cref="T:System.Threading.Tasks.TaskFactory" /> erstellt wurden, sofern beim Aufrufen der Factorymethoden kein anderes CancellationToken explizit angegeben wird.</param>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der angegebenen Konfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.Threading.Tasks.TaskFactory> Instanz mit einer Standardkonfiguration. Die <xref:System.Threading.Tasks.TaskCreationOptions> Eigenschaft wird initialisiert, um <xref:System.Threading.Tasks.TaskCreationOptions.None>, <xref:System.Threading.Tasks.TaskContinuationOptions> Eigenschaft wird initialisiert, um <xref:System.Threading.Tasks.TaskContinuationOptions.None>, und die <xref:System.Threading.Tasks.TaskScheduler> Eigenschaft mit dem aktuellen Planer initialisiert wird (finden Sie unter <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Abbruch</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory scheduler" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Der beim Planen von Aufgaben mit dieser TaskFactory zu verwendende <see cref="T:System.Threading.Tasks.TaskScheduler" />. Ein NULL-Wert gibt an, dass der aktuelle TaskScheduler verwendet werden soll.</param>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der angegebenen Konfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor die <xref:System.Threading.Tasks.TaskCreationOptions> Eigenschaft wird initialisiert, um <xref:System.Threading.Tasks.TaskCreationOptions.None>, <xref:System.Threading.Tasks.TaskContinuationOptions> Eigenschaft wird initialisiert, um <xref:System.Threading.Tasks.TaskContinuationOptions.None>, und die <xref:System.Threading.Tasks.TaskScheduler> Eigenschaft wird initialisiert, um `scheduler`, es sei denn, sie in diesem Fall null ist die Eigenschaft mit dem aktuellen Planer initialisiert wird (siehe <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (creationOptions As TaskCreationOptions, continuationOptions As TaskContinuationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory (creationOptions, continuationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="creationOptions">Das zum Erstellen von Aufgaben mit dieser TaskFactory zu verwendende Standard-<see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</param>
        <param name="continuationOptions">Das zum Erstellen von Fortsetzungsaufgaben mit dieser TaskFactory zu verwendende Standard-<see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</param>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der angegebenen Konfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor die <xref:System.Threading.Tasks.TaskCreationOptions> Eigenschaft wird initialisiert, um `creationOptions`, <xref:System.Threading.Tasks.TaskContinuationOptions> Eigenschaft wird initialisiert, um `continuationOptions`, und die <xref:System.Threading.Tasks.TaskScheduler> Eigenschaft mit dem aktuellen Planer initialisiert wird (finden Sie unter <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.  
  
- oder -  
Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert an.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory (cancellationToken, creationOptions, continuationOptions, scheduler)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Das standardmäßige <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das Aufgaben zugewiesen wird, die von dieser <see cref="T:System.Threading.Tasks.TaskFactory" /> erstellt wurden, sofern beim Aufrufen der Factorymethoden kein anderes CancellationToken explizit angegeben wird.</param>
        <param name="creationOptions">Das zum Erstellen von Aufgaben mit dieser TaskFactory zu verwendende Standard-<see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</param>
        <param name="continuationOptions">Das zum Erstellen von Fortsetzungsaufgaben mit dieser TaskFactory zu verwendende Standard-<see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</param>
        <param name="scheduler">Der beim Planen von Aufgaben mit dieser TaskFactory zu verwendende standardmäßige <see cref="T:System.Threading.Tasks.TaskScheduler" />. Ein NULL-Wert gibt an, dass TaskScheduler.Current verwendet werden soll.</param>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der angegebenen Konfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor die <xref:System.Threading.Tasks.TaskCreationOptions> Eigenschaft wird initialisiert, um `creationOptions`, <xref:System.Threading.Tasks.TaskContinuationOptions> Eigenschaft wird initialisiert, um `continuationOptions`, und die <xref:System.Threading.Tasks.TaskScheduler> Eigenschaft wird initialisiert, um `scheduler`, es sei denn, sie in diesem Fall null ist die Eigenschaft mit dem aktuellen Planer initialisiert wird (siehe <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.  
  
- oder -  
Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert an.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="CancellationToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken CancellationToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken CancellationToken" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CancellationToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CancellationToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken CancellationToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.CancellationToken : System.Threading.CancellationToken" Usage="System.Threading.Tasks.TaskFactory.CancellationToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Standardabbruchtoken für diese Aufgabenfactory ab.</summary>
        <value>Das standardmäßige Aufgabenabbruchtoken für diese Aufgabenfactory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft-Standardinstanz <xref:System.Threading.CancellationToken> , die für alle Aufgaben, die von dieser Factory erstellten zugewiesen wird, es sei denn, eine andere <xref:System.Threading.CancellationToken> Wert wird während des Aufrufs der Factorymethoden explizit angegeben.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinuationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskContinuationOptions ContinuationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskContinuationOptions ContinuationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.ContinuationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContinuationOptions As TaskContinuationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskContinuationOptions ContinuationOptions { System::Threading::Tasks::TaskContinuationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.ContinuationOptions : System.Threading.Tasks.TaskContinuationOptions" Usage="System.Threading.Tasks.TaskFactory.ContinuationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die standardmäßigen Aufgabenfortsetzungsoptionen für diese Aufgabenfactory ab.</summary>
        <value>Die standardmäßigen Aufgabenfortsetzungsoptionen für diese Aufgabenfactory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den Wert der Eigenschaft wird verwendet, alle Fortsetzungsaufgaben, zu erstellen, es sei denn, andere Optionen beim Aufrufen der Methoden dieser Factory explizit angegeben werden.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Beispiele für die parallele Programmierung mit .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationAction As Action(Of Task())) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> Methode führt die `continuationAction` delegieren, wenn alle Aufgaben im der `tasks` Array abgeschlossen wurden, unabhängig von deren Abschlussstatus.  
  
 Ausnahmen, die von Aufgaben in der `tasks` Array sind nicht verfügbar, das der Fortsetzungsaufgabe über die strukturierte Ausnahmebehandlung. Sie können bestimmen, welche Ausnahmen ausgelöst wurden, anhand der <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> Eigenschaft der einzelnen Aufgaben im der `tasks` Array. Zur Verwendung von strukturierter Ausnahmebehandlung zum Behandeln von Ausnahmen, die von Aufgaben in der `tasks` array, rufen Sie die <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine einzelne Aufgaben, die einen regulären Ausdruck zu verwenden, um die Anzahl der Wörter in einem Satz von Textdateien zählen gestartet. Die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> Methode wird verwendet, um eine Aufgabe zu starten, in dem die Anzahl der insgesamt Wörter angezeigt, nach Abschluss aller Vorgängeraufgaben.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall1.vb#1)]  
  
 Der Aufruf an der Fortsetzungsaufgabe <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Methode nicht zulässt, behandeln Ausnahmen, die durch die vorangehenden Aufgaben ausgelöst werden, damit das Beispiel untersucht die <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> Eigenschaft jede Vorgängeraufgabe zu bestimmen, ob die Aufgabe erfolgreich ausgeführt wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [\], Aktion (Aufgabe\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D% 2CSystem.Threading.CancellationToken%29 >-Methode führt die `continuationAction` delegieren, wenn alle Aufgaben im der `tasks` Array abgeschlossen wurden, unabhängig von deren Abschlussstatus.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Abbruchtoken, das er übergibt, um Aufgaben zu trennen, die einen regulären Ausdruck zu verwenden, um die Anzahl der Wörter in einem Satz von Textdateien zählen. Das Abbruchtoken, das wird festgelegt, wenn eine Datei nicht gefunden werden kann. Die [\], Aktion (Aufgabe\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A >-Methode verwendet, um eine Aufgabe zu starten, in dem die Anzahl der insgesamt Wörter angezeigt, nach Abschluss aller Vorgängeraufgaben. Wenn das Abbruchtoken festgelegt ist, die angibt, dass eine oder mehrere Aufgaben abgebrochen wurden, verarbeitet die <xref:System.AggregateException> Ausnahme und zeigt eine Fehlermeldung an.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.  
  
- oder -  
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationAction As Action(Of Task()), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern.</param>
        <param name="scheduler">Das Objekt, das verwendet wird, um die neue Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)())) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.  
  
- oder -  
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)()), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <param name="scheduler">Das Objekt, das verwendet wird, um die neue Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task(), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.  
  
- oder -  
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task(), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <param name="scheduler">Das Objekt, das verwendet wird, um die neue Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.  
  
- oder -  
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und der erstellten Aufgabe zugeordnet.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <c>tasks</c>-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <param name="scheduler">Das Objekt, das verwendet wird, um die neue Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.  
  
- oder -  
Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.  
  
- oder -  
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Beispiele für die parallele Programmierung mit .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit `ContinueWhenAny` und `ContinueWhenAll`:  
  
 [!code-csharp[System.Threading.Tasks.Task#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuewhenmulti.cs#05)]
 [!code-vb[System.Threading.Tasks.Task#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuewhenmulti.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen <see langword="null" />-Wert.  
  
- oder -  
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.  
  
- oder -  
 <paramref name="cancellationToken" /> wurde bereits gelöscht.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder -  
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen <see langword="null" />-Wert.  
  
- oder -  
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die NotOn * und OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, die für das Einschränken <xref:System.Threading.Tasks.TaskStatus> Zustände, die eine Fortsetzung ausgeführt wird, sind mit ContinueWhenAny ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme, die ausgelöst wird, wenn eines der Elemente im <paramref name="tasks" />-Array freigegeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array NULL ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationAction" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationOptions" />-Argument einen ungültigen TaskContinuationOptions-Wert angibt.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array einen NULL-Wert enthält.  
  
- oder -  
Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array leer ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das verwendet wird, um das erstellte Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> zu planen.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array NULL ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationAction" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="scheduler" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array einen NULL-Wert enthält.  
  
- oder -  
Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array leer ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult))) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme, die ausgelöst wird, wenn eines der Elemente im <paramref name="tasks" />-Array freigegeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array NULL ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationAction" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array einen NULL-Wert enthält.  
  
- oder -  
Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array leer ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme, die ausgelöst wird, wenn eines der Elemente im <paramref name="tasks" />-Array freigegeben wurde.  
  
- oder -  
Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array NULL ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationAction" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array einen NULL-Wert enthält.  
  
- oder -  
Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array leer ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die NotOn * und OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, die für das Einschränken <xref:System.Threading.Tasks.TaskStatus> Zustände, die eine Fortsetzung ausgeführt wird, sind mit ContinueWhenAny ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme, die ausgelöst wird, wenn eines der Elemente im <paramref name="tasks" />-Array freigegeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array NULL ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationAction" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationOptions" />-Argument einen ungültigen TaskContinuationOptions-Wert angibt.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array einen NULL-Wert enthält.  
  
- oder -  
Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array leer ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das verwendet wird, um das erstellte Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> zu planen.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die NotOn * und OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, die für das Einschränken <xref:System.Threading.Tasks.TaskStatus> Zustände, die eine Fortsetzung ausgeführt wird, sind mit ContinueWhenAny ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array NULL ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationAction" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="scheduler" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array einen NULL-Wert enthält.  
  
- oder -  
Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array leer ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und mit den erstellten verknüpften <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme, die ausgelöst wird, wenn eines der Elemente im <paramref name="tasks" />-Array freigegeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array NULL ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationFunction" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array einen NULL-Wert enthält.  
  
- oder -  
Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array leer ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und mit den erstellten verknüpften <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme, die ausgelöst wird, wenn eines der Elemente im <paramref name="tasks" />-Array freigegeben wurde.  
  
- oder -  
Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array NULL ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationFunction" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array einen NULL-Wert enthält.  
  
- oder -  
Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array leer ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und mit den erstellten verknüpften <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die NotOn * und OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, die für das Einschränken <xref:System.Threading.Tasks.TaskStatus> Zustände, die eine Fortsetzung ausgeführt wird, sind mit ContinueWhenAny ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme, die ausgelöst wird, wenn eines der Elemente im <paramref name="tasks" />-Array freigegeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array NULL ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationFunction" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationOptions" />-Argument einen ungültigen TaskContinuationOptions-Wert angibt.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array einen NULL-Wert enthält.  
  
- oder -  
Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array leer ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und mit den erstellten verknüpften <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das verwendet wird, um das erstellte Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> zu planen.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die NotOn * und OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, die für das Einschränken <xref:System.Threading.Tasks.TaskStatus> Zustände, die eine Fortsetzung ausgeführt wird, sind mit ContinueWhenAny ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array NULL ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationFunction" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="scheduler" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array einen NULL-Wert enthält.  
  
- oder -  
Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array leer ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und mit den erstellten verknüpften <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme, die ausgelöst wird, wenn eines der Elemente im <paramref name="tasks" />-Array freigegeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array NULL ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationFunction" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array einen NULL-Wert enthält.  
  
- oder -  
Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array leer ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und mit den erstellten verknüpften <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme, die ausgelöst wird, wenn eines der Elemente im <paramref name="tasks" />-Array freigegeben wurde.  
  
- oder -  
Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array NULL ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationFunction" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array einen NULL-Wert enthält.  
  
- oder -  
Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array leer ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und mit den erstellten verknüpften <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die NotOn * und OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, die für das Einschränken <xref:System.Threading.Tasks.TaskStatus> Zustände, die eine Fortsetzung ausgeführt wird, sind mit ContinueWhenAny ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Ausnahme, die ausgelöst wird, wenn eines der Elemente im <paramref name="tasks" />-Array freigegeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array NULL ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationFunction" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationOptions" />-Argument einen ungültigen TaskContinuationOptions-Wert angibt.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array einen NULL-Wert enthält.  
  
- oder -  
Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array leer ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Typ des Ergebnisses des Vorgängers <c>Aufgaben</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das von zurückgegebene der <c>ContinuationFunction</c> delegieren und mit den erstellten verknüpften <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <c>tasks</c>-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das verwendet wird, um das erstellte Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> zu planen.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die NotOn * und OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, die für das Einschränken <xref:System.Threading.Tasks.TaskStatus> Zustände, die eine Fortsetzung ausgeführt wird, sind mit ContinueWhenAny ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array NULL ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="continuationFunction" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="scheduler" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentException">Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array einen NULL-Wert enthält.  
  
- oder -  
Diese Ausnahme wird ausgelöst, wenn das <paramref name="tasks" />-Array leer ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.TaskFactory.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die standardmäßigen Aufgabenerstellungsoptionen für diese Aufgabenfactory ab.</summary>
        <value>Die standardmäßigen Aufgabenerstellungsoptionen für diese Aufgabenfactory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den Wert der Eigenschaft wird verwendet, alle Aufgaben erstellen, es sei denn, andere Optionen beim Aufrufen der Methoden dieser Factory explizit angegeben werden.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromAsync">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult})" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das IAsyncResult-Element, dessen Abschluss die Verarbeitung des <c>endMethod</c>-Elements auslösen sollte.</param>
        <param name="endMethod">Der Funktionsdelegat, der das abgeschlossene <c>asyncResult</c>-Objekt verarbeitet.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />-Element, das eine Endmethodenaktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> -Überladungen nehmen einen `asyncResult` -Parameter sind nicht so effizient wie der Überladungen, die eine `beginMethod` Parameter. Wenn die Leistung ein Problem ist, verwenden Sie die Überladungen, die bieten die `beginMethod` / `endMethod` Muster.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="asyncResult" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegat für den Thread gestartet wird, die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird.  Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult), creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das IAsyncResult-Element, dessen Abschluss die Verarbeitung des <c>endMethod</c>-Elements auslösen sollte.</param>
        <param name="endMethod">Der Funktionsdelegat, der das abgeschlossene <c>asyncResult</c>-Objekt verarbeitet.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />-Element, das eine Endmethodenaktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> -Überladungen nehmen einen `asyncResult` -Parameter sind nicht so effizient wie der Überladungen, die eine `beginMethod` Parameter. Wenn die Leistung ein Problem ist, verwenden Sie die Überladungen, die bieten die `beginMethod` / `endMethod` Muster.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="asyncResult" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegat für den Thread gestartet wird, die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst Ausnahmen, die von der `beginMethod`. Die <xref:System.Threading.Tasks.TaskCreationOptions> Werte <xref:System.Threading.Tasks.TaskCreationOptions.PreferFairness>, <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> und <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> sind sich gegenseitig ausschließende. In den FromAsync-Methoden entweder `LongRunning` oder `AttachedToParent` selbst führt dazu, dass ein <xref:System.ArgumentOutOfRangeException> ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult), creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das IAsyncResult-Element, dessen Abschluss die Verarbeitung des <c>endMethod</c>-Elements auslösen sollte.</param>
        <param name="endMethod">Der Funktionsdelegat, der das abgeschlossene <c>asyncResult</c>-Objekt verarbeitet.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />-Element, das verwendet wird, um die Aufgabe zu planen, die die Endmethode ausführt.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />-Element, das eine Endmethodenaktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> -Überladungen nehmen einen `asyncResult` -Parameter sind nicht so effizient wie der Überladungen, die eine `beginMethod` Parameter. Wenn die Leistung ein Problem ist, verwenden Sie die Überladungen, die bieten die `beginMethod` / `endMethod` Muster.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="asyncResult" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="scheduler" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des ersten Arguments an den die <c>BeginMethod</c> delegieren.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Der Typ des ersten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegat für den Thread gestartet wird, die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des ersten Arguments an den die <c>BeginMethod</c> delegieren.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Der Typ des ersten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegat für den Thread gestartet wird, die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="asyncResult">Das IAsyncResult-Element, dessen Abschluss die Verarbeitung des <c>endMethod</c>-Elements auslösen sollte.</param>
        <param name="endMethod">Der Funktionsdelegat, der das abgeschlossene <c>asyncResult</c>-Objekt verarbeitet.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das eine Endmethodenfunktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> -Überladungen nehmen einen `asyncResult` -Parameter sind nicht so effizient wie der Überladungen, die eine `beginMethod` Parameter. Wenn die Leistung ein Problem ist, verwenden Sie die Überladungen, die bieten die `beginMethod` / `endMethod` Muster.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="asyncResult" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult), creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="asyncResult">Das IAsyncResult-Element, dessen Abschluss die Verarbeitung des <c>endMethod</c>-Elements auslösen sollte.</param>
        <param name="endMethod">Der Funktionsdelegat, der das abgeschlossene <c>asyncResult</c>-Objekt verarbeitet.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das eine Endmethodenfunktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> -Überladungen nehmen einen `asyncResult` -Parameter sind nicht so effizient wie der Überladungen, die eine `beginMethod` Parameter. Wenn die Leistung ein Problem ist, verwenden Sie die Überladungen, die bieten die `beginMethod` / `endMethod` Muster.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="asyncResult" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult), creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="asyncResult">Das IAsyncResult-Element, dessen Abschluss die Verarbeitung des <c>endMethod</c>-Elements auslösen sollte.</param>
        <param name="endMethod">Der Funktionsdelegat, der das abgeschlossene <c>asyncResult</c>-Objekt verarbeitet.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />-Element, das verwendet wird, um die Aufgabe zu planen, die die Endmethode ausführt.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das eine Endmethodenfunktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> -Überladungen nehmen einen `asyncResult` -Parameter sind nicht so effizient wie der Überladungen, die eine `beginMethod` Parameter. Wenn die Leistung ein Problem ist, verwenden Sie die Überladungen, die bieten die `beginMethod` / `endMethod` Muster.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="asyncResult" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="scheduler" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des ersten Arguments an den die <c>BeginMethod</c> delegieren.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Der Typ des ersten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="arg2">Der Typ des zweiten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegat für den Thread gestartet wird, die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des ersten Arguments an den die <c>BeginMethod</c> delegieren.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Der Typ des ersten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="arg2">Der Typ des zweiten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegat für den Thread gestartet wird, die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TResult) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des ersten Arguments an den die <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Der Typ des ersten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegat für den Thread gestartet wird, die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TResult) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des ersten Arguments an den die <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Der Typ des ersten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegat für den Thread gestartet wird, die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des dritten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg3">Der Typ des ersten Arguments an den die <c>BeginMethod</c> delegieren.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Der Typ des ersten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="arg2">Der Typ des zweiten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="arg3">Der Typ des dritten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegat für den Thread gestartet wird, die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des dritten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg3">Der Typ des ersten Arguments an den die <c>BeginMethod</c> delegieren.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Der Typ des ersten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="arg2">Der Typ des zweiten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="arg3">Der Typ des dritten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegat für den Thread gestartet wird, die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TResult) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des ersten Arguments an den die <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Der Typ des ersten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="arg2">Der Typ des zweiten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegat für den Thread gestartet wird, die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TResult) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des ersten Arguments an den die <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Der Typ des ersten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="arg2">Der Typ des zweiten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegat für den Thread gestartet wird, die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3, TResult) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des dritten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg3">Der Typ des ersten Arguments an den die <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Der Typ des ersten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="arg2">Der Typ des zweiten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="arg3">Der Typ des dritten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegat für den Thread gestartet wird, die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3, TResult) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg2">Der Typ des dritten Arguments an den <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TArg3">Der Typ des ersten Arguments an den die <c>BeginMethod</c> delegieren.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Der Typ des ersten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="arg2">Der Typ des zweiten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="arg3">Der Typ des dritten, an den <c>beginMethod</c>-Delegaten übergebenen Arguments.</param>
        <param name="state">Ein Objekt, das vom <c>beginMethod</c>-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `beginMethod` Delegat für den Thread gestartet wird, die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> ausgeführt wird. Diese Methode löst Ausnahmen, die von der `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="beginMethod" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="endMethod" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="Scheduler">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskScheduler Scheduler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.TaskScheduler Scheduler" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.Scheduler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheduler As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskScheduler ^ Scheduler { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheduler : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskFactory.Scheduler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den standardmäßigen Aufgabenplaner für diese Aufgabenfactory ab.</summary>
        <value>Der standardmäßige Aufgabenplaner für diese Aufgabenfactory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den Wert der Eigenschaft wird verwendet, um alle Aufgaben zu planen, es sei denn, ein anderes Zeitplanungsmodul explizit, während Aufrufe der Methoden dieser Factory angegeben wird.  
  
 Wenn der Wert dieser Eigenschaft `null`, den Wert des der <xref:System.Threading.Tasks.TaskScheduler.Current%2A> Eigenschaft wird verwendet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartNew">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode ist die empfohlene Methode zum Starten einer rechnergebundene Aufgabe. Verwenden der <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Methode nur, wenn Sie eine präzisere Kontrolle für eine lang andauernde, rechnergebundene Aufgabe benötigen. Dies umfasst Szenarien, in denen Sie Folgendes steuern möchten:  
  
-   Aufgabenerstellungsoptionen. Von erstellten Aufgaben die <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode standardmäßig erstellt werden, mit der <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> Option. Zum Überschreiben dieses Verhaltens, oder um andere bereitzustellen <xref:System.Threading.Tasks.TaskCreationOptions> Optionen Aufrufen einer <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> überladen.  
  
-   Übergeben von Parametern. Die Überladungen der <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode können Sie einen Parameter an den Aufgabendelegaten übergeben. Der Überladungen der <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> -Methode.  
  
-   Taskplaner Die Überladungen der <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> -Methode verwenden, den standardmäßige Taskplaner. Rufen Sie zum Steuern der aufgabenplanung eine <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> -Überladung mit einem `scheduler` Parameter. Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Beispiele für die parallele Programmierung mit .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <summary>Erstellt und startet eine Aufgabe.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> ist funktionell gleichwertig mit einer seiner Konstruktoren verwenden, und rufen Sie dann einen Task erstellen die <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> Methode, um die Aufgabe für die Ausführung zu planen.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> -Methode, wie eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> mit Standardparametern. Beachten Sie jedoch, dass ein Unterschied im Verhalten zwischen den beiden Methoden besteht in Bezug auf: <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> standardmäßig lässt keine untergeordneten Aufgaben, die Schritte mit der <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> Option zum Anfügen an das aktuelle <xref:System.Threading.Tasks.Task> -Instanz, wohingegen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> ist. Weitere Informationen und Codebeispiele finden Sie unter ["Task.Run" Vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> Methode wiederholt Aufrufen einer <xref:System.Action> Delegat, der generiert eine zufällige Zahl ist, wird als Unicode-Codepunkt interpretiert, konvertiert es in einer UTF16-codierte Codeeinheit und zeigt Informationen über die resultierende Zeichen oder Zeichen.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew1.cs#1)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Aufgabe zugewiesen wird.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von `StartNew` ist funktionell gleichwertig mit der Erstellung eines Tasks, die mit einer seiner Konstruktoren und klicken Sie dann aufrufen <xref:System.Threading.Tasks.Task.Start%2A> zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> -Methode, wie eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> mit Standardparametern. Beachten Sie jedoch, dass ein Unterschied im Verhalten zwischen den beiden Methoden besteht in Bezug auf: <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> standardmäßig lässt keine untergeordneten Aufgaben, die Schritte mit der <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> Option zum Anfügen an das aktuelle <xref:System.Threading.Tasks.Task> -Instanz, wohingegen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> ist. Weitere Informationen und Codebeispiele finden Sie unter ["Task.Run" Vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> Methode, um eine Aufgabe zu erstellen, die die Dateien in das Verzeichnis C:\Windows\System32 durchläuft. Ruft die Lambda-Ausdruck die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode, um Informationen zu jeder Datei zum Hinzufügen einer <xref:System.Collections.Generic.List%601> Objekt. Jede getrennt geschachtelte Aufgabe aufgerufen, indem die <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Schleife überprüft den Status des Abbruchtokens und, wenn der Abbruch angefordert wird, ruft der <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Methode. Die <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> -Methode löst eine <xref:System.OperationCanceledException> in behandelte Ausnahme einer `catch` blockieren, wenn der aufrufende Thread Ruft die <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Methode.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew2.cs#2)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="action" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" />-Elements steuert</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer Aufgabe, die mit einer seiner Konstruktoren und klicken Sie dann aufrufen <xref:System.Threading.Tasks.Task.Start%2A> zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> -Methode mit einer <xref:System.Action> -Objekt als eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie unter ["Task.Run" Vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="action" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action(Of Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="state">Ein Objekt, das vom <c>action</c>-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> ist funktionell gleichwertig mit der Erstellung einer <xref:System.Threading.Tasks.Task> mithilfe einer seiner Konstruktoren und dem anschließenden Aufrufen der <xref:System.Threading.Tasks.Task.Start%2A> Methode zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> -Methode mit einer <xref:System.Action> -Objekt als eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie unter ["Task.Run" Vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
   
  
## Examples  
 Das folgende Beispiel definiert ein Array von 6 Buchstaben von Wörtern. Jedes Wort wird dann zum Übergeben einer <xref:System.Action%601> -Delegaten, der durcheinanderbringt des Worts, und der ursprüngliche Begriff und die verschlüsselte Version angezeigt.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew3.vb#3)]  
  
 Beachten Sie, dass im Beispiel wird einen einzelnen Zufallszahlengenerator initialisiert, die durch eine Sperre geschützt wird. Die Notwendigkeit einer Sperre, finden Sie unter "Der System.Random-Klasse und Threadsicherheit" in der <xref:System.Random> Thema-Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument lautet <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="state">Ein Objekt, das vom <c>action</c>-Delegaten zu verwendende Daten enthält.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />-Element, das der neuen <see cref="T:System.Threading.Tasks.Task" /> zugewiesen wird</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer Aufgabe, die mit einer seiner Konstruktoren und klicken Sie dann aufrufen <xref:System.Threading.Tasks.Task.Start%2A> zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> -Methode mit einer <xref:System.Action> -Objekt als eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie unter ["Task.Run" Vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
   
  
## Examples  
 Das folgende Beispiel definiert ein Array von 6 Buchstaben von Wörtern. Jedes Wort wird dann zum Übergeben einer <xref:System.Action%601> -Delegaten, der durcheinanderbringt des Worts, und der ursprüngliche Begriff und die verschlüsselte Version angezeigt.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew4.cs#4)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew4.vb#4)]  
  
 Beachten Sie, dass im Beispiel wird einen einzelnen Zufallszahlengenerator initialisiert, die durch eine Sperre geschützt wird. Die Notwendigkeit einer Sperre, finden Sie unter "Der System.Random-Klasse und Threadsicherheit" in der <xref:System.Random> Thema-Klasse. Um die Wahrscheinlichkeit einer Beschädigung der vom Zufallszahlen-Generator zu behandeln, wird ein Abbruchtoken übergeben, Vorgang. Wenn zwei zufällige Zahlen 0 (null) entspricht, wird die Methode davon ausgegangen, dass der Zufallszahlengenerator ist beschädigt, und das Abbruchtoken, das. Vor dem Sortieren der `chars` Array mit sechs Zeichen in einem Wort, ruft die Methode die <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Methode zum Auslösen einer <xref:System.OperationCanceledException> , wenn das Token abgebrochen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="action" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="state">Ein Objekt, das vom <c>action</c>-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" />-Elements steuert</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer Aufgabe, die mit einer seiner Konstruktoren und klicken Sie dann aufrufen <xref:System.Threading.Tasks.Task.Start%2A> zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> -Methode mit einer <xref:System.Action> -Objekt als eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie unter ["Task.Run" Vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="action" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />-Element, das der neuen <see cref="T:System.Threading.Tasks.Task" /> zugewiesen wird</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" />-Elements steuert</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das zum Planen des erstellten <see cref="T:System.Threading.Tasks.Task" /> verwendet wird.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer Aufgabe, die mit einer seiner Konstruktoren und klicken Sie dann aufrufen <xref:System.Threading.Tasks.Task.Start%2A> zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> -Methode mit einer <xref:System.Action> -Objekt als eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie unter ["Task.Run" Vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="action" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="scheduler" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="state">Ein Objekt, das vom <c>action</c>-Delegaten zu verwendende Daten enthält.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Aufgabe zugewiesen wird.</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" />-Elements steuert</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das zum Planen des erstellten <see cref="T:System.Threading.Tasks.Task" /> verwendet wird.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer Aufgabe, die mit einer seiner Konstruktoren und klicken Sie dann aufrufen <xref:System.Threading.Tasks.Task.Start%2A> zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> -Methode mit einer <xref:System.Action> -Objekt als eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie unter ["Task.Run" Vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="action" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="scheduler" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> ist funktionell gleichwertig mit der Erstellung einer <xref:System.Threading.Tasks.Task%601> mithilfe einer seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], rufen Sie die <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> -Methode, wie eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Beachten Sie jedoch, dass ein Unterschied im Verhalten zwischen den beiden Methoden besteht in Bezug auf: <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> standardmäßig lässt keine untergeordneten Aufgaben, die Schritte mit der <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> Option zum Anfügen an das aktuelle <xref:System.Threading.Tasks.Task%601> -Instanz, wohingegen <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29> ist. Weitere Informationen und Codebeispiele finden Sie im Eintrag ["Task.Run" Visual Studio. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine einfache Ergänzung-app, die beiden Zufallszahlen generiert, und fordert den Benutzer, deren Summe einzugeben. Anschließend zeigt es an, ob die Antwort richtig ist, oder, wenn die Antwort des Benutzers nicht über eine gültige Zahl ist, ist der Benutzer aufgefordert, eine gültige Zahl erneut eingeben. Die <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> dient zum Erstellen der <xref:System.Threading.Tasks.Task%601> Objekte, die Zufallszahlen hinzuzufügende zurückgeben.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Run#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="function" />-Argument lautet <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <param name="state">Ein Objekt, das vom <c>function</c>-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer <xref:System.Threading.Tasks.Task%601> mithilfe einer seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> -Methode mit einer <xref:System.Action> -Objekt als eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie im Eintrag ["Task.Run" Visual Studio. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="function" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />-Element, das der neuen <see cref="T:System.Threading.Tasks.Task" /> zugewiesen wird</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> ist funktionell gleichwertig mit der Erstellung einer <xref:System.Threading.Tasks.Task%601> mithilfe einer seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> -Methode, wie eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> mit Standardparametern. Beachten Sie jedoch, dass ein Unterschied im Verhalten zwischen den beiden Methoden besteht in Bezug auf: <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> standardmäßig lässt keine untergeordneten Aufgaben, die Schritte mit der <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> Option zum Anfügen an das aktuelle <xref:System.Threading.Tasks.Task%601> -Instanz, wohingegen <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> ist. Weitere Informationen und Codebeispiele finden Sie im Eintrag ["Task.Run" Visual Studio. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
   
  
## Examples  
 Das folgende Beispiel verwendet zwei Aufgaben zum Berechnen der Fibonacci-Folge F100 Endstand = F100-1 + F100-2 mit dem Startwerten F1 = 1 "," F2 = 1 und F1 = 0 "," F2 = 1. Ungefähr ist die Hälfte der Zeit, ein Abbruchtoken festgelegt wie die Vorgänge ausgeführt werden. Die Ausgabe des Beispiels zeigt das Ergebnis, wenn die beiden Tasks erfolgreich abgeschlossen, und wenn das Token abgebrochen wird.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run9.cs#9)]
 [!code-vb[System.Threading.Tasks.Task.Run#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run9.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="function" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of TResult), creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Elements steuert.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer <xref:System.Threading.Tasks.Task%601> mithilfe einer seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> -Methode mit einer <xref:System.Action> -Objekt als eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie im Eintrag ["Task.Run" Visual Studio. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="function" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <param name="state">Ein Objekt, das vom <c>function</c>-Delegaten zu verwendende Daten enthält.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />-Element, das der neuen <see cref="T:System.Threading.Tasks.Task" /> zugewiesen wird</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer <xref:System.Threading.Tasks.Task%601> mithilfe einer seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> -Methode mit einer <xref:System.Action> -Objekt als eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie im Eintrag ["Task.Run" Visual Studio. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="function" />-Argument 0 (null) ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of Object, TResult), state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <param name="state">Ein Objekt, das vom <c>function</c>-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Elements steuert.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer <xref:System.Threading.Tasks.Task%601> mithilfe einer seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> -Methode mit einer <xref:System.Action> -Objekt als eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie im Eintrag ["Task.Run" Visual Studio. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="function" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Aufgabe zugewiesen wird.</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Elements steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das zum Planen des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> verwendet wird.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer <xref:System.Threading.Tasks.Task%601> mithilfe einer seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> -Methode mit einer <xref:System.Action> -Objekt als eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie im Eintrag ["Task.Run" Visual Studio. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="function" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="scheduler" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über das <see cref="T:System.Threading.Tasks.Task`1" />-Element verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe des <see cref="T:System.Threading.Tasks.Task`1" />-Elements verfügbar sein wird.</param>
        <param name="state">Ein Objekt, das vom <c>function</c>-Delegaten zu verwendende Daten enthält.</param>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das der neuen Aufgabe zugewiesen wird.</param>
        <param name="creationOptions">Ein TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Elements steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das zum Planen des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> verwendet wird.</param>
        <summary>Erstellt und startet ein <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Der gestartete <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von StartNew entspricht funktional dem Erstellen einer <xref:System.Threading.Tasks.Task%601> mithilfe einer seiner Konstruktoren und dem anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> zur Planung der für die Ausführung.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie die <xref:System.Threading.Tasks.Task.Run%2A> -Methode mit einer <xref:System.Action> -Objekt als eine schnelle Möglichkeit zum Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern. Weitere Informationen und Codebeispiele finden Sie im Eintrag ["Task.Run" Visual Studio. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) im zur parallelen Programmierung mit .NET Blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="function" />-Argument 0 (null) ist.  
  
- oder -  
Die Ausnahme, die ausgelöst wird, wenn das <paramref name="scheduler" />-Argument 0 (null) ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Die Ausnahme, die ausgelöst wird, wenn das <paramref name="creationOptions" />-Argument einen ungültigen TaskCreationOptions-Wert angibt. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Aufgabenabbruch</related>
      </Docs>
    </Member>
  </Members>
</Type>