<Type Name="TaskFactory" FullName="System.Threading.Tasks.TaskFactory">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e08aab462c8350a9b401ba66fcc64f909b40c475" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86620063" /></Metadata><TypeSignature Language="C#" Value="public class TaskFactory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TaskFactory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskFactory" />
  <TypeSignature Language="VB.NET" Value="Public Class TaskFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskFactory" />
  <TypeSignature Language="F#" Value="type TaskFactory = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading.Tasks" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Bietet Unterstützung für das Erstellen und Planen von <see cref="T:System.Threading.Tasks.Task" />-Objekten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der .NET Framework stellt zwei Factorys zum Erstellen und Planen von Aufgaben bereit:  
  
-   Die <xref:System.Threading.Tasks.TaskFactory> -Klasse, die <xref:System.Threading.Tasks.Task> -und- <xref:System.Threading.Tasks.Task%601> Objekte erstellt. Sie können die über Ladungen dieser Methode aufzurufen, um eine Aufgabe zu erstellen und auszuführen, die nicht standardmäßige Argumente erfordert.  
  
    > [!WARNING]
    >  Ab [!INCLUDE[net_v45](~/includes/net-v45-md.md)] <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> bietet die-Methode die einfachste Möglichkeit, um eine Aufgabe mit Standard Konfigurations Werten zu erstellen und sofort zu starten.  
  
-   Die- <xref:System.Threading.Tasks.TaskFactory%601> Klasse, die- <xref:System.Threading.Tasks.Task%601> Objekte erstellt.  
  
 Mit der- <xref:System.Threading.Tasks.TaskFactory> Klasse können Sie folgende Aufgaben ausführen:  
  
-   Erstellen Sie eine Aufgabe, und starten Sie Sie sofort, indem Sie die- <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Methode aufrufen.  
  
    > [!WARNING]
    >  Ab [!INCLUDE[net_v45](~/includes/net-v45-md.md)] <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> bietet die-Methode die einfachste Möglichkeit, um eine Aufgabe mit Standard Konfigurations Werten zu erstellen und sofort zu starten.  
  
-   Erstellen Sie eine Aufgabe, die gestartet wird, wenn eine der Aufgaben in einem Array durch Aufrufen der-Methode abgeschlossen wurde <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> .  
  
-   Erstellen Sie eine Aufgabe, die gestartet wird, wenn alle Aufgaben in einem Array abgeschlossen wurden, indem Sie die- <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> Methode aufrufen.  
  
 Die statische- <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> Eigenschaft gibt ein-Standard <xref:System.Threading.Tasks.TaskFactory%601> Objekt zurück. Sie können auch einen der <xref:System.Threading.Tasks.TaskFactory> Klassenkonstruktoren zum Konfigurieren der <xref:System.Threading.Tasks.Task> Objekte, die von der-Klasse erstellt werden, Abrufen <xref:System.Threading.Tasks.TaskFactory> . Im folgenden Beispiel wird ein neues- <xref:System.Threading.Tasks.TaskFactory> Objekt konfiguriert, um Tasks zu erstellen, die über ein angegebenes Abbruch Token, Aufgaben Erstellungs Optionen, Fortsetzungs Optionen und einen angepassten Aufgabenplaner verfügen.  
  
 [!code-csharp[TPL_Factories#1](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_factories/cs/program.cs#1)]
 [!code-vb[TPL_Factories#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_factories/vb/factories_vb.vb#1)]  
  
 In den meisten Fällen ist es nicht erforderlich, eine neue Instanz zu instanziieren <xref:System.Threading.Tasks.TaskFactory> . Stattdessen können Sie die- <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> Eigenschaft verwenden, die ein Factory-Objekt zurückgibt, das Standardwerte verwendet. Anschließend können Sie die zugehörigen Methoden zum Starten neuer Aufgaben oder zum Definieren von Aufgaben Fortsetzungen aufzurufen. Eine Abbildung finden Sie im Beispiel.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die statische- <xref:System.Threading.Tasks.Task.Factory%2A> Eigenschaft verwendet, um zwei Aufrufe an die-Methode durchführen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> . Füllt zunächst ein Array mit den Namen der Dateien im Verzeichnis "MyDocuments" des Benutzers auf, während das zweite ein Array mit den Namen der Unterverzeichnisse des Verzeichnisses "MyDocuments" des Benutzers auffüllt. Anschließend wird die- <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> Methode aufgerufen, die Informationen über die Anzahl der Dateien und Verzeichnisse in den beiden Arrays anzeigt, nachdem die ersten beiden Tasks die Ausführung abgeschlossen haben.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle öffentlichen und geschützten Member von <see cref="T:System.Threading.Tasks.TaskFactory" /> sind Thread sicher und können gleichzeitig von mehreren Threads verwendet werden.</threadsafe>
    <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
    <related type="ExternalDocumentation" href="https://aka.ms/dotnet-parallel-samples">Beispiele für die parallele Programmierung mit .net Core und .NET Standard</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Tasks.TaskFactory" />-Klasse.</summary>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der Standardkonfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine- <xref:System.Threading.Tasks.TaskFactory> Instanz mit einer Standardkonfiguration. Die- <xref:System.Threading.Tasks.TaskCreationOptions> Eigenschaft wird mit initialisiert <xref:System.Threading.Tasks.TaskCreationOptions.None> , die <xref:System.Threading.Tasks.TaskContinuationOptions> -Eigenschaft wird mit initialisiert <xref:System.Threading.Tasks.TaskContinuationOptions.None> , und die- <xref:System.Threading.Tasks.TaskScheduler> Eigenschaft wird mit dem aktuellen Scheduler initialisiert (siehe <xref:System.Threading.Tasks.TaskScheduler.Current%2A> ).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (cancellationToken As CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.CancellationToken -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory cancellationToken" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Das <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das Aufgaben zugewiesen wird, die von dieser <see cref="T:System.Threading.Tasks.TaskFactory" /> erstellt wurden, sofern beim Aufrufen der Factorymethoden kein anderes CancellationToken explizit angegeben wird.</param>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der angegebenen Konfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine- <xref:System.Threading.Tasks.TaskFactory> Instanz mit einer Standardkonfiguration. Die- <xref:System.Threading.Tasks.TaskCreationOptions> Eigenschaft wird mit initialisiert <xref:System.Threading.Tasks.TaskCreationOptions.None> , die <xref:System.Threading.Tasks.TaskContinuationOptions> -Eigenschaft wird mit initialisiert <xref:System.Threading.Tasks.TaskContinuationOptions.None> , und die- <xref:System.Threading.Tasks.TaskScheduler> Eigenschaft wird mit dem aktuellen Scheduler initialisiert (siehe <xref:System.Threading.Tasks.TaskScheduler.Current%2A> ).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/threading/cancellation-in-managed-threads">Abbruch</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory scheduler" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Der beim Planen von Aufgaben mit dieser TaskFactory zu verwendende <see cref="T:System.Threading.Tasks.TaskScheduler" />. Ein NULL-Wert gibt an, dass der aktuelle TaskScheduler verwendet werden soll.</param>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der angegebenen Konfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor wird die- <xref:System.Threading.Tasks.TaskCreationOptions> Eigenschaft mit initialisiert <xref:System.Threading.Tasks.TaskCreationOptions.None> , die <xref:System.Threading.Tasks.TaskContinuationOptions> -Eigenschaft wird mit initialisiert <xref:System.Threading.Tasks.TaskContinuationOptions.None> , und die- <xref:System.Threading.Tasks.TaskScheduler> Eigenschaft wird mit initialisiert `scheduler` , sofern Sie nicht NULL ist. in diesem Fall wird die-Eigenschaft mit dem aktuellen Scheduler initialisiert (siehe <xref:System.Threading.Tasks.TaskScheduler.Current%2A> ).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (creationOptions As TaskCreationOptions, continuationOptions As TaskContinuationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory (creationOptions, continuationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="creationOptions">Das zum Erstellen von Aufgaben mit dieser TaskFactory zu verwendende Standard-<see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</param>
        <param name="continuationOptions">Das zum Erstellen von Fortsetzungsaufgaben mit dieser TaskFactory zu verwendende Standard-<see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</param>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der angegebenen Konfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor wird die- <xref:System.Threading.Tasks.TaskCreationOptions> Eigenschaft mit initialisiert `creationOptions` , die <xref:System.Threading.Tasks.TaskContinuationOptions> -Eigenschaft wird mit initialisiert `continuationOptions` , und die- <xref:System.Threading.Tasks.TaskScheduler> Eigenschaft wird mit dem aktuellen Scheduler initialisiert (siehe <xref:System.Threading.Tasks.TaskScheduler.Current%2A> ).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.  
  
- oder - 
Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert an.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (cancellationToken As CancellationToken, creationOptions As TaskCreationOptions, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory (cancellationToken, creationOptions, continuationOptions, scheduler)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Das standardmäßige <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, das Aufgaben zugewiesen wird, die von dieser <see cref="T:System.Threading.Tasks.TaskFactory" /> erstellt wurden, sofern beim Aufrufen der Factorymethoden kein anderes CancellationToken explizit angegeben wird.</param>
        <param name="creationOptions">Das zum Erstellen von Aufgaben mit dieser TaskFactory zu verwendende Standard-<see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</param>
        <param name="continuationOptions">Das zum Erstellen von Fortsetzungsaufgaben mit dieser TaskFactory zu verwendende Standard-<see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</param>
        <param name="scheduler">Der beim Planen von Aufgaben mit dieser TaskFactory zu verwendende standardmäßige <see cref="T:System.Threading.Tasks.TaskScheduler" />. Ein NULL-Wert gibt an, dass TaskScheduler.Current verwendet werden soll.</param>
        <summary>Initialisiert eine <see cref="T:System.Threading.Tasks.TaskFactory" />-Instanz mit der angegebenen Konfiguration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor wird die- <xref:System.Threading.Tasks.TaskCreationOptions> Eigenschaft mit initialisiert `creationOptions` , die <xref:System.Threading.Tasks.TaskContinuationOptions> -Eigenschaft wird mit initialisiert `continuationOptions` , und die- <xref:System.Threading.Tasks.TaskScheduler> Eigenschaft wird mit initialisiert `scheduler` , sofern Sie nicht NULL ist. in diesem Fall wird die-Eigenschaft mit dem aktuellen Scheduler initialisiert (siehe <xref:System.Threading.Tasks.TaskScheduler.Current%2A> ).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.  
  
- oder - 
Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert an.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="CancellationToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken CancellationToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken CancellationToken" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CancellationToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CancellationToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken CancellationToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.CancellationToken : System.Threading.CancellationToken" Usage="System.Threading.Tasks.TaskFactory.CancellationToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Standardabbruchtoken für diese Aufgabenfactory ab.</summary>
        <value>Das standardmäßige Aufgabenabbruchtoken für diese Aufgabenfactory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Standard <xref:System.Threading.CancellationToken> Wert zurück, der allen von dieser Factory erstellten Aufgaben zugewiesen wird, es sei denn, <xref:System.Threading.CancellationToken> während des Aufrufes der Factorymethoden wird explizit ein anderer Wert angegeben.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinuationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskContinuationOptions ContinuationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskContinuationOptions ContinuationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.ContinuationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContinuationOptions As TaskContinuationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskContinuationOptions ContinuationOptions { System::Threading::Tasks::TaskContinuationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.ContinuationOptions : System.Threading.Tasks.TaskContinuationOptions" Usage="System.Threading.Tasks.TaskFactory.ContinuationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die standardmäßigen Aufgabenfortsetzungsoptionen für diese Aufgabenfactory ab.</summary>
        <value>Die standardmäßigen Aufgabenfortsetzungsoptionen für diese Aufgabenfactory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der-Eigenschafts Wert wird verwendet, um alle Fortsetzungs Aufgaben zu erstellen, es sei denn, bei Aufrufen der Methoden dieser Factory sind andere Optionen explizit angegeben.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <related type="ExternalDocumentation" href="https://aka.ms/dotnet-parallel-samples">Beispiele für die parallele Programmierung mit .net Core und .NET Standard</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationAction As Action(Of Task())) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> Methode führt den Delegaten `continuationAction` aus, wenn alle Aufgaben im- `tasks` Array abgeschlossen wurden, unabhängig vom Abschluss Status.  
  
 Ausnahmen, die von Aufgaben im- `tasks` Array ausgelöst werden, sind für die Fortsetzungs Aufgabe nicht durch strukturierte Ausnahmebehandlung verfügbar. Sie können bestimmen, welche Ausnahmen ausgelöst wurden, indem Sie die- <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> Eigenschaft der einzelnen Aufgaben im Array untersuchen `tasks` . Um die strukturierte Ausnahmebehandlung zur Behandlung von Ausnahmen zu verwenden, die von Aufgaben im- `tasks` Array ausgelöst werden, wird die- <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> Methode aufgerufen.  
  
   
  
## Examples  
 Im folgenden Beispiel werden separate Aufgaben gestartet, die einen regulären Ausdruck verwenden, um die Anzahl der Wörter in einem Satz von Textdateien zu zählen. Die- <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> Methode wird verwendet, um eine Aufgabe zu starten, die die Gesamtanzahl von Wörtern anzeigt, wenn alle vorangehenden Aufgaben abgeschlossen sind.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall1.vb#1)]  
  
 Der-Befehl der-Methode der Fortsetzungs Aufgabe <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> ermöglicht es nicht, Ausnahmen zu behandeln, die von den vorangehenden Aufgaben ausgelöst werden. Daher wird im Beispiel die- <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> Eigenschaft jeder vorangehenden Aufgabe überprüft, um zu bestimmen, ob die Aufgabe erfolgreich war.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationAction As Action(Of Task()), cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Diese Methode führt den Delegaten `continuationAction` aus, wenn alle Aufgaben im- `tasks` Array abgeschlossen wurden, unabhängig vom Abschluss Status.  
  
## Examples

Im folgenden Beispiel wird ein Abbruch Token erstellt, das an separate Aufgaben weitergeleitet wird, die einen regulären Ausdruck verwenden, um die Anzahl der Wörter in einem Satz von Textdateien zu zählen. Das Abbruch Token wird festgelegt, wenn eine Datei nicht gefunden werden kann. Die- `ContinueWhenAll(Task[], Action{Task[]}, CancellationToken)` Methode wird verwendet, um eine Aufgabe zu starten, die die Gesamtanzahl von Wörtern anzeigt, wenn alle vorangehenden Aufgaben abgeschlossen sind. Wenn das Abbruch Token festgelegt wird, was darauf hinweist, dass mindestens eine Aufgabe abgebrochen wurde, wird die Ausnahme behandelt, und es wird <xref:System.AggregateException> eine Fehlermeldung angezeigt.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.  
  
- oder - 
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationAction As Action(Of Task()), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAll` .

]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationAction As Action(Of Task()), cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern.</param>
        <param name="scheduler">Das Objekt, das verwendet wird, um die neue Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAll` .

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert an.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)())) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)()), cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.  
  
- oder - 
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)()), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAll` .

          ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)()), cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <param name="scheduler">Das Objekt, das verwendet wird, um die neue Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAll` .

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert an.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task(), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und der erstellten Aufgabe zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task(), TResult), cancellationToken As CancellationToken) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und der erstellten Aufgabe zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.  
  
- oder - 
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task(), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und der erstellten Aufgabe zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAll` .

          ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task(), TResult), cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und der erstellten Aufgabe zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <param name="scheduler">Das Objekt, das verwendet wird, um die neue Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAll` .

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert an.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und der erstellten Aufgabe zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult), cancellationToken As CancellationToken) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und der erstellten Aufgabe zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.  
  
- oder - 
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und der erstellten Aufgabe zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAll` .

          ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult), cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und der erstellten Aufgabe zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn alle Aufgaben im <paramref name="tasks" />-Array abgeschlossen wurden.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Fortsetzungsaufgabe zugeordnet werden soll.</param>
        <param name="continuationOptions">Eine bitweise Kombination der Enumerationswerte, die das Verhalten der neuen Fortsetzungsaufgabe steuern. Die Member NotOn* und OnlyOn* werden nicht unterstützt.</param>
        <param name="scheduler">Das Objekt, das verwendet wird, um die neue Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt eine Fortsetzungsaufgabe, die beginnt, wenn ein Satz angegebener Aufgaben abgeschlossen wurde.</summary>
        <returns>Die neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAll` .

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationFunction" />-Argument lautet <see langword="null" />.  
  
- oder - 
Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array ist leer oder enthält einen NULL-Wert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.ObjectDisposedException">Ein Element im <paramref name="tasks" />-Array wurde freigegeben.  
  
- oder - 
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
        <related type="ExternalDocumentation" href="https://aka.ms/dotnet-parallel-samples">Beispiele für die parallele Programmierung mit .net Core und .NET Standard</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie `ContinueWhenAny` und verwendet werden `ContinueWhenAll` :  
  
 [!code-csharp[System.Threading.Tasks.Task#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuewhenmulti.cs#05)]
 [!code-vb[System.Threading.Tasks.Task#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuewhenmulti.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen <see langword="null" />-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationAction As Action(Of Task), cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.  
  
- oder - 
 <paramref name="cancellationToken" /> wurde bereits gelöscht.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen <see langword="null" />-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks
 
 Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAny` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="continuationAction" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> gibt einen ungültigen TaskContinuationOptions-Wert an.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen <see langword="null" />-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationAction As Action(Of Task), cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das verwendet wird, um das erstellte Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> zu planen.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAny` .

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="continuationAction" /> ist <see langword="null" />.  
  
- oder - 
<paramref name="scheduler" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen <see langword="null" />-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> gibt einen ungültigen TaskContinuationOptions-Wert an.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult))) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="continuationAction" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen <see langword="null" />-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)), cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.  
  
- oder - 
Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="continuationAction" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen NULL-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

 Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAny` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="continuationAction" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> gibt einen ungültigen TaskContinuationOptions-Wert an.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen NULL-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)), cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationAction">Der Aktionsdelegat, der ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das verwendet wird, um das erstellte Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> zu planen.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks
 
 Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAny` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="continuationAction" /> ist <see langword="null" />.  
  
- oder - 
paramref name="scheduler" /&gt; ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen <see langword="null" />-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert an.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und dem erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Element zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="continuationFunction" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen NULL-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task, TResult), cancellationToken As CancellationToken) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und dem erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Element zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.  
  
- oder - 
Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="continuationFunction" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen <see langword="null" />-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und dem erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Element zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAny` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
<paramref name="continuationFunction" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> gibt einen ungültigen TaskContinuationOptions-Wert an.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen <see langword="null" />-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task, TResult), cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und dem erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Element zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das verwendet wird, um das erstellte Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> zu planen.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAny` .

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="continuationFunction" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="scheduler" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen <see langword="null" />-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> gibt einen ungültigen TaskContinuationOptions-Wert an.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und dem erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Element zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
<paramref name="continuationFunction" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen NULL-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult), cancellationToken As CancellationToken) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und dem erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Element zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.  
  
- oder - 
Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
<paramref name="continuationFunction" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen <see langword="null" />-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und dem erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Element zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAny` .
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Eines der Elemente im <paramref name="tasks" />-Array wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
 <paramref name="continuationFunction" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> gibt einen ungültigen TaskContinuationOptions-Wert an.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen NULL-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult), cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Der Ergebnistyp des vorangehenden <paramref name="tasks" />-Elements.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das vom <paramref name="continuationFunction" />-Delegaten zurückgegeben und dem erstellten <see cref="T:System.Threading.Tasks.Task`1" />-Element zugeordnet wird.</typeparam>
        <param name="tasks">Das Array von Aufgaben, mit denen fortgefahren wird, wenn eine Aufgabe abgeschlossen ist.</param>
        <param name="continuationFunction">Der Funktionsdelegat, der asynchron ausgeführt werden soll, wenn eine Aufgabe im <paramref name="tasks" />-Array abgeschlossen wird.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Der <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />-Wert, der das Verhalten des erstellten Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das verwendet wird, um das erstellte Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" /> zu planen.</param>
        <summary>Erstellt ein Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />, das nach dem Abschluss einer Aufgabe im bereitgestellten Satz gestartet wird.</summary>
        <returns>Der neue Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Die noton \* und OnlyOn \* <xref:System.Threading.Tasks.TaskContinuationOptions> , die einschränken, für welche <xref:System.Threading.Tasks.TaskStatus> Zustände eine Fortsetzung ausgeführt wird, sind mit unzulässig `ContinueWhenAny` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="tasks" />-Array ist <see langword="null" />.  
  
- oder - 
<paramref name="continuationFunction" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="scheduler" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="tasks" />-Array enthält einen NULL-Wert.  
  
- oder - 
Das <paramref name="tasks" />-Array ist leer.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> gibt einen ungültigen TaskContinuationOptions-Wert an.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.TaskFactory.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die standardmäßigen Aufgabenerstellungsoptionen für diese Aufgabenfactory ab.</summary>
        <value>Die standardmäßigen Aufgabenerstellungsoptionen für diese Aufgabenfactory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der-Eigenschafts Wert wird zum Erstellen aller Aufgaben verwendet, es sei denn, bei Aufrufen der Methoden dieser Factory sind andere Optionen explizit angegeben.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromAsync">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult})" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das IAsyncResult-Element, dessen Abschluss die Verarbeitung des <paramref name="endMethod" />-Elements auslösen sollte.</param>
        <param name="endMethod">Der Aktionsdelegat, der das abgeschlossene <paramref name="asyncResult" />-Objekt verarbeitet.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />-Element, das eine Endmethodenaktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> über Ladungen, die einen-Parameter akzeptieren, `asyncResult` sind nicht so effizient wie die über Ladungen, die einen- `beginMethod` Parameter annehmen. Wenn die Leistung ein Problem ist, verwenden Sie die über Ladungen, die das Muster bereitstellen `beginMethod` / `endMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.  
  
- oder - 
<paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, state)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt;? beginMethod, Action&lt;IAsyncResult&gt; endMethod, object? state);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `beginMethod` wird in dem Thread gestartet, der <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> unter ausgeführt wird.  Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
<paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult), creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das IAsyncResult-Element, dessen Abschluss die Verarbeitung des <paramref name="endMethod" />-Elements auslösen sollte.</param>
        <param name="endMethod">Der Aktionsdelegat, der das abgeschlossene <paramref name="asyncResult" />-Objekt verarbeitet.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />-Element, das eine Endmethodenaktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> über Ladungen, die einen-Parameter akzeptieren, `asyncResult` sind nicht so effizient wie die über Ladungen, die einen- `beginMethod` Parameter annehmen. Wenn die Leistung ein Problem ist, verwenden Sie die über Ladungen, die das Muster bereitstellen `beginMethod` / `endMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">paramref name="creationOptions" /&gt; gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, state, creationOptions)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt;? beginMethod, Action&lt;IAsyncResult&gt; endMethod, object? state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `beginMethod` wird in dem Thread gestartet, der <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> unter ausgeführt wird. Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` . Die <xref:System.Threading.Tasks.TaskCreationOptions> Werte <xref:System.Threading.Tasks.TaskCreationOptions.PreferFairness> <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> und <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> schließen sich gegenseitig aus. In den FromAsync-Methoden `LongRunning` bewirkt, dass entweder oder eigenständig eine ausgelöst wird `AttachedToParent` <xref:System.ArgumentOutOfRangeException> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen TaskCreationOptions-Wert an.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult), creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das IAsyncResult-Element, dessen Abschluss die Verarbeitung des <paramref name="endMethod" />-Elements auslösen sollte.</param>
        <param name="endMethod">Der Aktionsdelegat, der das abgeschlossene <paramref name="asyncResult" />-Objekt verarbeitet.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />-Element, das verwendet wird, um die Aufgabe zu planen, die die Endmethode ausführt.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />-Element, das eine Endmethodenaktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> über Ladungen, die einen-Parameter akzeptieren, `asyncResult` sind nicht so effizient wie die über Ladungen, die einen- `beginMethod` Parameter annehmen. Wenn die Leistung ein Problem ist, verwenden Sie die über Ladungen, die das Muster bereitstellen `beginMethod` / `endMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.  
  
- oder - 
<paramref name="endMethod" /> ist <see langword="null" />.  
  
- oder - 
<paramref name="scheduler" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt;? beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object? state);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des ersten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `beginMethod` wird in dem Thread gestartet, der <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> unter ausgeführt wird. Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
<paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state, creationOptions)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt;? beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object? state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des ersten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `beginMethod` wird in dem Thread gestartet, der <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> unter ausgeführt wird. Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
<paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="asyncResult">Das IAsyncResult-Element, dessen Abschluss die Verarbeitung des <paramref name="endMethod" />-Elements auslösen sollte.</param>
        <param name="endMethod">Der Funktionsdelegat, der das abgeschlossene <paramref name="asyncResult" />-Objekt verarbeitet.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das eine Endmethodenfunktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> über Ladungen, die einen-Parameter akzeptieren, `asyncResult` sind nicht so effizient wie die über Ladungen, die einen- `beginMethod` Parameter annehmen. Wenn die Leistung ein Problem ist, verwenden Sie die über Ladungen, die das Muster bereitstellen `beginMethod` / `endMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, state)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt;? beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object? state);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult), creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="asyncResult">Das IAsyncResult-Element, dessen Abschluss die Verarbeitung des <paramref name="endMethod" />-Elements auslösen sollte.</param>
        <param name="endMethod">Der Funktionsdelegat, der das abgeschlossene <paramref name="asyncResult" />-Objekt verarbeitet.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das eine Endmethodenfunktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> über Ladungen, die einen-Parameter akzeptieren, `asyncResult` sind nicht so effizient wie die über Ladungen, die einen- `beginMethod` Parameter annehmen. Wenn die Leistung ein Problem ist, verwenden Sie die über Ladungen, die das Muster bereitstellen `beginMethod` / `endMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, state, creationOptions)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt;? beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object? state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult), creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="asyncResult">Das IAsyncResult-Element, dessen Abschluss die Verarbeitung des <paramref name="endMethod" />-Elements auslösen sollte.</param>
        <param name="endMethod">Der Funktionsdelegat, der das abgeschlossene <paramref name="asyncResult" />-Objekt verarbeitet.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />-Element, das verwendet wird, um die Aufgabe zu planen, die die Endmethode ausführt.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das eine Endmethodenfunktion ausführt, wenn ein angegebenes <see cref="T:System.IAsyncResult" />-Objekt abgeschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> über Ladungen, die einen-Parameter akzeptieren, `asyncResult` sind nicht so effizient wie die über Ladungen, die einen- `beginMethod` Parameter annehmen. Wenn die Leistung ein Problem ist, verwenden Sie die über Ladungen, die das Muster bereitstellen `beginMethod` / `endMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.  
  
- oder -

<paramref name="endMethod" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="scheduler" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen TaskCreationOptions-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt;? beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object? state);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TArg2">Der Typ des ersten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="arg2">Das zweite an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `beginMethod` wird in dem Thread gestartet, der <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> unter ausgeführt wird. Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state, creationOptions)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt;? beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object? state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TArg2">Der Typ des ersten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="arg2">Das zweite an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `beginMethod` wird in dem Thread gestartet, der <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> unter ausgeführt wird. Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TResult) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt;? beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object? state);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des ersten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `beginMethod` wird in dem Thread gestartet, der <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> unter ausgeführt wird. Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TResult) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state, creationOptions)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt;? beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object? state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des ersten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `beginMethod` wird in dem Thread gestartet, der <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> unter ausgeführt wird. Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt;? beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object? state);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TArg2">Der Typ des dritten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TArg3">Der Typ des ersten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="arg2">Das zweite an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="arg3">Das dritte an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `beginMethod` wird in dem Thread gestartet, der <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> unter ausgeführt wird. Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state, creationOptions)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt;? beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object? state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TArg2">Der Typ des dritten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TArg3">Der Typ des ersten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="arg2">Das zweite an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="arg3">Das dritte an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `beginMethod` wird in dem Thread gestartet, der <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> unter ausgeführt wird. Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TResult) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt;? beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object? state);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TArg2">Der Typ des ersten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="arg2">Das zweite an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `beginMethod` wird in dem Thread gestartet, der <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> unter ausgeführt wird. Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
<paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TResult) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state, creationOptions)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt;? beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object? state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TArg2">Der Typ des ersten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="arg2">Das zweite an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `beginMethod` wird in dem Thread gestartet, der <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> unter ausgeführt wird. Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3, TResult) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt;? beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object? state);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TArg2">Der Typ des dritten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TArg3">Der Typ des ersten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="arg2">Das zweite an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="arg3">Das dritte an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `beginMethod` wird in dem Thread gestartet, der <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> unter ausgeführt wird. Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3, TResult) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state, creationOptions)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt;? beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object? state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Der Typ des zweiten an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TArg2">Der Typ des dritten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TArg3">Der Typ des ersten, an den <paramref name="beginMethod" />-Delegaten übergebenen Arguments.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="beginMethod">Der Delegat, der den asynchronen Vorgang startet.</param>
        <param name="endMethod">Der Delegat, der den asynchronen Vorgang beendet.</param>
        <param name="arg1">Das erste an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="arg2">Das zweite an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="arg3">Das dritte an den <paramref name="beginMethod" />-Delegaten übergebene Argument.</param>
        <param name="state">Ein Objekt, das vom <paramref name="beginMethod" />-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Der TaskCreationOptions-Wert, der das Verhalten des erstellten <see cref="T:System.Threading.Tasks.Task`1" /> steuert.</param>
        <summary>Erstellt ein <see cref="T:System.Threading.Tasks.Task`1" />, das ein dem asynchronen Programmiermodellmuster entsprechendes Paar von Begin- und End-Methoden darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Threading.Tasks.Task`1" />, der den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `beginMethod` wird in dem Thread gestartet, der <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> unter ausgeführt wird. Diese Methode löst alle Ausnahmen aus, die von ausgelöst werden `beginMethod` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> ist <see langword="null" />.  
  
- oder - 
<paramref name="endMethod" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns">Verwenden von TPL mit anderen asynchronen Mustern</related>
      </Docs>
    </Member>
    <Member MemberName="Scheduler">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskScheduler Scheduler { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.TaskScheduler Scheduler" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.Scheduler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheduler As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskScheduler ^ Scheduler { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheduler : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskFactory.Scheduler" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskScheduler? Scheduler { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den standardmäßigen Aufgabenplaner für diese Aufgabenfactory ab.</summary>
        <value>Der standardmäßige Aufgabenplaner für diese Aufgabenfactory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der-Eigenschafts Wert wird verwendet, um alle Aufgaben zu planen, es sei denn, bei Aufrufen der Methoden dieser Factory wird explizit ein anderer Scheduler angegeben.  
  
 Wenn dieser Eigenschafts Wert ist `null` , wird der Wert der- <xref:System.Threading.Tasks.TaskScheduler.Current%2A> Eigenschaft verwendet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartNew">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt und startet eine Aufgabe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ab [!INCLUDE[net_v45](~/includes/net-v45-md.md)] <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> ist die-Methode die empfohlene Methode, um eine COMPUTE-gebundene Aufgabe zu starten. Verwenden <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Sie die-Methode nur, wenn Sie eine differenzierte Steuerung für einen Rechen gebundenen Task mit langer Ausführungszeit benötigen. Dies umfasst auch Szenarien, in denen Sie Folgendes steuern möchten:  
  
-   Aufgaben Erstellungs Optionen. Tasks, die von der- <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode standardmäßig erstellt werden, werden mit der- <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> Option erstellt. Um dieses Verhalten außer Kraft zu setzen oder andere Optionen bereitzustellen, müssen Sie eine-Überladung <xref:System.Threading.Tasks.TaskCreationOptions> aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> .  
  
-   Parameter Übergabe. Die über Ladungen der- <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode lassen nicht zu, dass Sie einen Parameter an den Aufgaben Delegaten übergeben. Über Ladungen der- <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Methode.  
  
-   Taskplaner Die über Ladungen der- <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode verwenden den Standardaufgaben Planer. Um den Taskplaner zu steuern, müssen Sie eine- <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> Überladung mit einem- `scheduler` Parameter aufrufen. Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://aka.ms/dotnet-parallel-samples">Beispiele für die parallele Programmierung mit .net Core und .NET Standard</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <summary>Erstellt und startet eine Aufgabe für den angegebenen Aktions Delegaten.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> von ist funktional äquivalent zum Erstellen einer Aufgabe mit einem ihrer Konstruktoren und dem anschließenden Aufrufen der- <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> Methode, um die Ausführung der Aufgabe zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> Methode als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> mit Standardparametern verwenden. Beachten Sie jedoch, dass es Unterschiede im Verhalten zwischen den beiden Methoden bezüglich gibt: Standardmäßig ist es nicht zulässig, dass untergeordnete <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> Aufgaben mit der- <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> Option an die aktuelle <xref:System.Threading.Tasks.Task> Instanz <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> angefügt werden. Weitere Informationen und Codebeispiele finden Sie unter [Task. Run vs Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die-Methode verwendet, <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> um wiederholt einen Delegaten aufzurufen, der <xref:System.Action> eine Zufallszahl generiert, als Unicode-Codepunkt interpretiert, in eine UTF16-codierte Code Einheit konvertiert und Informationen über das resultierende Zeichen anzeigt.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew1.cs#1)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument lautet <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Aufgabe zugewiesen wird.</param>
        <summary>Erstellt und startet eine Aufgabe für den angegebenen Aktions Delegaten und das Abbruch Token.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von `StartNew` ist funktional äquivalent zum Erstellen einer Aufgabe mit einem seiner Konstruktoren und dem anschließenden Aufrufen von <xref:System.Threading.Tasks.Task.Start%2A> , um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Methode als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> mit Standardparametern verwenden. Beachten Sie jedoch, dass es Unterschiede im Verhalten zwischen den beiden Methoden bezüglich gibt: Standardmäßig ist es nicht zulässig, dass untergeordnete <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Aufgaben mit der- <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> Option an die aktuelle <xref:System.Threading.Tasks.Task> Instanz <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> angefügt werden. Weitere Informationen und Codebeispiele finden Sie unter [Task. Run vs Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die- <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> Methode aufgerufen, um eine Aufgabe zu erstellen, die die Dateien im Verzeichnis c:\Windows\System32 durchläuft. Der Lambda-Ausdruck ruft die- <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Methode auf, um einem-Objektinformationen zu jeder Datei hinzuzufügen <xref:System.Collections.Generic.List%601> . Jede von der-Schleife aufgerufene getrennte, von der-Schleife aufgerufene Aufgabe <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> überprüft den Status des Abbruch Tokens und ruft, wenn der Abbruch angefordert wird, die- <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Methode auf. Die- <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Methode löst eine <xref:System.OperationCanceledException> Ausnahme aus, die in einem-Block behandelt wird, `catch` Wenn der aufrufende Thread die- <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> Methode aufruft.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew2.cs#2)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="creationOptions">Einer der Enumerationswerte, der das Verhalten der erstellten Aufgabe steuert.&gt;</param>
        <summary>Erstellt und startet eine Aufgabe für den angegebenen Aktions Delegaten und die Erstellungs Optionen.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von StartNew ist funktional äquivalent zum Erstellen einer Aufgabe mit einem ihrer Konstruktoren und dem anschließenden Aufrufen von <xref:System.Threading.Tasks.Task.Start%2A> , um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einem- <xref:System.Action> Objekt als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern verwenden. Weitere Informationen und Codebeispiele finden Sie unter [Task. Run vs Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action(Of Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt;? action, object? state);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="state">Ein Objekt, das vom <paramref name="action" />-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt und startet eine Aufgabe für den angegebenen Aktions Delegaten und-Zustand.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> ist funktional äquivalent zum Erstellen eines <xref:System.Threading.Tasks.Task> mit einem seiner Konstruktoren und zum anschließenden Aufrufen der- <xref:System.Threading.Tasks.Task.Start%2A> Methode, um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einem- <xref:System.Action> Objekt als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern verwenden. Weitere Informationen und Codebeispiele finden Sie unter [Task. Run vs Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array aus 6 Buchstaben definiert. Anschließend wird jedes Wort an einen-Delegaten weitergegeben <xref:System.Action%601> , der das Wort abstürzt und das ursprüngliche Wort und seine abgekratte Version anzeigt.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew3.vb#3)]  
  
 Beachten Sie, dass im Beispiel ein einzelner Zufallszahlen-Generator initialisiert wird, der durch eine Sperre geschützt wird. Eine Sperre finden Sie unter "System. Random-Klasse und Thread Sicherheit" im Thema zur- <xref:System.Random> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="action" />-Argument lautet <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action(Of Object), state As Object, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, cancellationToken)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt;? action, object? state, System.Threading.CancellationToken cancellationToken);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="state">Ein Objekt, das vom <paramref name="action" />-Delegaten zu verwendende Daten enthält.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Aufgabe zugewiesen wird.</param>
        <summary>Erstellt und startet eine Aufgabe für den angegebenen Aktions Delegaten, Zustand und Abbruch Token.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von StartNew ist funktional äquivalent zum Erstellen einer Aufgabe mit einem ihrer Konstruktoren und dem anschließenden Aufrufen von <xref:System.Threading.Tasks.Task.Start%2A> , um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einem- <xref:System.Action> Objekt als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern verwenden. Weitere Informationen und Codebeispiele finden Sie unter [Task. Run vs Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array aus 6 Buchstaben definiert. Anschließend wird jedes Wort an einen-Delegaten weitergegeben <xref:System.Action%601> , der das Wort abstürzt und das ursprüngliche Wort und seine abgekratte Version anzeigt.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew4.cs#4)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew4.vb#4)]  
  
 Beachten Sie, dass im Beispiel ein einzelner Zufallszahlen-Generator initialisiert wird, der durch eine Sperre geschützt wird. Eine Sperre finden Sie unter "System. Random-Klasse und Thread Sicherheit" im Thema zur- <xref:System.Random> Klasse. Um die Möglichkeit einer Beschädigung des Zufallszahlengenerators zu behandeln, wird ein Abbruch Token an den Task übermittelt. Wenn zwei Zufallszahlen gleich 0 (null) sind, geht die Methode davon aus, dass der Zufallszahlengenerator beschädigt ist, und legt das Abbruch Token fest. Vor dem Sortieren des `chars` Arrays, das die sechs Zeichen in einem Wort enthält, ruft die-Methode die- <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Methode auf, um eine auszulösen, <xref:System.OperationCanceledException> Wenn das Token abgebrochen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, creationOptions)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt;? action, object? state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="state">Ein Objekt, das vom <paramref name="action" />-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Einer der Enumerationswerte, der das Verhalten der erstellten Aufgabe steuert.</param>
        <summary>Erstellt und startet eine Aufgabe für den angegebenen Aktions Delegaten, den Status und die Erstellungs Optionen.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von StartNew ist funktional äquivalent zum Erstellen einer Aufgabe mit einem ihrer Konstruktoren und dem anschließenden Aufrufen von <xref:System.Threading.Tasks.Task.Start%2A> , um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einem- <xref:System.Action> Objekt als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern verwenden. Weitere Informationen und Codebeispiele finden Sie unter [Task. Run vs Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action, cancellationToken As CancellationToken, creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Aufgabe zugewiesen wird.</param>
        <param name="creationOptions">Einer der Enumerationswerte, der das Verhalten der erstellten Aufgabe steuert.</param>
        <param name="scheduler">Der Aufgabenplaner, der verwendet wird, um die erstellte Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt und startet eine Aufgabe für den angegebenen Aktions Delegaten, das Abbruch Token, die Erstellungs Optionen und den Status.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von StartNew ist funktional äquivalent zum Erstellen einer Aufgabe mit einem ihrer Konstruktoren und dem anschließenden Aufrufen von <xref:System.Threading.Tasks.Task.Start%2A> , um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einem- <xref:System.Action> Objekt als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern verwenden. Weitere Informationen und Codebeispiele finden Sie unter [Task. Run vs Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="scheduler" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen TaskCreationOptions-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action(Of Object), state As Object, cancellationToken As CancellationToken, creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, cancellationToken, creationOptions, scheduler)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt;? action, object? state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">Der Aktionsdelegat, der asynchron ausgeführt werden soll.</param>
        <param name="state">Ein Objekt, das vom <paramref name="action" />-Delegaten zu verwendende Daten enthält.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Aufgabe zugewiesen wird.</param>
        <param name="creationOptions">Einer der Enumerationswerte, der das Verhalten der erstellten Aufgabe steuert.</param>
        <param name="scheduler">Der Aufgabenplaner, der verwendet wird, um die erstellte Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt und startet eine Aufgabe für den angegebenen Aktions Delegaten, den Status, das Abbruch Token, die Erstellungs Optionen und den Taskplaner.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von StartNew ist funktional äquivalent zum Erstellen einer Aufgabe mit einem ihrer Konstruktoren und dem anschließenden Aufrufen von <xref:System.Threading.Tasks.Task.Start%2A> , um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einem- <xref:System.Action> Objekt als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern verwenden. Weitere Informationen und Codebeispiele finden Sie unter [Task. Run vs Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" />.  
  
- oder -

<paramref name="scheduler" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe der Aufgabe verfügbar sein wird.</param>
        <summary>Erstellt und startet eine Aufgabe des Typs <typeparamref name="TResult" /> für den angegebenen Funktions Delegaten.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> ist funktional äquivalent zum Erstellen einer <xref:System.Threading.Tasks.Task%601> mit einem seiner Konstruktoren und zum anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> von, um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> Methode als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern aufzurufen. Beachten Sie jedoch, dass es Unterschiede im Verhalten zwischen den beiden Methoden bezüglich gibt: Standardmäßig ist es nicht zulässig, dass untergeordnete <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> Aufgaben mit der- <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> Option an die aktuelle <xref:System.Threading.Tasks.Task%601> Instanz <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29> angefügt werden. Weitere Informationen und Codebeispiele finden Sie unter Entry [Task. Run vs. Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
   
  
## Examples  
 Das folgende Beispiel ist eine einfache Additions-APP, die zwei Zufallszahlen generiert und den Benutzer zur Eingabe seiner Summe auffordert. Sie gibt dann an, ob die Antwort richtig ist, oder fordert den Benutzer zur erneuten Eingabe einer gültigen Zahl auf, wenn die Antwort des Benutzers keine gültige Zahl ist. <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>Wird verwendet, um die-Objekte zu erstellen, die die hinzu zufügenden <xref:System.Threading.Tasks.Task%601> Zufallszahlen zurückgeben.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Run#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="function" />-Argument lautet <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt;? StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt;? function, object state);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe der Aufgabe verfügbar sein wird.</param>
        <param name="state">Ein Objekt, das vom <paramref name="function" />-Delegaten zu verwendende Daten enthält.</param>
        <summary>Erstellt und startet eine Aufgabe des Typs <typeparamref name="TResult" /> für den angegebenen Funktions Delegaten und-Zustand.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von StartNew ist funktional äquivalent zum Erstellen eines <xref:System.Threading.Tasks.Task%601> mit einem seiner Konstruktoren und zum anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> von, um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einem- <xref:System.Action> Objekt als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern verwenden. Weitere Informationen und Codebeispiele finden Sie unter Entry [Task. Run vs. Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of TResult), cancellationToken As CancellationToken) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe der Aufgabe verfügbar sein wird.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Aufgabe zugewiesen wird.</param>
        <summary>Erstellt und startet eine Aufgabe des Typs <typeparamref name="TResult" /> für den angegebenen Funktions Delegaten und Abbruch Token.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> ist funktional äquivalent zum Erstellen einer <xref:System.Threading.Tasks.Task%601> mit einem seiner Konstruktoren und zum anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> von, um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Methode als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> mit Standardparametern verwenden. Beachten Sie jedoch, dass es Unterschiede im Verhalten zwischen den beiden Methoden bezüglich gibt: Standardmäßig ist es nicht zulässig, dass untergeordnete <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Aufgaben mit der- <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> Option an die aktuelle <xref:System.Threading.Tasks.Task%601> Instanz <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> angefügt werden. Weitere Informationen und Codebeispiele finden Sie unter Entry [Task. Run vs. Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei Tasks verwendet, um die in F100 = F100-1 + F100-2 endende "mobonacci"-Sequenz mit den Seed-Werten F1 = 1, F2 = 1 und F1 = 0, F2 = 1 zu berechnen. Ungefähr die Hälfte der Zeit wird ein Abbruch Token festgelegt, wenn die Vorgänge ausgeführt werden. Die Ausgabe aus dem Beispiel zeigt das Ergebnis, wenn die beiden Aufgaben erfolgreich abgeschlossen werden und das Token abgebrochen wird.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run9.cs#9)]
 [!code-vb[System.Threading.Tasks.Task.Run#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run9.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of TResult), creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe der Aufgabe verfügbar sein wird.</param>
        <param name="creationOptions">Einer der Enumerationswerte, der das Verhalten der erstellten Aufgabe steuert.</param>
        <summary>Erstellt und startet eine Aufgabe des Typs <typeparamref name="TResult" /> für den angegebenen Funktions Delegaten und die Erstellungs Optionen.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von StartNew ist funktional äquivalent zum Erstellen eines <xref:System.Threading.Tasks.Task%601> mit einem seiner Konstruktoren und zum anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> von, um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einem- <xref:System.Action> Objekt als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern verwenden. Weitere Informationen und Codebeispiele finden Sie unter Entry [Task. Run vs. Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of Object, TResult), state As Object, cancellationToken As CancellationToken) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, cancellationToken)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt;? StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt;? function, object state, System.Threading.CancellationToken cancellationToken);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe der Aufgabe verfügbar sein wird.</param>
        <param name="state">Ein Objekt, das vom <paramref name="function" />-Delegaten zu verwendende Daten enthält.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Aufgabe zugewiesen wird.</param>
        <summary>Erstellt und startet eine Aufgabe des Typs <typeparamref name="TResult" /> für den angegebenen Funktions Delegaten, den Status und das Abbruch Token.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von StartNew ist funktional äquivalent zum Erstellen eines <xref:System.Threading.Tasks.Task%601> mit einem seiner Konstruktoren und zum anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> von, um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einem- <xref:System.Action> Objekt als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern verwenden. Weitere Informationen und Codebeispiele finden Sie unter Entry [Task. Run vs. Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> ist <see langword="null" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of Object, TResult), state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, creationOptions)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt;? StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt;? function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe der Aufgabe verfügbar sein wird.</param>
        <param name="state">Ein Objekt, das vom <paramref name="function" />-Delegaten zu verwendende Daten enthält.</param>
        <param name="creationOptions">Einer der Enumerationswerte, der das Verhalten der erstellten Aufgabe steuert.</param>
        <summary>Erstellt und startet eine Aufgabe des Typs <typeparamref name="TResult" /> für den angegebenen Funktions Delegaten, den Status und die Erstellungs Optionen.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von StartNew ist funktional äquivalent zum Erstellen eines <xref:System.Threading.Tasks.Task%601> mit einem seiner Konstruktoren und zum anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> von, um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einem- <xref:System.Action> Objekt als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern verwenden. Weitere Informationen und Codebeispiele finden Sie unter Entry [Task. Run vs. Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of TResult), cancellationToken As CancellationToken, creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe der Aufgabe verfügbar sein wird.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Aufgabe zugewiesen wird.</param>
        <param name="creationOptions">Einer der Enumerationswerte, der das Verhalten der erstellten Aufgabe steuert.</param>
        <param name="scheduler">Der Aufgabenplaner, der verwendet wird, um die erstellte Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt und startet eine Aufgabe des Typs <typeparamref name="TResult" /> für den angegebenen Funktions Delegaten, das Abbruch Token, die Erstellungs Optionen und den Taskplaner.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von StartNew ist funktional äquivalent zum Erstellen eines <xref:System.Threading.Tasks.Task%601> mit einem seiner Konstruktoren und zum anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> von, um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einem- <xref:System.Action> Objekt als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern verwenden. Weitere Informationen und Codebeispiele finden Sie unter Entry [Task. Run vs. Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="scheduler" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of Object, TResult), state As Object, cancellationToken As CancellationToken, creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, cancellationToken, creationOptions, scheduler)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt;? function, object? state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Ergebnisses, das über die Aufgabe verfügbar ist.</typeparam>
        <param name="function">Ein Funktionsdelegat, der das zukünftige Ergebnis zurückgibt, das mithilfe der Aufgabe verfügbar sein wird.</param>
        <param name="state">Ein Objekt, das vom <paramref name="function" />-Delegaten zu verwendende Daten enthält.</param>
        <param name="cancellationToken">Das Abbruchtoken, das der neuen Aufgabe zugewiesen wird.</param>
        <param name="creationOptions">Einer der Enumerationswerte, der das Verhalten der erstellten Aufgabe steuert.</param>
        <param name="scheduler">Der Aufgabenplaner, der verwendet wird, um die erstellte Fortsetzungsaufgabe zu planen.</param>
        <summary>Erstellt und startet eine Aufgabe des Typs <typeparamref name="TResult" /> für den angegebenen Funktions Delegaten, den Status, das Abbruch Token, die Erstellungs Optionen und den Taskplaner.</summary>
        <returns>Die begonnene Aufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von StartNew ist funktional äquivalent zum Erstellen eines <xref:System.Threading.Tasks.Task%601> mit einem seiner Konstruktoren und zum anschließenden Aufrufen <xref:System.Threading.Tasks.Task.Start%2A> von, um die Ausführung zu planen.  
  
 Beginnend mit [!INCLUDE[net_v45](~/includes/net-v45-md.md)] können Sie die- <xref:System.Threading.Tasks.Task.Run%2A> Methode mit einem- <xref:System.Action> Objekt als schnelle Möglichkeit zum aufzurufen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> mit Standardparametern verwenden. Weitere Informationen und Codebeispiele finden Sie unter Entry [Task. Run vs. Task. Factory. StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) im Blog zur parallelen Programmierung mit .net.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits verworfen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="scheduler" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> gibt einen ungültigen <see cref="T:System.Threading.Tasks.TaskCreationOptions" />-Wert an. Weitere Informationen finden Sie in den Hinweisen zu <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-cancellation">Aufgabenabbruch</related>
      </Docs>
    </Member>
  </Members>
</Type>
