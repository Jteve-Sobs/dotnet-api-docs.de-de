<Type Name="Task&lt;TResult&gt;" FullName="System.Threading.Tasks.Task&lt;TResult&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="265ac3022bd976ef52f4dec41a7406456c31c346" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57955971" /></Metadata><TypeSignature Language="C#" Value="public class Task&lt;TResult&gt; : System.Threading.Tasks.Task" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task`1&lt;TResult&gt; extends System.Threading.Tasks.Task" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Task(Of TResult)&#xA;Inherits Task" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA;public ref class Task : System::Threading::Tasks::Task" />
  <TypeSignature Language="F#" Value="type Task&lt;'Result&gt; = class&#xA;    inherit Task" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TResult" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Threading.Tasks.Task</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}, Result = {DebuggerDisplayResultDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TResult">Der von diesem <see cref="T:System.Threading.Tasks.Task`1" /> erzeugte Ergebnistyp.</typeparam>
    <summary>Stellt einen asynchronen Vorgang dar, der einen Wert zurückgeben kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Task%601> -Klasse stellt ein einzelnen Vorgang, der einen Wert und die zurückgibt, in der Regel führt asynchron aus. <xref:System.Threading.Tasks.Task%601> Objekte sind eine der zentralen Komponenten von der [aufgabenbasierte asynchrone Muster](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) in .NET Framework 4 eingeführt wurden. Da die Arbeit, indem geleistet eine <xref:System.Threading.Tasks.Task%601> Objekt in der Regel führt asynchron auf einem Threadpoolthread anstatt synchron auf dem Hauptanwendungsthread, Sie verwenden können der <xref:System.Threading.Tasks.Task.Status%2A> -Eigenschaft, als auch die <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, und <xref:System.Threading.Tasks.Task.IsFaulted%2A> Eigenschaften, um den Status eines Vorgangs zu bestimmen. In den meisten Fällen wird ein Lambda-Ausdruck verwendet, an die Arbeit, die die Aufgabe auszuführen.  
  
 <xref:System.Threading.Tasks.Task%601> Instanzen können auf verschiedene Arten erstellt werden. Die am häufigsten verwendete Ansatz, nämlich verfügbar ab der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], besteht im Aufrufen der statischen <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> oder <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Methode. Diese Methoden bieten eine einfache Möglichkeit, eine Aufgabe zu starten, mit Standardwerten und ohne zusätzliche Parameter abrufen zu müssen. Im folgenden Beispiel wird die <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> Methode, um eine Aufgabe zu starten, Schleifen und zeigt dann die Anzahl der Schleifeniterationen:  
  
 [!code-csharp[System.Threading.Tasks.Task\`1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task\`1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1/vb/run1.vb#6)]  
  
 Eine Alternative und die gängigste Methode zum Starten von einer Aufgabe in der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], besteht im Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> oder <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> Methode. Die <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> -Eigenschaft gibt eine <xref:System.Threading.Tasks.TaskFactory> -Objekt, und die <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> -Eigenschaft gibt eine <xref:System.Threading.Tasks.TaskFactory%601> Objekt. Überladungen der ihre `StartNew` -Methode können Sie die Argumente übergeben, Aufgabenerstellungsoptionen definieren und Angeben eines Aufgabenplaners. Im folgenden Beispiel wird die <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%29?displayProperty=nameWithType> Methode für den Aufgabenstart nutzt. Es ist funktionell gleichwertig mit der Code im vorherigen Beispiel.  
  
 [!code-csharp[System.Threading.Tasks.Task\`1#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task\`1#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1/vb/startnew1.vb#7)]  
  
 Ausführlichere Beispiele finden Sie unter [aufgabenbasierte asynchrone Programmierung](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).  
  
 Die <xref:System.Threading.Tasks.Task%601> Klasse stellt außerdem Konstruktoren, die den Task initialisiert, aber nicht planen sie für die Ausführung, bereit. Aus Leistungsgründen die <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> und `Task.Factory.StartNew` Methoden sind die bevorzugte Mechanismen zum Erstellen und Planen von Berechnungsaufgaben aus, aber für Szenarien, in dem taskerstellung und Planung getrennt werden müssen, können die Konstruktoren werden verwendet, und die Aufgabe <xref:System.Threading.Tasks.Task.Start%2A> Methode kann dann verwendet werden, um den Task für die Ausführung zu einem späteren Zeitpunkt planen.  
  
 Beginnend mit desktop-apps für die [!INCLUDE[net_v46](~/includes/net-v46-md.md)], die Kultur des Threads, der erstellt, und ruft eine Aufgabe wird der Kontext des Threads. Unabhängig von der aktuellen Kultur des Threads auf dem der Task ausgeführt wird, ist die aktuelle Kultur der Aufgabe, also die Kultur des aufrufenden Threads. Für apps mit Zielversionen von .NET Framework vor der [!INCLUDE[net_v46](~/includes/net-v46-md.md)], die der Aufgabe ist die Kultur des Threads auf dem der Task ausgeführt wird. Weitere Informationen finden Sie im Abschnitt "Kultur und aufgabenbasierte asynchrone Vorgänge" in der <xref:System.Globalization.CultureInfo> Thema. Beachten Sie, dass die Store-apps, die Windows-Runtime in festlegen und Abrufen der Standardkultur folgen.  
  
Für Vorgänge, die keinen Wert zurückgeben, verwenden Sie die <xref:System.Threading.Tasks.Task> Klasse. Beginnend mit C# 7.0, verwenden Sie für eine einfachere Aufgabe, die ein Werttyp, sondern einen Verweistyp handelt, ist die <xref:System.Threading.Tasks.ValueTask%601?displayProperty=nameWithType> Struktur. 
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Mitglieder der <see cref="T:System.Threading.Tasks.Task`1" />, mit Ausnahme von <see cref="M:System.Threading.Tasks.Task.Dispose" />sind threadsicher und können von mehreren Threads gleichzeitig verwendet werden.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Beispiele für die parallele Programmierung mit .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert ein neues <see cref="T:System.Threading.Tasks.Task`1" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; function" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt. Nachdem die Funktion abgeschlossen wurde, wird die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft der Aufgabe festgelegt, um den Ergebniswert der Funktion zurückzugeben.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task`1" /> mit der angegebenen Funktion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task%601> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> und <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%29?displayProperty=nameWithType> Methoden. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
   
  
## Examples  
 Im folgende Beispiel wird die ungefähre Anzahl der Wörter im Textdateien, die veröffentlichten Bücher darstellen. Jede Aufgabe ist verantwortlich für eine Datei zu öffnen, lesen den gesamten Inhalt asynchron und berechnen die Anzahl der Wörter mithilfe eines regulären Ausdrucks. Die <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> Methode wird aufgerufen, um sicherzustellen, dass alle Aufgaben abgeschlossen haben, bevor Sie die Anzahl der Wörter für jedes Buch in der Konsole anzeigen.  
  
 Objektinstanziierung wird vom Objekt-Ausführung in diesem Beispiel wird getrennt, damit das Beispiel sicherstellen kann, dass jede Datei vorhanden ist. Wenn dies nicht der Fall ist, wird der Name der fehlenden Datei. Andernfalls ruft sie die <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> Methode, um jede Aufgabe zu starten.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run3.vb#2)]  
  
 Muster für reguläre Ausdrücke `\p{P}*\s+` entspricht 0 (null), eine oder mehrere Interpunktionszeichen, gefolgt von einem oder mehreren Leerzeichen. Es wird davon ausgegangen, dass die Gesamtzahl der Übereinstimmungen wortzählung ungefähr gleich ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="function" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of Object, TResult), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="function">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt. Nachdem die Funktion abgeschlossen wurde, wird die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft der Aufgabe festgelegt, um den Ergebniswert der Funktion zurückzugeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Aktion verwendet werden sollen.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task`1" /> mit den angegebenen Werten für Funktion und Zustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task%601> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="function" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt. Nachdem die Funktion abgeschlossen wurde, wird die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft der Aufgabe festgelegt, um den Ergebniswert der Funktion zurückzugeben.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das dieser Aufgabe zugewiesen werden soll.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task`1" /> mit der angegebenen Funktion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task%601> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> und <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Methoden. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="function" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of TResult), creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt. Nachdem die Funktion abgeschlossen wurde, wird die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft der Aufgabe festgelegt, um den Ergebniswert der Funktion zurückzugeben.</param>
        <param name="creationOptions">Das <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, das verwendet wird, um das Verhalten der Aufgabe zu ändern.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task`1" /> mit den angegebenen Werten für Funktion und Erstellungsoptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task%601> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> an.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="function" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt. Nachdem die Funktion abgeschlossen wurde, wird die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft der Aufgabe festgelegt, um den Ergebniswert der Funktion zurückzugeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Funktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Aufgabe zugewiesen werden soll.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task`1" /> mit den angegebenen Werten für Aktion, Zustand und Optionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task%601> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="function" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of Object, TResult), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt. Nachdem die Funktion abgeschlossen wurde, wird die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft der Aufgabe festgelegt, um den Ergebniswert der Funktion zurückzugeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Funktion verwendet werden sollen.</param>
        <param name="creationOptions">Das <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, das verwendet wird, um das Verhalten der Aufgabe zu ändern.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task`1" /> mit den angegebenen Werten für Aktion, Zustand und Optionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task%601> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> an.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="function" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt. Nachdem die Funktion abgeschlossen wurde, wird die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft der Aufgabe festgelegt, um den Ergebniswert der Funktion zurückzugeben.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Aufgabe zugewiesen wird.</param>
        <param name="creationOptions">Das <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, das verwendet wird, um das Verhalten der Aufgabe zu ändern.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task`1" /> mit den angegebenen Werten für Funktion und Erstellungsoptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task%601> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> Methode.  Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> an.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="function" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">Der Delegat, der den in der Aufgabe auszuführenden Code darstellt. Nachdem die Funktion abgeschlossen wurde, wird die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft der Aufgabe festgelegt, um den Ergebniswert der Funktion zurückzugeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Funktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Aufgabe zugewiesen werden soll.</param>
        <param name="creationOptions">Das <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, das verwendet wird, um das Verhalten der Aufgabe zu ändern.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Task`1" /> mit den angegebenen Werten für Aktion, Zustand und Optionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt diesen Konstruktor aufrufen, der die gängigste Methode zum Instanziieren einer <xref:System.Threading.Tasks.Task%601> -Objekt, und starten Sie eine Aufgabe wird durch Aufrufen der statischen <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> Methode. Der einzige Vorteil, die von diesem Konstruktor bereitgestellt wird, dass die Objektinstanziierung vom taskaufruf getrennt werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="creationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> an.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="function" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;TResult&gt; ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1&lt;!TResult&gt; ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable&lt;TResult&gt; ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="override this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;'Result&gt;" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">"True", um zu versuchen, die Fortsetzung zurück in den ursprünglich erfassten Text zu marshallen; andernfalls "False".</param>
        <summary>Konfiguriert einen Awaiter, der verwendet wird, um diese <see cref="T:System.Threading.Tasks.Task`1" /> zu erwarten.</summary>
        <returns>Ein Objekt, das verwendet wird, um diese Aufgabe zu erwarten.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Fortsetzungsaufgabe, die ausgeführt wird, wenn eine andere Aufgabe beendet ist.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult))) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss vom vorhergehenden <see cref="T:System.Threading.Tasks.Task`1" /> ausgeführt werden soll. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn die Zielaufgabe abgeschlossen wurde.</summary>
        <returns>Eine neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang abgeschlossen wurde, erfolgreich ausgeführt, Fehler aufgrund einer nicht behandelten Ausnahme oder einem frühen Zeitpunkt aufgrund eines Abbruchs beendet.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Vorgängeraufgabe, die das Sieb des Eratosthenes zum Berechnen von Primzahlen zwischen 1 und vom Benutzer eingegebene Wert verwendet. Ein Array ist zum Speichern von Informationen über die Primzahlen verwendet. Index des Arrays darstellt, die Anzahl und den Wert des Elements angibt, ob diese Zahl zusammengesetzt ist (der Wert ist `true`) oder vorzubereiten (der Wert ist `false`). Diese Aufgabe wird dann an eine Fortsetzungsaufgabe übergeben, die für die Primzahlen aus einem Ganzzahlen-Array zu extrahieren und zu deren Anzeige zuständig ist.  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continue2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continue2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task`1" /> ausgeführt werden soll. Wenn der Delegat ausgeführt wird, werden ihm der abgeschlossene Task und das vom Aufrufer bereitgestellte Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <summary>Erstellt eine Fortsetzung, an die Zustandsinformationen übergeben werden und die ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Aufgabe, die eine ganze Zahl zwischen 2 und 20 übergeben wird, und gibt ein Array, das die ersten zehn Exponenten enthält (n<sup>1</sup> n<sup>10</sup>) dieser Zahl. Eine Fortsetzungsaufgabe ist dann dafür verantwortlich, die Exponenten. Es wird übergeben, sowohl der Vorgänger als auch die ursprüngliche Anzahl, deren Exponenten, die die vorangehende Aufgabe generiert.  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continuewith3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continuewith3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task`1" /> ausgeführt werden soll. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="cancellationToken">Das Abbruchtoken, das an die neue Fortsetzungsaufgabe übergeben werden soll.</param>
        <summary>Erstellt eine abzubrechende Fortsetzung, die asynchron ausgeführt wird, wenn die Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen wurde.</summary>
        <returns>Eine neue Fortsetzungsaufgabe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Vorgängeraufgabe, die das Sieb des Eratosthenes zum Berechnen von Primzahlen zwischen 1 und vom Benutzer eingegebene Wert verwendet. Ein Array ist zum Speichern von Informationen über die Primzahlen verwendet. Index des Arrays darstellt, die Anzahl und den Wert des Elements angibt, ob diese Zahl zusammengesetzt ist (der Wert ist `true`) oder vorzubereiten (der Wert ist `false`). Diese Aufgabe wird dann an eine Fortsetzungsaufgabe übergeben, die für die Primzahlen aus einem Ganzzahlen-Array zu extrahieren und zu deren Anzeige zuständig ist.  
  
 Sowohl der Vorgänger als auch der Fortsetzungsaufgabe wird ein Abbruchtoken übergeben. Ein <xref:System.Timers.Timer?displayProperty=nameWithType> Objekt wird verwendet, um einen Timeoutwert von 100 Millisekunden zu definieren. Wenn das Ereignis ausgelöst wird, die <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> Methode wird aufgerufen, und das Abbruchtoken, das wird verwendet, um den Abbruch der Aufgaben anzufordern.  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continue1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continue1.vb#1)]  
  
 In der Regel durch Angeben des ungefähr 100.000 Werts führt dazu, dass das Timeoutintervall abläuft und die <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> Ereignis ausgelöst, und die abbruchanforderung festgelegt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> wurde verworfen.  
  
- oder - 
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde gelöscht.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument lautet <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult)), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion entsprechend der in <paramref name="continuationOptions" /> angegebenen Bedingung. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Erstellt eine Fortsetzung, die nach der in <paramref name="continuationOptions" /> angegebenen Bedingung ausgeführt wird.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht für die Ausführung geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Fortsetzungskriterien über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird jedoch abgebrochen statt geplant.  
  
 Weitere Informationen finden Sie unter [Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult)), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task`1" /> ausgeführt werden soll. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen wurde.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument ist null.  
  
- oder - 
Das <paramref name="scheduler" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task`1" /> ausgeführt werden soll. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <summary>Erstellt eine Fortsetzung, die ausgeführt wird, wenn die Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument ist null.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits freigegeben.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task`1" /> ausgeführt werden soll. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Erstellt eine Fortsetzung, die ausgeführt wird, wenn die Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht für die Ausführung geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Fortsetzungskriterien über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird jedoch abgebrochen statt geplant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task`1" /> ausgeführt werden soll. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die ausgeführt wird, wenn die Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument lautet <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die entsprechend der in <paramref name="continuationOptions" /> angegebenen Bedingung ausgeführt wird. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die nach der in <paramref name="continuationOptions" /> angegebenen Bedingung ausgeführt wird.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht für die Ausführung geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Kriterien, über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird abgebrochen statt geplant. Weitere Informationen finden Sie unter [Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> wurde verworfen.  
  
- oder - 
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationAction" />-Argument ist null.  
  
- oder - 
Das <paramref name="scheduler" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Eine Aktion, die beim Abschluss von <see cref="T:System.Threading.Tasks.Task`1" /> ausgeführt werden soll. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsaktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Fortsetzungsaufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Der <see cref="T:System.Threading.Tasks.TaskScheduler" />, der der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die ausgeführt wird, wenn die Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task> wird nicht für die Ausführung geplant werden, bis der aktuelle Task abgeschlossen ist. Wenn die Kriterien, über angegeben die `continuationOptions` Parameter sind nicht erfüllt werden, das der Fortsetzungsaufgabe wird abgebrochen statt geplant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits freigegeben.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult)) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen wurde.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <summary>Erstellt eine Fortsetzung, die ausgeführt wird, wenn die Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Kette von Fortsetzungsaufgaben erstellt. Jede Aufgabe stellt die aktuelle Uhrzeit ein <xref:System.DateTime> -Objekt, um die Status-Argument, der die <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%2CSystem.Object%7D%2CSystem.Object%29> Methode. Jede <xref:System.DateTime> Wert darstellt, die Zeit, zu dem die Aufgabe weiter erstellt wird. Jede Aufgabe erzeugt als Ergebnis ein zweites <xref:System.DateTime> Wert, der die Zeit darstellt, an dem die Aufgabe abgeschlossen ist. Nachdem alle Aufgaben abgeschlossen haben, zeigt das Beispiel, das Datum und die Häufigkeit, mit denen jede Fortsetzungsaufgabe gestartet und abgeschlossen wurde.  
  
 [!code-csharp[TPL_ContinuationState#1](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_continuationstate/cs/continuationstate.cs#1)]
 [!code-vb[TPL_ContinuationState#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuationstate/vb/continuationstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Aufgabe zugewiesen wird.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen wurde.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> wurde verworfen.  
  
- oder - 
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult), continuationOptions As TaskContinuationOptions) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die entsprechend der in <paramref name="continuationOptions" /> angegebenen Bedingung ausgeführt wird.  
  
Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Erstellt eine Fortsetzung, die nach der in <paramref name="continuationOptions" /> angegebenen Bedingung ausgeführt wird.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 Die `continuationFunction`, bei der Ausführung sollte Zurückgeben einer <xref:System.Threading.Tasks.Task%601>. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult), scheduler As TaskScheduler) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist. Bei der Ausführung wird dem Delegaten die abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die asynchron ausgeführt wird, wenn der Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen wurde.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.  
  
- oder - 
Das <paramref name="scheduler" />-Argument ist null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Aufgabe zugewiesen wird.</param>
        <summary>Erstellt eine Fortsetzung, die ausgeführt wird, wenn die Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits freigegeben.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Erstellt eine Fortsetzung, die ausgeführt wird, wenn die Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 Die `continuationFunction`, bei der Ausführung sollte Zurückgeben einer <xref:System.Threading.Tasks.Task%601>. Abschlussstatus des Vorgangs wird für die Aufgabe, die vom ContinueWith-Aufruf zurückgegebene übertragen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object, scheduler As TaskScheduler) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die ausgeführt wird, wenn die Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument ist null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die entsprechend der in <paramref name="continuationOptions" /> angegebenen Bedingung ausgeführt wird.  
  
Bei der Ausführung wird dem Delegaten diese abgeschlossene Aufgabe als Argument übergeben.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Aufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die nach der in <paramref name="continuationOptions" /> angegebenen Bedingung ausgeführt wird.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 Die `continuationFunction`, bei der Ausführung sollte Zurückgeben einer <xref:System.Threading.Tasks.Task%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> wurde verworfen.  
  
- oder - 
Die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde bereits freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="continuationFunction" />-Argument ist null.  
  
- oder - 
Das <paramref name="scheduler" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Der Typ des von der Fortsetzung generierten Ergebnisses.</typeparam>
        <param name="continuationFunction">Eine Funktion, die ausgeführt werden soll, wenn das <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist. Bei der Ausführung werden dem Delegaten die abgeschlossene Aufgabe und das vom Aufrufer angegebene Zustandsobjekt als Argumente übergeben.</param>
        <param name="state">Ein Objekt, das Daten darstellt, die von der Fortsetzungsfunktion verwendet werden sollen.</param>
        <param name="cancellationToken">Das <see cref="T:System.Threading.CancellationToken" />, das der neuen Aufgabe zugewiesen wird.</param>
        <param name="continuationOptions">Optionen für die Planung und das Verhalten der Fortsetzung. Dazu zählen Kriterien wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> und Ausführungsoptionen wie <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Das <see cref="T:System.Threading.Tasks.TaskScheduler" />, das der Fortsetzungsaufgabe zugeordnet und für ihre Ausführung verwendet werden soll.</param>
        <summary>Erstellt eine Fortsetzung, die ausgeführt wird, wenn die Ziel-<see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen ist.</summary>
        <returns>Ein neuer Fortsetzungs-<see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene <xref:System.Threading.Tasks.Task%601> wird nicht zur Ausführung geplant werden erst nach Abschluss die aktuelle Aufgabe, ob der Vorgang aufgrund von erfolgreich ausgeführt, Fehler aufgrund eines Ausnahmefehlers oder beenden Sie frühzeitig aufgrund eines Abbruchs abgeschlossen ist.  
  
 Die `continuationFunction`, bei der Ausführung sollte Zurückgeben einer <xref:System.Threading.Tasks.Task%601>. Abschlussstatus des Vorgangs werden an die Rückgabe des Tasks durch Übertragen der <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> aufrufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="scheduler" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="continuationOptions" />-Argument gibt einen ungültigen Wert für <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> an.</exception>
        <exception cref="T:System.ObjectDisposedException">Das angegebene <see cref="T:System.Threading.CancellationToken" /> wurde bereits freigegeben.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</related>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory&lt;TResult&gt; Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory`1&lt;!TResult&gt; Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task`1.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory&lt;TResult&gt; ^ Factory { System::Threading::Tasks::TaskFactory&lt;TResult&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory&lt;'Result&gt;" Usage="System.Threading.Tasks.Task&lt;'Result&gt;.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bietet Zugriff auf Factorymethoden zum Erstellen und Konfigurieren von <see cref="T:System.Threading.Tasks.Task`1" />-Instanzen.</summary>
        <value>Ein Factoryobjekt, das eine Vielzahl von <see cref="T:System.Threading.Tasks.Task`1" />-Objekten erstellen kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt eine Standardinstanz von die <xref:System.Threading.Tasks.TaskFactory%601> Klasse, die identisch mit dem Kennwort erstellt, durch den Aufruf eines parameterlosen <xref:System.Threading.Tasks.TaskFactory%601.%23ctor?displayProperty=nameWithType> Konstruktor. Es hat die folgenden Eigenschaftenwerte fest:  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory%601.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.Scheduler%2A?displayProperty=nameWithType>|`null`, oder <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 Die häufigste Verwendung dieser Eigenschaft wird zum Erstellen und starten eine neue Aufgabe in einem einzigen Aufruf der <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> Methode.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> Methode bietet die einfachste Möglichkeit zum Erstellen einer <xref:System.Threading.Tasks.Task%601> Objekt mit den Standardwerten für die Konfiguration.  
  
 Im folgenden Beispiel wird die statische <xref:System.Threading.Tasks.Task%601.Factory%2A> Eigenschaft drei Aufrufe an die <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> Methode. Der erste beginnt eine `Task<Int32>` -Objekt, das einen Lambda-Ausdruck ausführt, die gibt 1 zurück. Die zweite beginnt eine `Task<Test>` -Objekt, das einen Lambda-Ausdruck ausgeführt wird, die eine neue instanziiert `Test` Instanz. Die dritte startet eine `Task<String[]>` -Objekt, das die Dateien im Verzeichnis C:\Users\Public\Pictures\Sample Beispiel zählt. (Beachten Sie, dass die erfolgreicher Ausführung des Beispiels setzt voraus, dass das Verzeichnis vorhanden sein, dass sie die Dateien enthält.  
  
 [!code-csharp[TPL#10](~/samples/snippets/csharp/VS_Snippets_Misc/tpl/cs/returnavalue10.cs#10)]
 [!code-vb[TPL#10](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl/vb/10_returnavalue.vb#10)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter&lt;TResult&gt; GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter`1&lt;!TResult&gt; GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter&lt;TResult&gt; GetAwaiter();" />
      <MemberSignature Language="F#" Value="override this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter&lt;'Result&gt;" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Awaiter ab, der verwendet wird, um dieses <see cref="T:System.Threading.Tasks.Task`1" /> zu erwarten.</summary>
        <returns>Eine Awaiter-Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für die Compiler-Benutzer und nicht für direkte Verwendung im Code vorgesehen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result">
      <MemberSignature Language="C#" Value="public TResult Result { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TResult Result" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task`1.Result" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Result As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TResult Result { TResult get(); };" />
      <MemberSignature Language="F#" Value="member this.Result : 'Result" Usage="System.Threading.Tasks.Task&lt;'Result&gt;.Result" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Ergebniswert dieses <see cref="T:System.Threading.Tasks.Task`1" /> ab.</summary>
        <value>Der Ergebniswert für diesen <see cref="T:System.Threading.Tasks.Task`1" />, vom gleichen Typ wie der Typparameter der Aufgabe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zugreifen auf die Get-Accessor der Eigenschaft blockiert den aufrufenden Thread, bis der asynchrone Vorgang abgeschlossen ist; Dies ist äquivalent zum Aufrufen der <xref:System.Threading.Tasks.Task.Wait%2A> Methode.  
  
 Sobald das Ergebnis eines Vorgangs verfügbar ist, wird gespeichert und bei nachfolgenden Aufrufen wird sofort zurückgegeben, die <xref:System.Threading.Tasks.Task%601.Result%2A> Eigenschaft. Beachten Sie, dass, wenn eine Ausnahme während der Ausführung der Aufgabe aufgetreten ist, oder wenn der Task abgebrochen wurde, die <xref:System.Threading.Tasks.Task%601.Result%2A> Eigenschaft gibt keinen Wert zurück. Stattdessen bei dem Versuch, die Zugriff auf die Eigenschaft löst Wert eine <xref:System.AggregateException> Ausnahme.  
  
   
  
## Examples  
 Das folgende Beispiel ist ein Befehlszeilen-Hilfsprogramm, das die Anzahl der Bytes in den Dateien in jedem Verzeichnis berechnet, deren Name als Befehlszeilenargument übergeben wird. Wenn das Verzeichnis Dateien enthält, führt er einen Lambda-Ausdruck, der instanziiert ein <xref:System.IO.FileStream> Objekt für jede Datei in das Verzeichnis und ruft den Wert des der <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> Eigenschaft. Wenn ein Verzeichnis keine Dateien enthält, ruft sie einfach die <xref:System.Threading.Tasks.Task.FromResult%2A> Methode, um eine Aufgabe zu erstellen, deren <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> -Eigenschaft ist 0 (null). Wenn die Aufgaben abgeschlossen haben, steht die Gesamtzahl der Bytes in allen ein Verzeichnis Dateien aus dem <xref:System.Threading.Tasks.Task%601.Result%2A> Eigenschaft.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AggregateException">Der Task wurde abgebrochen. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält ein <see cref="T:System.Threading.Tasks.TaskCanceledException" />-Objekt.  
  
- oder - 
Während der Ausführung des Tasks wurde eine Ausnahme ausgelöst. Die <see cref="P:System.AggregateException.InnerExceptions" />-Sammlung enthält Informationen zu der Ausnahme bzw. den Ausnahmen.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Aufgabenbasierte asynchrone Programmierung</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md">Gewusst wie: Zurückgeben eines Werts aus einer Aufgabe</related>
      </Docs>
    </Member>
  </Members>
</Type>