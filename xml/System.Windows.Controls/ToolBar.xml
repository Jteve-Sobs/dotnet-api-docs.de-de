<Type Name="ToolBar" FullName="System.Windows.Controls.ToolBar">
  <Metadata><Meta Name="ms.openlocfilehash" Value="67774564ff7c60cc34005a35f742f8781171bd53" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86822990" /></Metadata><TypeSignature Language="C#" Value="public class ToolBar : System.Windows.Controls.HeaderedItemsControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ToolBar extends System.Windows.Controls.HeaderedItemsControl" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.ToolBar" />
  <TypeSignature Language="VB.NET" Value="Public Class ToolBar&#xA;Inherits HeaderedItemsControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class ToolBar : System::Windows::Controls::HeaderedItemsControl" />
  <TypeSignature Language="F#" Value="type ToolBar = class&#xA;    inherit HeaderedItemsControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ToolBar extends System.Windows.Controls.HeaderedItemsControl" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.HeaderedItemsControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.TemplatePart(Name="PART_ToolBarOverflowPanel", Type=typeof(System.Windows.Controls.Primitives.ToolBarOverflowPanel))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.TemplatePart(Name="PART_ToolBarOverflowPanel", Type=typeof(System.Windows.Controls.Primitives.ToolBarOverflowPanel))&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.TemplatePart(Name="PART_ToolBarPanel", Type=typeof(System.Windows.Controls.Primitives.ToolBarPanel))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.TemplatePart(Name="PART_ToolBarPanel", Type=typeof(System.Windows.Controls.Primitives.ToolBarPanel))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Container für eine Gruppe von Befehlen oder Steuerelementen bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ToolBar> -Steuerelemente stellen einen Überlauf Mechanismus bereit, mit dem Elemente, die nicht in den passen, <xref:System.Windows.Controls.ToolBar> in einen Überlauf Bereich eingefügt werden. Nur Symbolleisten Elemente innerhalb eines <xref:System.Windows.Controls.ToolBarTray> übergeordneten Elements können vom Benutzer verschoben oder dessen Größe geändert werden.  
  
 <xref:System.Windows.Controls.ToolBar> ist eine <xref:System.Windows.Controls.HeaderedItemsControl> . Dies bedeutet, dass der Header und die Auflistung von-Objekten einen beliebigen Typ aufweisen können (z. b. Zeichenfolge, Bild oder Panel). Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Windows.Controls.HeaderedItemsControl>-Klasse.  
  
## <a name="customizing-the-toolbar-control"></a>Anpassen des Toolbar-Steuer Elements  
 Verwenden Sie die-Eigenschaft, um die gleichen Eigenschaften Einstellungen auf mehrere Steuer <xref:System.Windows.Controls.ToolBar> Elemente anzuwenden <xref:System.Windows.FrameworkElement.Style%2A> . Sie können die Standardeinstellung ändern <xref:System.Windows.Controls.ControlTemplate> , um dem Steuerelement eine eindeutige Darstellung zu verschaffen. Weitere Informationen zum Erstellen einer <xref:System.Windows.Controls.ControlTemplate> finden Sie unter [Anpassen der Darstellung eines vorhandenen Steuer Elements durch Erstellen einer ControlTemplate](/dotnet/framework/wpf/controls/customizing-the-appearance-of-an-existing-control).  Informationen zu den Teilen und Zuständen, die für spezifisch sind <xref:System.Windows.Controls.ToolBar> , finden Sie unter [Symbolleisten Stile und-Vorlagen](/dotnet/framework/wpf/controls/toolbar-styles-and-templates).  
  
 Abhängigkeits Eigenschaften für dieses Steuerelement können durch den Standardstil des Steuer Elements festgelegt werden.  Wenn eine Eigenschaft durch einen Standardstil festgelegt wird, kann sich die Eigenschaft von ihrem Standardwert ändern, wenn das Steuerelement in der Anwendung angezeigt wird. Der Standardstil wird bestimmt, welches Desktop Design verwendet wird, wenn die Anwendung ausgeführt wird.  Weitere Informationen finden Sie unter [standardmäßige WPF](https://go.microsoft.com/fwlink/?LinkID=158252)-Designs.  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein <xref:System.Windows.Controls.ToolBar> in einem erstellt wird <xref:System.Windows.Controls.ToolBarTray> .  
  
 [!code-xaml[ToolBarExample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBarExample/CS/Pane1.xaml#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
    <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
    <altmember cref="T:System.Windows.Controls.ToolBarTray" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160053">Beispiel für WPF-Steuerelementsammlungen</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ToolBar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ToolBar();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.ToolBar" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Band">
      <MemberSignature Language="C#" Value="public int Band { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Band" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.Band" />
      <MemberSignature Language="VB.NET" Value="Public Property Band As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Band { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Band : int with get, set" Usage="System.Windows.Controls.ToolBar.Band" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, an welcher Position im <see cref="T:System.Windows.Controls.ToolBarTray" /> sich die Symbolleiste befinden soll, oder legt diesen fest.</summary>
        <value>Das Band des <see cref="T:System.Windows.Controls.ToolBarTray" />, in dem die Symbolleiste positioniert ist. Die Standardeinstellung ist 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Position von <xref:System.Windows.Controls.ToolBar> in einer <xref:System.Windows.Controls.ToolBarTray> hängt von den Werten der <xref:System.Windows.Controls.ToolBarTray.Orientation%2A?displayProperty=nameWithType> <xref:System.Windows.Controls.ToolBar.Band%2A> Eigenschaften, und ab <xref:System.Windows.Controls.ToolBar.BandIndex%2A> . Wenn <xref:System.Windows.Controls.ToolBarTray.Orientation%2A> auf festgelegt ist <xref:System.Windows.Controls.Orientation.Horizontal> , stellt ein Band eine Zeile in dar <xref:System.Windows.Controls.ToolBarTray> . Wenn <xref:System.Windows.Controls.ToolBarTray.Orientation%2A> <xref:System.Windows.Controls.Orientation.Vertical> den Wert hat, stellt ein Band eine-Spalte dar <xref:System.Windows.Controls.ToolBarTray> . In der folgenden Tabelle wird die Beziehung zwischen <xref:System.Windows.Controls.ToolBarTray.Orientation%2A> , <xref:System.Windows.Controls.ToolBar.Band%2A> und beschrieben <xref:System.Windows.Controls.ToolBar.BandIndex%2A> .  
  
|Ausrichtung|Kreuz|BandIndex|  
|-----------------|----------|---------------|  
|Horizontal|Gibt die Zeile an, in der das <xref:System.Windows.Controls.ToolBar> positioniert ist. Symbolleisten, die <xref:System.Windows.Controls.ToolBar.Band%2A> auf einen kleineren Wert festgelegt wurden, sind oberhalb derjenigen mit einem größeren Wert.|Gibt die Position von <xref:System.Windows.Controls.ToolBar> auf dem an <xref:System.Windows.Controls.ToolBar.Band%2A> . Symbolleisten, die <xref:System.Windows.Controls.ToolBar.BandIndex%2A> auf einen kleineren Wert festgelegt wurden, befinden sich auf der linken Seite der Werte mit einem größeren Wert.|  
|Vertical|Gibt die Spalte an, in der die <xref:System.Windows.Controls.ToolBar> positioniert ist. Symbolleisten, die <xref:System.Windows.Controls.ToolBar.Band%2A> auf einen kleineren Wert festgelegt wurden, befinden sich auf der linken Seite der Werte mit einem größeren Wert.|Gibt die Position von <xref:System.Windows.Controls.ToolBar> auf dem an <xref:System.Windows.Controls.ToolBar.Band%2A> . Symbolleisten, die <xref:System.Windows.Controls.ToolBar.BandIndex%2A> auf einen kleineren Wert festgelegt wurden, sind oberhalb derjenigen mit einem größeren Wert.|  
  
<a name="dependencyPropertyInfo_Band"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ToolBar.BandProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie diese Eigenschaft verwendet wird, um Steuer <xref:System.Windows.Controls.ToolBar> Elemente in einem zu platzieren <xref:System.Windows.Controls.ToolBarTray> .  
  
 [!code-xaml[ToolBarExample#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBarExample/CS/Pane1.xaml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
        <altmember cref="T:System.Windows.Controls.ToolBarTray" />
      </Docs>
    </Member>
    <Member MemberName="BandIndex">
      <MemberSignature Language="C#" Value="public int BandIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BandIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.BandIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property BandIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BandIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BandIndex : int with get, set" Usage="System.Windows.Controls.ToolBar.BandIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Indexnummer des Bands ab, die die Position der Symbolleiste auf dem Band angibt, oder legt diese fest.</summary>
        <value>Die Position einer Symbolleiste auf dem Band eines <see cref="T:System.Windows.Controls.ToolBarTray" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Eigenschaft nicht explizit festlegen, wird der Wert durch die Reihenfolge bestimmt, in der die <xref:System.Windows.Controls.ToolBar> in der festgelegt ist <xref:System.Windows.Controls.ToolBarTray> . Wenn Sie z. b. zwei Symbolleisten in einem ablegen, <xref:System.Windows.Controls.ToolBarTray> ohne die-Eigenschaft und die-Eigenschaft festzulegen <xref:System.Windows.Controls.ToolBar.Band%2A> <xref:System.Windows.Controls.ToolBar.BandIndex%2A> , ist der Wert von <xref:System.Windows.Controls.ToolBar.Band%2A> für beide Symbolleisten gleich 0 (null). Der Wert von ist <xref:System.Windows.Controls.ToolBar.BandIndex%2A> 0 für die erste Symbolleiste und 1 für die zweite Symbolleiste.  
  
 Die Position von <xref:System.Windows.Controls.ToolBar> in einer <xref:System.Windows.Controls.ToolBarTray> hängt von den Werten der <xref:System.Windows.Controls.ToolBarTray.Orientation%2A?displayProperty=nameWithType> <xref:System.Windows.Controls.ToolBar.Band%2A> Eigenschaften, und ab <xref:System.Windows.Controls.ToolBar.BandIndex%2A> . Wenn <xref:System.Windows.Controls.ToolBarTray.Orientation%2A> auf festgelegt ist <xref:System.Windows.Controls.Orientation.Horizontal> , stellt ein Band eine Zeile in dar <xref:System.Windows.Controls.ToolBarTray> . Wenn <xref:System.Windows.Controls.ToolBarTray.Orientation%2A> <xref:System.Windows.Controls.Orientation.Vertical> den Wert hat, stellt ein Band eine-Spalte dar <xref:System.Windows.Controls.ToolBarTray> . In der folgenden Tabelle wird die Beziehung zwischen <xref:System.Windows.Controls.ToolBarTray.Orientation%2A> , <xref:System.Windows.Controls.ToolBar.Band%2A> und beschrieben <xref:System.Windows.Controls.ToolBar.BandIndex%2A> .  
  
|Ausrichtung|Kreuz|BandIndex|  
|-----------------|----------|---------------|  
|Horizontal|Gibt die Zeile an, in der das <xref:System.Windows.Controls.ToolBar> positioniert ist. Symbolleisten, die <xref:System.Windows.Controls.ToolBar.Band%2A> auf einen kleineren Wert festgelegt wurden, sind oberhalb derjenigen mit einem größeren Wert.|Gibt die Position von <xref:System.Windows.Controls.ToolBar> auf dem an <xref:System.Windows.Controls.ToolBar.Band%2A> . Symbolleisten, die <xref:System.Windows.Controls.ToolBar.BandIndex%2A> auf einen kleineren Wert festgelegt wurden, befinden sich auf der linken Seite der Werte mit einem größeren Wert.|  
|Vertical|Gibt die Spalte an, in der die <xref:System.Windows.Controls.ToolBar> positioniert ist. Symbolleisten, die <xref:System.Windows.Controls.ToolBar.Band%2A> auf einen kleineren Wert festgelegt wurden, befinden sich auf der linken Seite der Werte mit einem größeren Wert.|Gibt die Position von <xref:System.Windows.Controls.ToolBar> auf dem an <xref:System.Windows.Controls.ToolBar.Band%2A> . Symbolleisten, die <xref:System.Windows.Controls.ToolBar.BandIndex%2A> auf einen kleineren Wert festgelegt wurden, sind oberhalb derjenigen mit einem größeren Wert.|  
  
<a name="dependencyPropertyInfo_BandIndex"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ToolBar.BandIndexProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie diese Eigenschaft verwendet wird, um Steuer <xref:System.Windows.Controls.ToolBar> Elemente in einem zu platzieren <xref:System.Windows.Controls.ToolBarTray> .  
  
 [!code-xaml[ToolBarExample#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBarExample/CS/Pane1.xaml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
        <altmember cref="T:System.Windows.Controls.ToolBarTray" />
      </Docs>
    </Member>
    <Member MemberName="BandIndexProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BandIndexProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BandIndexProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ToolBar.BandIndexProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BandIndexProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BandIndexProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BandIndexProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ToolBar.BandIndexProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ToolBar.BandIndex" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ToolBar.BandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ToolBar.BandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ToolBar.Band" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ButtonStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey ButtonStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey ButtonStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.ButtonStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ButtonStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ ButtonStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ButtonStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.ButtonStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Style" /> ab, der auf Schaltflächen auf einer Symbolleiste angewendet ist.</summary>
        <value>Ein Ressourcenschlüssel, der den Standardstil für Schaltflächen auf der Symbolleiste darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um den Standardstil von Steuer <xref:System.Windows.Controls.Button> Elementen auf dem zu ändern <xref:System.Windows.Controls.ToolBar> .  
  
<a name="xamlAttributeUsage_ButtonStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <*Object* *Property*= " `{` **Toolbar. ButtonStyleKey**`}"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie diese Eigenschaft verwendet wird, um eine <xref:System.Windows.Style> auf Steuer <xref:System.Windows.Controls.Button> Elemente in einem anzuwenden <xref:System.Windows.Controls.ToolBar> .  
  
 [!code-xaml[ToolBar_snip#ToolBarButtonStyleKey](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBar_snip/CS/pane1.xaml#toolbarbuttonstylekey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckBoxStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey CheckBoxStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey CheckBoxStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.CheckBoxStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CheckBoxStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ CheckBoxStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CheckBoxStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.CheckBoxStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Style" /> ab, der auf die Kontrollkästchen auf einer <see cref="T:System.Windows.Controls.ToolBar" /> angewendet ist.</summary>
        <value>Ein Ressourcenschlüssel, der den Standardstil für Kontrollkästchen auf der <see cref="T:System.Windows.Controls.ToolBar" /> darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um den Standardstil von Steuer <xref:System.Windows.Controls.CheckBox> Elementen auf dem zu ändern <xref:System.Windows.Controls.ToolBar> .  
  
<a name="xamlAttributeUsage_CheckBoxStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <*Object* *Property*= " `{` **Toolbar. CheckBoxStyleKey**`}"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Eigenschaft verwendet, um eine <xref:System.Windows.Style> auf Steuer <xref:System.Windows.Controls.CheckBox> Elemente in einem anzuwenden <xref:System.Windows.Controls.ToolBar> .  
  
 [!code-xaml[ToolBar_snip#ToolBarCheckBoxStyleKey](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBar_snip/CS/pane1.xaml#toolbarcheckboxstylekey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ComboBoxStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey ComboBoxStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey ComboBoxStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.ComboBoxStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ComboBoxStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ ComboBoxStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ComboBoxStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.ComboBoxStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Style" /> ab, der auf die Kombinationsfelder auf einer <see cref="T:System.Windows.Controls.ToolBar" /> angewendet ist.</summary>
        <value>Ein Ressourcenschlüssel, der den Standardstil für Kombinationsfelder auf der Symbolleiste darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um den Standardstil von Steuer <xref:System.Windows.Controls.ComboBox> Elementen auf dem zu ändern <xref:System.Windows.Controls.ToolBar> .  
  
<a name="xamlAttributeUsage_ComboBoxStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <*Object* *Property*= " `{` **Toolbar. ComboBoxStyleKey**`}"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsOverflowItem">
      <MemberSignature Language="C#" Value="public static bool GetIsOverflowItem (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetIsOverflowItem(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.GetIsOverflowItem(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIsOverflowItem (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetIsOverflowItem(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetIsOverflowItem : System.Windows.DependencyObject -&gt; bool" Usage="System.Windows.Controls.ToolBar.GetIsOverflowItem element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, aus dem die Eigenschaft gelesen werden soll.</param>
        <summary>Liest den Wert der <see cref="P:System.Windows.Controls.ToolBar.IsOverflowItem" />-Eigenschaft aus dem angegebenen Element.</summary>
        <returns>Der Wert der Eigenschaft.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOverflowMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.OverflowMode GetOverflowMode (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Controls.OverflowMode GetOverflowMode(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.GetOverflowMode(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetOverflowMode (element As DependencyObject) As OverflowMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::OverflowMode GetOverflowMode(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetOverflowMode : System.Windows.DependencyObject -&gt; System.Windows.Controls.OverflowMode" Usage="System.Windows.Controls.ToolBar.GetOverflowMode element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.AttachedPropertyBrowsableForChildren(IncludeDescendants=true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.AttachedPropertyBrowsableForChildren(IncludeDescendants=true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.OverflowMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, aus dem die Eigenschaft gelesen werden soll.</param>
        <summary>Liest den Wert der <see cref="P:System.Windows.Controls.ToolBar.OverflowMode" />-Eigenschaft aus dem angegebenen Element.</summary>
        <returns>Der Wert der Eigenschaft.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mögliche Moduswerte finden Sie unter <xref:System.Windows.Controls.OverflowMode> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasOverflowItems">
      <MemberSignature Language="C#" Value="public bool HasOverflowItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasOverflowItems" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.HasOverflowItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasOverflowItems As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasOverflowItems { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasOverflowItems : bool" Usage="System.Windows.Controls.ToolBar.HasOverflowItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob auf der Symbolleiste nicht sichtbare Elemente vorhanden sind.</summary>
        <value><see langword="true" />, wenn nicht sichtbare Elemente auf der Symbolleiste vorhanden sind, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Windows.Controls.ToolBar> mehr Elemente enthält, als der anzuzeigende Platz aufweist, werden die restlichen Elemente in ihren Überlauf Bereich eingefügt. Der Benutzer kann auf den Pfeil auf dem Klicken <xref:System.Windows.Controls.ToolBar> , um auf die Überlauf Elemente zuzugreifen.  
  
<a name="dependencyPropertyInfo_HasOverflowItems"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ToolBar.HasOverflowItemsProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
        <altmember cref="T:System.Windows.Controls.ToolBarTray" />
      </Docs>
    </Member>
    <Member MemberName="HasOverflowItemsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HasOverflowItemsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HasOverflowItemsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ToolBar.HasOverflowItemsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HasOverflowItemsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HasOverflowItemsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HasOverflowItemsProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ToolBar.HasOverflowItemsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ToolBar.HasOverflowItems" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOverflowItem">
      <MemberSignature Language="C#" Value="see GetIsOverflowItem" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value="see GetIsOverflowItem" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.IsOverflowItem" />
      <MemberSignature Language="VB.NET" Value="see GetIsOverflowItem" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="see GetIsOverflowItem" Usage="see GetIsOverflowItem" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C#" Value="see GetIsOverflowItem, and SetIsOverflowItem" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value="see GetIsOverflowItem, and SetIsOverflowItem" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="see GetIsOverflowItem, and SetIsOverflowItem" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="see GetIsOverflowItem, and SetIsOverflowItem" Usage="see GetIsOverflowItem, and SetIsOverflowItem" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Windows.Controls.ToolBar" />-Element ein Überlaufelement ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist eine schreibgeschützte angefügte Eigenschaft. Schreibgeschützte angefügte Eigenschaften sind nicht üblich, und Sie haben keine direkte [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Verwendung. Sie können jedoch den Verweis auf die angefügte Eigenschaft als Eigenschafts-Triggern in einem Stil verwenden, um unterschiedliche Stilwerte auf ein Element innerhalb einer Symbolleiste im Überlauf Bereich anzuwenden.  
  
<a name="dependencyPropertyInfo_IsOverflowItem"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ToolBar.IsOverflowItemProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
<a name="xamlTextUsage_IsOverflowItem"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Siehe Hinweise.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
        <altmember cref="T:System.Windows.Controls.ToolBarTray" />
      </Docs>
    </Member>
    <Member MemberName="IsOverflowItemProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsOverflowItemProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsOverflowItemProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ToolBar.IsOverflowItemProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsOverflowItemProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsOverflowItemProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsOverflowItemProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ToolBar.IsOverflowItemProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Controls.ToolBar.IsOverflowItem" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOverflowOpen">
      <MemberSignature Language="C#" Value="public bool IsOverflowOpen { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOverflowOpen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.IsOverflowOpen" />
      <MemberSignature Language="VB.NET" Value="Public Property IsOverflowOpen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOverflowOpen { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsOverflowOpen : bool with get, set" Usage="System.Windows.Controls.ToolBar.IsOverflowOpen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Bindable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Bindable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Category("Appearance")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Category("Appearance")&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Windows.Controls.ToolBar" />-Überlaufbereich derzeit sichtbar ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der Überlaufbereich sichtbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsOverflowOpen"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ToolBar.IsOverflowOpenProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
        <altmember cref="T:System.Windows.Controls.ToolBarTray" />
      </Docs>
    </Member>
    <Member MemberName="IsOverflowOpenProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsOverflowOpenProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsOverflowOpenProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ToolBar.IsOverflowOpenProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsOverflowOpenProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsOverflowOpenProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsOverflowOpenProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ToolBar.IsOverflowOpenProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ToolBar.IsOverflowOpen" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="toolBar.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Die Einschränkungen der Maße. Eine <see cref="T:System.Windows.Controls.ToolBar" /> kann keine Größe zurückgeben, die diese Einschränkungen überschreitet.</param>
        <summary>Misst eine <see cref="T:System.Windows.Controls.ToolBar" /> neu ein.</summary>
        <returns>Die Größe des <see cref="T:System.Windows.Controls.ToolBar" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MenuStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey MenuStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey MenuStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.MenuStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MenuStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ MenuStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MenuStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.MenuStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Style" /> ab, der auf Menüs auf einer <see cref="T:System.Windows.Controls.ToolBar" /> angewendet ist.</summary>
        <value>Ein Ressourcenschlüssel, der den Standardstil für Menüs auf der Symbolleiste darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um den Standardstil von Steuer <xref:System.Windows.Controls.Menu> Elementen auf dem zu ändern <xref:System.Windows.Controls.ToolBar> .  
  
<a name="xamlAttributeUsage_MenuStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <*Object* *Property*= " `{` **Toolbar. menustylekey**`}"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Eigenschaft verwendet, um eine <xref:System.Windows.Style> auf Steuer <xref:System.Windows.Controls.Menu> Elemente in einem anzuwenden <xref:System.Windows.Controls.ToolBar> .  
  
 [!code-xaml[ToolBar_snip#ToolBarMenuStyleKey](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBar_snip/CS/pane1.xaml#toolbarmenustylekey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="toolBar.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt eine geeignete <see cref="T:System.Windows.Automation.Peers.ToolBarAutomationPeer" />-Implementierung für dieses Steuerelement als Teil der [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Infrastruktur bereit.</summary>
        <returns>Die typspezifische <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />-Implementierung.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsChanged">
      <MemberSignature Language="C#" Value="protected override void OnItemsChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnItemsChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.OnItemsChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnItemsChanged (e As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnItemsChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnItemsChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="toolBar.OnItemsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Argumente für das <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged" />-Ereignis.</param>
        <summary>Wird aufgerufen, wenn sich die <see cref="P:System.Windows.Controls.ItemsControl.Items" />-Eigenschaft ändert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="toolBar.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Argumente für das <see cref="E:System.Windows.UIElement.KeyDown" />-Ereignis.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.KeyDown" />-Routingereignis bereit, das eintritt, wenn eine Taste für ein Element auf der <see cref="T:System.Windows.Controls.ToolBar" /> gedrückt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Benutzer auf die Startseite drückt, erhält das erste Element im <xref:System.Windows.Controls.ToolBar> Tastaturfokus. Wenn der Benutzer auf "Ende" drückt, erhält das letzte Element in den <xref:System.Windows.Controls.ToolBar> Tastaturfokus. Wenn dies auftritt, markiert diese Implementierung das <xref:System.Windows.UIElement.KeyDown> Ereignis als behandelt, indem die- <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft der Ereignisdaten auf festgelegt wird `true` .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie überschreiben <see cref="M:System.Windows.Controls.ToolBar.OnKeyDown(System.Windows.Input.KeyEventArgs)" /> , müssen Sie immer die Basis Implementierung in der Implementierung von aufzurufen <see cref="M:System.Windows.Controls.ToolBar.OnKeyDown(System.Windows.Input.KeyEventArgs)" /> . Wenn Sie die Basis Implementierung nicht aufzurufen, wird verhindert, dass Basisklassen das Ereignis mit einem Klassen Handler behandeln, der das Laufzeitverhalten der endgültigen Klasse möglicherweise ändert. Abhängig von Ihren Anforderungen können Sie die Basis Implementierung entweder vor oder nach ihrer speziellen Behandlung abrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected override void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="toolBar.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Argumente für das <see cref="E:System.Windows.UIElement.LostMouseCapture" />-Ereignis.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.LostMouseCapture" />-Routingereignis bereit, das eintritt, wenn die <see cref="T:System.Windows.Controls.ToolBar" /> keine Mauseingaben mehr erfasst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ändert nicht den behandelten Zustand (die- <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft) der <xref:System.Windows.UIElement.LostMouseCapture> Ereignisdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie überschreiben <see cref="M:System.Windows.Controls.ToolBar.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" /> , müssen Sie immer die Basis Implementierung in der Implementierung von aufzurufen <see cref="M:System.Windows.Controls.ToolBar.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" /> . Wenn Sie die Basis Implementierung nicht aufzurufen, wird verhindert, dass Basisklassen das Ereignis mit einem Klassen Handler behandeln, der das Laufzeitverhalten der endgültigen Klasse möglicherweise ändert. Abhängig von Ihren Anforderungen können Sie die Basis Implementierung entweder vor oder nach ihrer speziellen Behandlung abrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Orientation">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Orientation Orientation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.Orientation Orientation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.Orientation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Orientation As Orientation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Orientation Orientation { System::Windows::Controls::Orientation get(); };" />
      <MemberSignature Language="F#" Value="member this.Orientation : System.Windows.Controls.Orientation" Usage="System.Windows.Controls.ToolBar.Orientation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Orientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Ausrichtung des <see cref="T:System.Windows.Controls.ToolBar" />-Objekts ab.</summary>
        <value>Die Ausrichtung der Symbolleiste. Der Standardwert ist <see cref="F:System.Windows.Controls.Orientation.Horizontal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft ihren Wert aus dem übergeordneten Element ab <xref:System.Windows.Controls.ToolBarTray> .  
  
<a name="dependencyPropertyInfo_Orientation"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ToolBar.OrientationProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie bestimmen können, ob ein <xref:System.Windows.Controls.ToolBar> vertikal ist.  
  
 [!code-csharp[ToolBarOrient_snip#ToolBarOrientation](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBarOrient_snip/CSharp/Pane1.xaml.cs#toolbarorientation)]
 [!code-vb[ToolBarOrient_snip#ToolBarOrientation](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ToolBarOrient_snip/visualbasic/pane1.xaml.vb#toolbarorientation)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
        <altmember cref="T:System.Windows.Controls.ToolBarTray" />
      </Docs>
    </Member>
    <Member MemberName="OrientationProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OrientationProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OrientationProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ToolBar.OrientationProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OrientationProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OrientationProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OrientationProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ToolBar.OrientationProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="T:System.Windows.Controls.Orientation" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OverflowMode">
      <MemberSignature Language="C#" Value="see GetOverflowMode, and SetOverflowMode" />
      <MemberSignature Language="ILAsm" Value="see GetOverflowMode, and SetOverflowMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.OverflowMode" />
      <MemberSignature Language="VB.NET" Value="see GetOverflowMode, and SetOverflowMode" />
      <MemberSignature Language="F#" Value="see GetOverflowMode, and SetOverflowMode" Usage="see GetOverflowMode, and SetOverflowMode" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, in welchem Fall ein Element im Überlaufbereich und nicht im Hauptbereich platziert werden soll, oder legt diesen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_OverflowMode"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ToolBar.OverflowModeProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
        <altmember cref="T:System.Windows.Controls.ToolBarTray" />
      </Docs>
    </Member>
    <Member MemberName="OverflowModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverflowModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverflowModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ToolBar.OverflowModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverflowModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverflowModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverflowModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ToolBar.OverflowModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Controls.ToolBar.OverflowMode" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected override void PrepareContainerForItemOverride (System.Windows.DependencyObject element, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void PrepareContainerForItemOverride(class System.Windows.DependencyObject element, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub PrepareContainerForItemOverride (element As DependencyObject, item As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void PrepareContainerForItemOverride(System::Windows::DependencyObject ^ element, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="override this.PrepareContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit" Usage="toolBar.PrepareContainerForItemOverride (element, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, von dem das Element angezeigt wird.</param>
        <param name="item">Das anzuzeigende Element.</param>
        <summary>Bereitet das angegebene Element auf die Anzeige des angegebenen Eintrags vor.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RadioButtonStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey RadioButtonStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey RadioButtonStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.RadioButtonStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RadioButtonStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ RadioButtonStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RadioButtonStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.RadioButtonStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Style" /> ab, der auf Optionsfelder auf einer Symbolleiste angewendet ist.</summary>
        <value>Ein Ressourcenschlüssel, der den Standardstil für Optionsfelder auf der Symbolleiste darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um den Standardstil von Steuer <xref:System.Windows.Controls.RadioButton> Elementen auf dem zu ändern <xref:System.Windows.Controls.ToolBar> .  
  
<a name="xamlAttributeUsage_RadioButtonStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <*Object* *Property*= " `{` **Toolbar. RadioButtonStyleKey**`}"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Eigenschaft verwendet, um eine <xref:System.Windows.Style> auf Steuer <xref:System.Windows.Controls.RadioButton> Elemente in einem anzuwenden <xref:System.Windows.Controls.ToolBar> .  
  
 [!code-xaml[ToolBar_snip#ToolBarRadioButtonStyleKey](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBar_snip/CS/pane1.xaml#toolbarradiobuttonstylekey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeparatorStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey SeparatorStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey SeparatorStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.SeparatorStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SeparatorStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ SeparatorStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SeparatorStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.SeparatorStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Style" /> ab, der auf Trennzeichen auf einer <see cref="T:System.Windows.Controls.ToolBar" /> angewendet ist.</summary>
        <value>Ein Ressourcenschlüssel, der den Standardstil für Trennzeichen auf der Symbolleiste darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um den Standardstil von Steuer <xref:System.Windows.Controls.Separator> Elementen auf dem zu ändern <xref:System.Windows.Controls.ToolBar> .  
  
<a name="xamlAttributeUsage_SeparatorStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <*Object* *Property*= " `{` **Toolbar. SeparatorStyleKey**`}"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Eigenschaft verwendet, um eine <xref:System.Windows.Style> auf Steuer <xref:System.Windows.Controls.Separator> Elemente in einem anzuwenden <xref:System.Windows.Controls.ToolBar> .  
  
 [!code-xaml[ToolBar_snip#ToolBarSeparatorStyleKey](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBar_snip/CS/pane1.xaml#toolbarseparatorstylekey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetOverflowMode">
      <MemberSignature Language="C#" Value="public static void SetOverflowMode (System.Windows.DependencyObject element, System.Windows.Controls.OverflowMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetOverflowMode(class System.Windows.DependencyObject element, valuetype System.Windows.Controls.OverflowMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.SetOverflowMode(System.Windows.DependencyObject,System.Windows.Controls.OverflowMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetOverflowMode (element As DependencyObject, mode As OverflowMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetOverflowMode(System::Windows::DependencyObject ^ element, System::Windows::Controls::OverflowMode mode);" />
      <MemberSignature Language="F#" Value="static member SetOverflowMode : System.Windows.DependencyObject * System.Windows.Controls.OverflowMode -&gt; unit" Usage="System.Windows.Controls.ToolBar.SetOverflowMode (element, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="mode" Type="System.Windows.Controls.OverflowMode" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, in das die Eigenschaft geschrieben werden soll.</param>
        <param name="mode">Der festzulegende Eigenschaftswert.</param>
        <summary>Schreibt den Wert der <see cref="P:System.Windows.Controls.ToolBar.OverflowMode" />-Eigenschaft in das angegebene Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mögliche Moduswerte finden Sie unter <xref:System.Windows.Controls.OverflowMode> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextBoxStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey TextBoxStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey TextBoxStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.TextBoxStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TextBoxStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ TextBoxStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TextBoxStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.TextBoxStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Style" /> ab, der auf die Textfelder auf einer <see cref="T:System.Windows.Controls.ToolBar" /> angewendet ist.</summary>
        <value>Ein Ressourcenschlüssel, der den Standardstil für Textfelder auf der Symbolleiste darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um den Standardstil von Steuer <xref:System.Windows.Controls.TextBox> Elementen auf dem zu ändern <xref:System.Windows.Controls.ToolBar> .  
  
<a name="xamlAttributeUsage_TextBoxStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <*Object* *Property*= " `{` **Toolbar. TextBoxStyleKey**`}"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Eigenschaft verwendet, um einen für-Steuer <xref:System.Windows.Style> <xref:System.Windows.Controls.TextBox> Elemente in einem zu erstellen <xref:System.Windows.Controls.ToolBar> .  
  
 [!code-xaml[ToolBar_snip#ToolBarTextBoxStyleKey](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBar_snip/CS/pane1.xaml#toolbartextboxstylekey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleButtonStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey ToggleButtonStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey ToggleButtonStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.ToggleButtonStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleButtonStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ ToggleButtonStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleButtonStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.ToggleButtonStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Style" /> ab, der auf <see cref="T:System.Windows.Controls.Primitives.ToggleButton" />-Steuerelemente auf einer <see cref="T:System.Windows.Controls.ToolBar" /> angewendet wird.</summary>
        <value>Ein Ressourcenschlüssel, der den Standardstil für Umschaltflächen auf der Symbolleiste darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um den Standardstil von Steuer <xref:System.Windows.Controls.Primitives.ToggleButton> Elementen auf dem zu ändern <xref:System.Windows.Controls.ToolBar> .  
  
<a name="xamlAttributeUsage_ToggleButtonStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <*Object* *Property*= " `{` **Toolbar. ToggleButtonStyleKey**`}"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
