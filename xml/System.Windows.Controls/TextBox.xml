<Type Name="TextBox" FullName="System.Windows.Controls.TextBox">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c617a652571ffdb92d8b329eedeb9e5a0132a55a" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69212464" /></Metadata><TypeSignature Language="C#" Value="public class TextBox : System.Windows.Controls.Primitives.TextBoxBase, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi TextBox extends System.Windows.Controls.Primitives.TextBoxBase implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.TextBox" />
  <TypeSignature Language="VB.NET" Value="Public Class TextBox&#xA;Inherits TextBoxBase&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextBox : System::Windows::Controls::Primitives::TextBoxBase, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type TextBox = class&#xA;    inherit TextBoxBase&#xA;    interface IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Primitives.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Text)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Text")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Steuerelement dar, das zum Anzeigen oder Bearbeiten von nicht formatiertem Text verwendet werden kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Controls.TextBox> Steuerelement kann nur unformatierten Text in <xref:System.Windows.Controls.TextBox.Text%2A> der-Eigenschaft enthalten. Die folgende Abbildung zeigt ein Beispiel für ein <xref:System.Windows.Controls.TextBox>.  
  
 ![TextBox-Bildschirmfoto] (~/add/media/ss-ctl-textbox.gif "TextBox-Bildschirmfoto")  
Beispiel für ein Textfeld  
  
 <xref:System.Windows.Controls.TextBox>ist ein zusammengesetztes Steuerelement, das aus mehreren gekapselten Komponenten besteht. Folglich werden einige Ereignisse nicht in das enthaltende Steuerelement hochskalieren, da Sie von gekapselten untergeordneten Elementen behandelt werden. Aus diesem Grund sollten Anwendungsentwickler auf die tunnelingversion eines Ereignisses (gekennzeichnet durch das Präfix "Preview") lauschen.  
  
 <xref:System.Windows.Controls.TextBox>unterstützt nur unformatierten Text. Anwendungen, die Unterstützung für umfangreichere Inhalte benötigen <xref:System.Windows.Controls.RichTextBox>, finden Sie unter. Anwendungen, die Kenn Wörter oder andere sensible Eingaben akzeptieren müssen, finden <xref:System.Windows.Controls.PasswordBox>Sie unter.  
  
 Die horizontale und vertikale Ausrichtung von Text <xref:System.Windows.Controls.TextBox> in einem erfolgt mit <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A> der <xref:System.Windows.Controls.Control.VerticalContentAlignment%2A> -Eigenschaft und der-Eigenschaft. Die Ausrichtung <xref:System.Windows.Controls.TextBox> des innerhalb des Layouts der Seite erfolgt mit den <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> Eigenschaften und <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> .  
  
 Am besten lässt sich der Rahmen um <xref:System.Windows.Controls.TextBox> einen ausblenden, indem die <xref:System.Windows.Controls.Control.BorderThickness%2A> -Eigenschaft von <xref:System.Windows.Controls.TextBox> auf `0`festgelegt wird.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Controls.TextBox>verfügt über eine integrierte Behandlung der Blasen <xref:System.Windows.UIElement.MouseUp> -und- <xref:System.Windows.UIElement.MouseDown> Ereignisse. Folglich werden benutzerdefinierte Ereignishandler, die auf <xref:System.Windows.UIElement.MouseUp> - <xref:System.Windows.UIElement.MouseDown> oder-Ereignisse <xref:System.Windows.Controls.TextBox> von einem lauschen, nicht aufgerufen. Wenn Sie auf diese Ereignisse reagieren müssen, lauschen Sie stattdessen auf Tunnelung <xref:System.Windows.UIElement.PreviewMouseUp> und <xref:System.Windows.UIElement.PreviewMouseDown> Ereignisse, oder registrieren Sie die Handler mit dem <xref:System.Windows.EventSetter.HandledEventsToo%2A> -Argument (diese zweite Option ist nur über Code verfügbar). Markieren Sie das Ereignis nicht als behandelt, es sei denn, <xref:System.Windows.Controls.TextBox> Sie möchten die native Behandlung dieser Ereignisse absichtlich deaktivieren, und beachten Sie, dass dies relevante Auswirkungen [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]auf die des Steuer Elements hat.  
  
 Scrollleisten werden in <xref:System.Windows.Controls.TextBox> standardmäßig nicht angezeigt. Legen Sie die-Eigenschaft und <xref:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility%2A> die- <xref:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility%2A> Eigenschaft auf <xref:System.Windows.Controls.ScrollBarVisibility.Visible> oder <xref:System.Windows.Controls.ScrollBarVisibility.Auto>fest, damit Scrollleisten sichtbar sind.  
  
 In der <xref:System.Windows.Controls.Primitives.TextBoxBase.TextChanged> Regel sollte das-Ereignis verwendet werden, um zu erkennen <xref:System.Windows.Controls.TextBox> , wann immer der <xref:System.Windows.UIElement.KeyDown> Text in einer-oder <xref:System.Windows.Controls.RichTextBox> -Datei geändert wird. Weitere Informationen finden Sie unter [How to: Erkennen, wenn Text in einem Textfeld für](~/docs/framework/wpf/controls/how-to-detect-when-text-in-a-textbox-has-changed.md) ein Beispiel geändert wurde.  
  
## <a name="customizing-the-textbox-control"></a>Anpassen des TextBox-Steuer Elements  
 Verwenden Sie die <xref:System.Windows.FrameworkElement.Style%2A> -Eigenschaft, um die <xref:System.Windows.Controls.TextBox> gleichen Eigenschaften Einstellungen auf mehrere Steuerelemente anzuwenden. Sie können die Standardeinstellung <xref:System.Windows.Controls.ControlTemplate> ändern, um dem Steuerelement eine eindeutige Darstellung zu verschaffen. Weitere Informationen zum Erstellen einer <xref:System.Windows.Controls.ControlTemplate>finden Sie unter [Anpassen der Darstellung eines vorhandenen Steuer Elements durch Erstellen einer ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Informationen zu den Teilen und Zuständen, die für <xref:System.Windows.Controls.TextBox>spezifisch sind, finden Sie unter [TextBox-Stile und-Vorlagen](~/docs/framework/wpf/controls/textbox-styles-and-templates.md).  
  
 Abhängigkeits Eigenschaften für dieses Steuerelement können durch den Standardstil des Steuer Elements festgelegt werden.  Wenn eine Eigenschaft durch einen Standardstil festgelegt wird, kann sich die Eigenschaft von ihrem Standardwert ändern, wenn das Steuerelement in der Anwendung angezeigt wird. Der Standardstil wird bestimmt, welches Desktop Design verwendet wird, wenn die Anwendung ausgeführt wird.  Weitere Informationen finden Sie unter [standardmäßige WPF](https://go.microsoft.com/fwlink/?LinkID=158252)-Designs.  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 In diesem Beispiel wird gezeigt, wie die Text-Eigenschaft verwendet wird, um den ursprünglichen Text Inhalt eines TextBox-Steuer Elements festzulegen.  
  
> [!NOTE]
>  Obwohl die Extensible Application Markup Language (XAML)-Version des Beispiels die \<TextBox. Text-> Tags um den Text der TextBox-Inhalte jeder Schaltfläche verwenden könnte, ist dies nicht notwendig, da das Textfeld das ContentPropertyAttribute-Attribut anwendet. -Attribut zur Text-Eigenschaft.  
  
```xaml  
<TextBox Name="tbSettingText">  
  Initial text contents of the TextBox.  
</TextBox>  
```  
  
```csharp  
tbSettingText.Text = "Initial text contents of the TextBox.";  
```  
  
```vb  
tbSettingText.Text = "Initial text contents of the TextBox."  
```  
  
 Weitere Beispiele finden Sie in der Version 4,0 dieses Dokuments: [TextBox-Klasse](https://msdn.microsoft.com/library/ms617604\(v=vs.100\).aspx).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.PasswordBox" />
    <altmember cref="T:System.Windows.Controls.RichTextBox" />
    <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/aa969815(v=vs.100).aspx">Übersicht über TextBox</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160053">Beispiel für WPF-Steuerelemente Gallery</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.TextBox" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CaretIndex">
      <MemberSignature Language="C#" Value="public int CaretIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CaretIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.CaretIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property CaretIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CaretIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CaretIndex : int with get, set" Usage="System.Windows.Controls.TextBox.CaretIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Index der Einfügeposition für das Caretzeichen ab oder legt diesen fest.</summary>
        <value>Der nullbasierte Index für die Einfügeposition des Caretzeichens.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim erhalten dieser Eigenschaft wird der aktuelle einfügepositions-Index der Einfügemarke zurückgegeben (Weitere Informationen zur Terminologie wie "Einfügeposition" finden <xref:System.Windows.Documents.TextPointer> Sie unter Durch Festlegen dieser Eigenschaft wird die Einfügemarke an die angegebene Einfügeposition verschoben.  
  
 Eine Einfügeposition liegt zwischen Zeichen oder Element Tags.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Documents.TextPointer" />
      </Docs>
    </Member>
    <Member MemberName="CharacterCasing">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.CharacterCasing CharacterCasing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.CharacterCasing CharacterCasing" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.CharacterCasing" />
      <MemberSignature Language="VB.NET" Value="Public Property CharacterCasing As CharacterCasing" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::CharacterCasing CharacterCasing { System::Windows::Controls::CharacterCasing get(); void set(System::Windows::Controls::CharacterCasing value); };" />
      <MemberSignature Language="F#" Value="member this.CharacterCasing : System.Windows.Controls.CharacterCasing with get, set" Usage="System.Windows.Controls.TextBox.CharacterCasing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.CharacterCasing</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Groß- oder Kleinschreibung von Zeichen ab, die manuell in das Textfeld eingegeben werden, oder legt diese fest.</summary>
        <value>Einer der <see cref="T:System.Windows.Controls.CharacterCasing" />-Werte, der die Groß- oder Kleinschreibung manuell eingegebener Zeichen angibt. Die Standardeinstellung ist <see cref="F:System.Windows.Controls.CharacterCasing.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wirkt sich nicht auf Zeichen aus, die Programm gesteuert hinzugefügt werden.  
  
<a name="dependencyPropertyInfo_CharacterCasing"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.TextBox.CharacterCasingProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Controls.TextBox.CharacterCasing%2A> -Eigenschaft verwendet wird, um alle manuell eingegebenen Zeichen in Großbuchstaben in einem Textfeld zu konvertieren.  
  
 [!code-xaml[TextBoxMiscSnippets_snip#CharacterCasingExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_snip/csharp/charactercasingexample.xaml#charactercasingexamplewholepage)]  
  
 [!code-csharp[TextBoxMiscSnippets_procedural_snip#CharacterCasingCodeExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/CSharp/CharacterCasingExample.cs#charactercasingcodeexamplewholepage)]
 [!code-vb[TextBoxMiscSnippets_procedural_snip#CharacterCasingCodeExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/visualbasic/charactercasingexample.vb#charactercasingcodeexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CharacterCasingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CharacterCasingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CharacterCasingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBox.CharacterCasingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CharacterCasingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CharacterCasingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CharacterCasingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBox.CharacterCasingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.TextBox.CharacterCasing" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="textBox.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht den gesamten Inhalt aus dem Textfeld.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.TextBox.Text" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterIndexFromLineIndex">
      <MemberSignature Language="C#" Value="public int GetCharacterIndexFromLineIndex (int lineIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetCharacterIndexFromLineIndex(int32 lineIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.GetCharacterIndexFromLineIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterIndexFromLineIndex (lineIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetCharacterIndexFromLineIndex(int lineIndex);" />
      <MemberSignature Language="F#" Value="member this.GetCharacterIndexFromLineIndex : int -&gt; int" Usage="textBox.GetCharacterIndexFromLineIndex lineIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lineIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="lineIndex">Der nullbasierte Index der Zeile, aus der der Anfangszeichenindex abgerufen werden soll.</param>
        <summary>Gibt den nullbasierten Zeichenindex für das erste Zeichen in der angegebenen Zeile zurück.</summary>
        <returns>Der nullbasierte Zeichenindex für das erste Zeichen in der angegebenen Zeile.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.TextBox.LineCount" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetCharacterIndexFromPoint(System.Windows.Point,System.Boolean)" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetLineIndexFromCharacterIndex(System.Int32)" />
        <altmember cref="Overload:System.Windows.Controls.TextBox.GetRectFromCharacterIndex" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetFirstVisibleLineIndex" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetLastVisibleLineIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterIndexFromPoint">
      <MemberSignature Language="C#" Value="public int GetCharacterIndexFromPoint (System.Windows.Point point, bool snapToText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetCharacterIndexFromPoint(valuetype System.Windows.Point point, bool snapToText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.GetCharacterIndexFromPoint(System.Windows.Point,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetCharacterIndexFromPoint(System::Windows::Point point, bool snapToText);" />
      <MemberSignature Language="F#" Value="member this.GetCharacterIndexFromPoint : System.Windows.Point * bool -&gt; int" Usage="textBox.GetCharacterIndexFromPoint (point, snapToText)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="snapToText" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point">Ein Punkt im Koordinatenbereich des <see cref="T:System.Windows.Controls.TextBox" />-Objekts, für das ein Index zurückgegeben werden soll.</param>
        <param name="snapToText"><see langword="true" />, um den nächstliegenden Index zurückzugeben, wenn am angegebenen Punkt kein Zeichen vorhanden ist, <see langword="false" />, um –1 zurückzugeben, wenn am angegebenen Punkt kein Zeichen vorhanden ist.</param>
        <summary>Gibt den nullbasierten Index des Zeichens zurück, das dem angegebenen Punkt am nächsten ist.</summary>
        <returns>Der Index des Zeichens, das dem angegebenen Punkt am nächsten ist, oder –1, wenn kein gültiger Index gefunden wird.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Controls.TextBox.GetCharacterIndexFromLineIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetLineIndexFromCharacterIndex(System.Int32)" />
        <altmember cref="Overload:System.Windows.Controls.TextBox.GetRectFromCharacterIndex" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetFirstVisibleLineIndex" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetLastVisibleLineIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetFirstVisibleLineIndex">
      <MemberSignature Language="C#" Value="public int GetFirstVisibleLineIndex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetFirstVisibleLineIndex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.GetFirstVisibleLineIndex" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirstVisibleLineIndex () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetFirstVisibleLineIndex();" />
      <MemberSignature Language="F#" Value="member this.GetFirstVisibleLineIndex : unit -&gt; int" Usage="textBox.GetFirstVisibleLineIndex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Zeilenindex der ersten Zeile zurück, die derzeit im Textfeld angezeigt wird.</summary>
        <returns>Der nullbasierte Index der ersten sichtbaren Zeile im Textfeld.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Controls.TextBox.GetCharacterIndexFromPoint(System.Windows.Point,System.Boolean)" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetCharacterIndexFromLineIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetLineIndexFromCharacterIndex(System.Int32)" />
        <altmember cref="Overload:System.Windows.Controls.TextBox.GetRectFromCharacterIndex" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetLastVisibleLineIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetLastVisibleLineIndex">
      <MemberSignature Language="C#" Value="public int GetLastVisibleLineIndex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLastVisibleLineIndex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.GetLastVisibleLineIndex" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastVisibleLineIndex () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLastVisibleLineIndex();" />
      <MemberSignature Language="F#" Value="member this.GetLastVisibleLineIndex : unit -&gt; int" Usage="textBox.GetLastVisibleLineIndex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Zeilenindex der letzten Zeile zurück, die derzeit im Textfeld angezeigt wird.</summary>
        <returns>Der nullbasierte Index der letzten sichtbaren Zeile im Textfeld.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Controls.TextBox.GetCharacterIndexFromPoint(System.Windows.Point,System.Boolean)" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetLineIndexFromCharacterIndex(System.Int32)" />
        <altmember cref="Overload:System.Windows.Controls.TextBox.GetRectFromCharacterIndex" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetCharacterIndexFromLineIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetFirstVisibleLineIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetLineIndexFromCharacterIndex">
      <MemberSignature Language="C#" Value="public int GetLineIndexFromCharacterIndex (int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLineIndexFromCharacterIndex(int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.GetLineIndexFromCharacterIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineIndexFromCharacterIndex (charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLineIndexFromCharacterIndex(int charIndex);" />
      <MemberSignature Language="F#" Value="member this.GetLineIndexFromCharacterIndex : int -&gt; int" Usage="textBox.GetLineIndexFromCharacterIndex charIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charIndex">Der nullbasierte Zeichenindex, für den der zugeordnete Zeilenindex abgerufen werden soll.</param>
        <summary>Gibt den nullbasierten Zeilenindex für die Zeile zurück, die den angegebenen Zeichenindex enthält.</summary>
        <returns>Der nullbasierte Index für die Zeile, die den angegebenen Zeichenindex enthält.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Controls.TextBox.GetCharacterIndexFromPoint(System.Windows.Point,System.Boolean)" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetCharacterIndexFromLineIndex(System.Int32)" />
        <altmember cref="Overload:System.Windows.Controls.TextBox.GetRectFromCharacterIndex" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetFirstVisibleLineIndex" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetLastVisibleLineIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetLineLength">
      <MemberSignature Language="C#" Value="public int GetLineLength (int lineIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLineLength(int32 lineIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.GetLineLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineLength (lineIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLineLength(int lineIndex);" />
      <MemberSignature Language="F#" Value="member this.GetLineLength : int -&gt; int" Usage="textBox.GetLineLength lineIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lineIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="lineIndex">Der nullbasierte Zeilenindex, für den die Zeichenanzahl zurückgegeben werden soll.</param>
        <summary>Gibt die Anzahl von Zeichen in der angegebenen Zeile zurück.</summary>
        <returns>Die Anzahl von Zeichen in der angegebenen Zeile.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.TextBox.LineCount" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetFirstVisibleLineIndex" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetLastVisibleLineIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetLineText">
      <MemberSignature Language="C#" Value="public string GetLineText (int lineIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLineText(int32 lineIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.GetLineText(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineText (lineIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetLineText(int lineIndex);" />
      <MemberSignature Language="F#" Value="member this.GetLineText : int -&gt; string" Usage="textBox.GetLineText lineIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lineIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="lineIndex">Der nullbasierte Zeilenindex, für den der aktuell angezeigte Text abgerufen wird.</param>
        <summary>Gibt den Text zurück, der derzeit in der angegebenen Zeile angezeigt wird.</summary>
        <returns>Eine Zeichenfolge, die eine Kopie des Texts enthält, der aktuell in der angegebenen Zeile angezeigt wird.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.TextBox.LineCount" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetFirstVisibleLineIndex" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetLastVisibleLineIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetNextSpellingErrorCharacterIndex">
      <MemberSignature Language="C#" Value="public int GetNextSpellingErrorCharacterIndex (int charIndex, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetNextSpellingErrorCharacterIndex(int32 charIndex, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.GetNextSpellingErrorCharacterIndex(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextSpellingErrorCharacterIndex (charIndex As Integer, direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetNextSpellingErrorCharacterIndex(int charIndex, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextSpellingErrorCharacterIndex : int * System.Windows.Documents.LogicalDirection -&gt; int" Usage="textBox.GetNextSpellingErrorCharacterIndex (charIndex, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="charIndex">Der nullbasierte Zeichenindex, der eine Position angibt, ab der nach dem nächsten Rechtschreibfehler gesucht werden soll.</param>
        <param name="direction">Einer der <see cref="T:System.Windows.Documents.LogicalDirection" />-Werte, der die Richtung angibt, in der nach dem nächsten Rechtschreibfehler gesucht werden soll, beginnend am angegebenen <paramref name="charIndex" />.</param>
        <summary>Gibt den Anfangszeichenindex für den nächsten Rechtschreibfehler im Inhalt des Textfelds zurück.</summary>
        <returns>Der Anfangszeichenindex für den Anfang des nächsten Rechtschreibfehlers im Inhalt des Textfelds, oder –1, wenn kein weiterer Rechtschreibfehler vorhanden ist.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Controls.TextBox.GetSpellingError(System.Int32)" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetSpellingErrorLength(System.Int32)" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetSpellingErrorStart(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRectFromCharacterIndex">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das Rechteck für einen Rand des Zeichens am angegebenen Index zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRectFromCharacterIndex">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetRectFromCharacterIndex (int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetRectFromCharacterIndex(int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.GetRectFromCharacterIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRectFromCharacterIndex (charIndex As Integer) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetRectFromCharacterIndex(int charIndex);" />
      <MemberSignature Language="F#" Value="member this.GetRectFromCharacterIndex : int -&gt; System.Windows.Rect" Usage="textBox.GetRectFromCharacterIndex charIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charIndex">Der nullbasierte Zeichenindex des Zeichens, für das das Rechteck abgerufen werden soll.</param>
        <summary>Gibt das Rechteck für den führenden Rand des Zeichens am angegebenen Index zurück.</summary>
        <returns>Ein Rechteck für den führenden Rand des Zeichens am angegebenen Zeichenindex oder <see cref="P:System.Windows.Rect.Empty" />, wenn kein umschließendes Rechteck bestimmt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da diese Methode ein Rechteck zurückgibt, das einen Rand des Zeichens darstellt, ist die Breite des Rechtecks 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRectFromCharacterIndex">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetRectFromCharacterIndex (int charIndex, bool trailingEdge);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetRectFromCharacterIndex(int32 charIndex, bool trailingEdge) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.GetRectFromCharacterIndex(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRectFromCharacterIndex (charIndex As Integer, trailingEdge As Boolean) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetRectFromCharacterIndex(int charIndex, bool trailingEdge);" />
      <MemberSignature Language="F#" Value="member this.GetRectFromCharacterIndex : int * bool -&gt; System.Windows.Rect" Usage="textBox.GetRectFromCharacterIndex (charIndex, trailingEdge)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="trailingEdge" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="charIndex">Der nullbasierte Zeichenindex des Zeichens, für das das Rechteck abgerufen werden soll.</param>
        <param name="trailingEdge"><see langword="true" />, um den nachgestellten Rand des Zeichens abzurufen, <see langword="false" />, um den führenden Rand des Zeichens abzurufen.</param>
        <summary>Gibt das Rechteck für den führenden oder nachgestellten Rand des Zeichens am angegebenen Index zurück.</summary>
        <returns>Ein Rechteck für einen Rand des Zeichens am angegebenen Zeichenindex oder <see cref="P:System.Windows.Rect.Empty" />, wenn kein umschließendes Rechteck bestimmt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da diese Methode ein Rechteck zurückgibt, das einen Rand des Zeichens darstellt, ist die Breite des Rechtecks 0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> ist negativ oder größer als die Länge des Inhalts.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSpellingError">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.SpellingError GetSpellingError (int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Controls.SpellingError GetSpellingError(int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.GetSpellingError(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSpellingError (charIndex As Integer) As SpellingError" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Controls::SpellingError ^ GetSpellingError(int charIndex);" />
      <MemberSignature Language="F#" Value="member this.GetSpellingError : int -&gt; System.Windows.Controls.SpellingError" Usage="textBox.GetSpellingError charIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.SpellingError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charIndex">Der nullbasierte Zeichenindex einer Position im Inhalt, der auf Rechtschreibfehler untersucht wird.</param>
        <summary>Gibt ein <see cref="T:System.Windows.Controls.SpellingError" />-Objekt zurück, das einem Rechtschreibfehler am angegebenen Zeichenindex zugeordnet ist.</summary>
        <returns>Ein <see cref="T:System.Windows.Controls.SpellingError" />-Objekt mit Details zum Rechtschreibfehler, der bei dem durch <paramref name="charIndex" /> angegebenen Zeichen gefunden wurde, oder <see langword="null" />, wenn beim angegebenen Zeichen kein Rechtschreibfehler gefunden wurde.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Controls.TextBox.GetNextSpellingErrorCharacterIndex(System.Int32,System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetSpellingErrorLength(System.Int32)" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetSpellingErrorStart(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetSpellingErrorLength">
      <MemberSignature Language="C#" Value="public int GetSpellingErrorLength (int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetSpellingErrorLength(int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.GetSpellingErrorLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSpellingErrorLength (charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetSpellingErrorLength(int charIndex);" />
      <MemberSignature Language="F#" Value="member this.GetSpellingErrorLength : int -&gt; int" Usage="textBox.GetSpellingErrorLength charIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charIndex">Der nullbasierte Zeichenindex einer Position im Inhalt, der auf Rechtschreibfehler untersucht wird.</param>
        <summary>Gibt die Länge eines Rechtschreibfehlers zurück, der das angegebene Zeichen enthält.</summary>
        <returns>Die Länge eines Rechtschreibfehlers, der das durch charIndex angegebene Zeichen enthält, oder 0, wenn das angegebene Zeichen in keinem Rechtschreibfehler enthalten ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpellingErrorStart">
      <MemberSignature Language="C#" Value="public int GetSpellingErrorStart (int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetSpellingErrorStart(int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.GetSpellingErrorStart(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSpellingErrorStart (charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetSpellingErrorStart(int charIndex);" />
      <MemberSignature Language="F#" Value="member this.GetSpellingErrorStart : int -&gt; int" Usage="textBox.GetSpellingErrorStart charIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charIndex">Der nullbasierte Zeichenindex einer Position im Inhalt, der auf Rechtschreibfehler untersucht wird.</param>
        <summary>Gibt den Anfangszeichenindex für jeden Rechtschreibfehler zurück, der das angegebene Zeichen enthält.</summary>
        <returns>Der Anfangszeichenindex eines Rechtschreibfehlers, der das durch <paramref name="charIndex" /> angegebene Zeichen enthält, oder –1, wenn das angegebene Zeichen in keinem Rechtschreibfehler enthalten ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineCount">
      <MemberSignature Language="C#" Value="public int LineCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LineCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.LineCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LineCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LineCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LineCount : int" Usage="System.Windows.Controls.TextBox.LineCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtzahl der Zeilen im Textfeld ab.</summary>
        <value>Die Gesamtanzahl der Zeilen im Textfeld oder-1, wenn keine Layoutinformationen verfügbar sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Umbenennen von Text aktiviert ist, kann dieser Wert durch Ändern der Breite des Textfelds geändert werden.  
  
 Der zurückgegebene Wert entspricht der Gesamtzahl der Zeilen im Textfeld, unabhängig davon, wie viele Zeilen momentan sichtbar sind.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBox.TextWrapping" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetCharacterIndexFromLineIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetFirstVisibleLineIndex" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetLastVisibleLineIndex" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetLineLength(System.Int32)" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetLineText(System.Int32)" />
        <altmember cref="P:System.Windows.Controls.TextBox.MaxLines" />
        <altmember cref="P:System.Windows.Controls.TextBox.MinLines" />
        <altmember cref="M:System.Windows.Controls.TextBox.ScrollToLine(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.TextBox.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator für die logischen untergeordneten Elemente des <see cref="T:System.Windows.Controls.TextBox" />-Objekts ab.</summary>
        <value>Ein Enumerator für die logischen untergeordneten Elemente des <see cref="T:System.Windows.Controls.TextBox" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.TextBox.LogicalChildren%2A> -Eigenschaft gibt einen Enumerator für eine Auflistung zurück, <xref:System.String> die ein-Objekt enthält <xref:System.Windows.Controls.TextBox.Text%2A> , das gleich der-Eigenschaft ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxLength">
      <MemberSignature Language="C#" Value="public int MaxLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.MaxLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxLength : int with get, set" Usage="System.Windows.Controls.TextBox.MaxLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Modifiability=System.Windows.Modifiability.Unmodifiable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Anzahl der Zeichen ab, die manuell in das Textfeld eingegeben werden können, oder legt diese fest.</summary>
        <value>Die maximale Anzahl der Zeichen, die manuell in das Textfeld eingegeben werden können. Der Standardwert ist 0, d. h. unbegrenzt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft verwenden, um die im Steuerelement eingegebene Textlänge für Werte wie Postleitzahlen und Telefonnummern einzuschränken. Sie können diese Eigenschaft auch verwenden, um die Länge des Texts einzuschränken, der eingegeben wird, wenn die Daten in einer Datenbank gespeichert werden, sodass der Text, der in das Steuerelement eingegeben wird, nicht die maximale Länge des entsprechenden Felds in der Datenbank überschreitet.  
  
 Diese Eigenschaft wirkt sich nicht auf Zeichen aus, die Programm gesteuert hinzugefügt werden.  
  
 Wenn diese Eigenschaft auf 0 festgelegt ist, wird die maximale Länge des Texts, der im Steuerelement eingegeben werden kann, nur durch den verfügbaren Arbeitsspeicher beschränkt.  
  
<a name="dependencyPropertyInfo_MaxLength"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.TextBox.MaxLengthProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein <xref:System.Windows.Controls.TextBox> mit einem <xref:System.Windows.Controls.TextBox.MaxLength%2A> von 500 Zeichen erstellt wird.  
  
 [!code-xaml[TextBoxMiscSnippets_snip#TextBoxExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_snip/csharp/textboxexample.xaml#textboxexamplewholepage)]  
  
 [!code-csharp[TextBoxMiscSnippets_procedural_snip#TextBoxCodeExampleInline1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/CSharp/TextBoxExample.cs#textboxcodeexampleinline1)]
 [!code-vb[TextBoxMiscSnippets_procedural_snip#TextBoxCodeExampleInline1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/visualbasic/textboxexample.vb#textboxcodeexampleinline1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBox.MaxLines" />
      </Docs>
    </Member>
    <Member MemberName="MaxLengthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxLengthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxLengthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBox.MaxLengthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxLengthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxLengthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxLengthProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBox.MaxLengthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.TextBox.MaxLength" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxLines">
      <MemberSignature Language="C#" Value="public int MaxLines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxLines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.MaxLines" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxLines As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxLines { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxLines : int with get, set" Usage="System.Windows.Controls.TextBox.MaxLines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Anzahl sichtbarer Zeilen ab oder legt diese fest.</summary>
        <value>Die maximale Anzahl sichtbarer Zeilen. Die Standardeinstellung ist <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim erhalten dieser Eigenschaft wird der aktuelle Wert <xref:System.Windows.Controls.TextBox.MaxLines%2A>von zurückgegeben. Das Festlegen dieser Eigenschaft bewirkt, dass die Größe des Textfelds geändert wird, wenn die Anzahl der sichtbaren <xref:System.Windows.Controls.TextBox.MaxLines%2A>Zeilen den von angegebenen Grenzwert überschreitet.  
  
 Diese Eigenschaft gilt nur für sichtbare Zeilen und schränkt nicht die tatsächliche Zeilen Anzahl ein. Abhängig von der Konfiguration kann ein Textfeld zusätzliche nicht sichtbare Zeilen enthalten, auf die durch Scrollen zugegriffen werden kann.  
  
 Wenn die <xref:System.Windows.FrameworkElement.Height%2A> Eigenschaft explizit für einen <xref:System.Windows.Controls.TextBox>festgelegt wird, <xref:System.Windows.Controls.TextBox.MaxLines%2A> werden <xref:System.Windows.Controls.TextBox.MinLines%2A> die-und-Eigenschaftswerte ignoriert.  
  
<a name="dependencyPropertyInfo_MaxLines"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.TextBox.MaxLinesProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.TextBox.MaxLines%2A> mit dem Wert 5 erstellt wird.  
  
 [!code-xaml[TextBoxMiscSnippets_snip#TextBoxExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_snip/csharp/textboxexample.xaml#textboxexamplewholepage)]  
  
 [!code-csharp[TextBoxMiscSnippets_procedural_snip#TextBoxCodeExampleInline1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/CSharp/TextBoxExample.cs#textboxcodeexampleinline1)]
 [!code-vb[TextBoxMiscSnippets_procedural_snip#TextBoxCodeExampleInline1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/visualbasic/textboxexample.vb#textboxcodeexampleinline1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception"><see cref="P:System.Windows.Controls.TextBox.MaxLines" /> ist kleiner als <see cref="P:System.Windows.Controls.TextBox.MinLines" />.</exception>
        <altmember cref="P:System.Windows.Controls.TextBox.MinLines" />
        <altmember cref="P:System.Windows.Controls.TextBox.MaxLength" />
      </Docs>
    </Member>
    <Member MemberName="MaxLinesProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxLinesProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxLinesProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBox.MaxLinesProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxLinesProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxLinesProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxLinesProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBox.MaxLinesProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.TextBox.MaxLines" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="textBox.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Eine <see cref="T:System.Windows.Size" />-Struktur, die die Einschränkungen für die Größe des Textfelds angibt.</param>
        <summary>Passt die Größe des Textfelds an dessen Inhalt an.</summary>
        <returns>Eine <see cref="T:System.Windows.Size" />-Struktur, die die neue Größe des Textfelds angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreiben Sie diese Methode, um ein benutzerdefiniertes Größen Anpassungs Verhalten  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinLines">
      <MemberSignature Language="C#" Value="public int MinLines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinLines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.MinLines" />
      <MemberSignature Language="VB.NET" Value="Public Property MinLines As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinLines { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MinLines : int with get, set" Usage="System.Windows.Controls.TextBox.MinLines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Mindestanzahl sichtbarer Zeilen ab oder legt diese fest.</summary>
        <value>Die Mindestanzahl sichtbarer Zeilen. Der Standard ist 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim erhalten dieser Eigenschaft wird der aktuelle Wert <xref:System.Windows.Controls.TextBox.MinLines%2A>von zurückgegeben. Das Festlegen dieser Eigenschaft bewirkt, dass die Größe des Textfelds geändert wird, wenn die Anzahl der sichtbaren Zeilen <xref:System.Windows.Controls.TextBox.MinLines%2A>kleiner ist als der von angegebene Wert.  
  
 Wenn die <xref:System.Windows.FrameworkElement.Height%2A> Eigenschaft explizit für einen <xref:System.Windows.Controls.TextBox>festgelegt wird, <xref:System.Windows.Controls.TextBox.MaxLines%2A> werden <xref:System.Windows.Controls.TextBox.MinLines%2A> die-und-Eigenschaftswerte ignoriert.  
  
<a name="dependencyPropertyInfo_MinLines"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.TextBox.MinLinesProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.TextBox.MinLines%2A> mit dem Wert 1 erstellt wird.  
  
 [!code-xaml[TextBoxMiscSnippets_snip#TextBoxExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_snip/csharp/textboxexample.xaml#textboxexamplewholepage)]  
  
 [!code-csharp[TextBoxMiscSnippets_procedural_snip#TextBoxCodeExampleInline1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/CSharp/TextBoxExample.cs#textboxcodeexampleinline1)]
 [!code-vb[TextBoxMiscSnippets_procedural_snip#TextBoxCodeExampleInline1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/visualbasic/textboxexample.vb#textboxcodeexampleinline1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception"><see cref="P:System.Windows.Controls.TextBox.MinLines" /> ist größer als <see cref="P:System.Windows.Controls.TextBox.MaxLines" />.</exception>
        <altmember cref="P:System.Windows.Controls.TextBox.MaxLines" />
        <altmember cref="P:System.Windows.Controls.TextBox.MaxLength" />
      </Docs>
    </Member>
    <Member MemberName="MinLinesProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinLinesProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinLinesProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBox.MinLinesProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinLinesProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinLinesProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinLinesProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBox.MinLinesProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.TextBox.MinLines" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="textBox.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />-Objekt für das Textfeld und gibt dieses zurück.</summary>
        <returns>Ein <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />-Objekt für das Textfeld.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="textBox.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Argumente des zugeordneten Ereignisses.</param>
        <summary>Wird aufgerufen, wenn der effektive Wert einer oder mehrerer Abhängigkeitseigenschaften des Elements geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyChangedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ScrollToLine">
      <MemberSignature Language="C#" Value="public void ScrollToLine (int lineIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToLine(int32 lineIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.ScrollToLine(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToLine (lineIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToLine(int lineIndex);" />
      <MemberSignature Language="F#" Value="member this.ScrollToLine : int -&gt; unit" Usage="textBox.ScrollToLine lineIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lineIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="lineIndex">Der nullbasierte Zeilenindex der Zeile, die durch einen Bildlauf sichtbar gemacht werden soll.</param>
        <summary>Führt einen Bildlauf aus, um die Zeile am angegebenen Zeilenindex sichtbar zu machen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bewirkt, dass das Textfeld durch den minimalen Betrag Scrollen muss, um die angegebene Zeile in die vollständige Ansicht zu bringen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.TextBox.GetFirstVisibleLineIndex" />
        <altmember cref="M:System.Windows.Controls.TextBox.GetLastVisibleLineIndex" />
        <altmember cref="P:System.Windows.Controls.TextBox.LineCount" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.Select(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(int start, int length);" />
      <MemberSignature Language="F#" Value="member this.Select : int * int -&gt; unit" Usage="textBox.Select (start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Der nullbasierte Zeichenindex des ersten Zeichens in der Auswahl.</param>
        <param name="length">Die Länge der Auswahl in Zeichen.</param>
        <summary>Wählt einen Textbereich im Textfeld aus.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" /> oder <paramref name="length" /> ist ein negativer Wert.</exception>
        <altmember cref="P:System.Windows.Controls.TextBox.SelectedText" />
        <altmember cref="P:System.Windows.Controls.TextBox.SelectionLength" />
        <altmember cref="P:System.Windows.Controls.TextBox.SelectionStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectedText">
      <MemberSignature Language="C#" Value="public string SelectedText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.SelectedText" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SelectedText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedText : string with get, set" Usage="System.Windows.Controls.TextBox.SelectedText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Inhalt der aktuellen Auswahl im Textfeld ab oder legt ihn fest.</summary>
        <value>Zeigt den aktuell ausgewählten Text im Textfeld an.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Eigenschaft erhalten, wird eine Zeichen folgen Kopie des aktuell ausgewählten Texts zurückgegeben. Durch Festlegen dieser Eigenschaft wird die aktuelle Auswahl durch die angegebene Zeichenfolge ersetzt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.TextBox.Select(System.Int32,System.Int32)" />
        <altmember cref="P:System.Windows.Controls.TextBox.SelectionLength" />
        <altmember cref="P:System.Windows.Controls.TextBox.SelectionStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectionLength">
      <MemberSignature Language="C#" Value="public int SelectionLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.SelectionLength" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionLength : int with get, set" Usage="System.Windows.Controls.TextBox.SelectionLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Anzahl von Zeichen in der aktuellen Auswahl im Textfeld angibt, oder legt diesen fest.</summary>
        <value>Die Anzahl von Zeichen in der aktuellen Auswahl im Textfeld. Der Standard ist 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim erhalten dieser Eigenschaft wird die Anzahl der Zeichen in der aktuellen Auswahl zurückgegeben. Wenn diese Eigenschaft festgelegt wird, wird die Länge der aktuellen Auswahl auf den angegebenen Wert festgelegt, sodass der Anfang der Auswahl fest bleibt.  
  
 Wenn die angegebene Auswahl Länge bewirkt, dass die Auswahl an einer ungültigen Position endet (z. b. zwischen einem Wagen Rücklauf Zeichen und einem Zeilenumbruch Zeichen oder innerhalb eines Tags), wird die Auswahl Länge automatisch so angepasst, dass die resultierende Auswahl gestartet wird. und endet an gültigen Positionen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Windows.Controls.TextBox.SelectionLength" /> ist auf einen negativen Wert festgelegt.</exception>
        <altmember cref="M:System.Windows.Controls.TextBox.Select(System.Int32,System.Int32)" />
        <altmember cref="P:System.Windows.Controls.TextBox.SelectedText" />
        <altmember cref="P:System.Windows.Controls.TextBox.SelectionStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectionStart">
      <MemberSignature Language="C#" Value="public int SelectionStart { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.SelectionStart" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionStart As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionStart { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionStart : int with get, set" Usage="System.Windows.Controls.TextBox.SelectionStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Zeichenindex für den Anfang der aktuellen Auswahl ab oder legt diesen fest.</summary>
        <value>Der Zeichenindex für den Anfang der aktuellen Auswahl.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Fällen, in denen die angegebene Auswahl Länge bewirkt, dass die Auswahl zwischen einem Wagen Rücklauf und einem Zeilenumbruch Zeichen endet, wird die Auswahl Länge automatisch um 1 angehoben, sodass die resultierende Auswahl den gesamten markerendemarker umfasst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Windows.Controls.TextBox.SelectionStart" /> ist auf einen negativen Wert festgelegt.</exception>
        <altmember cref="M:System.Windows.Controls.TextBox.Select(System.Int32,System.Int32)" />
        <altmember cref="P:System.Windows.Controls.TextBox.SelectedText" />
        <altmember cref="P:System.Windows.Controls.TextBox.SelectionLength" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeText">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeText (System.Windows.Markup.XamlDesignerSerializationManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeText(class System.Windows.Markup.XamlDesignerSerializationManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.ShouldSerializeText(System.Windows.Markup.XamlDesignerSerializationManager)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeText (manager As XamlDesignerSerializationManager) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeText(System::Windows::Markup::XamlDesignerSerializationManager ^ manager);" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeText : System.Windows.Markup.XamlDesignerSerializationManager -&gt; bool" Usage="textBox.ShouldSerializeText manager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.Windows.Markup.XamlDesignerSerializationManager" />
      </Parameters>
      <Docs>
        <param name="manager">Ein Serialisierungsdienst-Manager-Objekt für dieses Objekt.</param>
        <summary>Gibt einen Wert zurück, mit dem angegeben wird, ob der tatsächliche Wert der <see cref="P:System.Windows.Controls.TextBox.Text" />-Eigenschaft bei der Serialisierung des <see cref="T:System.Windows.Controls.TextBox" />-Objekts serialisiert werden soll.</summary>
        <returns><see langword="true" />, wenn die <see cref="P:System.Windows.Controls.TextBox.Text" />-Eigenschaft serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><paramref name="manager" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Ein Objekt, das als untergeordnetes Element hinzugefügt werden soll.</param>
        <summary>Löst in allen Fällen eine Ausnahme aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.TextBox>akzeptiert nur Text über die <xref:System.Windows.Markup.IAddChild> -Schnittstelle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">In allen anderen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBox.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Eine Zeichenfolge, die dem Objekt hinzugefügt werden soll.</param>
        <summary>Fügt dem Objekt den Textinhalt eines Knotens hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Controls.TextBox>-Instanz in eine <xref:System.Windows.Markup.IAddChild>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Controls.TextBox.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Text)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Textinhalt des Textfelds ab bzw. legt diesen fest.</summary>
        <value>Eine Zeichenfolge mit dem Textinhalt des Textfelds. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Eigenschaft erhalten, wird eine Zeichen folgen Kopie der Inhalte des Textfelds zurückgegeben. Durch Festlegen dieser Eigenschaft wird der Inhalt des Textfelds durch die angegebene Zeichenfolge ersetzt.  
  
 Diese Eigenschaft unterstützt keine Animation.  
  
 Bei der Verwendung in Daten Bindungs Szenarios verwendet diese Eigenschaft das standardmäßige Aktualisierungs <xref:System.Windows.Data.UpdateSourceTrigger.LostFocus?displayProperty=nameWithType>Verhalten von.  
  
<a name="xamlPropertyElementUsage_Text"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  String  
</object>  
```  
  
<a name="dependencyPropertyInfo_Text"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.TextBox.TextProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Journal%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBox.CharacterCasing" />
        <altmember cref="P:System.Windows.Controls.TextBox.TextAlignment" />
      </Docs>
    </Member>
    <Member MemberName="TextAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.TextAlignment TextAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextAlignment TextAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.TextAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property TextAlignment As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextAlignment TextAlignment { System::Windows::TextAlignment get(); void set(System::Windows::TextAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.TextAlignment : System.Windows.TextAlignment with get, set" Usage="System.Windows.Controls.TextBox.TextAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die horizontale Ausrichtung des Texts im Textfeld ab oder legt diese fest.</summary>
        <value>Einer der <see cref="T:System.Windows.TextAlignment" />-Werte, der die horizontale Ausrichtung des Inhalts des Textfelds angibt. Die Standardeinstellung ist <see cref="F:System.Windows.TextAlignment.Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim erhalten dieser Eigenschaft wird die aktuelle Ausrichtung zurückgegeben. Durch Festlegen dieser Eigenschaft wird der Inhalt des Textfelds angepasst, um die angegebene Ausrichtung widerzuspiegeln.  
  
 Diese Eigenschaft hat eine höhere Rangfolge als <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A> die-Eigenschaft.  
  
<a name="dependencyPropertyInfo_TextAlignment"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.TextBox.TextAlignmentProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.TextBox.TextAlignment%2A> mit der von <xref:System.Windows.TextAlignment.Center?displayProperty=nameWithType>erstellt wird.  
  
 [!code-xaml[TextBoxMiscSnippets_snip#TextBoxExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_snip/csharp/textboxexample.xaml#textboxexamplewholepage)]  
  
 [!code-csharp[TextBoxMiscSnippets_procedural_snip#TextBoxCodeExampleInline1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/CSharp/TextBoxExample.cs#textboxcodeexampleinline1)]
 [!code-vb[TextBoxMiscSnippets_procedural_snip#TextBoxCodeExampleInline1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/visualbasic/textboxexample.vb#textboxcodeexampleinline1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBox.Text" />
        <altmember cref="P:System.Windows.Controls.TextBox.CharacterCasing" />
      </Docs>
    </Member>
    <Member MemberName="TextAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBox.TextAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBox.TextAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.TextBox.TextAlignment" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextDecorations">
      <MemberSignature Language="C#" Value="public System.Windows.TextDecorationCollection TextDecorations { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TextDecorationCollection TextDecorations" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.TextDecorations" />
      <MemberSignature Language="VB.NET" Value="Public Property TextDecorations As TextDecorationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextDecorationCollection ^ TextDecorations { System::Windows::TextDecorationCollection ^ get(); void set(System::Windows::TextDecorationCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TextDecorations : System.Windows.TextDecorationCollection with get, set" Usage="System.Windows.Controls.TextBox.TextDecorations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextDecorationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Textdekorationen ab, die auf das Textfeld angewendet werden sollen.</summary>
        <value>Eine <see cref="T:System.Windows.TextDecorationCollection" />-Auflistung, die auf dieses Textfeld anzuwendende Textdekorationen enthält. Der Standardwert ist <see langword="null" /> (es werden keine Textdekorationen angewendet).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.TextDecoration> -Objekt ist eine visuelle Verzierung, die Sie Text hinzufügen können. Es gibt vier Arten von Text Dekorationen: Unterstreichung, Baseline, durchgestrichen und über Linien. Weitere Informationen zu Text Dekorationen finden [Sie unter Gewusst wie: Erstellen Sie eine Text](~/docs/framework/wpf/advanced/how-to-create-a-text-decoration.md)Dekoration.  
  
<a name="dependencyPropertyInfo_TextDecorations"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.TextBox.TextDecorationsProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie das <xref:System.Windows.Documents.Inline.TextDecorations%2A> -Attribut mithilfe <xref:System.Windows.Documents.Run> von als Beispiel Element festgelegt wird.  
  
 [!code-xaml[InlineSnippets#_Inline_TextDecXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/InlineSnippets/CSharp/Window1.xaml#_inline_textdecxaml)]  
  
 Die folgende Abbildung zeigt, wie dieses Beispiel gerendert wird.  
  
 ![Verschaffen Bildschirm Abbildung mit dem Standardeffekt](~/add/media/inline-textdec-strike.png "für durchgestrichen durch Strichen: Text mit Standard Effekten durch Strichen")  
  
 Der folgenden Abbildung wird wie die <xref:System.Windows.TextDecorations.OverLine%2A>, <xref:System.Windows.TextDecorations.Baseline%2A>, und <xref:System.Windows.TextDecorations.Underline%2A> Ergänzungen zu rendern, bzw.  
  
 ![Verschaffen Overline-Bildschirm Abbildung]von TextDecorator(~/add/media/inline-textdec-over.png ": Overline-TextDecorator")  
  
 ![Verschaffen Standard-Baseline-Effekt]für Text(~/add/media/inline-textdec-base.png "-Bildschirmfoto: Standard-baselineeffekt für Text")  
  
 ![Verschaffen Screenshot mit der standardmäßigen]Unterstreichung:(~/add/media/inline-textdec-under.png " Text mit Standardeffekt für Unterstreichung")  
  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Documents.Inline.TextDecorations%2A> -Eigenschaft Programm gesteuert festgelegt wird.  
  
 [!code-csharp[InlineSnippets#_Inline_TextDec](~/samples/snippets/csharp/VS_Snippets_Wpf/InlineSnippets/CSharp/Window1.xaml.cs#_inline_textdec)]
 [!code-vb[InlineSnippets#_Inline_TextDec](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InlineSnippets/visualbasic/window1.xaml.vb#_inline_textdec)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextDecorationsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextDecorationsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextDecorationsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBox.TextDecorationsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextDecorationsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextDecorationsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextDecorationsProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBox.TextDecorationsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.TextBox.TextDecorations" />-Abhängigkeitseigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bezeichner für die <xref:System.Windows.Controls.TextBox.TextDecorations%2A> -Abhängigkeitseigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBox.TextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBox.TextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.TextBox.Text" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextWrapping">
      <MemberSignature Language="C#" Value="public System.Windows.TextWrapping TextWrapping { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextWrapping TextWrapping" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.TextWrapping" />
      <MemberSignature Language="VB.NET" Value="Public Property TextWrapping As TextWrapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextWrapping TextWrapping { System::Windows::TextWrapping get(); void set(System::Windows::TextWrapping value); };" />
      <MemberSignature Language="F#" Value="member this.TextWrapping : System.Windows.TextWrapping with get, set" Usage="System.Windows.Controls.TextBox.TextWrapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextWrapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, wie Text im Textfeld umbrochen werden soll.</summary>
        <value>Einer der <see cref="T:System.Windows.TextWrapping" />-Werte, der den Textumbruch im Textfeld angibt. Die Standardeinstellung ist <see cref="F:System.Windows.TextWrapping.NoWrap" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Windows.Controls.TextBox.TextWrapping%2A> -Attribut <xref:System.Windows.TextWrapping.Wrap> auf festgelegt wird, wird der eingegebene Text in eine neue Zeile <xref:System.Windows.Controls.TextBox> eingeschlossen, wenn der Rand des Steuer Elements <xref:System.Windows.Controls.TextBox> erreicht ist, und die Höhe des Steuer Elements wird bei Bedarf automatisch um Platz für eine neue Zeile erweitert.  
  
<a name="dependencyPropertyInfo_TextWrapping"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.TextBox.TextWrappingProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie der Wert dieser Eigenschaft festgelegt wird.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase12](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase12)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase12](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextWrappingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextWrappingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextWrappingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBox.TextWrappingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextWrappingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextWrappingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextWrappingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBox.TextWrappingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.TextBox.TextWrapping" />-Abhängigkeitseigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bezeichner für die <xref:System.Windows.Controls.TextBox.TextWrapping%2A>-Abhängigkeitseigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Typography">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Typography Typography { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Typography Typography" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBox.Typography" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Typography As Typography" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Typography ^ Typography { System::Windows::Documents::Typography ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Typography : System.Windows.Documents.Typography" Usage="System.Windows.Controls.TextBox.Typography" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Typography</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuell verwendbaren Typografievarianten für den Textinhalt des Textfelds ab.</summary>
        <value>Ein <see cref="T:System.Windows.Documents.Typography" />-Objekt, mit dem die aktuell verwendbaren Typografievarianten angegeben werden. Eine Liste der Standardwerte für die Typografie finden Sie unter <see cref="T:System.Windows.Documents.Typography" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Documents.FlowDocument.Typography%2A> -Eigenschaft gilt nur für [!INCLUDE[TLA#tla_opentype](~/includes/tlasharptla-opentype-md.md)] Schriftarten. Eine Typografievariante wirkt sich nicht auf Schriftarten aus, die die Variante nicht unterstützen. Weitere Informationen zu diesem Thema finden Sie unter [Typografie in WPF](~/docs/framework/wpf/advanced/typography-in-wpf.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie das <xref:System.Windows.Documents.TextElement.Typography%2A> -Attribut mithilfe <xref:System.Windows.Documents.Paragraph> von als Beispiel Element festgelegt wird.  
  
 [!code-xaml[TextElementSnippets#_TextElement_TypogXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/TextElementSnippets/CSharp/Window1.xaml#_textelement_typogxaml)]  
  
 Die folgende Abbildung zeigt, wie dieses Beispiel gerendert wird.  
  
 ![Verschaffen Bildschirm Abbildung von Text]mit geänderter Typografie(~/add/media/textelement-typog.png ": Text mit geänderter Typografie")  
  
 Im Gegensatz dazu zeigt die folgende Abbildung, wie ein ähnliches Beispiel mit typografischen Standardeigenschaften gerendert wird.  
  
 ![Verschaffen Bildschirm Abbildung von Text]mit geänderter Typografie(~/add/media/textelement-typog-default.png ": Text mit geänderter Typografie")  
  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Controls.TextBox.Typography%2A> -Eigenschaft Programm gesteuert festgelegt wird.  
  
 [!code-csharp[TextElementSnippets#_TextElement_Typog](~/samples/snippets/csharp/VS_Snippets_Wpf/TextElementSnippets/CSharp/Window1.xaml.cs#_textelement_typog)]
 [!code-vb[TextElementSnippets#_TextElement_Typog](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextElementSnippets/visualbasic/window1.xaml.vb#_textelement_typog)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
