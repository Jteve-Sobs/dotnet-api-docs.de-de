<Type Name="Page" FullName="System.Windows.Controls.Page">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d2b2f547328a5918908d2949cdc123c74c5786fc" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32694918" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Page : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Page" />
  <TypeSignature Language="VB.NET" Value="Public Class Page&#xA;Inherits FrameworkElement&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class Page : System::Windows::FrameworkElement, System::Windows::Markup::IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Content")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Kapselt eine Inhaltsseite, zu der navigiert werden kann und die von Windows Internet Explorer, <see cref="T:System.Windows.Navigation.NavigationWindow" /> und <see cref="T:System.Windows.Controls.Frame" /> gehostet werden kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page> Kapselt einen Inhalt, der navigiert werden kann, enthält die folgenden wichtigsten Elemente:  
  
-   **Verwaltung der Objektlebensdauer**: <xref:System.Windows.Controls.Page.KeepAlive%2A>.  
  
-   **Navigation**: <xref:System.Windows.Controls.Page.NavigationService%2A>.  
  
-   **Darstellung**: <xref:System.Windows.Controls.Page.Background%2A>, <xref:System.Windows.Controls.Page.Content%2A>, <xref:System.Windows.Controls.Page.FontFamily%2A>, <xref:System.Windows.Controls.Page.FontSize%2A>, <xref:System.Windows.Controls.Page.Foreground%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>, <xref:System.Windows.Controls.Page.Template%2A>, <xref:System.Windows.Controls.Page.Title%2A>.  
  
-   **Hosten von Darstellung**: <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowTitle%2A>.  
  
 Eine Seite kann mit Markup, Markup und CodeBehind oder Code definiert werden. Eine Seite ist die bevorzugte Methode zum Paketinhalt für die Navigation, den folgenden Gründen:  
  
-   Es ist einfach zu definieren, wiederzuverwenden und zu verwalten.  
  
-   Zugriff auf und verwendet werden können die <xref:System.Windows.Navigation.NavigationService> , der dorthin navigiert ist.  
  
-   Sie können ändern, Titel, Breite, Höhe und die Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] des Hostfensters (<xref:System.Windows.Controls.Page.WindowTitle%2A>, <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>).  
  
-   Es verfügt über designerunterstützung im [!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)].  
  
 Eine Seite aufgenommen werden kann, aus <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, oder in einem Browser. Um gehostet werden, kann eine Seite sein:  
  
-   Direktes untergeordnetes Element von einem <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, oder <xref:System.Windows.Controls.Frame> Element im [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
-   Instanziiert, und legen Sie als Wert für die `Content` Eigenschaft <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, und <xref:System.Windows.Controls.Frame>.  
  
-   Legen Sie als die [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Quelle der `Source` Eigenschaft entweder <xref:System.Windows.Navigation.NavigationWindow> oder <xref:System.Windows.Controls.Frame>.  
  
-   Legen Sie als die <xref:System.Windows.Application.StartupUri%2A> in eine eigenständige Anwendung.  
  
-   Legen Sie als die <xref:System.Windows.Application.StartupUri%2A> in einer [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)].  
  
 In der Regel weist eine Anwendung zwei oder mehr Seiten navigiert werden können, zwischen der Verwendung der folgenden Mechanismen:  
  
-   Deklarativ mithilfe <xref:System.Windows.Documents.Hyperlink>.  
  
-   Programmgesteuert durch die Verwendung <xref:System.Windows.Navigation.NavigationService>.  
  
-   Visuell mithilfe der Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] des Hosts, einschließlich [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], <xref:System.Windows.Navigation.NavigationWindow>, und <xref:System.Windows.Controls.Frame>.  
  
 Für die strukturierte Navigation mithilfe der Seitenfunktionen (<xref:System.Windows.Navigation.PageFunction%601>), finden Sie unter [Übersicht über die strukturierte Navigation](~/docs/framework/wpf/app-development/structured-navigation-overview.md) und [Navigation Topologien Overview](~/docs/framework/wpf/app-development/navigation-topologies-overview.md).  
  
 Abhängigkeitseigenschaften für dieses Steuerelement können vom Standardformat für das Steuerelement festgelegt werden.  Wenn eine Eigenschaft von einem Standardformat festgelegt ist, kann die Eigenschaft von seinem Standardwert ändern, wenn das Steuerelement in der Anwendung angezeigt wird. Das Standardformat wird bestimmt, welche desktop Design verwendet wird, wenn die Anwendung ausgeführt wird.  Weitere Informationen finden Sie unter [Standard-WPF-Designs](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie eine standard-Seite ist nur mit Markup definiert:  
  
 [!code-xaml[PageSnippets#MarkupPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupPage.xaml#markuppagemarkup)]  
  
 Das folgende Beispiel zeigt, wie eine Standardseite mit definiert wurde nur code:  
  
 [!code-csharp[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/CodePage.cs#codepagecodebehind)]
 [!code-vb[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/codepage.vb#codepagecodebehind)]  
  
 Das folgende Beispiel zeigt, wie eine standard-Seite ist mit einer Kombination von Markup und CodeBehind definiert.  
  
 [!code-xaml[PageSnippets#MarkupAndCodeBehindPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml#markupandcodebehindpagemarkup)]  
  
 [!code-csharp[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml.cs#markupandcodebehindpagecodebehind)]
 [!code-vb[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/markupandcodebehindpage.xaml.vb#markupandcodebehindpagecodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Navigation.PageFunction`1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Page();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.Page" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Windows.Controls.Page> nicht wird beibehalten (finden Sie unter <xref:System.Windows.Controls.Page.KeepAlive%2A>), es muss einen Standardkonstruktor zur zulassen implementieren [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] erstellen eine neue Instanz der beim Sichern navigiert oder Navigationsverlauf.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">Die Größe, die zum Anordnen der untergeordneten Elemente verwendet werden soll.</param>
        <summary>Ordnet den Inhalt (die untergeordneten Elemente) der <see cref="T:System.Windows.Controls.Page" /> an.</summary>
        <returns>Eine <see cref="T:System.Windows.Size" />, die die angeordnete Größe der Seite darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Hintergrund einer <see cref="T:System.Windows.Controls.Page" /> ab oder legt diesen fest.</summary>
        <value>Der <see cref="T:System.Windows.Media.Brush" /> mit dem die <see cref="T:System.Windows.Controls.Page" /> ihren Hintergrund zeichnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageBackground"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.BackgroundProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.Background" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Inhalt einer <see cref="T:System.Windows.Controls.Page" /> ab oder legt diesen fest.</summary>
        <value>Ein Objekt, das den Inhalt einer <see cref="T:System.Windows.Controls.Page" /> enthält. Der Standardwert ist <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Controls.Page> kann nur ein einzelnes untergeordnetes Element verfügen. Alle anderen Elemente auf einer <xref:System.Windows.Controls.Page> Nachfolger dieses Elements werden muss. In der Regel der Inhalt des eine <xref:System.Windows.Controls.Page> hostet Layoutelement – z. B. <xref:System.Windows.Controls.Grid>, <xref:System.Windows.Controls.StackPanel>, und <xref:System.Windows.Controls.DockPanel>–, die den Inhalt des hostet die <xref:System.Windows.Controls.Page>.  
  
<a name="dependencyPropertyInfo_PageContent"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.ContentProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|Keiner|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.Content" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font, Modifiability=System.Windows.Modifiability.Unmodifiable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der angegebenen Schriftfamilie ab oder legt diesen fest.</summary>
        <value>Eine <see cref="T:System.Windows.Media.FontFamily" />, die die Schriftfamilie für den Inhalt einer <see cref="T:System.Windows.Controls.Page" /> ist. Der Standardwert ist <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageFontFamily"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.FontFamilyProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.FontFamily" />-Abhängigkeitseigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bezeichner für die <xref:System.Windows.Controls.Page.FontFamily%2A>-Abhängigkeitseigenschaft.  
  
   
  
## Examples  
 [Übersicht über Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Schriftgrad ab oder legt diesen fest.</summary>
        <value>Der Schriftgrad für den Inhalt einer <see cref="T:System.Windows.Controls.Page" />. Der Standardwert ist <see cref="P:System.Windows.SystemFonts.MessageFontSize" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Schriftgrad muss eine Positive Zahl sein und im Bereich der <xref:System.Windows.SystemFonts.MessageFontSize%2A>.  
  
<a name="dependencyPropertyInfo_PageFontSize"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.FontSizeProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.FontSize" />-Abhängigkeitseigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bezeichner für die <xref:System.Windows.Controls.Page.FontSize%2A>-Abhängigkeitseigenschaft.  
  
   
  
## Examples  
 [Übersicht über Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Vordergrund einer <see cref="T:System.Windows.Controls.Page" /> ab oder legt diesen fest.</summary>
        <value>Der <see cref="T:System.Windows.Media.Brush" /> mit dem die <see cref="T:System.Windows.Controls.Page" /> ihren Vordergrund zeichnet. Der Standardwert ist <see cref="P:System.Windows.Media.Brushes.Black" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageForeground"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.ForegroundProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.Foreground" />-Abhängigkeitseigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bezeichner für die <xref:System.Windows.Controls.Page.Foreground%2A>-Abhängigkeitseigenschaft.  
  
   
  
## Examples  
 [Übersicht über Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Windows.Controls.Page" />-Instanz in Navigationsverlauf beibehalten wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="T:System.Windows.Controls.Page" />-Instanz im Navigationsverlauf beibehalten wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Seite zuerst navigiert wird, eine neue Instanz der dem <xref:System.Windows.Controls.Page> Klasse erstellt wird. Wenn eine Seite aus (zurück oder vorwärts) navigiert wird, wird ein Eintrag für die Seite Navigationsverlauf hinzugefügt. Standardmäßig verweist der Eintrag nicht Page-Objekt. Stattdessen enthält der Eintrag einen Pack uniform Resource Identifier (URI) für die Seite. Wenn der Eintrag für die Seite mit Navigationsverlauf navigiert wird, wird der Paket-URI verwendet, um eine neue Instanz der Seite zu erstellen. Dieses Verhalten ist die Standardeinstellung, vermeiden Sie übermäßige arbeitsspeichernutzung: Seiteninstanzen beibehalten Arbeitsspeicher, speziell jene mit einem nicht trivialen Menge an Inhalten schnell verarbeiten kann. Dieses Problem wird durch die Tatsache erweitert, dass es keine Beschränkung für die Anzahl von Einträgen, die in der Rückseite gespeichert werden können und forward Aufruflisten von Navigationsverlauf ist. Im Gegensatz dazu hat ein Speichern von Paket-URIs für Seiten praktisch keine Auswirkung auf den Arbeitsspeicherverbrauch.  
  
 Die wichtigste Nebeneffekt beim Erstellen neuer Instanzen einer Seite ist, dass die Seitenstatus nicht von einer Instanz von einer Seite beibehalten wird. In diesen Fällen bietet Windows Presentation Foundation verschiedene Techniken zum Erinnern an den Zustand auf.  
  
 Um eine Seite beizubehalten, legen Sie die <xref:System.Windows.Controls.Page.KeepAlive%2A> Eigenschaft `true` (die Standardeinstellung ist `false`).  
  
> [!NOTE]
>  Seiten, die instanziiert und navigiert zur Verwendung nur Code (z. B. durch Aufruf von <xref:System.Windows.Navigation.NavigationService.Navigate%2A>), werden automatisch beibehalten.  
  
 Vermeiden Sie die Einstellung <xref:System.Windows.Controls.Page.KeepAlive%2A> auf `true` es sei denn, Sie möchten:  
  
-   Wenn eine Seite viel Inhalt aufweist, dauert es sehr lange zum Instanziieren. Wenn die Seite wird nicht beibehalten, und die Seite häufig navigiert wird, kann die Kosten der ständig Instanziierung der Seite eine negative Auswirkung auf die benutzerfreundlichkeit auswirken. Sie sollten jedoch hinsichtlich der Leistung basieren auf den Standardeinstellungen und die Leistung Ihrer Anwendung ein Profil erstellen; Wenn Seiten testen mit Ladezeiten erkannt werden, die unter dem Bereich für Ihre Anwendung erforderliche liegen, möglicherweise die Konfigurieren der Seiten, beibehalten zu werden, dass eine Möglichkeit zur Behebung des Problems.  
  
> [!NOTE]
>  Einträge für Seiten, die beibehalten werden, werden nicht im Navigationsverlauf des beibehalten einer [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] , wenn ein Benutzer vom navigiert und dann wieder auf die [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]. Nur Journaleinträge für Seiten, die nicht beibehalten werden, werden im Navigationsverlauf beibehalten.  
  
<a name="dependencyPropertyInfo_PageKeepAlive"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.KeepAliveProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|Keiner|  
  
> [!NOTE]
>  Der Metadatentyp für diese Abhängigkeitseigenschaft ist <xref:System.Windows.PropertyMetadata>, nicht <xref:System.Windows.FrameworkPropertyMetadata>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] beibehalten eine Instanz von der <xref:System.Windows.Controls.Page> -Klasse über mehrere Navigationen hinweg.  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml2)]  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang2)]  
  
 [!code-csharp[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml.cs#setpagekeepalivecodebehind)]
 [!code-vb[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageKeepAliveSnippets/visualbasic/homepage.xaml.vb#setpagekeepalivecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.JournalEntry.KeepAlive" />
      </Docs>
    </Member>
    <Member MemberName="KeepAliveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty KeepAliveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty KeepAliveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.KeepAliveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeepAliveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ KeepAliveProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.KeepAlive" />-Abhängigkeitseigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bezeichner für die <xref:System.Windows.Controls.Page.KeepAlive%2A>-Abhängigkeitseigenschaft.  
  
   
  
## Examples  
 [Übersicht über Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen Enumerator für die logischen untergeordneten Elemente einer <see cref="T:System.Windows.Controls.Page" /> zurück.</summary>
        <value>Der <see cref="T:System.Collections.IEnumerator" /> für die logischen untergeordneten Elemente einer <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Der verfügbare Bereich, den das Fenster seinen untergeordneten Elementen zuordnen kann.</param>
        <summary>Misst die untergeordneten Elemente der <see cref="T:System.Windows.Controls.Page" />.</summary>
        <returns>Eine <see cref="T:System.Windows.Size" />, die die tatsächliche Größe des Fensters darstellt. Die Methode gibt möglicherweise einen größeren Wert zurück. In diesem Fall muss das übergeordnete Element Bildlaufleisten hinzufügen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NavigationService">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.NavigationService NavigationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Navigation.NavigationService NavigationService" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.NavigationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NavigationService As NavigationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Navigation::NavigationService ^ NavigationService { System::Windows::Navigation::NavigationService ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Navigationsdienst ab, den der Host der Seite zum Verwalten der Navigation verwendet.</summary>
        <value>Das <see cref="T:System.Windows.Navigation.NavigationService" />-Objekt, mit der Host der Seite die Navigation verwaltet, oder <see langword="null" />, wenn der Host keine Navigation unterstützt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Seiten aufgenommen werden können, indem mehrere Typen von Hosts, einschließlich <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, und ein Browser auf.  
  
 Seiten müssen oft für die Integration des Hosts Navigation im Seitennavigation unterstützen. Da eine Seite möglicherweise nicht ist zur Laufzeit werden die Hosts bekannt, kann nicht es jedoch direkt mit ihrem Host Navigation Mitgliedern dazu integrieren.  
  
 Sie können stattdessen versuchen, einen Navigationsdienst verwendet wird, einen Dienst, der im Webbrowserstil Navigation unterstützt und ist Teil von der <xref:System.Windows.Navigation.NavigationService> Klasse. Sie können nicht erstellt, eine eigene <xref:System.Windows.Navigation.NavigationService> Instanz, jedoch. Stattdessen Hosttypen wie <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, oder einen Browser erstellen ihre eigenen <xref:System.Windows.Navigation.NavigationService> -Instanz, die Sie zugreifen können die <xref:System.Windows.Controls.Page.NavigationService%2A> Eigenschaft.  
  
 Dem Navigationsdienst, die von zurückgegeben wird das <xref:System.Windows.Controls.Page.NavigationService%2A> Eigenschaft ist für die Instanz von der <xref:System.Windows.Navigation.NavigationService> -Klasse, die von der ersten Navigator in der visuellen Struktur verwaltet wird. Falls nicht vorhanden, `null` zurückgegeben wird, wird eine Seite Host unterstützt keine Navigation angibt.  
  
> [!NOTE]
>  Die <xref:System.Windows.Window> Klasse unterstützt keine Navigation und stellt keine Navigationsdienst bereit.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie eine Seite kann überprüfen, ob ein Navigationsdienst verfügbar ist und, wenn dies der Fall ist, verwenden, um zurück zur vorherigen Seite navigieren.  
  
 [!code-csharp[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageNavigationServiceSnippets/CSharp/HomePage.xaml.cs#getpagenavigationservicecodebehind)]
 [!code-vb[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageNavigationServiceSnippets/visualbasic/homepage.xaml.vb#getpagenavigationservicecodebehind)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTemplateChanged (oldTemplate As ControlTemplate, newTemplate As ControlTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTemplateChanged(System::Windows::Controls::ControlTemplate ^ oldTemplate, System::Windows::Controls::ControlTemplate ^ newTemplate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">Die alte Vorlage.</param>
        <param name="newTemplate">Die neue Vorlage.</param>
        <summary>Wird aufgerufen, wenn die Vorlage für eine <see cref="T:System.Windows.Controls.Page" /> geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siehe <xref:System.Windows.Controls.Control.OnTemplateChanged%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Page.Template" />
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Das bisherige übergeordnete Element. Wird auf <see langword="null" /> festgelegt, wenn das <see cref="T:System.Windows.DependencyObject" /> kein vorheriges übergeordnetes Element hat.</param>
        <summary>Wird aufgerufen, wenn das übergeordnete Element der <see cref="T:System.Windows.Controls.Page" /> geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.UIElement.OnVisualParentChanged%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das neue übergeordnete Element ist weder ein <see cref="T:System.Windows.Window" /> noch ein <see cref="T:System.Windows.Controls.Frame" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeShowsNavigationUI ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeShowsNavigationUI() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeShowsNavigationUI () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeShowsNavigationUI();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es abgeleiteten Klassen, das Serialisierungsverhalten der <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" />-Eigenschaft zu bestimmen.</summary>
        <returns>
          <see langword="true" />, wenn der Inhalt serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTitle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es abgeleiteten Klassen, das Serialisierungsverhalten der <see cref="P:System.Windows.Controls.Page.Title" />-Eigenschaft zu bestimmen.</summary>
        <returns>
          <see langword="true" />, wenn der Inhalt serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowHeight">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowHeight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowHeight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowHeight () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowHeight();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es abgeleiteten Klassen, das Serialisierungsverhalten der <see cref="P:System.Windows.Controls.Page.WindowHeight" />-Eigenschaft zu bestimmen.</summary>
        <returns>
          <see langword="true" />, wenn der Inhalt serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowTitle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es abgeleiteten Klassen, das Serialisierungsverhalten der <see cref="P:System.Windows.Controls.Page.WindowTitle" />-Eigenschaft zu bestimmen.</summary>
        <returns>
          <see langword="true" />, wenn der Inhalt serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowWidth">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowWidth ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowWidth() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowWidth () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowWidth();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es abgeleiteten Klassen, das Serialisierungsverhalten der <see cref="P:System.Windows.Controls.Page.WindowWidth" />-Eigenschaft zu bestimmen.</summary>
        <returns>
          <see langword="true" />, wenn der Inhalt serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShowsNavigationUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsNavigationUI" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.ShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowsNavigationUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowsNavigationUI { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Navigations-[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] eines <see cref="T:System.Windows.Navigation.NavigationWindow" /> in [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)] sichtbar ist, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn die Navigations-[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] eines Host-<see cref="T:System.Windows.Navigation.NavigationWindow" /> sichtbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationWindow> Zeigt die Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] werden standardmäßig im Webbrowserstil Rückwärtsrichtung Navigation aktivieren. Wenn eine Seite, als festgelegt ist die <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application> automatisch geöffnet wird, eine <xref:System.Windows.Navigation.NavigationWindow> zum Hosten der Seite. Wenn die Seite nicht die Standardeinstellung verwenden möchte <xref:System.Windows.Navigation.NavigationWindow> Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], er kann festgelegt <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> auf `false`.  
  
> [!NOTE]
>  Da [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] kann nicht mit der Navigation integrieren [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] für [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)], ermöglicht eine eigene Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], die angezeigt oder ausgeblendet, indem kann <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>. [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] lässt sich mit Integrieren der [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]so festlegen <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> auf Seiten im [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] hat keine Auswirkungen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] Ausblenden der Navigationsleiste [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] von einem <xref:System.Windows.Navigation.NavigationWindow>.  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml2)]  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang2)]  
  
 [!code-csharp[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml.cs#setpageshowsnavigationuicodebehind)]
 [!code-vb[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageShowsNavigationUISnippets/visualbasic/homepage.xaml.vb#setpageshowsnavigationuicodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" />-Eigenschaft wird bei einer <see cref="T:System.Windows.Controls.Page" />-Instanz untersucht, die nicht von einem <see cref="T:System.Windows.Window" />, einem <see cref="T:System.Windows.Navigation.NavigationWindow" /> oder einem Browser gehostet wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (obj As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ obj) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das hinzuzufügende untergeordnete Objekt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Windows.Markup.IAddChild.AddChild(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Controls.Page>-Instanz in eine <xref:System.Windows.Markup.IAddChild>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string str);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (str As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ str) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Der dem Objekt hinzuzufügende Text.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Windows.Markup.IAddChild.AddText(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Controls.Page>-Instanz in eine <xref:System.Windows.Markup.IAddChild>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Template">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ControlTemplate Template { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ControlTemplate Template" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Template" />
      <MemberSignature Language="VB.NET" Value="Public Property Template As ControlTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ControlTemplate ^ Template { System::Windows::Controls::ControlTemplate ^ get(); void set(System::Windows::Controls::ControlTemplate ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ControlTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Steuerelementvorlage für eine <see cref="T:System.Windows.Controls.Page" /> ab oder legt diese fest.</summary>
        <value>Das <see cref="T:System.Windows.Controls.ControlTemplate" /> für eine <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_ContentTemplate"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Template="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlValues_ContentTemplate"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *resourceExtension*  
 Eine Markuperweiterung, die Vorgehensweise der Dialogfeldvorlagen-Ressource verweisen, entweder identifiziert `StaticResource` oder `DynamicResource`. Finden Sie unter [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Der Schlüssel, der die angeforderte Vorlagenauswahl identifiziert. Der Schlüssel verweist auf eine vorhandene Ressource in einem <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Eigenschaftenelementsyntax ist technisch zwar möglich, aber nicht empfehlenswert. Weitere Informationen finden Sie unter [Inline-Stile und Vorlagen](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  
  
<a name="dependencyPropertyInfo_PageTemplate"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.TemplateProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TemplateProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.Template" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Titel für das <see cref="T:System.Windows.Controls.Page" /> ab oder legt diesen fest.</summary>
        <value>Der Titel der <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des der <xref:System.Windows.Controls.Page.Title%2A> Eigenschaft wird nicht angezeigt, indem <xref:System.Windows.Controls.Page>, noch in der Titelleiste des Fensters, das gehostet wird angezeigt ein <xref:System.Windows.Controls.Page>. Legen Sie stattdessen <xref:System.Windows.Controls.Page.WindowTitle%2A> so ändern Sie den Titel eines Fensters Host.  
  
 <xref:System.Windows.Controls.Page.Title%2A> kann auch verwendet werden, um den Namen des Eintrags im Navigationsverlauf für ein Inhaltselement Navigation zu generieren. Die folgenden Teile der Daten werden verwendet, um automatisch der Name eines Eintrags in der Rangfolge Navigation erstellt:  
  
-   Der angefügte <xref:System.Windows.Navigation.JournalEntry.Name%2A> Attribut.  
  
-   Die <xref:System.Windows.Controls.Page.Title%2A>-Eigenschaft  
  
-   Die <xref:System.Windows.Controls.Page.WindowTitle%2A> Eigenschaft und die [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] für die aktuelle Seite  
  
-   [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] für die aktuelle Seite.  
  
 Wenn Sie verknüpft haben eine <xref:System.Windows.Navigation.CustomContentState> Objekt mit einem Inhaltselement im Navigationsverlauf, können Sie den angezeigten Namen in den Eintrag im Navigationsverlauf angeben, durch Überschreiben <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_PageTitle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Page.TitleProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|Keiner|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Page.Title" />-Abhängigkeitseigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bezeichner für die <xref:System.Windows.Controls.Page.Title%2A>-Abhängigkeitseigenschaft.  
  
   
  
## Examples  
 [Übersicht über Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public double WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowHeight { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe des Host-<see cref="T:System.Windows.Window" /> oder des Host-<see cref="T:System.Windows.Navigation.NavigationWindow" /> einer <see cref="T:System.Windows.Controls.Page" /> ab oder legt diese fest.</summary>
        <value>Die Höhe eines Fensters, das eine <see cref="T:System.Windows.Controls.Page" /> direkt hostet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowHeight%2A> wird nur angewendet, wenn eine <xref:System.Windows.Controls.Page> direkt von einem Fenster, einschließlich gehostet wird:  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 Wenn eine <xref:System.Windows.Controls.Page> gehostet wird, indem Sie eine <xref:System.Windows.Controls.Frame>wird durch das Festlegen <xref:System.Windows.Controls.Page.WindowHeight%2A> hat keine Auswirkungen, aber Sie erhalten weiterhin den Wert des <xref:System.Windows.Controls.Page.WindowHeight%2A>.  
  
 Ein <xref:System.Windows.Controls.Page> in einer [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] können nur <xref:System.Windows.Controls.Page.WindowHeight%2A> so ändern Sie die Höhe des [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; die Höhe kann nicht geändert werden, indem <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.MinHeight%2A>, oder <xref:System.Windows.FrameworkElement.MaxHeight%2A>.  
  
 Die Mindesthöhe der [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] Fenster beträgt 150 Pixel. Für Seiten die in einem Browser gehostet werden, bedeutet dies, dass den Wert der <xref:System.Windows.Controls.Page.WindowHeight%2A> können nicht angewendet werden, wenn sie die Höhe des verursachen würde die [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] Fenster aus, um weniger als 150 Pixel betragen.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie die Höhe eines Fensters von einer Seite festgelegt werden.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowHeightPage.xaml#setpagewindowheightxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowTitle">
      <MemberSignature Language="C#" Value="public string WindowTitle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WindowTitle { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Titel des Host-<see cref="T:System.Windows.Window" /> oder des Host-<see cref="T:System.Windows.Navigation.NavigationWindow" /> einer <see cref="T:System.Windows.Controls.Page" /> ab oder legt diesen fest.</summary>
        <value>Der Titel eines Fensters, das die <see cref="T:System.Windows.Controls.Page" /> direkt hostet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird der Titel eines Fensters, das eine Seite hostet einschließlich <xref:System.Windows.Navigation.NavigationWindow> und [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], ist der Name der Datei, die derzeit gehostet wird (mit einer XAML-Dateien, wenn die Seite lose ist [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], oder eine Erweiterung ".xbap", wenn die Seite Teil einer ist[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).  
  
 Eine Seite kann die Standardeinstellung ändern, indem Festlegen seiner <xref:System.Windows.Controls.Page.WindowTitle%2A> Eigenschaft.  
  
 Sobald eine Seite der Titel eines Fensters auf diese Weise legt fest, das Window-Titel ändert sich nicht, bis eine andere Seite legt <xref:System.Windows.Controls.Page.WindowTitle%2A> mit einem anderen Wert.  
  
> [!NOTE]
>  Die <xref:System.Windows.Controls.Page> muss das oberste Element in einem Fenster für Inhalt <xref:System.Windows.Controls.Page.WindowTitle%2A> ; Wenn wirksam ein <xref:System.Windows.Controls.Page> gehostet wird, innerhalb einer <xref:System.Windows.Controls.Frame>, z. B. <xref:System.Windows.Controls.Page.WindowTitle%2A> ändert sich nicht auf den Titel des Hostfensters.  
  
 <xref:System.Windows.Controls.Page.WindowTitle%2A> kann auch verwendet werden, um den Namen des Eintrags im Navigationsverlauf für ein Inhaltselement Navigation zu generieren. Die folgenden Teile der Daten werden verwendet, um automatisch der Name eines Eintrags in der Rangfolge Navigation erstellt:  
  
-   Der angefügte <xref:System.Windows.Navigation.JournalEntry.Name%2A> Attribut.  
  
-   Die <xref:System.Windows.Controls.Page.Title%2A>-Eigenschaft  
  
-   Die <xref:System.Windows.Controls.Page.WindowTitle%2A> Eigenschaft und die [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] für die aktuelle Seite  
  
-   [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] für die aktuelle Seite.  
  
 Wenn Sie verknüpft haben eine <xref:System.Windows.Navigation.CustomContentState> Objekt mit der ein Inhaltselement im Navigationsverlauf, können Sie die Name-Wert eines Elements Verlauf angeben, durch Überschreiben <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie den Titel eines Fensters von einer Seite festgelegt werden.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowTitleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowTitlePage.xaml#setpagewindowtitlexaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public double WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowWidth { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Breite des Host-<see cref="T:System.Windows.Window" /> oder des Host-<see cref="T:System.Windows.Navigation.NavigationWindow" /> einer <see cref="T:System.Windows.Controls.Page" /> ab oder legt diese fest.</summary>
        <value>Die Breite eines Fensters, das eine <see cref="T:System.Windows.Controls.Page" /> direkt hostet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowWidth%2A> wird nur angewendet, wenn eine <xref:System.Windows.Controls.Page> direkt von einem Fenster, einschließlich gehostet wird:  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 Wenn eine <xref:System.Windows.Controls.Page> gehostet wird, indem Sie eine <xref:System.Windows.Controls.Frame>wird durch das Festlegen <xref:System.Windows.Controls.Page.WindowWidth%2A> hat keine Auswirkungen, aber Sie erhalten weiterhin den Wert des <xref:System.Windows.Controls.Page.WindowWidth%2A>.  
  
 Ein <xref:System.Windows.Controls.Page> in einer [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] können nur <xref:System.Windows.Controls.Page.WindowWidth%2A> so ändern Sie die Breite des [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; die Breite kann nicht geändert werden, indem <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, oder <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  
  
 Die minimale Breite der [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] Fenster beträgt 250 Pixel. Für Seiten die in einem Browser gehostet werden, bedeutet dies, dass den Wert der <xref:System.Windows.Controls.Page.WindowWidth%2A> können nicht angewendet werden, wenn sie die Gesamtbreite der verursachen würde die [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] Fenster aus, um weniger als 250 Pixel betragen.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie die Breite eines Fensters von einer Seite festgelegt werden.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowWidthXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowWidthPage.xaml#setpagewindowwidthxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>