<Type Name="ScrollViewer" FullName="System.Windows.Controls.ScrollViewer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="15b26a45c171bcb272263621f5cb45888027f6cb" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75113250" /></Metadata><TypeSignature Language="C#" Value="public class ScrollViewer : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScrollViewer extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.ScrollViewer" />
  <TypeSignature Language="VB.NET" Value="Public Class ScrollViewer&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScrollViewer : System::Windows::Controls::ContentControl" />
  <TypeSignature Language="F#" Value="type ScrollViewer = class&#xA;    inherit ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("ScrollChangedEvent")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.TemplatePart(Name="PART_HorizontalScrollBar", Type=typeof(System.Windows.Controls.Primitives.ScrollBar))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.TemplatePart(Name="PART_VerticalScrollBar", Type=typeof(System.Windows.Controls.Primitives.ScrollBar))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.TemplatePart(Name="PART_ScrollContentPresenter", Type=typeof(System.Windows.Controls.ScrollContentPresenter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Bereich mit scrollbarem Fensterinhalt dar, der weitere sichtbare Elemente enthalten kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Controls.ScrollViewer> ermöglicht, dass Inhalte in einem kleineren Bereich als der tatsächlichen Größe angezeigt werden.  Wenn der Inhalt des <xref:System.Windows.Controls.ScrollViewer> nicht vollständig sichtbar ist, zeigt der <xref:System.Windows.Controls.ScrollViewer> Scrollleisten an, die der Benutzer zum Verschieben der sichtbaren Inhaltsbereiche verwenden kann.  Der Bereich, der den gesamten Inhalt der <xref:System.Windows.Controls.ScrollViewer> enthält, ist der Block.  Der sichtbare Bereich des Inhalts ist der Viewport.  
  
 Das physische Scrollen wird zum Scrollen durch Inhalt anhand eines vordefinierten physischen Werts verwendet – in der Regel durch einen Wert in Pixel. Das logische Scrollen wird verwendet, um zum nächsten Element in einer logischen Struktur zu scrollen. Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest. Physischer Bildlauf ist das Standardbild Laufverhalten für die meisten <xref:System.Windows.Controls.Panel> Elemente.  
  
 Wenn Ihr <xref:System.Windows.Controls.ScrollViewer> eine große Anzahl von Elementen enthält, kann die scrollleistung beeinträchtigt sein.  Legen Sie in diesem Fall <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> auf `true`fest.  Dies bewirkt, dass die Inhaltsansicht statisch bleibt, während die <xref:System.Windows.Controls.Primitives.Thumb> gezogen und nur aktualisiert wird, wenn die <xref:System.Windows.Controls.Primitives.Thumb> freigegeben wird.  
  
 Da die Bild Lauf leisten für ein <xref:System.Windows.Controls.ScrollViewer> Element im Standardstil des-Elements definiert sind, werden Scrollleisten nicht mehr angezeigt, wenn Sie einen benutzerdefinierten Stil auf einen <xref:System.Windows.Controls.ScrollViewer>anwenden. Scrollleisten müssen im benutzerdefinierten Stil definiert werden, damit Sie angezeigt werden.  
  
## <a name="customizing-the-scrollviewer-control"></a>Anpassen des ScrollViewer-Steuer Elements  
 Um dieselben Eigenschaften Einstellungen auf mehrere <xref:System.Windows.Controls.ScrollViewer> Steuerelemente anzuwenden, verwenden Sie die <xref:System.Windows.FrameworkElement.Style%2A>-Eigenschaft. Sie können die Standard <xref:System.Windows.Controls.ControlTemplate> ändern, um dem Steuerelement eine eindeutige Darstellung zu verschaffen. Weitere Informationen zum Erstellen eines <xref:System.Windows.Controls.ControlTemplate>finden Sie unter [Anpassen der Darstellung eines vorhandenen Steuer Elements durch Erstellen einer ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Informationen zu den für die <xref:System.Windows.Controls.ScrollViewer>spezifischen Teilen und Zuständen finden Sie unter [ScrollViewer-Stile und-Vorlagen](~/docs/framework/wpf/controls/scrollviewer-styles-and-templates.md).  
  
 Abhängigkeits Eigenschaften für dieses Steuerelement können durch den Standardstil des Steuer Elements festgelegt werden.  Wenn eine Eigenschaft durch einen Standardstil festgelegt wird, kann sich die Eigenschaft von ihrem Standardwert ändern, wenn das Steuerelement in der Anwendung angezeigt wird. Der Standardstil wird bestimmt, welches Desktop Design verwendet wird, wenn die Anwendung ausgeführt wird.  Weitere Informationen finden Sie unter [standardmäßige WPF](https://go.microsoft.com/fwlink/?LinkID=158252)-Designs.  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.Controls.ScrollViewer> erstellt, die Text und ein Rechteck enthält. Die Bild Lauf leisten werden nur angezeigt, wenn Sie benötigt werden. Wenn Sie die Größe des Fensters ändern, werden die Schiebe leisten angezeigt und verschwinden.  
  
 [!code-cpp[ScrollViewer#1](~/samples/snippets/cpp/VS_Snippets_Wpf/ScrollViewer/CPP/ScrollViewer_wcp.cpp#1)]
 [!code-csharp[ScrollViewer#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollViewer/CSharp/ScrollViewer_wcp.cs#1)]
 [!code-vb[ScrollViewer#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollViewer/VisualBasic/ScrollViewer.vb#1)]
 [!code-xaml[ScrollViewer#1](~/samples/snippets/xaml/VS_Snippets_Wpf/ScrollViewer/XAML/Pane1.xaml#1)]  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160053">Beispiel für WPF-Steuerelemente Gallery</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScrollViewer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScrollViewer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.ScrollViewer" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeSize);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="scrollViewer.ArrangeOverride arrangeSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeSize" Type="System.Windows.Size" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="arrangeSize">Der letzte Bereich im übergeordneten Element, den dieses Element verwenden soll, um sich selbst und seine untergeordneten Elemente anzuordnen.</param>
        <summary>Ordnet den Inhalt der <see cref="T:System.Windows.Controls.ScrollViewer" /> an.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Controls.ScrollViewer.ArrangeOverride(System.Windows.Size)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Controls.ScrollViewer.ArrangeOverride(System.Windows.Size)" />-Methode der Basisklasse aufzurufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="CanContentScroll">
      <MemberSignature Language="C#" Value="public bool CanContentScroll { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanContentScroll" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.CanContentScroll" />
      <MemberSignature Language="VB.NET" Value="Public Property CanContentScroll As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanContentScroll { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanContentScroll : bool with get, set" Usage="System.Windows.Controls.ScrollViewer.CanContentScroll" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Elemente, die die <see cref="T:System.Windows.Controls.Primitives.IScrollInfo" />-Schnittstelle unterstützen, bildlauffähig sind, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Windows.Controls.ScrollViewer" /> einen Bildlauf hinsichtlich logischer Einheiten ausführt; <see langword="false" />, wenn der <see cref="T:System.Windows.Controls.ScrollViewer" /> einen Bildlauf hinsichtlich physikalischer Einheiten ausführt. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Inhalt einer <xref:System.Windows.Controls.ScrollViewer> kann in Form physischer Einheiten oder logischer Einheiten gescrollt werden. Physische Einheiten sind geräteunabhängige Pixel. Logische Einheiten werden für das Scrollen von Elementen innerhalb einer <xref:System.Windows.Controls.ItemsControl>verwendet. Das Standardverhalten des <xref:System.Windows.Controls.ScrollViewer> ist die Verwendung physischer Einheiten, um einen Bildlauf für den Inhalt durchführen zu können. In Fällen, in denen die <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `true`festgelegt ist, kann der Inhalt jedoch logische Einheiten zum Scrollen verwenden. Beispielsweise können <xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.ListView>und andere Steuerelemente, die von Erben <xref:System.Windows.Controls.ItemsControl> logische Einheiten zum Scrollen verwenden. Wenn <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> `true`ist, sind die Werte der Eigenschaften <xref:System.Windows.Controls.ScrollViewer.ExtentHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ScrollableHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ViewportHeight%2A>und <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> die Anzahl der Elemente anstelle physischer Einheiten.  
  
 Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest. Physischer Bildlauf ist das Standardbild Laufverhalten für die meisten <xref:System.Windows.Controls.Panel> Elemente.  
  
<a name="dependencyPropertyInfo_CanContentScroll"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ScrollViewer.CanContentScrollProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A>-Eigenschaft mithilfe von Code festgelegt wird.  
  
 [!code-csharp[scrollchangedeventargsLayout#4](~/samples/snippets/csharp/VS_Snippets_Wpf/scrollchangedeventargsLayout/CSharp/Window1.xaml.cs#4)]
 [!code-vb[scrollchangedeventargsLayout#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/scrollchangedeventargsLayout/VisualBasic/Window1.xaml.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanContentScrollProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CanContentScrollProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CanContentScrollProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.CanContentScrollProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CanContentScrollProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CanContentScrollProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CanContentScrollProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.CanContentScrollProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.CanContentScroll" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.CanContentScroll" />
      </Docs>
    </Member>
    <Member MemberName="ComputedHorizontalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public System.Windows.Visibility ComputedHorizontalScrollBarVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Visibility ComputedHorizontalScrollBarVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ComputedHorizontalScrollBarVisibility As Visibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Visibility ComputedHorizontalScrollBarVisibility { System::Windows::Visibility get(); };" />
      <MemberSignature Language="F#" Value="member this.ComputedHorizontalScrollBarVisibility : System.Windows.Visibility" Usage="System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Visibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die horizontale <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> sichtbar ist.</summary>
        <value>Eine <see cref="T:System.Windows.Visibility" />, die angibt, ob die horizontale Schiebeleiste sichtbar ist. Der Standardwert ist <see cref="F:System.Windows.Controls.ScrollBarVisibility.Hidden" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ComputedHorizontalScrollBarVisibility"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibilityProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ScrollBar" />
      </Docs>
    </Member>
    <Member MemberName="ComputedHorizontalScrollBarVisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ComputedHorizontalScrollBarVisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ComputedHorizontalScrollBarVisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ComputedHorizontalScrollBarVisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ComputedHorizontalScrollBarVisibilityProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ComputedHorizontalScrollBarVisibilityProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibilityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibility" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibility" />
      </Docs>
    </Member>
    <Member MemberName="ComputedVerticalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public System.Windows.Visibility ComputedVerticalScrollBarVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Visibility ComputedVerticalScrollBarVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ComputedVerticalScrollBarVisibility As Visibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Visibility ComputedVerticalScrollBarVisibility { System::Windows::Visibility get(); };" />
      <MemberSignature Language="F#" Value="member this.ComputedVerticalScrollBarVisibility : System.Windows.Visibility" Usage="System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Visibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die vertikale <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> sichtbar ist.</summary>
        <value>Eine <see cref="T:System.Windows.Visibility" />, die angibt, ob die vertikale Schiebeleiste sichtbar ist. Der Standardwert ist <see cref="F:System.Windows.Controls.ScrollBarVisibility.Visible" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ComputedVerticalScrollBarVisibility"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibilityProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ScrollBar" />
      </Docs>
    </Member>
    <Member MemberName="ComputedVerticalScrollBarVisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ComputedVerticalScrollBarVisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ComputedVerticalScrollBarVisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ComputedVerticalScrollBarVisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ComputedVerticalScrollBarVisibilityProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ComputedVerticalScrollBarVisibilityProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibilityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibility" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibility" />
      </Docs>
    </Member>
    <Member MemberName="ContentHorizontalOffset">
      <MemberSignature Language="C#" Value="public double ContentHorizontalOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ContentHorizontalOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ContentHorizontalOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentHorizontalOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ContentHorizontalOffset { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentHorizontalOffset : double" Usage="System.Windows.Controls.ScrollViewer.ContentHorizontalOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den horizontalen Offset des sichtbaren Inhalts ab.</summary>
        <value>Der horizontale Offset des sichtbaren Inhalts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> `true`ist, wird ein Rollup des Inhalts ausgeführt, wenn der Benutzer die <xref:System.Windows.Controls.Primitives.Thumb> der <xref:System.Windows.Controls.Primitives.ScrollBar>freigibt.  Wenn der Benutzer den <xref:System.Windows.Controls.Primitives.Thumb>zieht, wird der <xref:System.Windows.Controls.ScrollViewer.ContentHorizontalOffset%2A> Wert nicht geändert.   Wenn der Benutzer die <xref:System.Windows.Controls.Primitives.Thumb>freigibt, <xref:System.Windows.Controls.ScrollViewer.ContentHorizontalOffset%2A> Updates auf den aktuellen <xref:System.Windows.Controls.ScrollViewer.HorizontalOffset%2A> Wert.  
  
 Wenn <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> `false`ist, wird ein Rollup des Inhalts durchgeführt, wenn der Benutzer den <xref:System.Windows.Controls.Primitives.Thumb>zieht.  In diesem Fall ist <xref:System.Windows.Controls.ScrollViewer.ContentVerticalOffset%2A> immer gleich <xref:System.Windows.Controls.ScrollViewer.HorizontalOffset%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentHorizontalOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContentHorizontalOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContentHorizontalOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ContentHorizontalOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContentHorizontalOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContentHorizontalOffsetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContentHorizontalOffsetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.ContentHorizontalOffsetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.ContentHorizontalOffset" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentVerticalOffset">
      <MemberSignature Language="C#" Value="public double ContentVerticalOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ContentVerticalOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ContentVerticalOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentVerticalOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ContentVerticalOffset { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentVerticalOffset : double" Usage="System.Windows.Controls.ScrollViewer.ContentVerticalOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vertikalen Offset des sichtbaren Inhalts ab.</summary>
        <value>Der vertikale Offset des sichtbaren Inhalts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> `true`ist, wird ein Rollup des Inhalts ausgeführt, wenn der Benutzer die <xref:System.Windows.Controls.Primitives.Thumb> der <xref:System.Windows.Controls.Primitives.ScrollBar>freigibt.  Wenn der Benutzer den <xref:System.Windows.Controls.Primitives.Thumb>zieht, ändert sich das <xref:System.Windows.Controls.ScrollViewer.ContentVerticalOffset%2A> nicht.  Wenn der Benutzer die <xref:System.Windows.Controls.Primitives.Thumb>freigibt, <xref:System.Windows.Controls.ScrollViewer.ContentVerticalOffset%2A> Updates auf den aktuellen <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> Wert.  
  
 Wenn <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> `false`ist, wird ein Rollup des Inhalts durchgeführt, wenn der Benutzer den <xref:System.Windows.Controls.Primitives.Thumb>zieht.  In diesem Fall ist <xref:System.Windows.Controls.ScrollViewer.ContentVerticalOffset%2A> immer gleich <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentVerticalOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContentVerticalOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContentVerticalOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ContentVerticalOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContentVerticalOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContentVerticalOffsetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContentVerticalOffsetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.ContentVerticalOffsetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.ContentVerticalOffset" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtentHeight">
      <MemberSignature Language="C#" Value="public double ExtentHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ExtentHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ExtentHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtentHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ExtentHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtentHeight : double" Usage="System.Windows.Controls.ScrollViewer.ExtentHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die vertikale Größe des Wertebereichs enthält.</summary>
        <value>Ein <see cref="T:System.Double" />-Wert, der die vertikale Größe des Wertebereichs enthält. Der Standardwert ist 0,0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ScrollViewer.ExtentHeight%2A> ist nur eine Ausgabe Eigenschaft. Sie kann effektiv festgelegt werden, indem die <xref:System.Windows.FrameworkElement.Height%2A> des Content-Elements angegeben wird.  
  
 Wenn <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> `true`ist, sind die Werte der Eigenschaften <xref:System.Windows.Controls.ScrollViewer.ExtentHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ScrollableHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ViewportHeight%2A>und <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> die Anzahl der Elemente. Wenn <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> `false`ist, sind die Werte dieser Eigenschaften geräteunabhängige Pixel.  
  
<a name="dependencyPropertyInfo_ExtentHeight"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ScrollViewer.ExtentHeightProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtentHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ExtentHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ExtentHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ExtentHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ExtentHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ExtentHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ExtentHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.ExtentHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.ExtentHeight" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ExtentHeight" />
      </Docs>
    </Member>
    <Member MemberName="ExtentWidth">
      <MemberSignature Language="C#" Value="public double ExtentWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ExtentWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ExtentWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtentWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ExtentWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtentWidth : double" Usage="System.Windows.Controls.ScrollViewer.ExtentWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die horizontale Größe des Wertebereichs enthält.</summary>
        <value>Ein <see cref="T:System.Double" />-Wert, der die horizontale Größe des Wertebereichs darstellt. Der Standardwert ist 0,0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ScrollViewer.ExtentWidth%2A> ist nur eine Ausgabe Eigenschaft. Sie kann effektiv festgelegt werden, indem die <xref:System.Windows.FrameworkElement.Width%2A> des Content-Elements angegeben wird.  
  
 Der zurückgegebene Wert wird in geräteunabhängigen Pixeln beschrieben.  
  
<a name="dependencyPropertyInfo_ExtentWidth"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ScrollViewer.ExtentWidthProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtentWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ExtentWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ExtentWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ExtentWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ExtentWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ExtentWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ExtentWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.ExtentWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.ExtentWidth" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ExtentWidth" />
      </Docs>
    </Member>
    <Member MemberName="GetCanContentScroll">
      <MemberSignature Language="C#" Value="public static bool GetCanContentScroll (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetCanContentScroll(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.GetCanContentScroll(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCanContentScroll (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetCanContentScroll(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetCanContentScroll : System.Windows.DependencyObject -&gt; bool" Usage="System.Windows.Controls.ScrollViewer.GetCanContentScroll element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, aus dem der Eigenschaftswert gelesen wird.</param>
        <summary>Ruft den Wert der <see cref="P:System.Windows.Controls.ScrollViewer.CanContentScroll" />-Abhängigkeitseigenschaft aus einem angegebenen Element ab.</summary>
        <returns><see langword="true" />, wenn dieses Element einen Bildlauf durchführen kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHorizontalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.ScrollBarVisibility GetHorizontalScrollBarVisibility (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Controls.ScrollBarVisibility GetHorizontalScrollBarVisibility(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.GetHorizontalScrollBarVisibility(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHorizontalScrollBarVisibility (element As DependencyObject) As ScrollBarVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::ScrollBarVisibility GetHorizontalScrollBarVisibility(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetHorizontalScrollBarVisibility : System.Windows.DependencyObject -&gt; System.Windows.Controls.ScrollBarVisibility" Usage="System.Windows.Controls.ScrollViewer.GetHorizontalScrollBarVisibility element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ScrollBarVisibility</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, aus dem der Eigenschaftswert gelesen wird.</param>
        <summary>Ruft den Wert der <see cref="P:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility" />-Abhängigkeitseigenschaft aus einem angegebenen Element ab.</summary>
        <returns>Der Wert der <see cref="P:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility" />-Abhängigkeitseigenschaft.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsDeferredScrollingEnabled">
      <MemberSignature Language="C#" Value="public static bool GetIsDeferredScrollingEnabled (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetIsDeferredScrollingEnabled(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.GetIsDeferredScrollingEnabled(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIsDeferredScrollingEnabled (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetIsDeferredScrollingEnabled(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetIsDeferredScrollingEnabled : System.Windows.DependencyObject -&gt; bool" Usage="System.Windows.Controls.ScrollViewer.GetIsDeferredScrollingEnabled element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Objekt, aus dem <see cref="P:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled" /> abgerufen werden soll.</param>
        <summary>Gibt den Wert der <see cref="P:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled" />-Eigenschaft des angegebenen Objekts zurück.</summary>
        <returns><see langword="true" />, wenn der Inhalt feststehend bleibt, wenn der Benutzer den <see cref="T:System.Windows.Controls.Primitives.Thumb" /> einer <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zieht, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPanningDeceleration">
      <MemberSignature Language="C#" Value="public static double GetPanningDeceleration (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetPanningDeceleration(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.GetPanningDeceleration(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPanningDeceleration (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetPanningDeceleration(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetPanningDeceleration : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Controls.ScrollViewer.GetPanningDeceleration element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, aus dem der Eigenschaftswert gelesen wird.</param>
        <summary>Gibt den Wert der <see cref="P:System.Windows.Controls.ScrollViewer.PanningDeceleration" />-Eigenschaft des angegebenen Objekts zurück.</summary>
        <returns>Die Auswertung als <see cref="T:System.Windows.Controls.ScrollViewer" /> verlangsamt sich in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] pro Millisekunde im Quadrat.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPanningMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.PanningMode GetPanningMode (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Controls.PanningMode GetPanningMode(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.GetPanningMode(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPanningMode (element As DependencyObject) As PanningMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::PanningMode GetPanningMode(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetPanningMode : System.Windows.DependencyObject -&gt; System.Windows.Controls.PanningMode" Usage="System.Windows.Controls.ScrollViewer.GetPanningMode element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.PanningMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, aus dem der Eigenschaftswert gelesen wird.</param>
        <summary>Gibt den Wert der <see cref="P:System.Windows.Controls.ScrollViewer.PanningMode" />-Eigenschaft des angegebenen Objekts zurück.</summary>
        <returns>Ein Wert, der angibt, wie <see cref="T:System.Windows.Controls.ScrollViewer" /> auf Fingereingabemanipulationen reagiert.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPanningRatio">
      <MemberSignature Language="C#" Value="public static double GetPanningRatio (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetPanningRatio(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.GetPanningRatio(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPanningRatio (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetPanningRatio(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetPanningRatio : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Controls.ScrollViewer.GetPanningRatio element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, aus dem der Eigenschaftswert gelesen wird.</param>
        <summary>Gibt den Wert der <see cref="P:System.Windows.Controls.ScrollViewer.PanningRatio" />-Eigenschaft des angegebenen Objekts zurück.</summary>
        <returns>Das Verhältnis des Bildlaufoffsets, mit dem Manipulationsoffsets übersetzt werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVerticalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.ScrollBarVisibility GetVerticalScrollBarVisibility (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Controls.ScrollBarVisibility GetVerticalScrollBarVisibility(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.GetVerticalScrollBarVisibility(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVerticalScrollBarVisibility (element As DependencyObject) As ScrollBarVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::ScrollBarVisibility GetVerticalScrollBarVisibility(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetVerticalScrollBarVisibility : System.Windows.DependencyObject -&gt; System.Windows.Controls.ScrollBarVisibility" Usage="System.Windows.Controls.ScrollViewer.GetVerticalScrollBarVisibility element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ScrollBarVisibility</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, aus dem der Eigenschaftswert gelesen wird.</param>
        <summary>Ruft den Wert der <see cref="P:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibility" />-Abhängigkeitseigenschaft aus einem angegebenen Element ab.</summary>
        <returns>Der Wert der <see cref="P:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibility" />-Abhängigkeitseigenschaft.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandlesScrolling">
      <MemberSignature Language="C#" Value="protected internal override bool HandlesScrolling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HandlesScrolling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.HandlesScrolling" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property HandlesScrolling As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool HandlesScrolling { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HandlesScrolling : bool" Usage="System.Windows.Controls.ScrollViewer.HandlesScrolling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, dass im Stil eines Steuerelements ein <see cref="T:System.Windows.Controls.ScrollViewer" /> definiert ist, der das benutzerdefinierte Tastaturbildlaufverhalten festlegt.</summary>
        <value><see langword="true" />, wenn für dieses Steuerelement das benutzerdefinierte Tastaturbildlaufverhalten definiert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft `true`zurückgibt, wird die Tastatureingabe nicht vom <xref:System.Windows.Controls.ScrollViewer>behandelt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="override this.HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult" Usage="scrollViewer.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">Die Parameter für Treffertests in einem visuellen Objekt.</param>
        <summary>Führt einen Treffertest aus, um zu bestimmen, ob die angegebenen Punkte innerhalb der Grenzen dieses <see cref="T:System.Windows.Controls.ScrollViewer" /> liegen.</summary>
        <returns>Das Ergebnis des Treffertests.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalOffset">
      <MemberSignature Language="C#" Value="public double HorizontalOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 HorizontalOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.HorizontalOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HorizontalOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double HorizontalOffset { double get(); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalOffset : double" Usage="System.Windows.Controls.ScrollViewer.HorizontalOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den horizontalen Offset des gescrollten Inhalts enthält.</summary>
        <value>Der <see cref="T:System.Double" />-Wert, der den horizontalen Offset des gescrollten Inhalts darstellt. Der Standardwert ist 0,0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein positiver <xref:System.Windows.Controls.ScrollViewer.HorizontalOffset%2A> Wert entspricht dem Inhalt, der auf der linken Seite versetzt wird.  
  
 Gültige Werte liegen zwischen 0 (null) und dem <xref:System.Windows.Controls.ScrollViewer.ExtentWidth%2A>-Wert minus dem <xref:System.Windows.Controls.ScrollViewer.ViewportWidth%2A>-Wert.  
  
 Der zurückgegebene Wert wird in geräteunabhängigen Pixeln beschrieben.  
  
 Beginnend mit der .NET Framework Version 3,5 SP1, wenn <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> `true`ist, ändern sich <xref:System.Windows.Controls.ScrollViewer.HorizontalOffset%2A> weiterhin, wenn der Benutzer den <xref:System.Windows.Controls.Primitives.Thumb>zieht, aber die Inhaltsansicht ändert sich erst, wenn die <xref:System.Windows.Controls.Primitives.Thumb> freigegeben wurde.  In diesem Fall stellt <xref:System.Windows.Controls.ScrollViewer.ContentHorizontalOffset%2A> den sichtbaren Inhalts Offset dar und <xref:System.Windows.Controls.ScrollViewer.HorizontalOffset%2A> den Inhalts Offset basierend auf der <xref:System.Windows.Controls.Primitives.Thumb> Position darstellt.  
  
<a name="dependencyPropertyInfo_HorizontalOffset"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ScrollViewer.HorizontalOffsetProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.HorizontalOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalOffsetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalOffsetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.HorizontalOffsetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.HorizontalOffset" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.HorizontalOffset" />
      </Docs>
    </Member>
    <Member MemberName="HorizontalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ScrollBarVisibility HorizontalScrollBarVisibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.ScrollBarVisibility HorizontalScrollBarVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalScrollBarVisibility As ScrollBarVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ScrollBarVisibility HorizontalScrollBarVisibility { System::Windows::Controls::ScrollBarVisibility get(); void set(System::Windows::Controls::ScrollBarVisibility value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalScrollBarVisibility : System.Windows.Controls.ScrollBarVisibility with get, set" Usage="System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ScrollBarVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine horizontale <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> angezeigt werden soll, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.Controls.ScrollBarVisibility" />-Wert, der angibt, ob eine horizontale <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> angezeigt werden soll. Der Standardwert ist <see cref="F:System.Windows.Controls.ScrollBarVisibility.Hidden" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft verfügt auch über die Verwendung angefügter Eigenschaften.  
  
<a name="dependencyPropertyInfo_HorizontalScrollBarVisibility"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibilityProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalScrollBarVisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalScrollBarVisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalScrollBarVisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalScrollBarVisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalScrollBarVisibilityProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalScrollBarVisibilityProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibilityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateScrollInfo">
      <MemberSignature Language="C#" Value="public void InvalidateScrollInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateScrollInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.InvalidateScrollInfo" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateScrollInfo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateScrollInfo();" />
      <MemberSignature Language="F#" Value="member this.InvalidateScrollInfo : unit -&gt; unit" Usage="scrollViewer.InvalidateScrollInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von einer <see cref="T:System.Windows.Controls.Primitives.IScrollInfo" />-Schnittstelle aufgerufen, die an einen <see cref="T:System.Windows.Controls.ScrollViewer" /> angefügt wird, wenn sich der Wert einer Eigenschaftsgröße für den Bildlauf ändert. Zu den Scrolleigenschaften zählen Offset, Wertebereich und Viewport.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behandelt die Invalidierung anderer Elemente, z. b. Scrollleisten, die von den scrolleigenschaften dieses <xref:System.Windows.Controls.ScrollViewer>abhängen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.IScrollInfo" />
      </Docs>
    </Member>
    <Member MemberName="IsDeferredScrollingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDeferredScrollingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDeferredScrollingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsDeferredScrollingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDeferredScrollingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsDeferredScrollingEnabled : bool with get, set" Usage="System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Inhalt feststehend bleibt, wenn der Benutzer den <see cref="T:System.Windows.Controls.Primitives.Thumb" /> einer <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zieht, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn der Inhalt feststehend bleibt, wenn der Benutzer den <see cref="T:System.Windows.Controls.Primitives.Thumb" /> einer <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zieht, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine große Anzahl von Elementen angezeigt wird, kann dies zu Leistungsproblemen führen.  In diesem Fall kann es nützlich sein, einen verzögerten Bildlauf zu verwenden.  Weitere Informationen finden Sie unter [Optimieren der Leistung: Steuerelemente](~/docs/framework/wpf/advanced/optimizing-performance-controls.md).  
  
 Diese Eigenschaft kann als Instanzeigenschaft und als angefügte Eigenschaft verwendet werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Windows.Controls.ScrollViewer>, bei der die <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A>-Eigenschaft auf `true`festgelegt ist.  
  
 [!code-xaml[DeferredScrolling#DeferredScrolling](~/samples/snippets/xaml/VS_Snippets_Wpf/DeferredScrolling/xaml/window1.xaml#deferredscrolling)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDeferredScrollingEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsDeferredScrollingEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsDeferredScrollingEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsDeferredScrollingEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsDeferredScrollingEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsDeferredScrollingEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineDown">
      <MemberSignature Language="C#" Value="public void LineDown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineDown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.LineDown" />
      <MemberSignature Language="VB.NET" Value="Public Sub LineDown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LineDown();" />
      <MemberSignature Language="F#" Value="member this.LineDown : unit -&gt; unit" Usage="scrollViewer.LineDown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verschiebt den <see cref="T:System.Windows.Controls.ScrollViewer" />-Inhalt um eine Zeile nach unten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt kein Scrollverhalten aus, wenn <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> `null`ist.  
  
 Logischer Bildlauf wird verwendet, um einen Bildlauf zum nächsten Element in der logischen Struktur durchführen. Dies unterscheidet sich vom physischen Bildlauf, bei dem der Inhalt durch ein definiertes physisches Inkrement in einer angegebenen Richtung verschoben wird. Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineLeft">
      <MemberSignature Language="C#" Value="public void LineLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.LineLeft" />
      <MemberSignature Language="VB.NET" Value="Public Sub LineLeft ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LineLeft();" />
      <MemberSignature Language="F#" Value="member this.LineLeft : unit -&gt; unit" Usage="scrollViewer.LineLeft " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Scrollt den <see cref="T:System.Windows.Controls.ScrollViewer" />-Inhalt um einen zuvor ermittelten Wert nach links.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt kein Scrollverhalten aus, wenn <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> `null`ist.  
  
 Logischer Bildlauf wird verwendet, um einen Bildlauf zum nächsten Element in der logischen Struktur durchführen. Dies unterscheidet sich vom physischen Bildlauf, bei dem der Inhalt durch ein definiertes physisches Inkrement in einer angegebenen Richtung verschoben wird. Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineRight">
      <MemberSignature Language="C#" Value="public void LineRight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineRight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.LineRight" />
      <MemberSignature Language="VB.NET" Value="Public Sub LineRight ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LineRight();" />
      <MemberSignature Language="F#" Value="member this.LineRight : unit -&gt; unit" Usage="scrollViewer.LineRight " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Scrollt den <see cref="T:System.Windows.Controls.ScrollViewer" />-Inhalt um einen zuvor ermittelten Wert nach rechts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt kein Scrollverhalten aus, wenn <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> `null`ist.  
  
 Logischer Bildlauf wird verwendet, um einen Bildlauf zum nächsten Element in der logischen Struktur durchführen. Dies unterscheidet sich vom physischen Bildlauf, bei dem der Inhalt durch ein definiertes physisches Inkrement in einer angegebenen Richtung verschoben wird. Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineUp">
      <MemberSignature Language="C#" Value="public void LineUp ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineUp() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.LineUp" />
      <MemberSignature Language="VB.NET" Value="Public Sub LineUp ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LineUp();" />
      <MemberSignature Language="F#" Value="member this.LineUp : unit -&gt; unit" Usage="scrollViewer.LineUp " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verschiebt den <see cref="T:System.Windows.Controls.ScrollViewer" />-Inhalt um eine Zeile nach oben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt kein Scrollverhalten aus, wenn <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> `null`ist.  
  
 Logischer Bildlauf wird verwendet, um einen Bildlauf zum nächsten Element in der logischen Struktur durchführen. Dies unterscheidet sich vom physischen Bildlauf, bei dem der Inhalt durch ein definiertes physisches Inkrement in einer angegebenen Richtung verschoben wird. Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="scrollViewer.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Die Obergrenze für die <see cref="T:System.Windows.Size" />, die nicht überstiegen werden darf.</param>
        <summary>Misst den Inhalt eines <see cref="T:System.Windows.Controls.ScrollViewer" />-Elements.</summary>
        <returns>Die berechnete gewünschte Grenze für die <see cref="T:System.Windows.Size" /> des <see cref="T:System.Windows.Controls.ScrollViewer" />-Elements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public override void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="override this.OnApplyTemplate : unit -&gt; unit" Usage="scrollViewer.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird aufgerufen, wenn ein interner Prozess oder eine interne Anwendung <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" /> aufruft, mit der die visuelle Struktur der aktuellen Vorlage erstellt wird.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ApplyTemplate" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="scrollViewer.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt eine geeignete <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />-Implementierung für dieses Steuerelement als Teil der [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Automatisierungsinfrastruktur bereit.</summary>
        <returns>Die entsprechende <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />-Implementierung für dieses Steuerelement.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Automation.Peers.AutomationPeer" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="scrollViewer.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Erforderliche Argumente für dieses Ereignis.</param>
        <summary>Reagiert auf bestimmte Tastatureingaben und ruft das zugeordnete Bildlaufverhalten auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tastatureingabe wird erkannt:  
  
-   Die nach-links-Taste: führt einen Bildlauf um eine Zeile nach links aus.  
  
-   Die nach-rechts-Taste: führt einen Bildlauf um eine Zeile nach rechts aus.  
  
-   Die nach-oben-Taste: führt einen Bildlauf um eine Zeile nach oben aus.  
  
-   Die nach-unten-Taste: führt einen Bildlauf um eine Zeile nach unten aus.  
  
-   Bild-auf: führt im Inhalt einen Bildlauf zum oberen Rand der aktuellen Seite durch.  
  
-   Bild-ab: führt im Inhalt einen Bildlauf zum unteren Rand der aktuellen Seite durch.  
  
-   Home: führt im Inhalt einen Bildlauf zum oberen Rand der ersten Seite durch.  
  
-   Ende: führt im Inhalt einen Bildlauf zum unteren Rand der letzten Seite durch.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationCompleted">
      <MemberSignature Language="C#" Value="protected override void OnManipulationCompleted (System.Windows.Input.ManipulationCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationCompleted(class System.Windows.Input.ManipulationCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationCompleted (e As ManipulationCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationCompleted(System::Windows::Input::ManipulationCompletedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationCompleted : System.Windows.Input.ManipulationCompletedEventArgs -&gt; unit" Usage="scrollViewer.OnManipulationCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationCompletedEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Wird aufgerufen, wenn das <see cref="E:System.Windows.UIElement.ManipulationCompleted" />-Ereignis eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.ScrollViewer.OnManipulationCompleted%2A>-Methode legt die <xref:System.Windows.RoutedEventArgs.Handled%2A>-Eigenschaft auf `true`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationDelta">
      <MemberSignature Language="C#" Value="protected override void OnManipulationDelta (System.Windows.Input.ManipulationDeltaEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationDelta(class System.Windows.Input.ManipulationDeltaEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationDelta (e As ManipulationDeltaEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationDelta(System::Windows::Input::ManipulationDeltaEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationDelta : System.Windows.Input.ManipulationDeltaEventArgs -&gt; unit" Usage="scrollViewer.OnManipulationDelta e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationDeltaEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Wird aufgerufen, wenn das <see cref="E:System.Windows.UIElement.ManipulationDelta" />-Ereignis eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.ScrollViewer.OnManipulationDelta%2A>-Methode legt die <xref:System.Windows.RoutedEventArgs.Handled%2A>-Eigenschaft auf `true`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationInertiaStarting">
      <MemberSignature Language="C#" Value="protected override void OnManipulationInertiaStarting (System.Windows.Input.ManipulationInertiaStartingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationInertiaStarting(class System.Windows.Input.ManipulationInertiaStartingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationInertiaStarting (e As ManipulationInertiaStartingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationInertiaStarting(System::Windows::Input::ManipulationInertiaStartingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationInertiaStarting : System.Windows.Input.ManipulationInertiaStartingEventArgs -&gt; unit" Usage="scrollViewer.OnManipulationInertiaStarting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationInertiaStartingEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Wird aufgerufen, wenn das <see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" />-Ereignis eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.ScrollViewer.OnManipulationInertiaStarting%2A>-Methode legt die <xref:System.Windows.RoutedEventArgs.Handled%2A>-Eigenschaft auf `true`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationStarting">
      <MemberSignature Language="C#" Value="protected override void OnManipulationStarting (System.Windows.Input.ManipulationStartingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationStarting(class System.Windows.Input.ManipulationStartingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationStarting (e As ManipulationStartingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationStarting(System::Windows::Input::ManipulationStartingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationStarting : System.Windows.Input.ManipulationStartingEventArgs -&gt; unit" Usage="scrollViewer.OnManipulationStarting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationStartingEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Wird aufgerufen, wenn das <see cref="E:System.Windows.UIElement.ManipulationStarting" />-Ereignis eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.ScrollViewer.OnManipulationInertiaStarting%2A>-Methode legt die <xref:System.Windows.RoutedEventArgs.Handled%2A>-Eigenschaft auf `true`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="scrollViewer.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Erforderliche Argumente, die dieses Ereignis beschreiben.</param>
        <summary>Reagiert auf einen Klick mit der linken Maustaste.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected override void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="scrollViewer.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Erforderliche Argumente, die dieses Ereignis beschreiben.</param>
        <summary>Reagiert auf einen Klick mit dem Mausrad.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnScrollChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnScrollChanged (System.Windows.Controls.ScrollChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnScrollChanged(class System.Windows.Controls.ScrollChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnScrollChanged(System.Windows.Controls.ScrollChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnScrollChanged (e As ScrollChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnScrollChanged(System::Windows::Controls::ScrollChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnScrollChanged : System.Windows.Controls.ScrollChangedEventArgs -&gt; unit&#xA;override this.OnScrollChanged : System.Windows.Controls.ScrollChangedEventArgs -&gt; unit" Usage="scrollViewer.OnScrollChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ScrollChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.Windows.Controls.ScrollChangedEventArgs" />, die Informationen über die Änderung des Scrollzustands enthalten.</param>
        <summary>Wird aufgerufen, wenn eine Änderung des Scrollzustands erkannt wird, beispielsweise eine Änderung der Scrollposition, des Wertebereichs oder der Größe des Viewports.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Methode überschreiben, wenden Sie `base.OnScrollChanged(ScrollChangedEventArgs)` an, um sicherzustellen, dass dieses Ereignis ausgelöst wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected override void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="scrollViewer.OnStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> mit Informationen zur Bewegung.</param>
        <summary>Wird aufgerufen, wenn eine von einem Stift ausgelöste Tippbewegung erkannt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird intern verwendet, um Entscheidungen zum Schwenken zu treffen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageDown">
      <MemberSignature Language="C#" Value="public void PageDown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageDown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.PageDown" />
      <MemberSignature Language="VB.NET" Value="Public Sub PageDown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PageDown();" />
      <MemberSignature Language="F#" Value="member this.PageDown : unit -&gt; unit" Usage="scrollViewer.PageDown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verschiebt den <see cref="T:System.Windows.Controls.ScrollViewer" />-Inhalt um eine Seite nach unten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt kein Scrollverhalten aus, wenn <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> `null`ist.  
  
 Logischer Bildlauf wird verwendet, um einen Bildlauf zum nächsten Element in der logischen Struktur durchführen. Dies unterscheidet sich vom physischen Bildlauf, bei dem der Inhalt durch ein definiertes physisches Inkrement in einer angegebenen Richtung verschoben wird. Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageLeft">
      <MemberSignature Language="C#" Value="public void PageLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.PageLeft" />
      <MemberSignature Language="VB.NET" Value="Public Sub PageLeft ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PageLeft();" />
      <MemberSignature Language="F#" Value="member this.PageLeft : unit -&gt; unit" Usage="scrollViewer.PageLeft " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt einen Bildlauf durch den <see cref="T:System.Windows.Controls.ScrollViewer" />-Inhalt um eine Seite nach links durch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt kein Scrollverhalten aus, wenn <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> `null`ist.  
  
 Logischer Bildlauf wird verwendet, um einen Bildlauf zum nächsten Element in der logischen Struktur durchführen. Dies unterscheidet sich vom physischen Bildlauf, bei dem der Inhalt durch ein definiertes physisches Inkrement in einer angegebenen Richtung verschoben wird. Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageRight">
      <MemberSignature Language="C#" Value="public void PageRight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageRight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.PageRight" />
      <MemberSignature Language="VB.NET" Value="Public Sub PageRight ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PageRight();" />
      <MemberSignature Language="F#" Value="member this.PageRight : unit -&gt; unit" Usage="scrollViewer.PageRight " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt für den <see cref="T:System.Windows.Controls.ScrollViewer" />-Inhalt einen Bildlauf um eine Seite nach rechts durch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt kein Scrollverhalten aus, wenn <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> `null`ist.  
  
 Logischer Bildlauf wird verwendet, um einen Bildlauf zum nächsten Element in der logischen Struktur durchführen. Dies unterscheidet sich vom physischen Bildlauf, bei dem der Inhalt durch ein definiertes physisches Inkrement in einer angegebenen Richtung verschoben wird. Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageUp">
      <MemberSignature Language="C#" Value="public void PageUp ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageUp() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.PageUp" />
      <MemberSignature Language="VB.NET" Value="Public Sub PageUp ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PageUp();" />
      <MemberSignature Language="F#" Value="member this.PageUp : unit -&gt; unit" Usage="scrollViewer.PageUp " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verschiebt den <see cref="T:System.Windows.Controls.ScrollViewer" />-Inhalt um eine Seite nach oben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt kein Scrollverhalten aus, wenn <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> `null`ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PanningDeceleration">
      <MemberSignature Language="C#" Value="public double PanningDeceleration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 PanningDeceleration" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.PanningDeceleration" />
      <MemberSignature Language="VB.NET" Value="Public Property PanningDeceleration As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double PanningDeceleration { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.PanningDeceleration : double with get, set" Usage="System.Windows.Controls.ScrollViewer.PanningDeceleration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Rate ab, um die <see cref="T:System.Windows.Controls.ScrollViewer" /> in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] bei Trägheit per quadrierter Millisekunde verlangsamt wird.</summary>
        <value>Die Auswertung als <see cref="T:System.Windows.Controls.ScrollViewer" /> verlangsamt sich in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] pro Millisekunde im Quadrat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Benutzer mithilfe von Touch einen Bildlauf durch den <xref:System.Windows.Controls.ScrollViewer> durchführt, legt der Benutzer einen Finger auf die <xref:System.Windows.Controls.ScrollViewer>, bewegt den Finger für eine kurze Entfernung auf dem Bildschirm und drückt dann den Finger, während er bewegt wird.  Das Ergebnis ist, dass die <xref:System.Windows.Controls.ScrollViewer> weiter bewegt wird, nachdem der Benutzer den Finger bewegt hat. Die <xref:System.Windows.Controls.ScrollViewer.PanningDeceleration%2A>-Eigenschaft gibt die Rate an, mit der der Bildlauf verlangsamt wird, nachdem der Benutzer den Finger hebt  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PanningDecelerationProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PanningDecelerationProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PanningDecelerationProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.PanningDecelerationProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PanningDecelerationProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PanningDecelerationProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PanningDecelerationProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.PanningDecelerationProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.PanningDeceleration" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PanningMode">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.PanningMode PanningMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.PanningMode PanningMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.PanningMode" />
      <MemberSignature Language="VB.NET" Value="Public Property PanningMode As PanningMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::PanningMode PanningMode { System::Windows::Controls::PanningMode get(); void set(System::Windows::Controls::PanningMode value); };" />
      <MemberSignature Language="F#" Value="member this.PanningMode : System.Windows.Controls.PanningMode with get, set" Usage="System.Windows.Controls.ScrollViewer.PanningMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.PanningMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Art und Weise ab, in der <see cref="T:System.Windows.Controls.ScrollViewer" /> auf Fingereingabemanipulationen reagiert, oder legt diese fest.</summary>
        <value>Ein Wert, der angibt, wie <see cref="T:System.Windows.Controls.ScrollViewer" /> auf Fingereingabemanipulationen reagiert.  Der Standardwert ist <see cref="F:System.Windows.Controls.PanningMode.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A>-Eigenschaft gibt an, ob der <xref:System.Windows.Controls.ScrollViewer> horizontal, vertikal oder beides durchlaufen wird. Der <xref:System.Windows.Controls.ScrollViewer> führt einen Bildlauf durch, wenn ein Benutzer einen Finger auf dem Steuerelement auf einem Touch-Gerät zieht, das Windows Touch unterstützt.  
  
 <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A> können entweder direkt auf einem <xref:System.Windows.Controls.ScrollViewer> festgelegt oder als angefügte Eigenschaft verwendet werden.  Wenn ein Steuerelement eine <xref:System.Windows.Controls.ScrollViewer> im <xref:System.Windows.Controls.ControlTemplate>enthält, verwenden Sie <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A?displayProperty=nameWithType> als angefügte Eigenschaft, um das Verhalten der <xref:System.Windows.Controls.ScrollViewer> in der <xref:System.Windows.Controls.ControlTemplate>anzugeben. Wenn Sie einen <xref:System.Windows.Controls.ScrollViewer> außerhalb eines <xref:System.Windows.Controls.ControlTemplate>verwenden, legen Sie <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A> direkt auf dem <xref:System.Windows.Controls.ScrollViewer>fest.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.Controls.ScrollViewer> erstellt und mehrere-Elemente hinzugefügt.  In diesem Beispiel ändert sich die Größe der `textblock1` auch, wenn sich die Größe des Fensters ändert.  Wenn die <xref:System.Windows.Controls.TextBlock> zu klein ist, um den gesamten Inhalt anzuzeigen, wird der <xref:System.Windows.Controls.ScrollViewer> scrollfähig. Im Beispiel wird <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A> auf <xref:System.Windows.Controls.PanningMode.Both> festgelegt, sodass der Benutzer einen Bildlauf in der <xref:System.Windows.Controls.ScrollViewer> horizontal und vertikal mithilfe eines Fingers durchführen kann.  
  
 [!code-xaml[ScrollViewerPanning#PanningModeDirect](~/samples/snippets/csharp/VS_Snippets_Wpf/scrollviewerpanning/CS/mainwindow.xaml#panningmodedirect)]   
  
 Im folgenden Beispiel wird eine <xref:System.Windows.Controls.TextBox> erstellt und als angefügte Eigenschaft <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A?displayProperty=nameWithType> verwendet. Standardmäßig ist der <xref:System.Windows.Controls.ScrollViewer> in der <xref:System.Windows.Controls.ControlTemplate> eines <xref:System.Windows.Controls.TextBox> seine <xref:System.Windows.Controls.PanningMode> <xref:System.Windows.Controls.PanningMode.VerticalFirst>.  Dies ist so, dass der Benutzer den Text hervorhebt, wenn der Benutzer einen Finger horizontal bewegt, bevor er ihn vertikal verschiebt.  Im Beispiel wird <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A> auf <xref:System.Windows.Controls.PanningMode.VerticalOnly> festgelegt, sodass der Benutzer Text nicht mit einem Finger auswählen kann.  Beachten Sie, dass das Festlegen von <xref:System.Windows.Controls.PanningMode> auf <xref:System.Windows.Controls.PanningMode.Both> auch den Benutzer daran hindert, Text auszuwählen.  Im Beispiel wird die <xref:System.Windows.TextWrapping>-Eigenschaft auf <xref:System.Windows.TextWrapping.Wrap>festgelegt, sodass horizontales Scrollen nicht erforderlich ist.  
  
 [!code-xaml[ScrollViewerPanning#PanningModeAttached](~/samples/snippets/csharp/VS_Snippets_Wpf/scrollviewerpanning/CS/mainwindow.xaml#panningmodeattached)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PanningModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PanningModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PanningModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.PanningModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PanningModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PanningModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PanningModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.PanningModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.PanningMode" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PanningRatio">
      <MemberSignature Language="C#" Value="public double PanningRatio { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 PanningRatio" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.PanningRatio" />
      <MemberSignature Language="VB.NET" Value="Public Property PanningRatio As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double PanningRatio { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.PanningRatio : double with get, set" Usage="System.Windows.Controls.ScrollViewer.PanningRatio" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Verhältnis des Bildlaufoffsets ab, mit dem Manipulationsoffsets übersetzt werden, oder legt dieses fest.</summary>
        <value>Das Verhältnis des Bildlaufoffsets, mit dem Manipulationsoffsets übersetzt werden. Der Standard ist 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Benutzer einen Finger über ein Objekt zieht, wird er als Verschiebe Bearbeitung betrachtet.  Der <xref:System.Windows.Controls.ScrollViewer> verwendet diese Bearbeitung zum Scrollen. Die <xref:System.Windows.Controls.ScrollViewer.PanningRatio%2A>-Eigenschaft gibt an, wie viel der <xref:System.Windows.Controls.ScrollViewer> für jede Übersetzungseinheit einen Bildlauf durchführt.  Wenn <xref:System.Windows.Controls.ScrollViewer.PanningRatio%2A> z. b. 2 ist, wird der <xref:System.Windows.Controls.ScrollViewer> für jede [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] der Translation-Manipulation den Bildlauf 2 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] durchführen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PanningRatioProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PanningRatioProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PanningRatioProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.PanningRatioProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PanningRatioProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PanningRatioProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PanningRatioProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.PanningRatioProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.PanningRatio" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollableHeight">
      <MemberSignature Language="C#" Value="public double ScrollableHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ScrollableHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ScrollableHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScrollableHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ScrollableHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ScrollableHeight : double" Usage="System.Windows.Controls.ScrollViewer.ScrollableHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die vertikale Größe des Inhaltselements darstellt, das bildlauffähig ist.</summary>
        <value><see cref="T:System.Double" /> gibt an, dass die vertikale Größe des Inhaltselements bildlauffähig ist. Diese Eigenschaft hat keinen Standardwert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> `true`ist, sind die Werte der Eigenschaften <xref:System.Windows.Controls.ScrollViewer.ExtentHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ScrollableHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ViewportHeight%2A>und <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> die Anzahl der Elemente. Wenn <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> `false`ist, sind die Werte dieser Eigenschaften geräteunabhängige Pixel.  
  
<a name="dependencyPropertyInfo_ScrollableHeight"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ScrollViewer.ScrollableHeightProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollableHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ScrollableHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ScrollableHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ScrollableHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollableHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ScrollableHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollableHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.ScrollableHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.ScrollableHeight" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ScrollableHeight" />
      </Docs>
    </Member>
    <Member MemberName="ScrollableWidth">
      <MemberSignature Language="C#" Value="public double ScrollableWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ScrollableWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ScrollableWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScrollableWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ScrollableWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ScrollableWidth : double" Usage="System.Windows.Controls.ScrollViewer.ScrollableWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die horizontale Größe des Inhaltselements darstellt, das bildlauffähig ist.</summary>
        <value>Ein <see cref="T:System.Double" />, das die horizontale Größe des Inhaltselements darstellt, das bildlauffähig ist. Diese Eigenschaft hat keinen Standardwert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ScrollableWidth"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ScrollViewer.ScrollableWidthProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollableWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ScrollableWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ScrollableWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ScrollableWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollableWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ScrollableWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollableWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.ScrollableWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.ScrollableWidth" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ScrollableWidth" />
      </Docs>
    </Member>
    <Member MemberName="ScrollChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ScrollChangedEventHandler ScrollChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ScrollChangedEventHandler ScrollChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.ScrollViewer.ScrollChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ScrollChanged As ScrollChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ScrollChangedEventHandler ^ ScrollChanged;" />
      <MemberSignature Language="F#" Value="member this.ScrollChanged : System.Windows.Controls.ScrollChangedEventHandler " Usage="member this.ScrollChanged : System.Windows.Controls.ScrollChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ScrollChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn Änderungen an der Scrollposition, am Wertebereich oder an der Größe des Viewports erkannt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_ScrollChanged"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ScrollViewer.ScrollChangedEvent>|  
|Routing Strategie|Blasen|  
|delegate|<xref:System.Windows.Controls.ScrollChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ScrollChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ScrollChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ScrollChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ScrollChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ScrollChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.ScrollViewer.ScrollChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.Controls.ScrollViewer.ScrollChanged" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Controls.ScrollViewer.ScrollChanged" />
      </Docs>
    </Member>
    <Member MemberName="ScrollInfo">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Controls.Primitives.IScrollInfo ScrollInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.Primitives.IScrollInfo ScrollInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ScrollInfo" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property ScrollInfo As IScrollInfo" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Controls::Primitives::IScrollInfo ^ ScrollInfo { System::Windows::Controls::Primitives::IScrollInfo ^ get(); void set(System::Windows::Controls::Primitives::IScrollInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollInfo : System.Windows.Controls.Primitives.IScrollInfo with get, set" Usage="System.Windows.Controls.ScrollViewer.ScrollInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.IScrollInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Element ab, das die <see cref="T:System.Windows.Controls.Primitives.IScrollInfo" />-Schnittstelle implementiert und Werte für die Scrolleigenschaften dieses <see cref="T:System.Windows.Controls.ScrollViewer" /> angibt, oder legt dieses Element fest.</summary>
        <value>Das Element, das die Scrolleigenschaften steuert, wie etwa Ausdehnung, Offset oder Viewportgröße. Diese Eigenschaft hat keinen Standardwert.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToBottom">
      <MemberSignature Language="C#" Value="public void ScrollToBottom ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToBottom() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToBottom" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToBottom ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToBottom();" />
      <MemberSignature Language="F#" Value="member this.ScrollToBottom : unit -&gt; unit" Usage="scrollViewer.ScrollToBottom " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt einen vertikalen Bildlauf bis zum Ende des <see cref="T:System.Windows.Controls.ScrollViewer" />-Inhalts aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt kein Scrollverhalten aus, wenn <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> `null`ist.  
  
 Logischer Bildlauf wird verwendet, um einen Bildlauf zum nächsten Element in der logischen Struktur durchführen. Dies unterscheidet sich vom physischen Bildlauf, bei dem der Inhalt durch ein definiertes physisches Inkrement in einer angegebenen Richtung verschoben wird. Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToEnd">
      <MemberSignature Language="C#" Value="public void ScrollToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToEnd ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToEnd();" />
      <MemberSignature Language="F#" Value="member this.ScrollToEnd : unit -&gt; unit" Usage="scrollViewer.ScrollToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt einen vertikalen Bildlauf bis zum Ende des <see cref="T:System.Windows.Controls.ScrollViewer" />-Inhalts aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Bildlauf zu den vertikalen und horizontalen Endpunkten des Inhalts durch.  
  
 Diese Methode führt kein Scrollverhalten aus, wenn <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> `null`ist.  
  
 Logischer Bildlauf wird verwendet, um einen Bildlauf zum nächsten Element in der logischen Struktur durchführen. Dies unterscheidet sich vom physischen Bildlauf, bei dem der Inhalt durch ein definiertes physisches Inkrement in einer angegebenen Richtung verschoben wird. Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHome">
      <MemberSignature Language="C#" Value="public void ScrollToHome ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToHome() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToHome" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToHome ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToHome();" />
      <MemberSignature Language="F#" Value="member this.ScrollToHome : unit -&gt; unit" Usage="scrollViewer.ScrollToHome " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt einen vertikalen Bildlauf bis zum Anfang des <see cref="T:System.Windows.Controls.ScrollViewer" />-Inhalts aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt kein Scrollverhalten aus, wenn <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> `null`ist.  
  
 Logischer Bildlauf wird verwendet, um einen Bildlauf zum nächsten Element in der logischen Struktur durchführen. Dies unterscheidet sich vom physischen Bildlauf, bei dem der Inhalt durch ein definiertes physisches Inkrement in einer angegebenen Richtung verschoben wird. Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHorizontalOffset">
      <MemberSignature Language="C#" Value="public void ScrollToHorizontalOffset (double offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToHorizontalOffset(float64 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToHorizontalOffset(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToHorizontalOffset (offset As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToHorizontalOffset(double offset);" />
      <MemberSignature Language="F#" Value="member this.ScrollToHorizontalOffset : double -&gt; unit" Usage="scrollViewer.ScrollToHorizontalOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="offset">Die Position, bis zu der der Inhalt gescrollt werden soll.</param>
        <summary>Scrollt den Inhalt im <see cref="T:System.Windows.Controls.ScrollViewer" /> bis zur angegebenen horizontalen Offsetposition.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToLeftEnd">
      <MemberSignature Language="C#" Value="public void ScrollToLeftEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToLeftEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToLeftEnd" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToLeftEnd ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToLeftEnd();" />
      <MemberSignature Language="F#" Value="member this.ScrollToLeftEnd : unit -&gt; unit" Usage="scrollViewer.ScrollToLeftEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt einen horizontalen Bildlauf bis zum Anfang des <see cref="T:System.Windows.Controls.ScrollViewer" />-Inhalts aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt kein Scrollverhalten aus, wenn <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> `null`ist.  
  
 Logischer Bildlauf wird verwendet, um einen Bildlauf zum nächsten Element in der logischen Struktur durchführen. Dies unterscheidet sich vom physischen Bildlauf, bei dem der Inhalt durch ein definiertes physisches Inkrement in einer angegebenen Richtung verschoben wird. Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToRightEnd">
      <MemberSignature Language="C#" Value="public void ScrollToRightEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToRightEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToRightEnd" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToRightEnd ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToRightEnd();" />
      <MemberSignature Language="F#" Value="member this.ScrollToRightEnd : unit -&gt; unit" Usage="scrollViewer.ScrollToRightEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt einen horizontalen Bildlauf bis zum Ende des <see cref="T:System.Windows.Controls.ScrollViewer" />-Inhalts aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt kein Scrollverhalten aus, wenn <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> `null`ist.  
  
 Logischer Bildlauf wird verwendet, um einen Bildlauf zum nächsten Element in der logischen Struktur durchführen. Dies unterscheidet sich vom physischen Bildlauf, bei dem der Inhalt durch ein definiertes physisches Inkrement in einer angegebenen Richtung verschoben wird. Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToTop">
      <MemberSignature Language="C#" Value="public void ScrollToTop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToTop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToTop" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToTop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToTop();" />
      <MemberSignature Language="F#" Value="member this.ScrollToTop : unit -&gt; unit" Usage="scrollViewer.ScrollToTop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt einen vertikalen Bildlauf bis zum Anfang des <see cref="T:System.Windows.Controls.ScrollViewer" />-Inhalts aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt kein Scrollverhalten aus, wenn <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> `null`ist.  
  
 Logischer Bildlauf wird verwendet, um einen Bildlauf zum nächsten Element in der logischen Struktur durchführen. Dies unterscheidet sich vom physischen Bildlauf, bei dem der Inhalt durch ein definiertes physisches Inkrement in einer angegebenen Richtung verschoben wird. Wenn Sie einen physischen Bildlauf anstelle eines logischen Bildlaufs benötigen, wrappen Sie den Host <xref:System.Windows.Controls.Panel> Element in einem <xref:System.Windows.Controls.ScrollViewer>, und legen Sie dessen Eigenschaft <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> auf `false`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToVerticalOffset">
      <MemberSignature Language="C#" Value="public void ScrollToVerticalOffset (double offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToVerticalOffset(float64 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToVerticalOffset(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToVerticalOffset (offset As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToVerticalOffset(double offset);" />
      <MemberSignature Language="F#" Value="member this.ScrollToVerticalOffset : double -&gt; unit" Usage="scrollViewer.ScrollToVerticalOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="offset">Die Position, bis zu der der Inhalt gescrollt werden soll.</param>
        <summary>Scrollt den Inhalt im <see cref="T:System.Windows.Controls.ScrollViewer" /> bis zur angegebenen vertikalen Offsetposition.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCanContentScroll">
      <MemberSignature Language="C#" Value="public static void SetCanContentScroll (System.Windows.DependencyObject element, bool canContentScroll);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCanContentScroll(class System.Windows.DependencyObject element, bool canContentScroll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.SetCanContentScroll(System.Windows.DependencyObject,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCanContentScroll (element As DependencyObject, canContentScroll As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCanContentScroll(System::Windows::DependencyObject ^ element, bool canContentScroll);" />
      <MemberSignature Language="F#" Value="static member SetCanContentScroll : System.Windows.DependencyObject * bool -&gt; unit" Usage="System.Windows.Controls.ScrollViewer.SetCanContentScroll (element, canContentScroll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="canContentScroll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, auf das der Wert der Eigenschaft festgelegt werden soll.</param>
        <param name="canContentScroll">Der festzulegende Eigenschaftswert.</param>
        <summary>Legt den Wert der <see cref="P:System.Windows.Controls.ScrollViewer.CanContentScroll" />-Abhängigkeitseigenschaft auf ein angegebenes Element fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHorizontalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public static void SetHorizontalScrollBarVisibility (System.Windows.DependencyObject element, System.Windows.Controls.ScrollBarVisibility horizontalScrollBarVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetHorizontalScrollBarVisibility(class System.Windows.DependencyObject element, valuetype System.Windows.Controls.ScrollBarVisibility horizontalScrollBarVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.SetHorizontalScrollBarVisibility(System.Windows.DependencyObject,System.Windows.Controls.ScrollBarVisibility)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetHorizontalScrollBarVisibility (element As DependencyObject, horizontalScrollBarVisibility As ScrollBarVisibility)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetHorizontalScrollBarVisibility(System::Windows::DependencyObject ^ element, System::Windows::Controls::ScrollBarVisibility horizontalScrollBarVisibility);" />
      <MemberSignature Language="F#" Value="static member SetHorizontalScrollBarVisibility : System.Windows.DependencyObject * System.Windows.Controls.ScrollBarVisibility -&gt; unit" Usage="System.Windows.Controls.ScrollViewer.SetHorizontalScrollBarVisibility (element, horizontalScrollBarVisibility)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="horizontalScrollBarVisibility" Type="System.Windows.Controls.ScrollBarVisibility" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, auf das der Wert der Eigenschaft festgelegt werden soll.</param>
        <param name="horizontalScrollBarVisibility">Der festzulegende Eigenschaftswert.</param>
        <summary>Legt den Wert der <see cref="P:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility" />-Abhängigkeitseigenschaft auf ein angegebenes Element fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsDeferredScrollingEnabled">
      <MemberSignature Language="C#" Value="public static void SetIsDeferredScrollingEnabled (System.Windows.DependencyObject element, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIsDeferredScrollingEnabled(class System.Windows.DependencyObject element, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.SetIsDeferredScrollingEnabled(System.Windows.DependencyObject,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIsDeferredScrollingEnabled (element As DependencyObject, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIsDeferredScrollingEnabled(System::Windows::DependencyObject ^ element, bool value);" />
      <MemberSignature Language="F#" Value="static member SetIsDeferredScrollingEnabled : System.Windows.DependencyObject * bool -&gt; unit" Usage="System.Windows.Controls.ScrollViewer.SetIsDeferredScrollingEnabled (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="element">Das Objekt, für das die <see cref="P:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled" />-Eigenschaft festgelegt werden soll.</param>
        <param name="value"><see langword="true" />, wenn der Inhalt feststehend bleiben soll, wenn der Benutzer den <see cref="T:System.Windows.Controls.Primitives.Thumb" /> einer <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zieht, andernfalls <see langword="false" />.</param>
        <summary>Legt die <see cref="P:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled" />-Eigenschaft für das angegebene Objekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine große Anzahl von Elementen angezeigt wird, kann dies zu Leistungsproblemen führen.  In diesem Fall kann es nützlich sein, einen verzögerten Bildlauf zu verwenden.  Weitere Informationen finden Sie unter [Optimieren der Leistung: Steuerelemente](~/docs/framework/wpf/advanced/optimizing-performance-controls.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPanningDeceleration">
      <MemberSignature Language="C#" Value="public static void SetPanningDeceleration (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetPanningDeceleration(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.SetPanningDeceleration(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetPanningDeceleration (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetPanningDeceleration(System::Windows::DependencyObject ^ element, double value);" />
      <MemberSignature Language="F#" Value="static member SetPanningDeceleration : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Controls.ScrollViewer.SetPanningDeceleration (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element">Das Objekt, für das die <see cref="P:System.Windows.Controls.ScrollViewer.PanningDeceleration" />-Eigenschaft festgelegt werden soll.</param>
        <param name="value">Die Auswertung als <see cref="T:System.Windows.Controls.ScrollViewer" /> verlangsamt sich in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] pro Millisekunde im Quadrat.</param>
        <summary>Legt die <see cref="P:System.Windows.Controls.ScrollViewer.PanningDeceleration" />-Eigenschaft für das angegebene Objekt fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPanningMode">
      <MemberSignature Language="C#" Value="public static void SetPanningMode (System.Windows.DependencyObject element, System.Windows.Controls.PanningMode panningMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetPanningMode(class System.Windows.DependencyObject element, valuetype System.Windows.Controls.PanningMode panningMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.SetPanningMode(System.Windows.DependencyObject,System.Windows.Controls.PanningMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetPanningMode(System::Windows::DependencyObject ^ element, System::Windows::Controls::PanningMode panningMode);" />
      <MemberSignature Language="F#" Value="static member SetPanningMode : System.Windows.DependencyObject * System.Windows.Controls.PanningMode -&gt; unit" Usage="System.Windows.Controls.ScrollViewer.SetPanningMode (element, panningMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="panningMode" Type="System.Windows.Controls.PanningMode" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element">Das Objekt, für das die <see cref="P:System.Windows.Controls.ScrollViewer.PanningMode" />-Eigenschaft festgelegt werden soll.</param>
        <param name="panningMode">Ein Wert, der angibt, wie <see cref="T:System.Windows.Controls.ScrollViewer" /> auf Fingereingabemanipulationen reagiert.</param>
        <summary>Legt die <see cref="P:System.Windows.Controls.ScrollViewer.PanningMode" />-Eigenschaft für das angegebene Objekt fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPanningRatio">
      <MemberSignature Language="C#" Value="public static void SetPanningRatio (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetPanningRatio(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.SetPanningRatio(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetPanningRatio (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetPanningRatio(System::Windows::DependencyObject ^ element, double value);" />
      <MemberSignature Language="F#" Value="static member SetPanningRatio : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Controls.ScrollViewer.SetPanningRatio (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element">Das Objekt, für das die <see cref="P:System.Windows.Controls.ScrollViewer.PanningRatio" />-Eigenschaft festgelegt werden soll.</param>
        <param name="value">Das Verhältnis des Bildlaufoffsets, mit dem Manipulationsoffsets übersetzt werden.</param>
        <summary>Legt die <see cref="P:System.Windows.Controls.ScrollViewer.PanningRatio" />-Eigenschaft für das angegebene Objekt fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetVerticalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public static void SetVerticalScrollBarVisibility (System.Windows.DependencyObject element, System.Windows.Controls.ScrollBarVisibility verticalScrollBarVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetVerticalScrollBarVisibility(class System.Windows.DependencyObject element, valuetype System.Windows.Controls.ScrollBarVisibility verticalScrollBarVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.SetVerticalScrollBarVisibility(System.Windows.DependencyObject,System.Windows.Controls.ScrollBarVisibility)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetVerticalScrollBarVisibility (element As DependencyObject, verticalScrollBarVisibility As ScrollBarVisibility)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetVerticalScrollBarVisibility(System::Windows::DependencyObject ^ element, System::Windows::Controls::ScrollBarVisibility verticalScrollBarVisibility);" />
      <MemberSignature Language="F#" Value="static member SetVerticalScrollBarVisibility : System.Windows.DependencyObject * System.Windows.Controls.ScrollBarVisibility -&gt; unit" Usage="System.Windows.Controls.ScrollViewer.SetVerticalScrollBarVisibility (element, verticalScrollBarVisibility)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="verticalScrollBarVisibility" Type="System.Windows.Controls.ScrollBarVisibility" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, auf das der Wert der Eigenschaft festgelegt werden soll.</param>
        <param name="verticalScrollBarVisibility">Der festzulegende Eigenschaftswert.</param>
        <summary>Legt den Wert der <see cref="P:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibility" />-Abhängigkeitseigenschaft auf ein angegebenes Element fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalOffset">
      <MemberSignature Language="C#" Value="public double VerticalOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 VerticalOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.VerticalOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VerticalOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double VerticalOffset { double get(); };" />
      <MemberSignature Language="F#" Value="member this.VerticalOffset : double" Usage="System.Windows.Controls.ScrollViewer.VerticalOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den vertikalen Offset des Inhalts nach dem Bildlauf enthält.</summary>
        <value>Ein <see cref="T:System.Double" />-Wert, der den vertikalen Offset des Inhalts nach dem Bildlauf enthält. Der Standardwert ist 0,0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein positiver <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> Wert entspricht dem Inhalt, der nach oben versetzt wird.  
  
 Gültige Werte liegen zwischen 0 (null) und dem <xref:System.Windows.Controls.ScrollViewer.ExtentHeight%2A>-Wert minus dem <xref:System.Windows.Controls.ScrollViewer.ViewportHeight%2A>-Wert.  
  
 Wenn <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> `true`ist, sind die Werte der Eigenschaften <xref:System.Windows.Controls.ScrollViewer.ExtentHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ScrollableHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ViewportHeight%2A>und <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> die Anzahl der Elemente. Wenn <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> `false`ist, sind die Werte dieser Eigenschaften geräteunabhängige Pixel.  
  
 Beginnend mit der .NET Framework Version 3,5 SP1, wenn <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> `true`ist, ändern sich <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> weiterhin, wenn der Benutzer den <xref:System.Windows.Controls.Primitives.Thumb>zieht, aber die Inhaltsansicht ändert sich erst, wenn die <xref:System.Windows.Controls.Primitives.Thumb> freigegeben wurde.  In diesem Fall stellt <xref:System.Windows.Controls.ScrollViewer.ContentVerticalOffset%2A> den sichtbaren Inhalts Offset dar und <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> den Inhalts Offset basierend auf der <xref:System.Windows.Controls.Primitives.Thumb> Position darstellt.  
  
<a name="dependencyPropertyInfo_VerticalOffset"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ScrollViewer.VerticalOffsetProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.VerticalOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalOffsetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalOffsetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.VerticalOffsetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.VerticalOffset" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.VerticalOffset" />
      </Docs>
    </Member>
    <Member MemberName="VerticalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ScrollBarVisibility VerticalScrollBarVisibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.ScrollBarVisibility VerticalScrollBarVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibility" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalScrollBarVisibility As ScrollBarVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ScrollBarVisibility VerticalScrollBarVisibility { System::Windows::Controls::ScrollBarVisibility get(); void set(System::Windows::Controls::ScrollBarVisibility value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalScrollBarVisibility : System.Windows.Controls.ScrollBarVisibility with get, set" Usage="System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ScrollBarVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine vertikale <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> angezeigt werden soll, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.Controls.ScrollBarVisibility" />-Wert, der angibt, ob eine vertikale <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> angezeigt werden soll. Der Standardwert ist <see cref="F:System.Windows.Controls.ScrollBarVisibility.Visible" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_VerticalScrollBarVisibility"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibilityProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollBarVisibility" />
      </Docs>
    </Member>
    <Member MemberName="VerticalScrollBarVisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalScrollBarVisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalScrollBarVisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalScrollBarVisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalScrollBarVisibilityProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalScrollBarVisibilityProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibilityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibility" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibility" />
      </Docs>
    </Member>
    <Member MemberName="ViewportHeight">
      <MemberSignature Language="C#" Value="public double ViewportHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ViewportHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ViewportHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ViewportHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ViewportHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewportHeight : double" Usage="System.Windows.Controls.ScrollViewer.ViewportHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die vertikale Größe des Viewports des Inhalts enthält.</summary>
        <value>Ein <see cref="T:System.Double" />-Wert, der die vertikale Größe des Viewports des Inhalts angibt. Diese Eigenschaft hat keinen Standardwert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Viewport ist der sichtbare Bereich des Inhalts.  
  
 <xref:System.Windows.Controls.ScrollViewer.ViewportHeight%2A> ist nur eine Ausgabe Eigenschaft. Sie kann effektiv festgelegt werden, indem die <xref:System.Windows.FrameworkElement.Height%2A> des Content-Elements angegeben wird.  
  
 Wenn <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> `true`ist, sind die Werte der Eigenschaften <xref:System.Windows.Controls.ScrollViewer.ExtentHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ScrollableHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ViewportHeight%2A>und <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> die Anzahl der Elemente. Wenn <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> `false`ist, sind die Werte dieser Eigenschaften geräteunabhängige Pixel.  
  
<a name="dependencyPropertyInfo_ViewportHeight"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ScrollViewer.ViewportHeightProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ViewportHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ViewportHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ViewportHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ViewportHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ViewportHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ViewportHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.ViewportHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.ViewportHeight" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ViewportHeight" />
      </Docs>
    </Member>
    <Member MemberName="ViewportWidth">
      <MemberSignature Language="C#" Value="public double ViewportWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ViewportWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ViewportWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ViewportWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ViewportWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewportWidth : double" Usage="System.Windows.Controls.ScrollViewer.ViewportWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die horizontale Größe des Viewports des Inhalts enthält.</summary>
        <value>Ein <see cref="T:System.Double" />-Wert, der die horizontale Größe des Viewports des Inhalts angibt. Der Standardwert ist 0,0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Viewport ist der sichtbare Bereich des Inhalts.  
  
<a name="dependencyPropertyInfo_ViewportWidth"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.ScrollViewer.ViewportWidthProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ViewportWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ViewportWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ViewportWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ViewportWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ViewportWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ViewportWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ScrollViewer.ViewportWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.ScrollViewer.ViewportWidth" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ViewportWidth" />
      </Docs>
    </Member>
  </Members>
</Type>
