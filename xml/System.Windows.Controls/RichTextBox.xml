<Type Name="RichTextBox" FullName="System.Windows.Controls.RichTextBox">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c70555e269398a3b3bda717933331e5e8f56fb40" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53297319" /></Metadata><TypeSignature Language="C#" Value="public class RichTextBox : System.Windows.Controls.Primitives.TextBoxBase, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi RichTextBox extends System.Windows.Controls.Primitives.TextBoxBase implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.RichTextBox" />
  <TypeSignature Language="VB.NET" Value="Public Class RichTextBox&#xA;Inherits TextBoxBase&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class RichTextBox : System::Windows::Controls::Primitives::TextBoxBase, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type RichTextBox = class&#xA;    inherit TextBoxBase&#xA;    interface IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Primitives.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Inherit)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ContentProperty("Document")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein erweitertes Bearbeitungssteuerelement für <see cref="T:System.Windows.Documents.FlowDocument" />-Objekte dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.FlowDocument> ist das einzige unterstützte untergeordnete Element für eine <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Controls.RichTextBox> bietet eine integrierte Behandlung für das Bubblingereignis <xref:System.Windows.UIElement.MouseUp> und <xref:System.Windows.UIElement.MouseDown> Ereignisse.  Daher benutzerdefinierter Ereignishandler, die für die Überwachung `MouseUp` oder `MouseDown` Ereignisse aus einem <xref:System.Windows.Controls.RichTextBox> wird nie aufgerufen werden.  Warten, dass wenn Sie auf diese Ereignisse reagieren müssen, das tunneling <xref:System.Windows.UIElement.PreviewMouseUp> und <xref:System.Windows.UIElement.PreviewMouseDown> Ereignisse stattdessen oder registrieren Sie die Handler mit der <xref:System.Windows.EventSetter.HandledEventsToo%2A> Argument (letztere Option ist nur verfügbar, durch Code). Markieren Sie das Ereignis als behandelt, es sei denn, Sie deaktivieren möchten nicht <xref:System.Windows.Controls.RichTextBox> native Behandlung dieser Ereignisse, und beachten Sie, dass dies wesentliche Auswirkungen auf die des Steuerelements hat [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  
  
 Während <xref:System.Windows.Controls.RichTextBox> unterstützt das Kopieren und Einfügen von Bildern, bestimmte Szenarien werden derzeit nicht unterstützt und funktioniert möglicherweise nicht ordnungsgemäß.  In der folgende Tabelle werden diese Szenarien und die erwarteten Ergebnisse zusammengefasst.  
  
|Kopieren der Bildquelle|Bild einfügen Ergebnis|  
|-----------------------|------------------------|  
|Bildquelle ist eine grafische Metadatei|Es wird kein Bild eingefügt.|  
|Bildquelle verwendet werden, der relative Pfad oder link|Verstümmelt oder leeres Bild wird eingefügt.|  
|Image-Link "Quelle" endet nicht mit einem Bild-Format (. PNG. JPG. GIF)|Verstümmelt oder leeres Bild wird eingefügt.|  
|Bildquelle kopiert von falsch formatierten RichText (RTF)|Link zur Quelle eingefügt wird (statt image)|  
  
 Einfügen von HTML-Inhalt in einem <xref:System.Windows.Controls.RichTextBox> kann zu unerwartetem Verhalten führen, da <xref:System.Windows.Controls.RichTextBox> RTF-format statt direkt HTML-Format verwendet.  
  
 Text umbrochen wird immer einem <xref:System.Windows.Controls.RichTextBox>. Wenn Sie nicht, dass Text umbrochen, legen Sie dann möchten die <xref:System.Windows.Documents.FlowDocument.PageWidth%2A> auf die <xref:System.Windows.Documents.FlowDocument> größer sein als die Breite des der <xref:System.Windows.Controls.RichTextBox>. Jedoch erreichen die Seitenbreite dient als Wrapper für der Text trotzdem.  
  
 Horizontale und vertikale Ausrichtung von Inhalten in einem <xref:System.Windows.Controls.RichTextBox> erfolgt mit der <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A> und <xref:System.Windows.Controls.Control.VerticalContentAlignment%2A> Eigenschaften. Ausrichten von der <xref:System.Windows.Controls.RichTextBox> innerhalb des Layouts der Seite erfolgt mit der <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> und <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> Eigenschaften.  
  
 Bildlaufleisten sind nicht sichtbar ist, auf eine <xref:System.Windows.Controls.RichTextBox> standardmäßig. Um eine Bildlaufleiste sichtbar machen, legen Sie die <xref:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility%2A> Eigenschaft <xref:System.Windows.Controls.ScrollBarVisibility.Visible> oder <xref:System.Windows.Controls.ScrollBarVisibility.Auto>.  
  
 In der Regel die <xref:System.Windows.Controls.Primitives.TextBoxBase.TextChanged> Ereignis sollte verwendet werden, erkennen, wann der Text in eine <xref:System.Windows.Controls.TextBox> oder <xref:System.Windows.Controls.RichTextBox> geändert wird, klicken Sie dann stattdessen <xref:System.Windows.UIElement.KeyDown> wie zu erwarten. Ein Beispiel finden Sie unter [Vorgehensweise: Erkennen von Änderungen an Text in einem Textfeld](~/docs/framework/wpf/controls/how-to-detect-when-text-in-a-textbox-has-changed.md).  
  
 <xref:System.Windows.Controls.RichTextBox> unterstützt eine Vielzahl von Tastaturbefehlen. Eine Liste der Tastenkombinationen, finden Sie unter <xref:System.Windows.Documents.EditingCommands>.  
  
 Abhängigkeitseigenschaften für dieses Steuerelement können vom Standardformat des Steuerelements festgelegt werden.  Wenn eine Eigenschaft von einem standardmäßigen Format festgelegt ist, kann die Eigenschaft den Standardwert ändern, wenn das Steuerelement in der Anwendung angezeigt wird. Das Standardformat wird bestimmt durch die Desktopdesign verwendet wird, wenn die Anwendung ausgeführt wird.  Weitere Informationen finden Sie unter [Default WPF Themes](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 Das folgende Beispiel deklariert eine <xref:System.Windows.Controls.RichTextBox> , enthält eine einfache <xref:System.Windows.Documents.FlowDocument>.  
  
 [!code-xaml[RichTextBoxSnippets#_RTB_XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml#_rtb_xaml)]  
  
 [!code-csharp[RichTextBoxMiscSnippets_procedural_snip#RichTextBoxCodeOnlyExample](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxMiscSnippets_procedural_snip/CSharp/RichTextBoxExample.cs#richtextboxcodeonlyexample)]
 [!code-vb[RichTextBoxMiscSnippets_procedural_snip#RichTextBoxCodeOnlyExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxMiscSnippets_procedural_snip/visualbasic/richtextboxexample.vb#richtextboxcodeonlyexample)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.RichTextBox" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Standardinstanz der <see cref="T:System.Windows.Controls.RichTextBox" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein leeres <xref:System.Windows.Documents.FlowDocument> , die Document-Eigenschaft zugeordnet ist.  Das leere <xref:System.Windows.Documents.FlowDocument> enthält speziell einen einzelnen <xref:System.Windows.Documents.Paragraph>, der wiederum einen einzelnen <xref:System.Windows.Documents.Run> ohne Text enthält.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox (System.Windows.Documents.FlowDocument document);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.FlowDocument document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.#ctor(System.Windows.Documents.FlowDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (document As FlowDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox(System::Windows::Documents::FlowDocument ^ document);" />
      <MemberSignature Language="F#" Value="new System.Windows.Controls.RichTextBox : System.Windows.Documents.FlowDocument -&gt; System.Windows.Controls.RichTextBox" Usage="new System.Windows.Controls.RichTextBox document" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="document" Type="System.Windows.Documents.FlowDocument" />
      </Parameters>
      <Docs>
        <param name="document">Ein <see cref="T:System.Windows.Documents.FlowDocument" />, das als ursprünglicher Inhalt der neuen <see cref="T:System.Windows.Controls.RichTextBox" /> hinzugefügt werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.RichTextBox" />-Klasse, wobei ein angegebenes <see cref="T:System.Windows.Documents.FlowDocument" /> als ursprünglicher Inhalt hinzugefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Constructor](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_constructor)]
 [!code-vb[RichTextBoxSnippets#_RTB_Constructor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_constructor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaretPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer CaretPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer CaretPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.CaretPosition" />
      <MemberSignature Language="VB.NET" Value="Public Property CaretPosition As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ CaretPosition { System::Windows::Documents::TextPointer ^ get(); void set(System::Windows::Documents::TextPointer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CaretPosition : System.Windows.Documents.TextPointer with get, set" Usage="System.Windows.Controls.RichTextBox.CaretPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position der Einfügemarke ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.Documents.TextPointer" />-Objekt, das die Position der Einfügemarke angibt.  
  
Standardmäßig ist die Einfügemarke die erste Einfügeposition im Inhalt, der von der <see cref="T:System.Windows.Controls.RichTextBox" /> gehostet wird. Weitere Informationen zu Textpositionierungsbegriffen wie "Einfügeposition" finden Sie unter <see cref="T:System.Windows.Documents.TextPointer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieser Eigenschaft.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_CaretPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_caretposition)]
 [!code-vb[RichTextBoxSnippets#_RTB_CaretPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_caretposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Es wird versucht, diese Eigenschaft auf <see langword="null" /> festzulegen.</exception>
        <exception cref="T:System.ArgumentException">Es wurde versucht, diese Eigenschaft auf einen <see cref="T:System.Windows.Documents.TextPointer" /> festzulegen, der auf eine Position außerhalb des aktuellen Dokuments verweist.</exception>
        <altmember cref="T:System.Windows.Documents.TextPointer" />
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.FlowDocument Document { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.FlowDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.Document" />
      <MemberSignature Language="VB.NET" Value="Public Property Document As FlowDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::FlowDocument ^ Document { System::Windows::Documents::FlowDocument ^ get(); void set(System::Windows::Documents::FlowDocument ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Documents.FlowDocument with get, set" Usage="System.Windows.Controls.RichTextBox.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.FlowDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Windows.Documents.FlowDocument" /> ab, das den Inhalt der <see cref="T:System.Windows.Controls.RichTextBox" /> darstellt, oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Windows.Documents.FlowDocument" />-Objekt, das den Inhalt der <see cref="T:System.Windows.Controls.RichTextBox" /> darstellt.  
  
Standardmäßig wird diese Eigenschaft auf ein leeres <see cref="T:System.Windows.Documents.FlowDocument" /> festgelegt.  Das leere <see cref="T:System.Windows.Documents.FlowDocument" /> enthält speziell einen einzelnen <see cref="T:System.Windows.Documents.Paragraph" />, der wiederum einen einzelnen <see cref="T:System.Windows.Documents.Run" /> ohne Text enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein FlowDocument kann nur durch eine einzelne gehostet werden <xref:System.Windows.Controls.RichTextBox>.  Festlegen eines einzelnen FlowDocument als Inhalt für mehrere <xref:System.Windows.Controls.RichTextBox> Steuerelemente wird nicht unterstützt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieser Eigenschaft.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Document](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_document)]
 [!code-vb[RichTextBoxSnippets#_RTB_Document](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_document)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Es wird versucht, diese Eigenschaft auf <see langword="null" /> festzulegen.</exception>
        <exception cref="T:System.ArgumentException">Es wurde versucht, diese Eigenschaft auf ein <see cref="T:System.Windows.Documents.FlowDocument" /> festzulegen, das den Inhalt einer anderen <see cref="T:System.Windows.Controls.RichTextBox" /> darstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wird während des Aktivierens eines Änderungsblocks festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNextSpellingErrorPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextSpellingErrorPosition (System.Windows.Documents.TextPointer position, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextSpellingErrorPosition(class System.Windows.Documents.TextPointer position, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextSpellingErrorPosition (position As TextPointer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextSpellingErrorPosition(System::Windows::Documents::TextPointer ^ position, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextSpellingErrorPosition : System.Windows.Documents.TextPointer * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="richTextBox.GetNextSpellingErrorPosition (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="position">Ein <see cref="T:System.Windows.Documents.TextPointer" />, der eine Position angibt, ab der nach dem nächsten Rechtschreibfehler gesucht werden soll.</param>
        <param name="direction">Eine <see cref="T:System.Windows.Documents.LogicalDirection" />, in der nach dem nächsten Rechtschreibfehler gesucht werden soll, beginnend an der angegebenen <c>position</c>.</param>
        <summary>Gibt einen <see cref="T:System.Windows.Documents.TextPointer" /> zurück, der im Inhalt der <see cref="T:System.Windows.Controls.RichTextBox" /> auf den nächsten Rechtschreibfehler zeigt.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextPointer" />, der im Inhalt der <see cref="T:System.Windows.Controls.RichTextBox" /> auf den nächsten Rechtschreibfehler zeigt, oder <see langword="null" />, wenn kein nächster Rechtschreibfehler vorhanden ist.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionFromPoint (System.Windows.Point point, bool snapToText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionFromPoint(valuetype System.Windows.Point point, bool snapToText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetPositionFromPoint(System.Windows.Point,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionFromPoint(System::Windows::Point point, bool snapToText);" />
      <MemberSignature Language="F#" Value="member this.GetPositionFromPoint : System.Windows.Point * bool -&gt; System.Windows.Documents.TextPointer" Usage="richTextBox.GetPositionFromPoint (point, snapToText)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="snapToText" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point">Ein <see cref="T:System.Windows.Point" />-Objekt, das die Position angibt, für die ein <see cref="T:System.Windows.Documents.TextPointer" /> abgerufen werden soll.</param>
        <param name="snapToText">Beim Wert <see langword="true" /> gibt diese Methode immer einen <see cref="T:System.Windows.Documents.TextPointer" /> zurück, der die nächste Einfügeposition für den angegebenen <see cref="T:System.Windows.Point" /> angibt, wobei es keine Rolle spielt, ob sich der angegebene <see cref="T:System.Windows.Point" /> im umgebenden Rechteck eines Zeichens befindet.  
  
Beim Wert <see langword="false" /> gibt diese Methode <see langword="null" /> zurück, wenn der angegebene <see cref="T:System.Windows.Point" /> nicht im umgebenden Rechteck eines Zeichens liegt.</param>
        <summary>Gibt einen <see cref="T:System.Windows.Documents.TextPointer" /> zurück, der auf die Einfügemarke zeigt, die der angegebenen Position am nächsten liegt.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextPointer" />, der die nächste Einfügeposition für den angegebenen Punkt angibt, oder <see langword="null" />, wenn <paramref name="snapToText" /><see langword="false" /> ist und der angegebene <see cref="T:System.Windows.Point" /> sich nicht im umgebenden Rechteck eines Zeichens befindet. Beachten Sie, dass der zurückgegebene <see cref="T:System.Windows.Documents.TextPointer" /> normalerweise die Position zwischen zwei Zeichen darstellt. Bestimmen Sie mit der <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />-Eigenschaft des zurückgegebenen <see cref="T:System.Windows.Documents.TextPointer" />, welchem der beiden Zeichen der <see cref="T:System.Windows.Documents.TextPointer" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RichTextBox> ein Standardkoordinatensystem mit dem Ursprung befindet sich auf der linken oberen Ecke des verwendet die <xref:System.Windows.Controls.RichTextBox>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wird ausgelöst, wenn die Layoutinformationen für die <see cref="T:System.Windows.Controls.RichTextBox" /> nicht aktuell sind.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSpellingError">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.SpellingError GetSpellingError (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Controls.SpellingError GetSpellingError(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSpellingError (position As TextPointer) As SpellingError" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Controls::SpellingError ^ GetSpellingError(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetSpellingError : System.Windows.Documents.TextPointer -&gt; System.Windows.Controls.SpellingError" Usage="richTextBox.GetSpellingError position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.SpellingError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Ein <see cref="T:System.Windows.Documents.TextPointer" />, der eine Position und eine logische Richtung angibt, die in ein Zeichen aufgelöst wird, das auf einen Rechtschreibfehler untersucht werden soll. Verwenden Sie die <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />-Eigenschaft dieses <see cref="T:System.Windows.Documents.TextPointer" />, um die Richtung des zu untersuchenden Zeichens anzugeben.</param>
        <summary>Gibt ein <see cref="T:System.Windows.Controls.SpellingError" />-Objekt zurück, das einem Rechtschreibfehler an einer bestimmten Position im Inhalt des <see cref="T:System.Windows.Controls.RichTextBox" /> zugeordnet ist.</summary>
        <returns>Ein <see cref="T:System.Windows.Controls.SpellingError" />-Objekt mit Details zum Rechtschreibfehler, der bei dem durch <paramref name="position" /> angegebenen Zeichen gefunden wurde, oder <see langword="null" />, wenn beim angegebenen Zeichen kein Rechtschreibfehler gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Documents.TextPointer> wie `position` in der Regel gibt eine Position zwischen zwei Zeichen lang sein. Verwenden der <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> Eigenschaft `position` um die zu untersuchenden Zeichens anzugeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetSpellingErrorRange">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextRange GetSpellingErrorRange (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextRange GetSpellingErrorRange(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSpellingErrorRange (position As TextPointer) As TextRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextRange ^ GetSpellingErrorRange(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetSpellingErrorRange : System.Windows.Documents.TextPointer -&gt; System.Windows.Documents.TextRange" Usage="richTextBox.GetSpellingErrorRange position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Ein <see cref="T:System.Windows.Documents.TextPointer" />, der eine Position und eine logische Richtung angibt, die in ein Zeichen aufgelöst wird, das auf einen Rechtschreibfehler untersucht werden soll. Verwenden Sie die <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />-Eigenschaft dieses <see cref="T:System.Windows.Documents.TextPointer" />, um die Richtung des zu untersuchenden Zeichens anzugeben.</param>
        <summary>Gibt ein <see cref="T:System.Windows.Documents.TextRange" />-Objekt zurück, das jedes falsch geschriebene Wort an der angegebenen Position im Inhalt der <see cref="T:System.Windows.Controls.RichTextBox" /> umfasst.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextRange" />-Objekt das jedes falsch geschriebene Wort umfasst, das das von <paramref name="position" /> angegebene Zeichen enthält, oder <see langword="null" />, wenn am angegebenen Zeichen kein Rechtschreibfehler vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Documents.TextPointer> wie `position` in der Regel gibt eine Position zwischen zwei Zeichen lang sein. Verwenden der <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> Eigenschaft `position` um die zu untersuchenden Zeichens anzugeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsDocumentEnabled">
      <MemberSignature Language="C#" Value="public bool IsDocumentEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDocumentEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.IsDocumentEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsDocumentEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDocumentEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsDocumentEnabled : bool with get, set" Usage="System.Windows.Controls.RichTextBox.IsDocumentEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Benutzer mit <see cref="T:System.Windows.UIElement" />- und <see cref="T:System.Windows.ContentElement" />-Objekten innerhalb der <see cref="T:System.Windows.Controls.RichTextBox" /> interagieren kann, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn der Benutzer mit <see cref="T:System.Windows.UIElement" />- und <see cref="T:System.Windows.ContentElement" />-Objekten innerhalb der <see cref="T:System.Windows.Controls.RichTextBox" /> interagieren kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RichTextBox.IsDocumentEnabled%2A> wird in .NET Framework, Version 3.5 eingeführt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt <xref:System.Windows.Controls.CheckBox> und <xref:System.Windows.Controls.RichTextBox> , enthält eine <xref:System.Windows.Documents.Hyperlink> und <xref:System.Windows.Controls.Button>.  Die <xref:System.Windows.Controls.RichTextBox.IsDocumentEnabled%2A> Eigenschaft der <xref:System.Windows.Controls.RichTextBox> gebunden ist die <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A> Eigenschaft der <xref:System.Windows.Controls.CheckBox>.  Wenn der Benutzer wählt die <xref:System.Windows.Controls.CheckBox>, der Benutzer interagieren kann die <xref:System.Windows.Controls.Button> und <xref:System.Windows.Documents.Hyperlink>. Wenn der Benutzer löscht die <xref:System.Windows.Controls.CheckBox>, <xref:System.Windows.Controls.Button> und <xref:System.Windows.Documents.Hyperlink> sind deaktiviert.  
  
 [!code-xaml[RTBIsDocumentEnabled#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RTBIsDocumentEnabled/VB/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDocumentEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsDocumentEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsDocumentEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.RichTextBox.IsDocumentEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsDocumentEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsDocumentEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsDocumentEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.RichTextBox.IsDocumentEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Controls.RichTextBox.IsDocumentEnabled" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.RichTextBox.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator ab, der die logischen untergeordneten Elemente des <see langword="RichTextBox" /> durchlaufen kann.</summary>
        <value>Ein Enumerator für die logischen untergeordneten Elemente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="richTextBox.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Eine <see cref="T:System.Windows.Size" />-Struktur, die Einschränkungen für die Größe der <see cref="T:System.Windows.Controls.RichTextBox" /> angibt.</param>
        <summary>Wird aufgerufen, um den <see cref="T:System.Windows.Controls.RichTextBox" /> erneut zu messen.</summary>
        <returns>Eine <see cref="T:System.Windows.Size" />-Struktur, die die neue Größe des <see cref="T:System.Windows.Controls.RichTextBox" /> angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.Controls.Control.MeasureOverride%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="richTextBox.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />-Objekt für dieses <see cref="T:System.Windows.Controls.RichTextBox" /> und gibt dieses zurück.</summary>
        <returns>Ein <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />-Objekt für dieses <see cref="T:System.Windows.Controls.RichTextBox" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpiScaleInfo, System.Windows.DpiScale newDpiScaleInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpiScaleInfo, valuetype System.Windows.DpiScale newDpiScaleInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpiScaleInfo As DpiScale, newDpiScaleInfo As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpiScaleInfo, System::Windows::DpiScale newDpiScaleInfo);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit&#xA;override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="richTextBox.OnDpiChanged (oldDpiScaleInfo, newDpiScaleInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpiScaleInfo" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpiScaleInfo" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpiScaleInfo">Die vorherige DPI-Größeneinstellung.</param>
        <param name="newDpiScaleInfo">Die neue DPI-Größeneinstellung.</param>
        <summary>Wird aufgerufen, wenn sich der DPI-Wert ändert, mit dem dieses Rich-Text-Feld gerendert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Selection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextSelection Selection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextSelection Selection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.Selection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Selection As TextSelection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextSelection ^ Selection { System::Windows::Documents::TextSelection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Selection : System.Windows.Documents.TextSelection" Usage="System.Windows.Controls.RichTextBox.Selection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextSelection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Windows.Documents.TextSelection" />-Objekt ab, das die aktuelle Auswahl im <see cref="T:System.Windows.Controls.RichTextBox" /> enthält.</summary>
        <value>Ein <see cref="T:System.Windows.Documents.TextSelection" />-Objekt, das die aktuelle Auswahl im <see cref="T:System.Windows.Controls.RichTextBox" /> enthält.  
  
Die standardmäßige zurückgegebene <see cref="T:System.Windows.Documents.TextSelection" /> hat einen <see cref="P:System.Windows.Documents.TextRange.IsEmpty" />-Eigenschaftswert von <see langword="true" />. Eine leere <see cref="T:System.Windows.Documents.TextSelection" /> wird im Textbereich als Einfügemarke ohne Auswahl gerendert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Documents.TextRange.Select%2A> Methode programmgesteuert Inhalt aus.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieser Eigenschaft.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Selection](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_selection)]
 [!code-vb[RichTextBoxSnippets#_RTB_Selection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_selection)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeDocument">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeDocument() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.ShouldSerializeDocument" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeDocument () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeDocument();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeDocument : unit -&gt; bool" Usage="richTextBox.ShouldSerializeDocument " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob der tatsächliche Wert der <see cref="P:System.Windows.Controls.RichTextBox.Document" />-Eigenschaft bei der Serialisierung eines <see cref="T:System.Windows.Controls.RichTextBox" />-Objekts serialisiert werden soll.</summary>
        <returns><see langword="true" />, wenn die <see cref="P:System.Windows.Controls.RichTextBox.Document" />-Eigenschaft serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Ein Objekt, das als untergeordnetes Element hinzugefügt werden soll.</param>
        <summary>Dieser Typ oder Member unterstützt die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Eine Zeichenfolge, die dem Objekt hinzugefügt werden soll.</param>
        <summary>Dieser Typ oder Member unterstützt die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>