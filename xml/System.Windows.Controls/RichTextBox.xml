<Type Name="RichTextBox" FullName="System.Windows.Controls.RichTextBox">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f866e5313d4b5466feff172d2240dce1c1a7cb79" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83492405" /></Metadata><TypeSignature Language="C#" Value="public class RichTextBox : System.Windows.Controls.Primitives.TextBoxBase, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RichTextBox extends System.Windows.Controls.Primitives.TextBoxBase implements class System.Windows.Markup.IAddChild" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.RichTextBox" />
  <TypeSignature Language="VB.NET" Value="Public Class RichTextBox&#xA;Inherits TextBoxBase&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class RichTextBox : System::Windows::Controls::Primitives::TextBoxBase, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type RichTextBox = class&#xA;    inherit TextBoxBase&#xA;    interface IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi RichTextBox extends System.Windows.Controls.Primitives.TextBoxBase implements class System.Windows.Markup.IAddChild" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Primitives.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Inherit)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Document")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein erweitertes Bearbeitungssteuerelement für <see cref="T:System.Windows.Documents.FlowDocument" />-Objekte dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.FlowDocument> ist das einzige unterstützte untergeordnete Element für eine <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Controls.RichTextBox> verfügt über eine integrierte Behandlung der Blasen <xref:System.Windows.UIElement.MouseUp> und <xref:System.Windows.UIElement.MouseDown>-Ereignisse.  Folglich werden benutzerdefinierte Ereignishandler, die auf `MouseUp` oder `MouseDown` Ereignisse eines <xref:System.Windows.Controls.RichTextBox> lauschen, nie aufgerufen.  Wenn Sie auf diese Ereignisse reagieren müssen, lauschen Sie stattdessen auf das Tunneling<xref:System.Windows.UIElement.PreviewMouseUp> und <xref:System.Windows.UIElement.PreviewMouseDown> Ereignisse, oder registrieren Sie die Handler mit dem <xref:System.Windows.EventSetter.HandledEventsToo%2A>-Argument (diese zweite Option ist nur über Code verfügbar). Markieren Sie das Ereignis nicht als behandelt, es sei denn, Sie möchten die <xref:System.Windows.Controls.RichTextBox> systemeigene Behandlung dieser Ereignisse absichtlich deaktivieren und beachten, dass dies relevante Auswirkungen auf die [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]des Steuer Elements hat.  
  
 Obwohl <xref:System.Windows.Controls.RichTextBox> das Kopieren und Einfügen von Bildern unterstützt, werden bestimmte Szenarien derzeit nicht unterstützt und funktionieren möglicherweise nicht ordnungsgemäß.  In der folgenden Tabelle werden diese Szenarien und die erwarteten Ergebnisse zusammengefasst.  
  
|Quelle für Bild Kopie|Ergebnis der Bild einfügen|  
|-----------------------|------------------------|  
|Die Bildquelle ist eine Grafik Metadatei.|Es ist kein Bild eingefügt.|  
|Bildquelle verwendet relativen Pfad oder Link|Gegartes oder leeres Bild ist eingefügt|  
|Der Bild Quell Link endet nicht mit einem erwarteten Bildformat (). PNG,. JPG,. GIF|Gegartes oder leeres Bild ist eingefügt|  
|Bildquelle aus falsch formatierten RichText (RTF) kopiert|Der Link zur Bildquelle ist eingefügt (anstelle von Image).|  
  
 Das Einfügen von HTML-Inhalt in eine <xref:System.Windows.Controls.RichTextBox> kann zu unerwartetem Verhalten führen, da <xref:System.Windows.Controls.RichTextBox> das RTF-Format verwendet, anstatt direkt das HTML-Format zu verwenden.  
  
 Text wird immer in einem <xref:System.Windows.Controls.RichTextBox>umschlossen. Wenn Sie den Text nicht einbinden möchten, legen Sie den <xref:System.Windows.Documents.FlowDocument.PageWidth%2A> auf dem <xref:System.Windows.Documents.FlowDocument> auf einen Wert fest, der größer als die Breite des <xref:System.Windows.Controls.RichTextBox>ist. Sobald die Seitenbreite erreicht ist, wird der Text jedoch immer noch umschlossen.  
  
 Die horizontale und vertikale Ausrichtung von Inhalt in einem <xref:System.Windows.Controls.RichTextBox> erfolgt mit den Eigenschaften <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A> und <xref:System.Windows.Controls.Control.VerticalContentAlignment%2A>. Die Ausrichtung der <xref:System.Windows.Controls.RichTextBox> im Layout der Seite erfolgt mit den Eigenschaften <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> und <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>.  
  
 Scrollleisten werden in einem <xref:System.Windows.Controls.RichTextBox> standardmäßig nicht angezeigt. Um eine Scrollleiste sichtbar zu machen, legen Sie die <xref:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility%2A>-Eigenschaft auf <xref:System.Windows.Controls.ScrollBarVisibility.Visible> oder <xref:System.Windows.Controls.ScrollBarVisibility.Auto>fest.  
  
 Normalerweise sollte das <xref:System.Windows.Controls.Primitives.TextBoxBase.TextChanged> Ereignis verwendet werden, um zu erkennen, wann der Text in einem <xref:System.Windows.Controls.TextBox> oder <xref:System.Windows.Controls.RichTextBox> geändert wird, und <xref:System.Windows.UIElement.KeyDown>, wie Sie es möglicherweise erwartet. Ein Beispiel finden Sie unter Gewusst [wie: erkennen, wenn Text in einem Textfeld geändert wurde](~/docs/framework/wpf/controls/how-to-detect-when-text-in-a-textbox-has-changed.md).  
  
 <xref:System.Windows.Controls.RichTextBox> unterstützt eine Vielzahl von Tastaturbefehlen. Eine Liste der Tastaturbefehle finden Sie unter <xref:System.Windows.Documents.EditingCommands>.  
  
 Abhängigkeits Eigenschaften für dieses Steuerelement können durch den Standardstil des Steuer Elements festgelegt werden.  Wenn eine Eigenschaft durch einen Standardstil festgelegt wird, kann sich die Eigenschaft von ihrem Standardwert ändern, wenn das Steuerelement in der Anwendung angezeigt wird. Der Standardstil wird bestimmt, welches Desktop Design verwendet wird, wenn die Anwendung ausgeführt wird.  Weitere Informationen finden Sie unter [standardmäßige WPF](https://go.microsoft.com/fwlink/?LinkID=158252)-Designs.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Windows.Controls.RichTextBox> deklariert, der einen einfachen <xref:System.Windows.Documents.FlowDocument>enthält.  
  
 [!code-xaml[RichTextBoxSnippets#_RTB_XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml#_rtb_xaml)]  
  
 [!code-csharp[RichTextBoxMiscSnippets_procedural_snip#RichTextBoxCodeOnlyExample](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxMiscSnippets_procedural_snip/CSharp/RichTextBoxExample.cs#richtextboxcodeonlyexample)]
 [!code-vb[RichTextBoxMiscSnippets_procedural_snip#RichTextBoxCodeOnlyExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxMiscSnippets_procedural_snip/visualbasic/richtextboxexample.vb#richtextboxcodeonlyexample)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Standardinstanz der <see cref="T:System.Windows.Controls.RichTextBox" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine leere <xref:System.Windows.Documents.FlowDocument>, die der Dokument Eigenschaft zugeordnet ist.  Das leere <xref:System.Windows.Documents.FlowDocument> enthält speziell einen einzelnen <xref:System.Windows.Documents.Paragraph>, der wiederum einen einzelnen <xref:System.Windows.Documents.Run> ohne Text enthält.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox (System.Windows.Documents.FlowDocument document);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.FlowDocument document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.#ctor(System.Windows.Documents.FlowDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (document As FlowDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox(System::Windows::Documents::FlowDocument ^ document);" />
      <MemberSignature Language="F#" Value="new System.Windows.Controls.RichTextBox : System.Windows.Documents.FlowDocument -&gt; System.Windows.Controls.RichTextBox" Usage="new System.Windows.Controls.RichTextBox document" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="document" Type="System.Windows.Documents.FlowDocument" />
      </Parameters>
      <Docs>
        <param name="document">Ein <see cref="T:System.Windows.Documents.FlowDocument" />, das als ursprünglicher Inhalt der neuen <see cref="T:System.Windows.Controls.RichTextBox" /> hinzugefügt werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.RichTextBox" />-Klasse, wobei ein angegebenes <see cref="T:System.Windows.Documents.FlowDocument" /> als ursprünglicher Inhalt hinzugefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die Verwendung dieses Konstruktors veranschaulicht.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Constructor](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_constructor)]
 [!code-vb[RichTextBoxSnippets#_RTB_Constructor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_constructor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaretPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer CaretPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer CaretPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.CaretPosition" />
      <MemberSignature Language="VB.NET" Value="Public Property CaretPosition As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ CaretPosition { System::Windows::Documents::TextPointer ^ get(); void set(System::Windows::Documents::TextPointer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CaretPosition : System.Windows.Documents.TextPointer with get, set" Usage="System.Windows.Controls.RichTextBox.CaretPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position der Einfügemarke ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.Documents.TextPointer" />-Objekt, das die Position der Einfügemarke angibt.  
  
Standardmäßig ist die Einfügemarke die erste Einfügeposition im Inhalt, der von der <see cref="T:System.Windows.Controls.RichTextBox" /> gehostet wird. Weitere Informationen zu Textpositionierungsbegriffen wie "Einfügeposition" finden Sie unter <see cref="T:System.Windows.Documents.TextPointer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieser Eigenschaft.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_CaretPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_caretposition)]
 [!code-vb[RichTextBoxSnippets#_RTB_CaretPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_caretposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Es wird versucht, diese Eigenschaft auf <see langword="null" /> festzulegen.</exception>
        <exception cref="T:System.ArgumentException">Es wurde versucht, diese Eigenschaft auf einen <see cref="T:System.Windows.Documents.TextPointer" /> festzulegen, der auf eine Position außerhalb des aktuellen Dokuments verweist.</exception>
        <altmember cref="T:System.Windows.Documents.TextPointer" />
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.FlowDocument Document { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.FlowDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.Document" />
      <MemberSignature Language="VB.NET" Value="Public Property Document As FlowDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::FlowDocument ^ Document { System::Windows::Documents::FlowDocument ^ get(); void set(System::Windows::Documents::FlowDocument ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Documents.FlowDocument with get, set" Usage="System.Windows.Controls.RichTextBox.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.FlowDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Windows.Documents.FlowDocument" /> ab, das den Inhalt der <see cref="T:System.Windows.Controls.RichTextBox" /> darstellt, oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Windows.Documents.FlowDocument" />-Objekt, das den Inhalt der <see cref="T:System.Windows.Controls.RichTextBox" /> darstellt.  
  
Standardmäßig wird diese Eigenschaft auf ein leeres <see cref="T:System.Windows.Documents.FlowDocument" /> festgelegt.  Das leere <see cref="T:System.Windows.Documents.FlowDocument" /> enthält speziell einen einzelnen <see cref="T:System.Windows.Documents.Paragraph" />, der wiederum einen einzelnen <see cref="T:System.Windows.Documents.Run" /> ohne Text enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein FlowDocument kann nur von einem einzelnen <xref:System.Windows.Controls.RichTextBox>gehostet werden.  Das Angeben eines einzelnen FlowDocument als Inhalt mehrerer <xref:System.Windows.Controls.RichTextBox> Steuerelemente wird nicht unterstützt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieser Eigenschaft.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Document](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_document)]
 [!code-vb[RichTextBoxSnippets#_RTB_Document](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_document)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Es wird versucht, diese Eigenschaft auf <see langword="null" /> festzulegen.</exception>
        <exception cref="T:System.ArgumentException">Es wurde versucht, diese Eigenschaft auf ein <see cref="T:System.Windows.Documents.FlowDocument" /> festzulegen, das den Inhalt einer anderen <see cref="T:System.Windows.Controls.RichTextBox" /> darstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wird während des Aktivierens eines Änderungsblocks festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNextSpellingErrorPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextSpellingErrorPosition (System.Windows.Documents.TextPointer position, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextSpellingErrorPosition(class System.Windows.Documents.TextPointer position, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextSpellingErrorPosition (position As TextPointer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextSpellingErrorPosition(System::Windows::Documents::TextPointer ^ position, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextSpellingErrorPosition : System.Windows.Documents.TextPointer * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="richTextBox.GetNextSpellingErrorPosition (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="position">Ein <see cref="T:System.Windows.Documents.TextPointer" />, der eine Position angibt, ab der nach dem nächsten Rechtschreibfehler gesucht werden soll.</param>
        <param name="direction">Eine <see cref="T:System.Windows.Documents.LogicalDirection" />, in der nach dem nächsten Rechtschreibfehler gesucht werden soll, beginnend an der angegebenen <c>Position</c>.</param>
        <summary>Gibt einen <see cref="T:System.Windows.Documents.TextPointer" /> zurück, der im Inhalt der <see cref="T:System.Windows.Controls.RichTextBox" /> auf den nächsten Rechtschreibfehler zeigt.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextPointer" />, der im Inhalt der <see cref="T:System.Windows.Controls.RichTextBox" /> auf den nächsten Rechtschreibfehler zeigt, oder <see langword="null" />, wenn kein nächster Rechtschreibfehler vorhanden ist.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionFromPoint (System.Windows.Point point, bool snapToText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionFromPoint(valuetype System.Windows.Point point, bool snapToText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetPositionFromPoint(System.Windows.Point,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionFromPoint (point As Point, snapToText As Boolean) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionFromPoint(System::Windows::Point point, bool snapToText);" />
      <MemberSignature Language="F#" Value="member this.GetPositionFromPoint : System.Windows.Point * bool -&gt; System.Windows.Documents.TextPointer" Usage="richTextBox.GetPositionFromPoint (point, snapToText)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="snapToText" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point">Ein <see cref="T:System.Windows.Point" />-Objekt, das die Position angibt, für die ein <see cref="T:System.Windows.Documents.TextPointer" /> abgerufen werden soll.</param>
        <param name="snapToText">Beim Wert <see langword="true" /> gibt diese Methode immer einen <see cref="T:System.Windows.Documents.TextPointer" /> zurück, der die nächste Einfügeposition für den angegebenen <see cref="T:System.Windows.Point" /> angibt, wobei es keine Rolle spielt, ob sich der angegebene <see cref="T:System.Windows.Point" /> im umgebenden Rechteck eines Zeichens befindet.  
  
Beim Wert <see langword="false" /> gibt diese Methode <see langword="null" /> zurück, wenn der angegebene <see cref="T:System.Windows.Point" /> nicht im umgebenden Rechteck eines Zeichens liegt.</param>
        <summary>Gibt einen <see cref="T:System.Windows.Documents.TextPointer" /> zurück, der auf die Einfügemarke zeigt, die der angegebenen Position am nächsten liegt.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextPointer" />, der die nächste Einfügeposition für den angegebenen Punkt angibt, oder <see langword="null" />, wenn <paramref name="snapToText" /><see langword="false" /> ist und der angegebene <see cref="T:System.Windows.Point" /> sich nicht im umgebenden Rechteck eines Zeichens befindet. Beachten Sie, dass der zurückgegebene <see cref="T:System.Windows.Documents.TextPointer" /> normalerweise die Position zwischen zwei Zeichen darstellt. Bestimmen Sie mit der <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />-Eigenschaft des zurückgegebenen <see cref="T:System.Windows.Documents.TextPointer" />, welchem der beiden Zeichen der <see cref="T:System.Windows.Documents.TextPointer" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RichTextBox> verwendet ein Standard Koordinatensystem mit dem Ursprung, der sich in der oberen linken Ecke des <xref:System.Windows.Controls.RichTextBox>befindet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wird ausgelöst, wenn die Layoutinformationen für die <see cref="T:System.Windows.Controls.RichTextBox" /> nicht aktuell sind.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSpellingError">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.SpellingError GetSpellingError (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Controls.SpellingError GetSpellingError(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSpellingError (position As TextPointer) As SpellingError" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Controls::SpellingError ^ GetSpellingError(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetSpellingError : System.Windows.Documents.TextPointer -&gt; System.Windows.Controls.SpellingError" Usage="richTextBox.GetSpellingError position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.SpellingError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Ein <see cref="T:System.Windows.Documents.TextPointer" />, der eine Position und eine logische Richtung angibt, die in ein Zeichen aufgelöst wird, das auf einen Rechtschreibfehler untersucht werden soll. Verwenden Sie die <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />-Eigenschaft dieses <see cref="T:System.Windows.Documents.TextPointer" />, um die Richtung des zu untersuchenden Zeichens anzugeben.</param>
        <summary>Gibt ein <see cref="T:System.Windows.Controls.SpellingError" />-Objekt zurück, das einem Rechtschreibfehler an einer bestimmten Position im Inhalt des <see cref="T:System.Windows.Controls.RichTextBox" /> zugeordnet ist.</summary>
        <returns>Ein <see cref="T:System.Windows.Controls.SpellingError" />-Objekt mit Details zum Rechtschreibfehler, der bei dem durch <paramref name="position" /> angegebenen Zeichen gefunden wurde, oder <see langword="null" />, wenn beim angegebenen Zeichen kein Rechtschreibfehler gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Documents.TextPointer> wie `position` gibt in der Regel eine Position zwischen zwei Zeichen an. Verwenden Sie die <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A>-Eigenschaft von `position`, um anzugeben, welches Zeichen untersucht werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetSpellingErrorRange">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextRange GetSpellingErrorRange (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextRange GetSpellingErrorRange(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSpellingErrorRange (position As TextPointer) As TextRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextRange ^ GetSpellingErrorRange(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetSpellingErrorRange : System.Windows.Documents.TextPointer -&gt; System.Windows.Documents.TextRange" Usage="richTextBox.GetSpellingErrorRange position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Ein <see cref="T:System.Windows.Documents.TextPointer" />, der eine Position und eine logische Richtung angibt, die in ein Zeichen aufgelöst wird, das auf einen Rechtschreibfehler untersucht werden soll. Verwenden Sie die <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />-Eigenschaft dieses <see cref="T:System.Windows.Documents.TextPointer" />, um die Richtung des zu untersuchenden Zeichens anzugeben.</param>
        <summary>Gibt ein <see cref="T:System.Windows.Documents.TextRange" />-Objekt zurück, das jedes falsch geschriebene Wort an der angegebenen Position im Inhalt der <see cref="T:System.Windows.Controls.RichTextBox" /> umfasst.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextRange" />-Objekt das jedes falsch geschriebene Wort umfasst, das das von <paramref name="position" /> angegebene Zeichen enthält, oder <see langword="null" />, wenn am angegebenen Zeichen kein Rechtschreibfehler vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Documents.TextPointer> wie `position` gibt in der Regel eine Position zwischen zwei Zeichen an. Verwenden Sie die <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A>-Eigenschaft von `position`, um anzugeben, welches Zeichen untersucht werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsDocumentEnabled">
      <MemberSignature Language="C#" Value="public bool IsDocumentEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDocumentEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.IsDocumentEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsDocumentEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDocumentEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsDocumentEnabled : bool with get, set" Usage="System.Windows.Controls.RichTextBox.IsDocumentEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Benutzer mit <see cref="T:System.Windows.UIElement" />- und <see cref="T:System.Windows.ContentElement" />-Objekten innerhalb der <see cref="T:System.Windows.Controls.RichTextBox" /> interagieren kann, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn der Benutzer mit <see cref="T:System.Windows.UIElement" />- und <see cref="T:System.Windows.ContentElement" />-Objekten innerhalb der <see cref="T:System.Windows.Controls.RichTextBox" /> interagieren kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RichTextBox.IsDocumentEnabled%2A> wird in .NET Framework Version 3,5 eingeführt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Im folgenden Beispiel werden <xref:System.Windows.Controls.CheckBox> und ein <xref:System.Windows.Controls.RichTextBox> erstellt, das eine <xref:System.Windows.Documents.Hyperlink> und eine <xref:System.Windows.Controls.Button>enthält.  Die <xref:System.Windows.Controls.RichTextBox.IsDocumentEnabled%2A>-Eigenschaft des <xref:System.Windows.Controls.RichTextBox> ist an die <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A>-Eigenschaft der <xref:System.Windows.Controls.CheckBox>gebunden.  Wenn der Benutzer den <xref:System.Windows.Controls.CheckBox>auswählt, kann der Benutzer mit dem <xref:System.Windows.Controls.Button> und <xref:System.Windows.Documents.Hyperlink>interagieren. Wenn der Benutzer den <xref:System.Windows.Controls.CheckBox>löscht, werden die <xref:System.Windows.Controls.Button> und <xref:System.Windows.Documents.Hyperlink> deaktiviert.  
  
 [!code-xaml[RTBIsDocumentEnabled#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RTBIsDocumentEnabled/VB/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDocumentEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsDocumentEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsDocumentEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.RichTextBox.IsDocumentEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsDocumentEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsDocumentEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsDocumentEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.RichTextBox.IsDocumentEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.RichTextBox.IsDocumentEnabled" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.RichTextBox.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator ab, der die logischen untergeordneten Elemente des <see langword="RichTextBox" /> durchlaufen kann.</summary>
        <value>Ein Enumerator für die logischen untergeordneten Elemente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="richTextBox.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Eine <see cref="T:System.Windows.Size" />-Struktur, die Einschränkungen für die Größe der <see cref="T:System.Windows.Controls.RichTextBox" /> angibt.</param>
        <summary>Wird aufgerufen, um den <see cref="T:System.Windows.Controls.RichTextBox" /> erneut zu messen.</summary>
        <returns>Eine <see cref="T:System.Windows.Size" />-Struktur, die die neue Größe des <see cref="T:System.Windows.Controls.RichTextBox" /> angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.Controls.Control.MeasureOverride%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="richTextBox.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />-Objekt für dieses <see cref="T:System.Windows.Controls.RichTextBox" /> und gibt dieses zurück.</summary>
        <returns>Ein <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />-Objekt für dieses <see cref="T:System.Windows.Controls.RichTextBox" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpiScaleInfo, System.Windows.DpiScale newDpiScaleInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpiScaleInfo, valuetype System.Windows.DpiScale newDpiScaleInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpiScaleInfo As DpiScale, newDpiScaleInfo As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpiScaleInfo, System::Windows::DpiScale newDpiScaleInfo);" />
      <MemberSignature Language="F#" Value="override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="richTextBox.OnDpiChanged (oldDpiScaleInfo, newDpiScaleInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpiScaleInfo" Type="System.Windows.DpiScale" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="newDpiScaleInfo" Type="System.Windows.DpiScale" Index="1" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="oldDpiScaleInfo">Die vorherige DPI-Größeneinstellung.</param>
        <param name="newDpiScaleInfo">Die neue DPI-Größeneinstellung.</param>
        <summary>Wird aufgerufen, wenn sich der DPI-Wert ändert, mit dem dieses Rich-Text-Feld gerendert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Selection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextSelection Selection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextSelection Selection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.Selection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Selection As TextSelection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextSelection ^ Selection { System::Windows::Documents::TextSelection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Selection : System.Windows.Documents.TextSelection" Usage="System.Windows.Controls.RichTextBox.Selection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextSelection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Windows.Documents.TextSelection" />-Objekt ab, das die aktuelle Auswahl im <see cref="T:System.Windows.Controls.RichTextBox" /> enthält.</summary>
        <value>Ein <see cref="T:System.Windows.Documents.TextSelection" />-Objekt, das die aktuelle Auswahl im <see cref="T:System.Windows.Controls.RichTextBox" /> enthält.  
  
Die standardmäßige zurückgegebene <see cref="T:System.Windows.Documents.TextSelection" /> hat einen <see cref="P:System.Windows.Documents.TextRange.IsEmpty" />-Eigenschaftswert von <see langword="true" />. Eine leere <see cref="T:System.Windows.Documents.TextSelection" /> wird im Textbereich als Einfügemarke ohne Auswahl gerendert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Documents.TextRange.Select%2A>-Methode, um Inhalt Programm gesteuert auszuwählen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieser Eigenschaft.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Selection](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_selection)]
 [!code-vb[RichTextBoxSnippets#_RTB_Selection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_selection)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeDocument">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeDocument() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.ShouldSerializeDocument" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeDocument () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeDocument();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeDocument : unit -&gt; bool" Usage="richTextBox.ShouldSerializeDocument " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob der tatsächliche Wert der <see cref="P:System.Windows.Controls.RichTextBox.Document" />-Eigenschaft bei der Serialisierung eines <see cref="T:System.Windows.Controls.RichTextBox" />-Objekts serialisiert werden soll.</summary>
        <returns><see langword="true" />, wenn die <see cref="P:System.Windows.Controls.RichTextBox.Document" />-Eigenschaft serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberSignature Language="F#" Value="abstract member System.Windows.Markup.IAddChild.AddChild : obj -&gt; unit&#xA;override this.System.Windows.Markup.IAddChild.AddChild : obj -&gt; unit" Usage="richTextBox.System.Windows.Markup.IAddChild.AddChild value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Ein Objekt, das als untergeordnetes Element hinzugefügt werden soll.</param>
        <summary>Dieser Typ oder Member unterstützt die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberSignature Language="F#" Value="abstract member System.Windows.Markup.IAddChild.AddText : string -&gt; unit&#xA;override this.System.Windows.Markup.IAddChild.AddText : string -&gt; unit" Usage="richTextBox.System.Windows.Markup.IAddChild.AddText text" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Eine Zeichenfolge, die dem Objekt hinzugefügt werden soll.</param>
        <summary>Dieser Typ oder Member unterstützt die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
