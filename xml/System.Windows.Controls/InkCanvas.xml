<Type Name="InkCanvas" FullName="System.Windows.Controls.InkCanvas">
  <Metadata><Meta Name="ms.openlocfilehash" Value="700471e6256bd1dfdd8e5ee052345d9f4bf24cb4" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75175325" /></Metadata><TypeSignature Language="C#" Value="public class InkCanvas : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi InkCanvas extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.InkCanvas" />
  <TypeSignature Language="VB.NET" Value="Public Class InkCanvas&#xA;Inherits FrameworkElement&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class InkCanvas : System::Windows::FrameworkElement, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type InkCanvas = class&#xA;    inherit FrameworkElement&#xA;    interface IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Children")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiert einen Bereich, der letzte Striche empfängt und anzeigt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Controls.InkCanvas> ist ein Element, das zum empfangen und Anzeigen von frei Hand Eingaben verwendet werden kann. Dies erfolgt in der Regel durch die Verwendung eines Tablettstifts, der mit einem Digitalisierungsprogramm interagiert, um Hand Striche mithilfe eines Tablettstifts oder einer Maus zu liefern. Die erstellten Striche werden als <xref:System.Windows.Ink.Stroke> Objekte dargestellt und können entweder Programm gesteuert oder basierend auf Benutzereingaben bearbeitet werden. Der <xref:System.Windows.Controls.InkCanvas> ermöglicht es Benutzern, eine vorhandene <xref:System.Windows.Ink.Stroke>zu ändern oder zu löschen.  
  
 Der <xref:System.Windows.Controls.InkCanvas> kann an eine Datenquelle gebunden werden. Beispielsweise können Sie die <xref:System.Windows.Controls.InkCanvas.Strokes%2A>-Eigenschaft an binden: eine Base-64-codierte Zeichenfolge, die frei Hand Daten im frei Hand Format (Ink Serialized Format, ISF) enthält; oder sogar für die <xref:System.Windows.Controls.InkCanvas.Strokes%2A>-Eigenschaft eines anderen <xref:System.Windows.Controls.InkCanvas>. Sie können auch Eigenschaften, z. b. <xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes%2A> und <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>, an andere Datenquellen binden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie die Verwendung eines Stifts und eines Hervorhebung auf derselben <xref:System.Windows.Controls.InkCanvas>simulieren. Im Beispiel wird davon ausgegangen, dass das root-Element in der Markup Language (XAML)-Datei eine <xref:System.Windows.Controls.DockPanel> namens `root`ist. Außerdem wird davon ausgegangen, dass eine <xref:System.Windows.Controls.Button> mit dem Namen `switchHighlighter` vorhanden ist, und dass sowohl die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> als auch die <xref:System.Windows.FrameworkElement.Loaded> Ereignisse mit dem Ereignishandler des Beispiels verbunden sind.  
  
 [!code-csharp[DrawingAttributes#3](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingAttributes/CSharp/Window1.xaml.cs#3)]
 [!code-vb[DrawingAttributes#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingAttributes/VisualBasic/Window1.xaml.vb#3)]  
  
 Im folgenden Beispiel werden zwei <xref:System.Windows.Controls.InkCanvas>-Objekte in XAML deklariert und eine Datenbindung zwischen Ihnen und anderen Datenquellen hergestellt. Der erste <xref:System.Windows.Controls.InkCanvas>`ic`, der als bezeichnet wird, wird an zwei Datenquellen gebunden. Die Eigenschaften <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> und <xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes%2A> auf `ic` sind an <xref:System.Windows.Controls.ListBox> Objekte gebunden, die wiederum an Arrays gebunden sind, die im XAML-Code definiert sind. Die Eigenschaften <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>, <xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes%2A>und <xref:System.Windows.Controls.InkCanvas.Strokes%2A> der zweiten <xref:System.Windows.Controls.InkCanvas> sind an die erste <xref:System.Windows.Controls.InkCanvas> im folgenden Code gebunden.  
  
 [!code-xaml[InkCanvasBindingSnippet#1](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasBindingSnippet/CS/Window1.xaml#1)]   
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms771466(v=vs.90)">Beispiel für WPF-Steuerelemente Gallery</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InkCanvas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InkCanvas();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der InkCanvas-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveEditingMode">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.InkCanvasEditingMode ActiveEditingMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.InkCanvasEditingMode ActiveEditingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.ActiveEditingMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveEditingMode As InkCanvasEditingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::InkCanvasEditingMode ActiveEditingMode { System::Windows::Controls::InkCanvasEditingMode get(); };" />
      <MemberSignature Language="F#" Value="member this.ActiveEditingMode : System.Windows.Controls.InkCanvasEditingMode" Usage="System.Windows.Controls.InkCanvas.ActiveEditingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasEditingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den aktuellen Bearbeitungsmodus der <see cref="T:System.Windows.Controls.InkCanvas" /> ab.</summary>
        <value>Der aktuelle Bearbeitungsmodus der <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A>-Eigenschaft gibt die aktuelle <xref:System.Windows.Controls.InkCanvasEditingMode> der <xref:System.Windows.Controls.InkCanvas>an.  Angenommen, die <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> ist auf <xref:System.Windows.Controls.InkCanvasEditingMode.Ink> festgelegt, und die <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> wird auf <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>festgelegt.  Wenn der Tablettstift an umgekehrter Position verwendet wird, hat <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> den Wert <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>. Andernfalls ist der Wert <xref:System.Windows.Controls.InkCanvasEditingMode.Ink>.  
  
<a name="dependencyPropertyInfo_ActiveEditingMode"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.ActiveEditingModeProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Wert von <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> bei jeder Änderung gemeldet.  
  
 [!code-csharp[InkCanvasSamples#36](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#36)]
 [!code-vb[InkCanvasSamples#36](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveEditingModeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler ActiveEditingModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler ActiveEditingModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.ActiveEditingModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ActiveEditingModeChanged As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ ActiveEditingModeChanged;" />
      <MemberSignature Language="F#" Value="member this.ActiveEditingModeChanged : System.Windows.RoutedEventHandler " Usage="member this.ActiveEditingModeChanged : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der aktuelle Bearbeitungsmodus ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A>-Eigenschaft ändert sich, wenn die <xref:System.Windows.Controls.InkCanvas> in einen neuen Bearbeitungsmodus wechselt. Nehmen wir beispielsweise an, dass die <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> auf <xref:System.Windows.Controls.InkCanvasEditingMode.Ink> festgelegt ist und die <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> auf <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>festgelegt ist. Wenn der Benutzer die Spitze des Tablettstifts ändert, tritt das <xref:System.Windows.Controls.InkCanvas.ActiveEditingModeChanged>-Ereignis auf.  
  
<a name="routedEventInfo_ActiveEditingModeChanged"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.ActiveEditingModeChangedEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Wert von <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> bei jeder Änderung gemeldet.  
  
 [!code-csharp[InkCanvasSamples#36](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#36)]
 [!code-vb[InkCanvasSamples#36](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#36)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnActiveEditingModeChanged(System.Windows.RoutedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ActiveEditingModeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ActiveEditingModeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ActiveEditingModeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.ActiveEditingModeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActiveEditingModeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ActiveEditingModeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActiveEditingModeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.ActiveEditingModeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.Controls.InkCanvas.ActiveEditingModeChanged" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveEditingModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActiveEditingModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActiveEditingModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.ActiveEditingModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActiveEditingModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActiveEditingModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActiveEditingModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.ActiveEditingModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Controls.InkCanvas.ActiveEditingMode" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeSize);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="inkCanvas.ArrangeOverride arrangeSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeSize">Der letzte Bereich im übergeordneten Element, den dieses Element verwenden soll, um sich selbst und seine untergeordneten Elemente anzuordnen.</param>
        <summary>Positioniert untergeordnete Elemente und bestimmt die Größe für das <see cref="T:System.Windows.Controls.InkCanvas" />-Objekt.</summary>
        <returns>Die tatsächlich verwendete Größe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Background : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.InkCanvas.Background" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Windows.Media.Brush" /> ab oder legt diese fest. Der Pinsel wird verwendet, um den Rahmenbereich um eine <see cref="T:System.Windows.Controls.InkCanvas" /> auszufüllen.</summary>
        <value>Der <see cref="T:System.Windows.Media.Brush" />, der verwendet wird, um den Rahmenbereich um eine <see cref="T:System.Windows.Controls.InkCanvas" /> auszufüllen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Background"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.BackgroundProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Windows.Controls.InkCanvas.Background%2A>-Eigenschaft für ein <xref:System.Windows.Controls.InkCanvas>festgelegt wird.  
  
 [!code-csharp[InkCanvasSamples#37](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#37)]
 [!code-vb[InkCanvasSamples#37](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#37)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BackgroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.BackgroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Controls.InkCanvas.Background" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Bottom">
      <MemberSignature Language="C#" Value="see GetBottom, and SetBottom" />
      <MemberSignature Language="ILAsm" Value="see GetBottom, and SetBottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Bottom" />
      <MemberSignature Language="VB.NET" Value="see GetBottom, and SetBottom" />
      <MemberSignature Language="F#" Value="see GetBottom, and SetBottom" Usage="see GetBottom, and SetBottom" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Abstand zwischen dem unteren Rand eines Elements und dem unteren Rand seiner übergeordneten <see cref="T:System.Windows.Controls.InkCanvas" /> ab oder legt diesen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Bottom"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.BottomProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
<a name="xamlAttributeUsage_Bottom"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object InkCanvas.Bottom="double"/>  
- or -  
<object InkCanvas.Bottom="qualifiedDouble"/>  
```  
  
<a name="xamlValues_Bottom"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 Zeichen folgen Darstellung eines <xref:System.Double> Werts. Dies wird als [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung interpretiert. Zeichen folgen müssen nicht explizit Dezimalstellen enthalten. Beispielsweise ist der Wert `1` akzeptabel.  
  
 *qualifiedDouble*  
 Ein *doppelter* Wert, wie oben beschrieben, gefolgt von einer der folgenden Einheiten Deklarations Zeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px` (Standard) ist [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll. 1In = = 96px  
  
 `cm` ist Zentimeter. 1cm = = (96/2,54) px  
  
 `pt` ist Punkte. 1pt = = (96/72) px  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Position einer <xref:System.Windows.Controls.Label> auf einem <xref:System.Windows.Controls.InkCanvas>festgelegt wird.  
  
 [!code-xml[InkCanvasSamples#35](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BottomProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BottomProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BottomProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.BottomProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BottomProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BottomProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BottomProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.BottomProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Controls.InkCanvas.Bottom" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanPaste">
      <MemberSignature Language="C#" Value="public bool CanPaste ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanPaste() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.CanPaste" />
      <MemberSignature Language="VB.NET" Value="Public Function CanPaste () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanPaste();" />
      <MemberSignature Language="F#" Value="member this.CanPaste : unit -&gt; bool" Usage="inkCanvas.CanPaste " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob der Inhalt der Zwischenablage in die <see cref="T:System.Windows.Controls.InkCanvas" /> eingefügt werden kann.</summary>
        <returns><see langword="true" />, wenn der Inhalt der Zwischenablage eingefügt werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Controls.InkCanvas> kann Zwischenablage Daten in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Format-, [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]-und Textformat unterstützen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Element in die Zwischenablage kopiert und in den <xref:System.Windows.Controls.InkCanvas>eingefügt. In diesem Beispiel wird davon ausgegangen, dass ein Element mit dem Namen "`rect1`" vorhanden ist und dass die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignisse mit den Ereignis Handlern im Beispiel verbunden wurden.  
  
 [!code-csharp[InkCanvasSamples#1](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#1)]
 [!code-vb[InkCanvasSamples#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Berechtigung zum Einfügen von Inhalt aus der Zwischenablage in die <see cref="T:System.Windows.Controls.InkCanvas" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionClipboard.AllClipboard" /></permission>
        <altmember cref="M:System.Windows.Controls.InkCanvas.CopySelection" />
        <altmember cref="Overload:System.Windows.Controls.InkCanvas.Paste" />
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.UIElementCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.UIElementCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As UIElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::UIElementCollection ^ Children { System::Windows::Controls::UIElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.Windows.Controls.UIElementCollection" Usage="System.Windows.Controls.InkCanvas.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.UIElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft untergeordnete Elemente der <see cref="T:System.Windows.Controls.InkCanvas" /> ab.</summary>
        <value>Eine Auflistung von untergeordneten Elementen auf der <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlPropertyElementUsage_Children"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  OneOrMoreUIElements  
</object>  
```  
  
<a name="xamlValues_Children"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *Oneormoreuielements*  
 Mindestens ein <xref:System.Windows.UIElement>-Objekt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einer <xref:System.Windows.Controls.InkCanvas>ein <xref:System.Windows.Controls.TextBlock> hinzugefügt.  
  
 [!code-csharp[InkCanvasSamples#8](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#8)]
 [!code-vb[InkCanvasSamples#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySelection">
      <MemberSignature Language="C#" Value="public void CopySelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopySelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.CopySelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopySelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopySelection();" />
      <MemberSignature Language="F#" Value="member this.CopySelection : unit -&gt; unit" Usage="inkCanvas.CopySelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert ausgewählte Striche und/oder Elemente in die Zwischenablage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Controls.InkCanvas> kann Zwischenablage Daten in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Format-, [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]-und Textformat unterstützen. Striche in die Zwischenablage werden [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Format [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)].  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei-Elemente in einem <xref:System.Windows.Controls.InkCanvas> ausgewählt und in die Zwischenablage kopiert. In diesem Beispiel wird davon ausgegangen, dass eine <xref:System.Windows.Controls.TextBox> mit dem Namen `textbox1` und eine <xref:System.Windows.Controls.Button> mit dem Namen `button1 -` vorhanden sind und dass beide Steuerelemente untergeordnete Elemente des <xref:System.Windows.Controls.InkCanvas>sind.  
  
 [!code-csharp[InkCanvasSamples#3](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#3)]
 [!code-vb[InkCanvasSamples#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.CanPaste" />
        <altmember cref="Overload:System.Windows.Controls.InkCanvas.Paste" />
      </Docs>
    </Member>
    <Member MemberName="CutSelection">
      <MemberSignature Language="C#" Value="public void CutSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CutSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.CutSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub CutSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CutSelection();" />
      <MemberSignature Language="F#" Value="member this.CutSelection : unit -&gt; unit" Usage="inkCanvas.CutSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die ausgewählten Striche und Elemente und kopiert sie in die Zwischenablage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Controls.InkCanvas> kann Zwischenablage Daten in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Format-, [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]-und Textformat unterstützen. Striche in die Zwischenablage werden [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Format [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)].  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei-Elemente in einem-<xref:System.Windows.Controls.InkCanvas>ausgewählt und gekürzt. In diesem Beispiel wird davon ausgegangen, dass eine <xref:System.Windows.Controls.TextBox> mit dem Namen `textbox1` und eine <xref:System.Windows.Controls.Button> `button1` und beide Steuerelemente untergeordnete Elemente des <xref:System.Windows.Controls.InkCanvas>sind.  
  
 [!code-csharp[InkCanvasSamples#4](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#4)]
 [!code-vb[InkCanvasSamples#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultDrawingAttributes">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.DrawingAttributes DefaultDrawingAttributes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Ink.DrawingAttributes DefaultDrawingAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultDrawingAttributes As DrawingAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Ink::DrawingAttributes ^ DefaultDrawingAttributes { System::Windows::Ink::DrawingAttributes ^ get(); void set(System::Windows::Ink::DrawingAttributes ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultDrawingAttributes : System.Windows.Ink.DrawingAttributes with get, set" Usage="System.Windows.Controls.InkCanvas.DefaultDrawingAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.DrawingAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeichnungsattribute ab, die auf neue Freihandstriche auf der <see cref="T:System.Windows.Controls.InkCanvas" /> angewendet werden, oder legt diese fest.</summary>
        <value>Die Standardzeichnungsattribute für die <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Festlegen dieser Eigenschaft wirkt sich nur auf neue Striche aus, die nach dem Festlegen dieser Eigenschaft vorgenommen werden. Um neue Zeichnungs Attribute auf bereits erstellte <xref:System.Windows.Ink.Stroke> Objekte anzuwenden, greifen Sie mithilfe der <xref:System.Windows.Controls.InkCanvas.Strokes%2A>-Eigenschaft einzeln auf Sie zu.  
  
<a name="dependencyPropertyInfo_DefaultDrawingAttributes"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributesProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie zwei <xref:System.Windows.Ink.DrawingAttributes>-Objekte verwendet werden, um die Verwendung eines Stifts und eines highheller auf derselben <xref:System.Windows.Controls.InkCanvas>zu simulieren. Im Beispiel wird davon ausgegangen, dass das root-Element in der Markup Language (XAML)-Datei eine <xref:System.Windows.Controls.DockPanel> namens `root`ist. Außerdem wird davon ausgegangen, dass eine <xref:System.Windows.Controls.Button> mit dem Namen `switchHighlighter` vorhanden ist und dass das <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis mit dem Ereignishandler verbunden ist.  
  
 [!code-csharp[DrawingAttributes#3](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingAttributes/CSharp/Window1.xaml.cs#3)]
 [!code-vb[DrawingAttributes#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingAttributes/VisualBasic/Window1.xaml.vb#3)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes%2A>-Eigenschaft an eine Datenquelle gebunden wird.  
  
 [!code-xaml[InkCanvasBindingSnippet#3](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasBindingSnippet/CS/Window2.xaml#3)]  
 [!code-xaml[InkCanvasBindingSnippet#4](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasBindingSnippet/CS/Window2.xaml#4)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.InkCanvas.Strokes" />
      </Docs>
    </Member>
    <Member MemberName="DefaultDrawingAttributesProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DefaultDrawingAttributesProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DefaultDrawingAttributesProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.DefaultDrawingAttributesProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultDrawingAttributesProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DefaultDrawingAttributesProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultDrawingAttributesProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.DefaultDrawingAttributesProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultDrawingAttributesReplaced">
      <MemberSignature Language="C#" Value="public event System.Windows.Ink.DrawingAttributesReplacedEventHandler DefaultDrawingAttributesReplaced;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Ink.DrawingAttributesReplacedEventHandler DefaultDrawingAttributesReplaced" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.DefaultDrawingAttributesReplaced" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DefaultDrawingAttributesReplaced As DrawingAttributesReplacedEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Ink::DrawingAttributesReplacedEventHandler ^ DefaultDrawingAttributesReplaced;" />
      <MemberSignature Language="F#" Value="member this.DefaultDrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventHandler " Usage="member this.DefaultDrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event DefaultDrawingAttributesReplaced As DrawingAttributesReplacedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.DrawingAttributesReplacedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="P:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes" />-Eigenschaft ersetzt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird der Wert der <xref:System.Windows.Ink.DrawingAttributes.IsHighlighter%2A>-Eigenschaft des neuen <xref:System.Windows.Ink.DrawingAttributes>-Objekts überprüft.  
  
 [!code-csharp[DrawingAttributes#17](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingAttributes/CSharp/Window1.xaml.cs#17)]
 [!code-vb[DrawingAttributes#17](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingAttributes/VisualBasic/Window1.xaml.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStylusPointDescription">
      <MemberSignature Language="C#" Value="public System.Windows.Input.StylusPointDescription DefaultStylusPointDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.StylusPointDescription DefaultStylusPointDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.DefaultStylusPointDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultStylusPointDescription As StylusPointDescription" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::StylusPointDescription ^ DefaultStylusPointDescription { System::Windows::Input::StylusPointDescription ^ get(); void set(System::Windows::Input::StylusPointDescription ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStylusPointDescription : System.Windows.Input.StylusPointDescription with get, set" Usage="System.Windows.Controls.InkCanvas.DefaultStylusPointDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusPointDescription</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Beschreibung von Tablettstiftpunkten für eine <see cref="T:System.Windows.Controls.InkCanvas" /> ab oder legt diese fest.</summary>
        <value>Die Beschreibung von Tablettstiftpunkten für eine <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig speichert das <xref:System.Windows.Controls.InkCanvas> nur die Eigenschaften <xref:System.Windows.Input.StylusPointProperties.X>, <xref:System.Windows.Input.StylusPointProperties.Y>und <xref:System.Windows.Input.StylusPointProperties.NormalPressure> für jede <xref:System.Windows.Input.StylusPoint>, die zu einem Strich gehört. Sie können die defaultstyluspointdescription-Eigenschaft verwenden, um zusätzliche Informationen zu Punkten zu speichern, die die Striche auf einem <xref:System.Windows.Controls.InkCanvas>enthalten. Das Festlegen dieser Eigenschaft wirkt sich nur auf neue Striche aus, die nach dem Festlegen der Eigenschaft vorgenommen werden.  
  
<a name="xamlTextUsage_DefaultStylusPointDescription"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Sie können diese Eigenschaft nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Windows.Controls.InkCanvas.DefaultStylusPointDescription%2A> so festgelegt, dass die Tablettstiftpunkte der Striche auf der <xref:System.Windows.Controls.InkCanvas> die Eigenschaften <xref:System.Windows.Input.StylusPointProperties.X>, <xref:System.Windows.Input.StylusPointProperties.Y>, <xref:System.Windows.Input.StylusPointProperties.NormalPressure>und <xref:System.Windows.Input.StylusPointProperties.TipButton> enthalten.  
  
> [!NOTE]
>  Nur die Striche, die der <xref:System.Windows.Controls.InkCanvas> hinzugefügt werden, nachdem das <xref:System.Windows.Controls.InkCanvas.DefaultStylusPointDescription%2A> auf die zusätzliche Eigenschaft festgelegt wurde.  
  
 [!code-csharp[InkCanvasSamples#9](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#9)]
 [!code-vb[InkCanvasSamples#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.StylusPointProperties" />
        <altmember cref="T:System.Windows.Input.StylusPointProperty" />
        <altmember cref="T:System.Windows.Input.StylusPointPropertyInfo" />
      </Docs>
    </Member>
    <Member MemberName="DynamicRenderer">
      <MemberSignature Language="C#" Value="protected System.Windows.Input.StylusPlugIns.DynamicRenderer DynamicRenderer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.StylusPlugIns.DynamicRenderer DynamicRenderer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.DynamicRenderer" />
      <MemberSignature Language="VB.NET" Value="Protected Property DynamicRenderer As DynamicRenderer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Input::StylusPlugIns::DynamicRenderer ^ DynamicRenderer { System::Windows::Input::StylusPlugIns::DynamicRenderer ^ get(); void set(System::Windows::Input::StylusPlugIns::DynamicRenderer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicRenderer : System.Windows.Input.StylusPlugIns.DynamicRenderer with get, set" Usage="System.Windows.Controls.InkCanvas.DynamicRenderer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusPlugIns.DynamicRenderer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Renderer ab, der Freihand dynamisch auf der <see cref="T:System.Windows.Controls.InkCanvas" /> zeichnet, oder legt diesen fest.</summary>
        <value>Der Renderer, der Freihand dynamisch auf der <see cref="T:System.Windows.Controls.InkCanvas" /> zeichnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Windows.Controls.InkCanvas.DynamicRenderer%2A>-Eigenschaft auf eine benutzerdefinierte <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> festlegen, wenn Sie die frei Hand Eingaben anpassen möchten.  
  
> [!NOTE]
>  Der <xref:System.Windows.Controls.InkCanvas.DynamicRenderer%2A> ist ein Member der <xref:System.Windows.UIElement.StylusPlugIns%2A> Auflistung. Wenn Sie die <xref:System.Windows.Controls.InkCanvas.DynamicRenderer%2A>festlegen, entfernt das <xref:System.Windows.Controls.InkCanvas> den alten <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> aus dem <xref:System.Windows.Input.StylusPlugIns.StylusPlugInCollection> und fügt den neuen <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> am Ende der Auflistung hinzu. Dadurch kann das Verhalten des <xref:System.Windows.Controls.InkCanvas>geändert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingMode">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.InkCanvasEditingMode EditingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.InkCanvasEditingMode EditingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.EditingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property EditingMode As InkCanvasEditingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::InkCanvasEditingMode EditingMode { System::Windows::Controls::InkCanvasEditingMode get(); void set(System::Windows::Controls::InkCanvasEditingMode value); };" />
      <MemberSignature Language="F#" Value="member this.EditingMode : System.Windows.Controls.InkCanvasEditingMode with get, set" Usage="System.Windows.Controls.InkCanvas.EditingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasEditingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Benutzerbearbeitungsmodus ab, der von einem aktiven Zeigegerät verwendet wird, oder legt diesen fest.</summary>
        <value>Der verwendete Bearbeitungsmodus, wenn ein Zeigegerät (z. B. ein Tablettstift oder eine Maus) aktiv ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardeinstellung für <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> ist <xref:System.Windows.Controls.InkCanvasEditingMode.Ink>. Wenn Sie die <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> ändern, werden alle vorhandenen Optionen gelöscht.  
  
 Der <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> gibt den Modus des Zeige Geräts an, wenn es mit dem <xref:System.Windows.Controls.InkCanvas>interagiert. <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> wird von einigen Digitalisierern verwendet, wenn der "Radierer Ende" des Tablettstifts den Digitalisierer kontaktiert.  
  
<a name="dependencyPropertyInfo_EditingMode"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.EditingModeProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Anwendung erstellt, die die verschiedenen Typen von Bearbeitungsmodi für eine <xref:System.Windows.Controls.InkCanvas>verwendet.  
  
 [!code-csharp[ICEditingModeSample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ICEditingModeSample/CSharp/Window1.xaml.cs#1)]
 [!code-vb[ICEditingModeSample#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ICEditingModeSample/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.InkCanvas.EditingModeInverted" />
      </Docs>
    </Member>
    <Member MemberName="EditingModeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler EditingModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler EditingModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.EditingModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EditingModeChanged As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ EditingModeChanged;" />
      <MemberSignature Language="F#" Value="member this.EditingModeChanged : System.Windows.RoutedEventHandler " Usage="member this.EditingModeChanged : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="P:System.Windows.Controls.InkCanvas.EditingMode" />-Eigenschaft eines <see cref="T:System.Windows.Controls.InkCanvas" />-Objekts geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, nachdem der Bearbeitungsmodus geändert wurde. die Änderungen werden in der <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>-Eigenschaft der <xref:System.Windows.Controls.InkCanvas>widergespiegelt.  
  
<a name="routedEventInfo_EditingModeChanged"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.EditingModeChangedEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob die <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>-Eigenschaft auf <xref:System.Windows.Controls.InkCanvasEditingMode.Ink> oder <xref:System.Windows.Controls.InkCanvasEditingMode.Select>festgelegt ist.  
  
 [!code-csharp[InkCanvasSamples#21](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#21)]
 [!code-vb[InkCanvasSamples#21](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent EditingModeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent EditingModeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.EditingModeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditingModeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ EditingModeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditingModeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.EditingModeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.Controls.InkCanvas.EditingModeChanged" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeInverted">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.InkCanvasEditingMode EditingModeInverted { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.InkCanvasEditingMode EditingModeInverted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.EditingModeInverted" />
      <MemberSignature Language="VB.NET" Value="Public Property EditingModeInverted As InkCanvasEditingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::InkCanvasEditingMode EditingModeInverted { System::Windows::Controls::InkCanvasEditingMode get(); void set(System::Windows::Controls::InkCanvasEditingMode value); };" />
      <MemberSignature Language="F#" Value="member this.EditingModeInverted : System.Windows.Controls.InkCanvasEditingMode with get, set" Usage="System.Windows.Controls.InkCanvas.EditingModeInverted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasEditingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Benutzerbearbeitungsmodus ab, wenn der Eingabestift bei einer Interaktion mit der <see cref="T:System.Windows.Controls.InkCanvas" />-Klasse umgedreht wird, oder legt ihn fest.</summary>
        <value>Der invertierte Bearbeitungsmodus der <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft steuert die Aktionen, die ausgeführt werden, wenn der Tablettstift umgekehrt wird.  
  
 Entsprechend steuert die <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>-Eigenschaft Aktionen, die ausgeführt werden, wenn sich der Tablettstift in einer standardmäßigen Tip-Down-Position gegen den Digitalisierer befindet.  
  
<a name="dependencyPropertyInfo_EditingModeInverted"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.EditingModeInvertedProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einem Benutzer das teilweise Löschen von Strichen mit der umgekehrten Spitze eines Tablettstifts gestattet wird. Ein elliptischer Cursor wird auf dem <xref:System.Windows.Controls.InkCanvas> angezeigt, wenn der Benutzer frei Hand Eingaben löscht.  
  
 [!code-csharp[InkCanvasSamples#6](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#6)]
 [!code-vb[InkCanvasSamples#6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeInvertedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler EditingModeInvertedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler EditingModeInvertedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.EditingModeInvertedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EditingModeInvertedChanged As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ EditingModeInvertedChanged;" />
      <MemberSignature Language="F#" Value="member this.EditingModeInvertedChanged : System.Windows.RoutedEventHandler " Usage="member this.EditingModeInvertedChanged : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="P:System.Windows.Controls.InkCanvas.EditingModeInverted" />-Eigenschaft eines <see cref="T:System.Windows.Controls.InkCanvas" />-Objekts geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, nachdem der invertierte Bearbeitungsmodus geändert wurde. Diese Änderungen werden in der <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A>-Eigenschaft der <xref:System.Windows.Controls.InkCanvas>widergespiegelt.  
  
<a name="routedEventInfo_EditingModeInvertedChanged"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.EditingModeInvertedChangedEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob die <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A>-Eigenschaft auf <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint> oder <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByStroke>festgelegt ist.  
  
 [!code-csharp[InkCanvasSamples#20](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#20)]
 [!code-vb[InkCanvasSamples#20](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeInvertedChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent EditingModeInvertedChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent EditingModeInvertedChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.EditingModeInvertedChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditingModeInvertedChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ EditingModeInvertedChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditingModeInvertedChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.EditingModeInvertedChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.Controls.InkCanvas.EditingModeInvertedChanged" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeInvertedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EditingModeInvertedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EditingModeInvertedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.EditingModeInvertedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditingModeInvertedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ EditingModeInvertedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditingModeInvertedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.EditingModeInvertedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Controls.InkCanvas.EditingModeInverted" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EditingModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EditingModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.EditingModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditingModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ EditingModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditingModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.EditingModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Controls.InkCanvas.EditingMode" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EraserShape">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.StylusShape EraserShape { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Ink.StylusShape EraserShape" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.EraserShape" />
      <MemberSignature Language="VB.NET" Value="Public Property EraserShape As StylusShape" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Ink::StylusShape ^ EraserShape { System::Windows::Ink::StylusShape ^ get(); void set(System::Windows::Ink::StylusShape ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EraserShape : System.Windows.Ink.StylusShape with get, set" Usage="System.Windows.Controls.InkCanvas.EraserShape" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StylusShape</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Windows.Ink.StylusShape" /> ab, die zum punktweisen Löschen von Freihand auf einer <see cref="T:System.Windows.Controls.InkCanvas" /> verwendet wird, oder legt diese fest.</summary>
        <value>Die der <see cref="T:System.Windows.Controls.InkCanvas" /> zugeordnete Radiererform.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Form wird zum Löschen von frei Hand Eingaben aus einem <xref:System.Windows.Controls.InkCanvas> verwendet, wenn der aktuelle <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> auf <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>festgelegt ist.  
  
 Einzelne Eigenschaften eines <xref:System.Windows.Ink.StylusShape> können nicht geändert werden, nachdem die Form erstellt wurde.  
  
 Wenn Sie die <xref:System.Windows.Controls.InkCanvas.EraserShape%2A>ändern, wird der auf der <xref:System.Windows.Controls.InkCanvas> gerenderte Cursor bis zur nächsten <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> Änderung nicht aktualisiert.  
  
<a name="xamlTextUsage_EraserShape"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Diese Eigenschaft wird in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einem Benutzer das teilweise Löschen von Strichen mit der umgekehrten Spitze eines Tablettstifts gestattet wird. Ein elliptischer Cursor wird auf dem <xref:System.Windows.Controls.InkCanvas> angezeigt, wenn der Benutzer frei Hand Eingaben löscht.  
  
 [!code-csharp[InkCanvasSamples#6](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#6)]
 [!code-vb[InkCanvasSamples#6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Ink.StylusShape" />
      </Docs>
    </Member>
    <Member MemberName="Gesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasGestureEventHandler Gesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasGestureEventHandler Gesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.Gesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Gesture As InkCanvasGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasGestureEventHandler ^ Gesture;" />
      <MemberSignature Language="F#" Value="member this.Gesture : System.Windows.Controls.InkCanvasGestureEventHandler " Usage="member this.Gesture : System.Windows.Controls.InkCanvasGestureEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="T:System.Windows.Controls.InkCanvas" /> eine Stiftbewegung erkennt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_Gesture"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.GestureEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Controls.InkCanvasGestureEventHandler>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie eine <xref:System.Windows.Controls.InkCanvas> einrichten, um Anwendungs Gesten zu erkennen.  
  
 [!code-csharp[GestureSample#3](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#3)]
 [!code-vb[GestureSample#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#3)]  
[!code-csharp[GestureSample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#1)]
[!code-vb[GestureSample#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.GestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.GestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.Controls.InkCanvas.Gesture" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBottom">
      <MemberSignature Language="C#" Value="public static double GetBottom (System.Windows.UIElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetBottom(class System.Windows.UIElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetBottom(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBottom (element As UIElement) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetBottom(System::Windows::UIElement ^ element);" />
      <MemberSignature Language="F#" Value="static member GetBottom : System.Windows.UIElement -&gt; double" Usage="System.Windows.Controls.InkCanvas.GetBottom element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForChildren</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, dessen bottom-Eigenschaft abgerufen werden soll.</param>
        <summary>Ruft den Wert der angefügten <see cref="P:System.Windows.Controls.InkCanvas.Bottom" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt ab.</summary>
        <returns>Die untere Koordinate des Abhängigkeitsobjekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie die Position einer <xref:System.Windows.Controls.Button>erhalten.  
  
 [!code-csharp[InkCanvasSamples#34](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#34)]
 [!code-vb[InkCanvasSamples#34](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnabledGestures">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Ink.ApplicationGesture&gt; GetEnabledGestures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;valuetype System.Windows.Ink.ApplicationGesture&gt; GetEnabledGestures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetEnabledGestures" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnabledGestures () As ReadOnlyCollection(Of ApplicationGesture)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Ink::ApplicationGesture&gt; ^ GetEnabledGestures();" />
      <MemberSignature Language="F#" Value="member this.GetEnabledGestures : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Ink.ApplicationGesture&gt;" Usage="inkCanvas.GetEnabledGestures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Ink.ApplicationGesture&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Auflistung von Anwendungsstiftbewegungen zurück, die von <see cref="T:System.Windows.Controls.InkCanvas" /> erkannt werden.</summary>
        <returns>Eine Auflistung von Stiftbewegungen, die die <see cref="T:System.Windows.Controls.InkCanvas" /> erkennt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie die aktivierten Anwendungs Gesten aus dem <xref:System.Windows.Controls.InkCanvas>erhalten.  
  
 [!code-csharp[InkCanvasSamples#24](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#24)]
 [!code-vb[InkCanvasSamples#24](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Windows.Controls.InkCanvas.IsGestureRecognizerAvailable" />-Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLeft">
      <MemberSignature Language="C#" Value="public static double GetLeft (System.Windows.UIElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetLeft(class System.Windows.UIElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetLeft(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLeft (element As UIElement) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetLeft(System::Windows::UIElement ^ element);" />
      <MemberSignature Language="F#" Value="static member GetLeft : System.Windows.UIElement -&gt; double" Usage="System.Windows.Controls.InkCanvas.GetLeft element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForChildren</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, dessen left-Eigenschaft abgerufen werden soll.</param>
        <summary>Ruft den Wert der angefügten <see cref="P:System.Windows.Controls.InkCanvas.Left" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt ab.</summary>
        <returns>Die linke Koordinate des Abhängigkeitsobjekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie die Position einer <xref:System.Windows.Controls.Button>erhalten.  
  
 [!code-csharp[InkCanvasSamples#31](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#31)]
 [!code-vb[InkCanvasSamples#31](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRight">
      <MemberSignature Language="C#" Value="public static double GetRight (System.Windows.UIElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetRight(class System.Windows.UIElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetRight(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRight (element As UIElement) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetRight(System::Windows::UIElement ^ element);" />
      <MemberSignature Language="F#" Value="static member GetRight : System.Windows.UIElement -&gt; double" Usage="System.Windows.Controls.InkCanvas.GetRight element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForChildren</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, dessen right-Eigenschaft abgerufen werden soll.</param>
        <summary>Ruft den Wert der angefügten <see cref="P:System.Windows.Controls.InkCanvas.Right" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt ab.</summary>
        <returns>Die rechte Koordinate des Abhängigkeitsobjekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie die Position einer <xref:System.Windows.Controls.Button>erhalten.  
  
 [!code-csharp[InkCanvasSamples#32](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#32)]
 [!code-vb[InkCanvasSamples#32](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSelectedElements">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.UIElement&gt; GetSelectedElements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.UIElement&gt; GetSelectedElements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSelectedElements () As ReadOnlyCollection(Of UIElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::UIElement ^&gt; ^ GetSelectedElements();" />
      <MemberSignature Language="F#" Value="member this.GetSelectedElements : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.UIElement&gt;" Usage="inkCanvas.GetSelectedElements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.UIElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die <see cref="T:System.Windows.FrameworkElement" />-Objekte ab, die auf der <see cref="T:System.Windows.Controls.InkCanvas" /> ausgewählt wurden.</summary>
        <returns>Array von <see cref="T:System.Windows.FrameworkElement" />-Objekten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt nur <xref:System.Windows.FrameworkElement>-Objekte zurück, nicht <xref:System.Windows.Ink.Stroke>-Objekten.  
  
 Rufen Sie die <xref:System.Windows.Controls.InkCanvas.GetSelectedStrokes%2A>-Methode auf, um die ausgewählten <xref:System.Windows.Ink.Stroke> Objekte abzurufen.  
  
 Wenn die <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> von <xref:System.Windows.Controls.InkCanvas> auf <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>festgelegt ist, können Benutzer <xref:System.Windows.Ink.Stroke> Objekte und <xref:System.Windows.FrameworkElement> Objekte auswählen. Alternativ können beide Objekttypen mithilfe von Code ausgewählt werden: Rufen Sie einfach die <xref:System.Windows.Controls.InkCanvas.Select%2A> Methode auf.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Höhe und Breite der einzelnen ausgewählten Elemente in einem <xref:System.Windows.Controls.InkCanvas>verdoppelt.  
  
 [!code-csharp[InkCanvasSamples#12](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#12)]
 [!code-vb[InkCanvasSamples#12](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="Overload:System.Windows.Controls.InkCanvas.Select" />
      </Docs>
    </Member>
    <Member MemberName="GetSelectedStrokes">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.StrokeCollection GetSelectedStrokes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Ink.StrokeCollection GetSelectedStrokes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSelectedStrokes () As StrokeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Ink::StrokeCollection ^ GetSelectedStrokes();" />
      <MemberSignature Language="F#" Value="member this.GetSelectedStrokes : unit -&gt; System.Windows.Ink.StrokeCollection" Usage="inkCanvas.GetSelectedStrokes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StrokeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine <see cref="T:System.Windows.Ink.StrokeCollection" /> ab, die die ausgewählten <see cref="T:System.Windows.Ink.Stroke" />-Objekte auf der <see cref="T:System.Windows.Controls.InkCanvas" /> darstellt.</summary>
        <returns>Die Auflistung der ausgewählten Striche.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt nur <xref:System.Windows.Ink.Stroke>-Objekte zurück. Rufen Sie die <xref:System.Windows.Controls.InkCanvas.GetSelectedElements%2A>-Methode auf, um die ausgewählten <xref:System.Windows.FrameworkElement> Objekte abzurufen.  
  
 Wenn die <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> von <xref:System.Windows.Controls.InkCanvas> auf <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>festgelegt ist, können Benutzer <xref:System.Windows.Ink.Stroke> Objekte und <xref:System.Windows.FrameworkElement> Objekte auswählen. Alternativ können beide Objekttypen mithilfe von Code ausgewählt werden: Rufen Sie einfach die <xref:System.Windows.Controls.InkCanvas.Select%2A> Methode auf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Farbe der einzelnen ausgewählten Striche in einem <xref:System.Windows.Controls.InkCanvas>geändert.  
  
 [!code-csharp[InkCanvasSamples#11](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#11)]
 [!code-vb[InkCanvasSamples#11](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Controls.InkCanvas.Select" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="GetSelectionBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetSelectionBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetSelectionBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetSelectionBounds" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSelectionBounds () As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetSelectionBounds();" />
      <MemberSignature Language="F#" Value="member this.GetSelectionBounds : unit -&gt; System.Windows.Rect" Usage="inkCanvas.GetSelectionBounds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Grenzen der ausgewählten Striche und der Elemente auf der <see cref="T:System.Windows.Controls.InkCanvas" /> ab.</summary>
        <returns>Das kleinste Rechteck, das alle ausgewählten Striche und Elemente umschließt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird verhindert, dass der Benutzer eine Auswahl unterscheidet, die kleiner als die ursprüngliche Größe ist.  
  
 [!code-csharp[InkCanvasSamples#16](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#16)]
 [!code-vb[InkCanvasSamples#16](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTop">
      <MemberSignature Language="C#" Value="public static double GetTop (System.Windows.UIElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetTop(class System.Windows.UIElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetTop(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTop (element As UIElement) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetTop(System::Windows::UIElement ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTop : System.Windows.UIElement -&gt; double" Usage="System.Windows.Controls.InkCanvas.GetTop element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForChildren</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, dessen top-Eigenschaft abgerufen werden soll.</param>
        <summary>Ruft den Wert der angefügten <see cref="P:System.Windows.Controls.InkCanvas.Top" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt ab.</summary>
        <returns>Die obere Koordinate des Abhängigkeitsobjekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie die Position einer <xref:System.Windows.Controls.Button>erhalten.  
  
 [!code-csharp[InkCanvasSamples#33](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#33)]
 [!code-vb[InkCanvasSamples#33](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="inkCanvas.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des angeforderten untergeordneten Elements in der Auflistung.</param>
        <summary>Überschreibt <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /> und gibt aus einer Auflistung untergeordneter Elemente ein untergeordnetes Element an der angegebenen Indexposition zurück.</summary>
        <returns>Das angeforderte untergeordnete Element. Es sollte nicht <see langword="null" /> zurückgeben; wenn der angegebene Index außerhalb des Bereichs liegt, wird eine Ausnahme ausgelöst.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParams);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HitTestCore (hitTestParams As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParams);" />
      <MemberSignature Language="F#" Value="override this.HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult" Usage="inkCanvas.HitTestCore hitTestParams" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParams" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParams">Ein Objekt, das den <see cref="T:System.Windows.Point" /> angibt, der auf Treffer getestet werden soll.</param>
        <summary>Bestimmt, ob ein angegebener Punkt innerhalb der Renderinggrenzen einer <see cref="T:System.Windows.Controls.InkCanvas" /> liegt.</summary>
        <returns>Ein Objekt, das das von einem Treffertest zurückgegebene <see cref="T:System.Windows.Media.Visual" /> darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestSelection">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.InkCanvasSelectionHitResult HitTestSelection (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Controls.InkCanvasSelectionHitResult HitTestSelection(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.HitTestSelection(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Controls::InkCanvasSelectionHitResult HitTestSelection(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.HitTestSelection : System.Windows.Point -&gt; System.Windows.Controls.InkCanvasSelectionHitResult" Usage="inkCanvas.HitTestSelection point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasSelectionHitResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Der auf Treffer zu überprüfende Punkt.</param>
        <summary>Gibt einen Wert zurück, der angibt, welcher Teil des Auswahladorners den angegebenen Punkt überschneidet oder umschließt.</summary>
        <returns>Ein Wert, der angibt, welcher Teil des Auswahladorners den angegebenen Punkt überschneidet oder umschließt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Controls.InkCanvas.HitTestSelection%2A>-Methode, um zu bestimmen, ob sich der Punkt innerhalb der Grenzen einer Strich Auswahl oder in einem der acht Handles befindet.  Dies ist hilfreich beim Ausführen von Drag & Drop-Vorgängen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie mithilfe von <xref:System.Windows.Controls.InkCanvas.HitTestSelection%2A> festgelegt wird, ob ein <xref:System.Windows.DataObject> zum Initiieren von Drag & Drop erstellt werden soll.  Informationen zum Implementieren von Drag & Drop zwischen zwei <xref:System.Windows.Controls.InkCanvas> Objekten finden Sie unter Gewusst [wie: Drag](~/docs/framework/wpf/advanced/how-to-drag-and-drop-ink.md)& Drop Ink.  
  
 [!code-csharp[InkDragDrop#3](~/samples/snippets/csharp/VS_Snippets_Wpf/InkDragDrop/CSharp/Window1.xaml.cs#3)]
 [!code-vb[InkDragDrop#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkDragDrop/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InkPresenter">
      <MemberSignature Language="C#" Value="protected System.Windows.Controls.InkPresenter InkPresenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.InkPresenter InkPresenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.InkPresenter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property InkPresenter As InkPresenter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Controls::InkPresenter ^ InkPresenter { System::Windows::Controls::InkPresenter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InkPresenter : System.Windows.Controls.InkPresenter" Usage="System.Windows.Controls.InkCanvas.InkPresenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkPresenter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Freihanddarstellung ab, mit der Freihand auf der <see cref="T:System.Windows.Controls.InkCanvas" /> angezeigt wird.</summary>
        <value>Die Freihanddarstellung, mit der Freihand auf der <see cref="T:System.Windows.Controls.InkCanvas" /> angezeigt wird.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGestureRecognizerAvailable">
      <MemberSignature Language="C#" Value="public bool IsGestureRecognizerAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGestureRecognizerAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.IsGestureRecognizerAvailable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGestureRecognizerAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGestureRecognizerAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGestureRecognizerAvailable : bool" Usage="System.Windows.Controls.InkCanvas.IsGestureRecognizerAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab (bestimmt), ob die Stiftbewegungserkennungskomponente auf dem System des Benutzers verfügbar ist.</summary>
        <value><see langword="true" />, wenn die Erkennungskomponente verfügbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein <xref:System.Windows.Controls.InkCanvas> konfiguriert wird, um Anwendungs Gesten zu erkennen.  
  
 [!code-csharp[GestureSample#3](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#3)]
 [!code-vb[GestureSample#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#3)]  
[!code-csharp[GestureSample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#1)]
[!code-vb[GestureSample#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="see GetLeft, and SetLeft" />
      <MemberSignature Language="ILAsm" Value="see GetLeft, and SetLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Left" />
      <MemberSignature Language="VB.NET" Value="see GetLeft, and SetLeft" />
      <MemberSignature Language="F#" Value="see GetLeft, and SetLeft" Usage="see GetLeft, and SetLeft" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Abstand zwischen dem linken Rand eines Elements und dem linken Rand seiner übergeordneten <see cref="T:System.Windows.Controls.InkCanvas" /> ab oder legt diesen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Left"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.LeftProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
<a name="xamlAttributeUsage_Left"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object InkCanvas.Left="double"/>  
- or -  
<object InkCanvas.Left="qualifiedDouble"/>  
```  
  
<a name="xamlValues_Left"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 Zeichen folgen Darstellung eines <xref:System.Double> Werts. Dies wird als [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung interpretiert. Zeichen folgen müssen nicht explizit Dezimalstellen enthalten. Beispielsweise ist der Wert `1` akzeptabel.  
  
 *qualifiedDouble*  
 Ein *doppelter* Wert, wie oben beschrieben, gefolgt von einer der folgenden Einheiten Deklarations Zeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px` (Standard) ist [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll. 1In = = 96px  
  
 `cm` ist Zentimeter. 1cm = = (96/2,54) px  
  
 `pt` ist Punkte. 1pt = = (96/72) px  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Position einer <xref:System.Windows.Controls.Label> auf einem <xref:System.Windows.Controls.InkCanvas>festgelegt wird.  
  
 [!code-xml[InkCanvasSamples#35](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Controls.InkCanvas.Left" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.InkCanvas.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den Enumerator für logische untergeordnete Elemente zurück.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="inkCanvas.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Die verfügbare Größe, die dieses Element untergeordneten Elementen bereitstellen kann. „Unendlich“ kann als Wert angegeben werden, um festzulegen, dass das Element an die Größe des jeweiligen Inhalts angepasst wird.</param>
        <summary>Misst die für untergeordnete Elemente im Layout benötigte Größe und bestimmt eine Größe für das <see cref="T:System.Windows.Controls.InkCanvas" />-Objekt.</summary>
        <returns>Die für dieses Element beim Layout benötigte Größe, basierend auf der Berechnung der Größen der untergeordneten Elemente.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="MoveEnabled">
      <MemberSignature Language="C#" Value="public bool MoveEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MoveEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.MoveEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property MoveEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MoveEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MoveEnabled : bool with get, set" Usage="System.Windows.Controls.InkCanvas.MoveEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob der Benutzer ausgewählte Freihandstriche und/oder Elemente auf der <see cref="T:System.Windows.Controls.InkCanvas" /> verschieben darf, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn ein Benutzer Striche und/oder Elemente auf der <see cref="T:System.Windows.Controls.InkCanvas" /> verschieben darf, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft auf `true`festgelegt ist, wird ein adornerrahmen um frei Hand Striche und/oder Elemente, wenn Sie ausgewählt werden, gezeichnet. Dieser Rahmen ermöglicht dem Benutzer das Verschieben der ausgewählten Objekte. Wenn <xref:System.Windows.Controls.InkCanvas.ResizeEnabled%2A> `true`ist, ermöglicht der Funktions Indikator dem Benutzer auch, die Größe der Striche und/oder Elemente zu ändern.  
  
 Wenn diese Eigenschaft auf `false` festgelegt ist, während mindestens ein frei Hand Strich und/oder ein Element ausgewählt ist, wird der adornerrahmen automatisch aus den ausgewählten Objekten entfernt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird verhindert, dass ein Benutzer das Verschieben und Ändern der Größe der Elemente und Striche in einem <xref:System.Windows.Controls.InkCanvas>verhindert.  
  
 [!code-csharp[InkCanvasSamples#7](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#7)]
 [!code-vb[InkCanvasSamples#7](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActiveEditingModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnActiveEditingModeChanged (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActiveEditingModeChanged(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnActiveEditingModeChanged(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActiveEditingModeChanged (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActiveEditingModeChanged(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActiveEditingModeChanged : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnActiveEditingModeChanged : System.Windows.RoutedEventArgs -&gt; unit" Usage="inkCanvas.OnActiveEditingModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Controls.InkCanvas.ActiveEditingModeChanged" /> aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="inkCanvas.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt eine geeignete <see cref="T:System.Windows.Automation.Peers.InkCanvasAutomationPeer" />-Implementierung für dieses Steuerelement als Teil der [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Infrastruktur bereit.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDefaultDrawingAttributesReplaced">
      <MemberSignature Language="C#" Value="protected virtual void OnDefaultDrawingAttributesReplaced (System.Windows.Ink.DrawingAttributesReplacedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDefaultDrawingAttributesReplaced(class System.Windows.Ink.DrawingAttributesReplacedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnDefaultDrawingAttributesReplaced(System.Windows.Ink.DrawingAttributesReplacedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDefaultDrawingAttributesReplaced (e As DrawingAttributesReplacedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDefaultDrawingAttributesReplaced(System::Windows::Ink::DrawingAttributesReplacedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDefaultDrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventArgs -&gt; unit&#xA;override this.OnDefaultDrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventArgs -&gt; unit" Usage="inkCanvas.OnDefaultDrawingAttributesReplaced e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Ink.DrawingAttributesReplacedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Controls.InkCanvas.DefaultDrawingAttributesReplaced" /> aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEditingModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEditingModeChanged (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEditingModeChanged(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnEditingModeChanged(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEditingModeChanged (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEditingModeChanged(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEditingModeChanged : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnEditingModeChanged : System.Windows.RoutedEventArgs -&gt; unit" Usage="inkCanvas.OnEditingModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Controls.InkCanvas.EditingModeChanged" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, nachdem der Bearbeitungsmodus geändert wurde. die Änderungen werden in der <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>-Eigenschaft der <xref:System.Windows.Controls.InkCanvas>widergespiegelt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEditingModeInvertedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEditingModeInvertedChanged (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEditingModeInvertedChanged(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnEditingModeInvertedChanged(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEditingModeInvertedChanged (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEditingModeInvertedChanged(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEditingModeInvertedChanged : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnEditingModeInvertedChanged : System.Windows.RoutedEventArgs -&gt; unit" Usage="inkCanvas.OnEditingModeInvertedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Controls.InkCanvas.EditingModeInvertedChanged" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, nachdem der invertierte Bearbeitungsmodus geändert wurde. die Änderungen, die in der <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A>-Eigenschaft der <xref:System.Windows.Controls.InkCanvas>widergespiegelt werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnGesture (System.Windows.Controls.InkCanvasGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGesture(class System.Windows.Controls.InkCanvasGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnGesture(System.Windows.Controls.InkCanvasGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGesture (e As InkCanvasGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGesture(System::Windows::Controls::InkCanvasGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGesture : System.Windows.Controls.InkCanvasGestureEventArgs -&gt; unit&#xA;override this.OnGesture : System.Windows.Controls.InkCanvasGestureEventArgs -&gt; unit" Usage="inkCanvas.OnGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Controls.InkCanvas.Gesture" /> aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="inkCanvas.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten, die die geänderte Eigenschaft beschreibt, sowie die alten und neuen Werte.</param>
        <summary>Wird immer dann aufgerufen, wenn der effektive Wert einer Abhängigkeitseigenschaft für dieses <see cref="T:System.Windows.FrameworkElement" /> aktualisiert wurde. Welche spezifische Abhängigkeitseigenschaft geändert wird, wird im Argumentparameter gemeldet. Überschreibt <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionChanged : EventArgs -&gt; unit&#xA;override this.OnSelectionChanged : EventArgs -&gt; unit" Usage="inkCanvas.OnSelectionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Controls.InkCanvas.SelectionChanged" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, nachdem ein Satz von frei Hand Strichen und/oder Elementen vom Benutzer ausgewählt wurde und die Auswahl Änderung angewendet wurde. Vor dem Anwenden der Änderung wird die <xref:System.Windows.Controls.InkCanvas.OnSelectionChanging%2A>-Methode aufgerufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionChanging(System.Windows.Controls.InkCanvasSelectionChangingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanging (System.Windows.Controls.InkCanvasSelectionChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanging(class System.Windows.Controls.InkCanvasSelectionChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionChanging(System.Windows.Controls.InkCanvasSelectionChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanging (e As InkCanvasSelectionChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanging(System::Windows::Controls::InkCanvasSelectionChangingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionChanging : System.Windows.Controls.InkCanvasSelectionChangingEventArgs -&gt; unit&#xA;override this.OnSelectionChanging : System.Windows.Controls.InkCanvasSelectionChangingEventArgs -&gt; unit" Usage="inkCanvas.OnSelectionChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasSelectionChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Controls.InkCanvas.SelectionChanging" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn ein Benutzer eine neue Auswahl von Strichen und/oder Elementen vorhat, bevor die Änderung angewendet wird. Nachdem die Änderung angewendet wurde, wird die <xref:System.Windows.Controls.InkCanvas.OnSelectionChanged%2A>-Methode aufgerufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionMoved (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionMoved(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionMoved(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionMoved (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionMoved(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionMoved : EventArgs -&gt; unit&#xA;override this.OnSelectionMoved : EventArgs -&gt; unit" Usage="inkCanvas.OnSelectionMoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Nicht verwendet.</param>
        <summary>Ein Ereignis, das angibt, dass der Benutzer eine Auswahl von Strichen und/oder Elementen ausgewählt und verschoben hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, nachdem eine Auswahl von Strichen und/oder Elementen vom Benutzer verschoben wurde und die Änderung angewendet wurde. Vor dem Anwenden der Änderung wird die <xref:System.Windows.Controls.InkCanvas.OnSelectionMoving%2A>-Methode aufgerufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionMoving(System.Windows.Controls.InkCanvasSelectionEditingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionMoving (System.Windows.Controls.InkCanvasSelectionEditingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionMoving(class System.Windows.Controls.InkCanvasSelectionEditingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionMoving(System.Windows.Controls.InkCanvasSelectionEditingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionMoving (e As InkCanvasSelectionEditingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionMoving(System::Windows::Controls::InkCanvasSelectionEditingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionMoving : System.Windows.Controls.InkCanvasSelectionEditingEventArgs -&gt; unit&#xA;override this.OnSelectionMoving : System.Windows.Controls.InkCanvasSelectionEditingEventArgs -&gt; unit" Usage="inkCanvas.OnSelectionMoving e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasSelectionEditingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Controls.InkCanvas.SelectionMoving" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, nachdem der Benutzer eine Auswahl von Strichen und/oder Elementen angefordert hat und bevor die Änderung angewendet wird. Nachdem die Änderung angewendet wurde, wird die <xref:System.Windows.Controls.InkCanvas.OnSelectionMoved%2A>-Methode aufgerufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionMoved(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionResized">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionResized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionResized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionResized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionResized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionResized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionResized : EventArgs -&gt; unit&#xA;override this.OnSelectionResized : EventArgs -&gt; unit" Usage="inkCanvas.OnSelectionResized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Controls.InkCanvas.SelectionResized" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, nachdem eine Auswahl von Strichen und/oder Elementen vom Benutzer geändert wurde und die Änderung angewendet wurde. Vor dem Anwenden der Änderung wird die <xref:System.Windows.Controls.InkCanvas.OnSelectionResizing%2A>-Methode aufgerufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionResizing(System.Windows.Controls.InkCanvasSelectionEditingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionResizing">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionResizing (System.Windows.Controls.InkCanvasSelectionEditingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionResizing(class System.Windows.Controls.InkCanvasSelectionEditingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionResizing(System.Windows.Controls.InkCanvasSelectionEditingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionResizing (e As InkCanvasSelectionEditingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionResizing(System::Windows::Controls::InkCanvasSelectionEditingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionResizing : System.Windows.Controls.InkCanvasSelectionEditingEventArgs -&gt; unit&#xA;override this.OnSelectionResizing : System.Windows.Controls.InkCanvasSelectionEditingEventArgs -&gt; unit" Usage="inkCanvas.OnSelectionResizing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasSelectionEditingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Controls.InkCanvas.SelectionResizing" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, nachdem der Benutzer eine Auswahl von Strichen und/oder Elementen geändert hat und bevor die Änderung angewendet wird. Nachdem die Änderung angewendet wurde, wird die <xref:System.Windows.Controls.InkCanvas.OnSelectionResized%2A>-Methode aufgerufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionResized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStrokeCollected">
      <MemberSignature Language="C#" Value="protected virtual void OnStrokeCollected (System.Windows.Controls.InkCanvasStrokeCollectedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStrokeCollected(class System.Windows.Controls.InkCanvasStrokeCollectedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnStrokeCollected(System.Windows.Controls.InkCanvasStrokeCollectedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStrokeCollected (e As InkCanvasStrokeCollectedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStrokeCollected(System::Windows::Controls::InkCanvasStrokeCollectedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStrokeCollected : System.Windows.Controls.InkCanvasStrokeCollectedEventArgs -&gt; unit&#xA;override this.OnStrokeCollected : System.Windows.Controls.InkCanvasStrokeCollectedEventArgs -&gt; unit" Usage="inkCanvas.OnStrokeCollected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasStrokeCollectedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Controls.InkCanvas.StrokeCollected" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas.OnStrokeCollected%2A> wird aufgerufen, wenn ein Benutzer einen Strich physisch abschließt, indem er z. b. den Tablettstift von einem Tablet nach einer Bewegung aufhebt.  
  
 Eine programmgesteuerte Addition von Strichen zur <xref:System.Windows.Controls.InkCanvas.Strokes%2A> Auflistung ruft nicht die <xref:System.Windows.Controls.InkCanvas.OnStrokeCollected%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStrokeErased">
      <MemberSignature Language="C#" Value="protected virtual void OnStrokeErased (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStrokeErased(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnStrokeErased(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStrokeErased (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStrokeErased(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStrokeErased : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnStrokeErased : System.Windows.RoutedEventArgs -&gt; unit" Usage="inkCanvas.OnStrokeErased e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Controls.InkCanvas.StrokeErased" /> aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStrokeErasing">
      <MemberSignature Language="C#" Value="protected virtual void OnStrokeErasing (System.Windows.Controls.InkCanvasStrokeErasingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStrokeErasing(class System.Windows.Controls.InkCanvasStrokeErasingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnStrokeErasing(System.Windows.Controls.InkCanvasStrokeErasingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStrokeErasing (e As InkCanvasStrokeErasingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStrokeErasing(System::Windows::Controls::InkCanvasStrokeErasingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStrokeErasing : System.Windows.Controls.InkCanvasStrokeErasingEventArgs -&gt; unit&#xA;override this.OnStrokeErasing : System.Windows.Controls.InkCanvasStrokeErasingEventArgs -&gt; unit" Usage="inkCanvas.OnStrokeErasing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasStrokeErasingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Controls.InkCanvas.StrokeErasing" /> aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStrokesReplaced">
      <MemberSignature Language="C#" Value="protected virtual void OnStrokesReplaced (System.Windows.Controls.InkCanvasStrokesReplacedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStrokesReplaced(class System.Windows.Controls.InkCanvasStrokesReplacedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnStrokesReplaced(System.Windows.Controls.InkCanvasStrokesReplacedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStrokesReplaced (e As InkCanvasStrokesReplacedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStrokesReplaced(System::Windows::Controls::InkCanvasStrokesReplacedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStrokesReplaced : System.Windows.Controls.InkCanvasStrokesReplacedEventArgs -&gt; unit&#xA;override this.OnStrokesReplaced : System.Windows.Controls.InkCanvasStrokesReplacedEventArgs -&gt; unit" Usage="inkCanvas.OnStrokesReplaced e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasStrokesReplacedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Controls.InkCanvas.StrokesReplaced" /> aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Paste">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt den Inhalt der Zwischenablage auf der <see cref="T:System.Windows.Controls.InkCanvas" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Controls.InkCanvas> kann Zwischenablage Daten in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Format-, [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]-und Textformat unterstützen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Paste" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste();" />
      <MemberSignature Language="F#" Value="member this.Paste : unit -&gt; unit" Usage="inkCanvas.Paste " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fügt den Inhalt der Zwischenablage in der linken oberen Ecke der <see cref="T:System.Windows.Controls.InkCanvas" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Controls.InkCanvas> kann Zwischenablage Daten in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Format-, [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]-und Textformat unterstützen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Element in die Zwischenablage kopiert und in den <xref:System.Windows.Controls.InkCanvas>eingefügt. In diesem Beispiel wird davon ausgegangen, dass ein Element mit dem Namen "`rect1`" vorhanden ist und dass die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignisse mit den Ereignis Handlern im Beispiel verbunden wurden.  
  
 [!code-csharp[InkCanvasSamples#1](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#1)]
 [!code-vb[InkCanvasSamples#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Einfügen von Inhalt aus der Zwischenablage in die <see cref="T:System.Windows.Controls.InkCanvas" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionClipboard.AllClipboard" /></permission>
        <altmember cref="M:System.Windows.Controls.InkCanvas.CopySelection" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.CanPaste" />
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Paste(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.Paste : System.Windows.Point -&gt; unit" Usage="inkCanvas.Paste point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Der Punkt, an dem die Striche eingefügt werden.</param>
        <summary>Fügt den Inhalt der Zwischenablage an einem angegebenen Punkt auf der <see cref="T:System.Windows.Controls.InkCanvas" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Controls.InkCanvas> kann Zwischenablage Daten in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Format-, [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]-und Textformat unterstützen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Element in die Zwischenablage kopiert und in den <xref:System.Windows.Controls.InkCanvas>eingefügt. In diesem Beispiel wird davon ausgegangen, dass ein Element mit dem Namen "`rect1`" vorhanden ist und dass die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignisse mit den Ereignis Handlern im Beispiel verbunden sind.  
  
 [!code-csharp[InkCanvasSamples#1](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#1)]
 [!code-vb[InkCanvasSamples#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Berechtigung zum Einfügen von Inhalt aus der Zwischenablage in die <see cref="T:System.Windows.Controls.InkCanvas" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionClipboard.AllClipboard" /></permission>
        <altmember cref="M:System.Windows.Controls.InkCanvas.CopySelection" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.CanPaste" />
      </Docs>
    </Member>
    <Member MemberName="PreferredPasteFormats">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Controls.InkCanvasClipboardFormat&gt; PreferredPasteFormats { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Windows.Controls.InkCanvasClipboardFormat&gt; PreferredPasteFormats" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.PreferredPasteFormats" />
      <MemberSignature Language="VB.NET" Value="Public Property PreferredPasteFormats As IEnumerable(Of InkCanvasClipboardFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Controls::InkCanvasClipboardFormat&gt; ^ PreferredPasteFormats { System::Collections::Generic::IEnumerable&lt;System::Windows::Controls::InkCanvasClipboardFormat&gt; ^ get(); void set(System::Collections::Generic::IEnumerable&lt;System::Windows::Controls::InkCanvasClipboardFormat&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PreferredPasteFormats : seq&lt;System.Windows.Controls.InkCanvasClipboardFormat&gt; with get, set" Usage="System.Windows.Controls.InkCanvas.PreferredPasteFormats" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Controls.InkCanvasClipboardFormat&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Formate ab, die auf der <see cref="T:System.Windows.Controls.InkCanvas" /> eingefügt werden können, oder legt diese fest.</summary>
        <value>Eine Auflistung von Enumerationswerten. Der Standardwert ist <see cref="F:System.Windows.Controls.InkCanvasClipboardFormat.InkSerializedFormat" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlPropertyElementUsage_PreferredPasteFormats"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.PreferredPasteFormats>  
    InkCanvasClipboardFormats  
  </object.PreferredPasteFormats>  
</object>  
```  
  
<a name="xamlValues_PreferredPasteFormats"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *Inkcanvasclipboardformats*  
 Ein Array von <xref:System.Windows.Controls.InkCanvasClipboardFormat> Enumerationswerten. Die Angabe eines Arrays in XAML erfordert `x:Array` Verwendung. Die Angabe eines Enumerationswerts als Element, das einen Array Member deklariert, erfordert `x:Static` Verwendung. Weitere Informationen finden Sie unter [x:Array-Markup Erweiterung](~/docs/framework/xaml-services/x-array-markup-extension.md) und [x:statische Markup Erweiterung](~/docs/framework/xaml-services/x-static-markup-extension.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird der <xref:System.Windows.Controls.InkCanvas.PreferredPasteFormats%2A> festgelegt, damit der <xref:System.Windows.Controls.InkCanvas> [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Format akzeptiert, [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)].  
  
 [!code-csharp[InkCanvasSamples#26](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#26)]
 [!code-vb[InkCanvasSamples#26](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#26)]  
  
 Im folgenden Beispiel wird das gleiche in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]erreicht.  
  
 [!code-xaml[InkCanvasSamples#38](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window2.xaml#38)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizeEnabled">
      <MemberSignature Language="C#" Value="public bool ResizeEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResizeEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.ResizeEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ResizeEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeEnabled : bool with get, set" Usage="System.Windows.Controls.InkCanvas.ResizeEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob der Benutzer die Größe der ausgewählten Freihandstriche und/oder Elemente auf der <see cref="T:System.Windows.Controls.InkCanvas" /> ändern darf, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn ein Benutzer die Größe von Strichen und/oder Elementen auf der <see cref="T:System.Windows.Controls.InkCanvas" /> ändern darf, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft auf `true`festgelegt ist, wird ein adornerrahmen um frei Hand Striche und/oder Elemente, wenn Sie ausgewählt werden, gezeichnet. Dieser Rahmen ermöglicht es dem Benutzer, die Größe der ausgewählten Objekte zu ändern. Wenn <xref:System.Windows.Controls.InkCanvas.MoveEnabled%2A> `true`ist, ermöglicht der Funktions Indikator es dem Benutzer, die Striche und/oder Elemente ebenfalls zu verschieben.  
  
 Wenn diese Eigenschaft auf `false` festgelegt ist, während mindestens ein frei Hand Strich und/oder ein Element ausgewählt ist, wird der adornerrahmen automatisch aus den ausgewählten Objekten entfernt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird verhindert, dass ein Benutzer das Verschieben und Ändern der Größe der Elemente und Striche in einem <xref:System.Windows.Controls.InkCanvas>verhindert.  
  
 [!code-csharp[InkCanvasSamples#7](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#7)]
 [!code-vb[InkCanvasSamples#7](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="see GetRight, and SetRight" />
      <MemberSignature Language="ILAsm" Value="see GetRight, and SetRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Right" />
      <MemberSignature Language="VB.NET" Value="see GetRight, and SetRight" />
      <MemberSignature Language="F#" Value="see GetRight, and SetRight" Usage="see GetRight, and SetRight" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Abstand zwischen dem rechten Rand eines Elements und dem rechten Rand seiner übergeordneten <see cref="T:System.Windows.Controls.InkCanvas" /> ab oder legt diesen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Right"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.RightProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
<a name="xamlAttributeUsage_Right"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object InkCanvas.Right="double"/>  
- or -  
<object InkCanvas.Right="qualifiedDouble"/>  
```  
  
<a name="xamlValues_Right"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 Zeichen folgen Darstellung eines <xref:System.Double> Werts. Dies wird als [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung interpretiert. Zeichen folgen müssen nicht explizit Dezimalstellen enthalten. Beispielsweise ist der Wert `1` akzeptabel.  
  
 *qualifiedDouble*  
 Ein *doppelter* Wert, wie oben beschrieben, gefolgt von einer der folgenden Einheiten Deklarations Zeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px` (Standard) ist [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll. 1In = = 96px  
  
 `cm` ist Zentimeter. 1cm = = (96/2,54) px  
  
 `pt` ist Punkte. 1pt = = (96/72) px  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Position einer <xref:System.Windows.Controls.Label> auf einem <xref:System.Windows.Controls.InkCanvas>festgelegt wird.  
  
 [!code-xml[InkCanvasSamples#35](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.RightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ RightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable RightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.RightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Controls.InkCanvas.Right" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wählt einen Satz von Freihand-<see cref="T:System.Windows.Ink.Stroke" />-Objekten und/oder <see cref="T:System.Windows.FrameworkElement" />-Objekten aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Controls.InkCanvas> kann <xref:System.Windows.Ink.Stroke> Objekte enthalten, die als Reaktion auf Benutzer Stift Eingaben erstellt werden, und <xref:System.Windows.FrameworkElement> Objekten, z. b. <xref:System.Windows.Controls.Image>-und <xref:System.Windows.Controls.Button> Objekte.  
  
 Ausgewählte Striche werden angezeigt, um Sie zu vereinfachen und leichter zu erkennen und zu manipulieren. <xref:System.Windows.FrameworkElement> Objekte werden nicht anders angezeigt, wenn Sie ausgewählt werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (System.Collections.Generic.IEnumerable&lt;System.Windows.UIElement&gt; selectedElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.UIElement&gt; selectedElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Select(System.Collections.Generic.IEnumerable{System.Windows.UIElement})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (selectedElements As IEnumerable(Of UIElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(System::Collections::Generic::IEnumerable&lt;System::Windows::UIElement ^&gt; ^ selectedElements);" />
      <MemberSignature Language="F#" Value="member this.Select : seq&lt;System.Windows.UIElement&gt; -&gt; unit" Usage="inkCanvas.Select selectedElements" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectedElements" Type="System.Collections.Generic.IEnumerable&lt;System.Windows.UIElement&gt;" />
      </Parameters>
      <Docs>
        <param name="selectedElements">Eine Auflistung von <see cref="T:System.Windows.UIElement" />-Objekten für die Auswahl.</param>
        <summary>Wählt einen Satz von <see cref="T:System.Windows.UIElement" />-Objekten aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Controls.InkCanvas> kann <xref:System.Windows.Ink.Stroke> Objekte enthalten, die als Reaktion auf Eingabe-und <xref:System.Windows.UIElement> Objekte des Benutzers (z. b. <xref:System.Windows.Controls.Image> und <xref:System.Windows.Controls.Button> Objekte) erstellt werden.  
  
 Ausgewählte Striche werden mit einem Funktions Indikator herum angezeigt, um Sie leichter zu erkennen und zu manipulieren. <xref:System.Windows.UIElement> Objekte werden nicht anders angezeigt, wenn Sie ausgewählt werden. Wenn eine <xref:System.Windows.UIElement> in `selectedElements` nicht in der Children-Auflistung enthalten ist, ignoriert <xref:System.Windows.Controls.InkCanvas.Select%2A> die <xref:System.Windows.UIElement>.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Striche und zwei Elemente in einem <xref:System.Windows.Controls.InkCanvas>ausgewählt. In diesem Beispiel wird davon ausgegangen, dass eine <xref:System.Windows.Controls.TextBox> mit dem Namen `textbox1` und eine <xref:System.Windows.Controls.Button> `button1` und beide Steuerelemente untergeordnete Elemente des <xref:System.Windows.Controls.InkCanvas>sind.  
  
 [!code-csharp[InkCanvasSamples#2](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#2)]
 [!code-vb[InkCanvasSamples#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (System.Windows.Ink.StrokeCollection selectedStrokes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(class System.Windows.Ink.StrokeCollection selectedStrokes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Select(System.Windows.Ink.StrokeCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (selectedStrokes As StrokeCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(System::Windows::Ink::StrokeCollection ^ selectedStrokes);" />
      <MemberSignature Language="F#" Value="member this.Select : System.Windows.Ink.StrokeCollection -&gt; unit" Usage="inkCanvas.Select selectedStrokes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectedStrokes" Type="System.Windows.Ink.StrokeCollection" />
      </Parameters>
      <Docs>
        <param name="selectedStrokes">Eine Auflistung von <see cref="T:System.Windows.Ink.Stroke" />-Objekten für die Auswahl.</param>
        <summary>Wählt einen Satz von Freihand-<see cref="T:System.Windows.Ink.Stroke" />-Objekten aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Controls.InkCanvas> kann <xref:System.Windows.Ink.Stroke> Objekte enthalten, die als Reaktion auf Benutzer Stift Eingaben erstellt werden, und <xref:System.Windows.FrameworkElement> Objekten, z. b. <xref:System.Windows.Controls.Image>-und <xref:System.Windows.Controls.Button> Objekte.  
  
 Ausgewählte Striche werden mit einem Funktions Indikator herum angezeigt, um Sie leichter zu erkennen und zu manipulieren. <xref:System.Windows.FrameworkElement> Objekte werden nicht anders angezeigt, wenn Sie ausgewählt sind.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Striche und zwei Elemente in einem <xref:System.Windows.Controls.InkCanvas>ausgewählt.  In diesem Beispiel wird davon ausgegangen, dass eine <xref:System.Windows.Controls.TextBox> mit dem Namen `textbox1` und eine <xref:System.Windows.Controls.Button> `button1` und beide Steuerelemente untergeordnete Elemente des <xref:System.Windows.Controls.InkCanvas>sind.  
  
 [!code-csharp[InkCanvasSamples#2](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#2)]
 [!code-vb[InkCanvasSamples#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Mindestens ein Strich in <paramref name="selectedStrokes" /> ist nicht in der <see cref="P:System.Windows.Controls.InkCanvas.Strokes" />-Eigenschaft enthalten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (System.Windows.Ink.StrokeCollection selectedStrokes, System.Collections.Generic.IEnumerable&lt;System.Windows.UIElement&gt; selectedElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(class System.Windows.Ink.StrokeCollection selectedStrokes, class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.UIElement&gt; selectedElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Select(System.Windows.Ink.StrokeCollection,System.Collections.Generic.IEnumerable{System.Windows.UIElement})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (selectedStrokes As StrokeCollection, selectedElements As IEnumerable(Of UIElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(System::Windows::Ink::StrokeCollection ^ selectedStrokes, System::Collections::Generic::IEnumerable&lt;System::Windows::UIElement ^&gt; ^ selectedElements);" />
      <MemberSignature Language="F#" Value="member this.Select : System.Windows.Ink.StrokeCollection * seq&lt;System.Windows.UIElement&gt; -&gt; unit" Usage="inkCanvas.Select (selectedStrokes, selectedElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectedStrokes" Type="System.Windows.Ink.StrokeCollection" />
        <Parameter Name="selectedElements" Type="System.Collections.Generic.IEnumerable&lt;System.Windows.UIElement&gt;" />
      </Parameters>
      <Docs>
        <param name="selectedStrokes">Eine Auflistung von <see cref="T:System.Windows.Ink.Stroke" />-Objekten für die Auswahl.</param>
        <param name="selectedElements">Eine Auflistung von <see cref="T:System.Windows.UIElement" />-Objekten für die Auswahl.</param>
        <summary>Wählt eine Kombination aus <see cref="T:System.Windows.Ink.Stroke" />-Objekten und <see cref="T:System.Windows.UIElement" />-Objekten aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Controls.InkCanvas> kann <xref:System.Windows.Ink.Stroke> Objekte enthalten, die als Reaktion auf Eingabe-und <xref:System.Windows.UIElement> Objekte des Benutzers (z. b. <xref:System.Windows.Controls.Image> und <xref:System.Windows.Controls.Button> Objekte) erstellt werden.  
  
 Ausgewählte Striche werden angezeigt, um Sie zu vereinfachen und leichter zu erkennen und zu manipulieren. <xref:System.Windows.UIElement> Objekte werden nicht anders angezeigt, wenn Sie ausgewählt werden. Wenn eine <xref:System.Windows.UIElement> in `selectedElements` nicht in der Children-Auflistung enthalten ist, ignoriert <xref:System.Windows.Controls.InkCanvas.Select%2A> die <xref:System.Windows.UIElement>.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Striche und zwei Elemente in einem <xref:System.Windows.Controls.InkCanvas>ausgewählt.  In diesem Beispiel wird davon ausgegangen, dass eine <xref:System.Windows.Controls.TextBox> mit dem Namen `textbox1` und eine <xref:System.Windows.Controls.Button> `button1` und beide Steuerelemente untergeordnete Elemente des <xref:System.Windows.Controls.InkCanvas>sind.  
  
 [!code-csharp[InkCanvasSamples#2](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#2)]
 [!code-vb[InkCanvasSamples#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Mindestens ein Strich in <paramref name="selectedStrokes" /> ist nicht in der <see cref="P:System.Windows.Controls.InkCanvas.Strokes" />-Eigenschaft enthalten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionChanged As EventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectionChanged : EventHandler " Usage="member this.SelectionChanged : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionChanged As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Auswahl auf einer <see cref="T:System.Windows.Controls.InkCanvas" /> geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, nachdem ein Satz von frei Hand Strichen und/oder Elementen ausgewählt und vom Benutzer angewendet wurde.  
  
 Wenn Sie stattdessen eine Anforderung verarbeiten müssen, die einen Satz von frei Hand Strichen und/oder Elementen auswählt, bevor die Auswahl angewendet wird, fügen Sie dem <xref:System.Windows.Controls.InkCanvas.SelectionChanging>-Ereignis einen Ereignishandler hinzu.  
  
   
  
## Examples  
 Im folgenden Beispiel wird verhindert, dass der Benutzer eine Auswahl unterscheidet, die kleiner als die ursprüngliche Größe ist.  
  
 [!code-csharp[InkCanvasSamples#16](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#16)]
 [!code-vb[InkCanvasSamples#16](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionChanging" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SelectionChanging">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasSelectionChangingEventHandler SelectionChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasSelectionChangingEventHandler SelectionChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionChanging As InkCanvasSelectionChangingEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasSelectionChangingEventHandler ^ SelectionChanging;" />
      <MemberSignature Language="F#" Value="member this.SelectionChanging : System.Windows.Controls.InkCanvasSelectionChangingEventHandler " Usage="member this.SelectionChanging : System.Windows.Controls.InkCanvasSelectionChangingEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionChanging As InkCanvasSelectionChangingEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasSelectionChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein neuer Satz von Freihandstrichen und/oder Elementen ausgewählt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Controls.InkCanvas.SelectionChanging>-Ereignis wird ausgelöst, wenn vom Benutzer Striche und/oder Elemente ausgewählt werden, aber bevor die Änderung angewendet wird.  
  
 Das <xref:System.Windows.Controls.InkCanvas.SelectionChanging>-Ereignis wird verarbeitet, wenn der <xref:System.Windows.Controls.InkCanvasSelectionChangingEventHandler> ein <xref:System.Windows.Controls.InkCanvasSelectionChangingEventArgs>-Objekt empfängt. <xref:System.Windows.Controls.InkCanvasSelectionChangingEventArgs> stellt Methoden für den Zugriff auf <xref:System.Windows.FrameworkElement> und <xref:System.Windows.Ink.StrokeCollection> Objekte bereit, nachdem Sie vom Benutzer ausgewählt wurden.  
  
 Nachdem die Änderung angewendet wurde, wird das <xref:System.Windows.Controls.InkCanvas.SelectionChanged>-Ereignis ausgelöst.  
  
> [!NOTE]
>  Das <xref:System.Windows.Controls.InkCanvas.SelectionChanging> Ereignis tritt nicht auf, wenn die ausgewählten Striche gelöscht werden oder wenn sich die <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A>-Eigenschaft ändert.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die markierten Striche "Royal Blue" ausgewählt.  
  
 [!code-csharp[InkCanvasSamples#14](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#14)]
 [!code-vb[InkCanvasSamples#14](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvasSelectionChangingEventArgs.GetSelectedElements" />
        <altmember cref="M:System.Windows.Controls.InkCanvasSelectionChangingEventArgs.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvasSelectionChangingEventArgs.SetSelectedElements(System.Collections.Generic.IEnumerable{System.Windows.UIElement})" />
        <altmember cref="M:System.Windows.Controls.InkCanvasSelectionChangingEventArgs.SetSelectedStrokes(System.Windows.Ink.StrokeCollection)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionMoved">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionMoved" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionMoved As EventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionMoved;" />
      <MemberSignature Language="F#" Value="member this.SelectionMoved : EventHandler " Usage="member this.SelectionMoved : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionMoved As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem der Benutzer eine Auswahl von Strichen und/oder Elementen verschoben hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, nachdem eine Auswahl von Strichen und/oder Elementen verschoben wurde, aber bevor die Striche-oder Elementdaten aktualisiert werden, um die neue Position aufzuzeichnen. Fügen Sie dem <xref:System.Windows.Controls.InkCanvas.SelectionMoving>-Ereignis einen Ereignishandler hinzu.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Elemente in einer <xref:System.Windows.Controls.InkCanvas> entfernt, nachdem Sie vom Benutzer verschoben wurden.  
  
 [!code-csharp[InkCanvasSamples#19](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#19)]
 [!code-vb[InkCanvasSamples#19](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#19)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionMoving" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SelectionMoving">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasSelectionEditingEventHandler SelectionMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasSelectionEditingEventHandler SelectionMoving" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionMoving As InkCanvasSelectionEditingEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasSelectionEditingEventHandler ^ SelectionMoving;" />
      <MemberSignature Language="F#" Value="member this.SelectionMoving : System.Windows.Controls.InkCanvasSelectionEditingEventHandler " Usage="member this.SelectionMoving : System.Windows.Controls.InkCanvasSelectionEditingEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionMoving As InkCanvasSelectionEditingEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasSelectionEditingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor ausgewählte Striche und Elemente verschoben werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, nachdem der Benutzer eine Auswahl von Strichen und/oder Elementen angefordert hat, jedoch bevor die Änderung angewendet wird.  
  
 Der Ereignishandler empfängt ein Argument vom Typ <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs> mit zwei Eigenschaften: <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.OldRectangle%2A> und <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.NewRectangle%2A>. <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.OldRectangle%2A> die Begrenzungen der Auswahl vor dem Verschieben definiert, und <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.NewRectangle%2A> die Begrenzungen der Auswahl nach dem Verschieben definiert.  
  
 Nachdem die Änderung angewendet wurde, tritt das <xref:System.Windows.Controls.InkCanvas.SelectionMoved>-Ereignis auf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird verhindert, dass der Benutzer ausgewählte Elemente in einer <xref:System.Windows.Controls.InkCanvas>vertikal verschiebt.  
  
 [!code-csharp[InkCanvasSamples#13](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#13)]
 [!code-vb[InkCanvasSamples#13](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionMoved" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SelectionResized">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionResized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionResized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionResized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionResized As EventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionResized;" />
      <MemberSignature Language="F#" Value="member this.SelectionResized : EventHandler " Usage="member this.SelectionResized : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionResized As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Größe einer Auswahl von Strichen und/oder Elementen vom Benutzer geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, nachdem die Größe der Striche und/oder Elemente geändert wurde.  
  
 Wenn Sie stattdessen eine Anforderung verarbeiten müssen, um die Größe einer Auswahl zu ändern, bevor die Striche und/oder Elemente geändert werden, fügen Sie dem <xref:System.Windows.Controls.InkCanvas.SelectionResizing>-Ereignis einen Ereignishandler hinzu.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Elemente in einer <xref:System.Windows.Controls.InkCanvas> deaktiviert, nachdem der Benutzer die Auswahl neu in der Größe ausgewählt hat.  
  
 [!code-csharp[InkCanvasSamples#23](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#23)]
 [!code-vb[InkCanvasSamples#23](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#23)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionResizing" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SelectionResizing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasSelectionEditingEventHandler SelectionResizing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasSelectionEditingEventHandler SelectionResizing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionResizing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionResizing As InkCanvasSelectionEditingEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasSelectionEditingEventHandler ^ SelectionResizing;" />
      <MemberSignature Language="F#" Value="member this.SelectionResizing : System.Windows.Controls.InkCanvasSelectionEditingEventHandler " Usage="member this.SelectionResizing : System.Windows.Controls.InkCanvasSelectionEditingEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionResizing As InkCanvasSelectionEditingEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasSelectionEditingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor die Größe der ausgewählten Striche und Elemente geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, nachdem der Benutzer die Größe der Striche und/oder Elemente geändert hat, jedoch bevor die Änderung angewendet wird.  
  
 Der Ereignishandler empfängt ein Argument vom Typ <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs>, das zwei Eigenschaften enthält: <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.OldRectangle%2A> und <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.NewRectangle%2A>. <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.OldRectangle%2A> definiert die Begrenzungen der Auswahl vor dem Vorgang zum Ändern der Größe und <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.NewRectangle%2A> die Begrenzungen der Auswahl nach dem Vorgang zum Ändern der Größe definiert.  
  
 Nachdem die Striche und/oder Elemente mit der neuen Größe aktualisiert wurden, wird das <xref:System.Windows.Controls.InkCanvas.SelectionResized>-Ereignis ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird verhindert, dass der Benutzer eine Auswahl unterscheidet, die kleiner als die ursprüngliche Größe ist.  
  
 [!code-csharp[InkCanvasSamples#16](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#16)]
 [!code-vb[InkCanvasSamples#16](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionResized" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SetBottom">
      <MemberSignature Language="C#" Value="public static void SetBottom (System.Windows.UIElement element, double length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBottom(class System.Windows.UIElement element, float64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetBottom(System.Windows.UIElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBottom (element As UIElement, length As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBottom(System::Windows::UIElement ^ element, double length);" />
      <MemberSignature Language="F#" Value="static member SetBottom : System.Windows.UIElement * double -&gt; unit" Usage="System.Windows.Controls.InkCanvas.SetBottom (element, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="length" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, dessen bottom-Eigenschaft festgelegt werden soll.</param>
        <param name="length">Die untere Koordinate von <paramref name="element" />.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Controls.InkCanvas.Bottom" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Position einer <xref:System.Windows.Controls.Button>festgelegt wird.  
  
 [!code-csharp[InkCanvasSamples#28](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#28)]
 [!code-vb[InkCanvasSamples#28](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEnabledGestures">
      <MemberSignature Language="C#" Value="public void SetEnabledGestures (System.Collections.Generic.IEnumerable&lt;System.Windows.Ink.ApplicationGesture&gt; applicationGestures);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetEnabledGestures(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Windows.Ink.ApplicationGesture&gt; applicationGestures) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetEnabledGestures(System.Collections.Generic.IEnumerable{System.Windows.Ink.ApplicationGesture})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetEnabledGestures (applicationGestures As IEnumerable(Of ApplicationGesture))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetEnabledGestures(System::Collections::Generic::IEnumerable&lt;System::Windows::Ink::ApplicationGesture&gt; ^ applicationGestures);" />
      <MemberSignature Language="F#" Value="member this.SetEnabledGestures : seq&lt;System.Windows.Ink.ApplicationGesture&gt; -&gt; unit" Usage="inkCanvas.SetEnabledGestures applicationGestures" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationGestures" Type="System.Collections.Generic.IEnumerable&lt;System.Windows.Ink.ApplicationGesture&gt;" />
      </Parameters>
      <Docs>
        <param name="applicationGestures">Eine Auflistung von Anwendungsstiftbewegungen, die von der <see cref="T:System.Windows.Controls.InkCanvas" /> erkannt werden.</param>
        <summary>Legt die Anwendungsstiftbewegungen fest, die von der <see cref="T:System.Windows.Controls.InkCanvas" /> erkannt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im folgenden Beispiel wird veranschaulicht, wie Sie eine <xref:System.Windows.Controls.InkCanvas> einrichten, um Anwendungs Gesten zu erkennen.  
  
 [!code-csharp[GestureSample#3](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#3)]
 [!code-vb[GestureSample#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#3)]  
[!code-csharp[GestureSample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#1)]
[!code-vb[GestureSample#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Windows.Controls.InkCanvas.IsGestureRecognizerAvailable" />-Eigenschaft ist <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLeft">
      <MemberSignature Language="C#" Value="public static void SetLeft (System.Windows.UIElement element, double length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLeft(class System.Windows.UIElement element, float64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetLeft(System.Windows.UIElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLeft (element As UIElement, length As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLeft(System::Windows::UIElement ^ element, double length);" />
      <MemberSignature Language="F#" Value="static member SetLeft : System.Windows.UIElement * double -&gt; unit" Usage="System.Windows.Controls.InkCanvas.SetLeft (element, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="length" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, dessen left-Eigenschaft festgelegt werden soll.</param>
        <param name="length">Die linke Koordinate von <paramref name="element" />.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Controls.InkCanvas.Left" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Position einer <xref:System.Windows.Controls.Button>festgelegt wird.  
  
 [!code-csharp[InkCanvasSamples#29](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#29)]
 [!code-vb[InkCanvasSamples#29](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#29)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetRight">
      <MemberSignature Language="C#" Value="public static void SetRight (System.Windows.UIElement element, double length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetRight(class System.Windows.UIElement element, float64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetRight(System.Windows.UIElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetRight (element As UIElement, length As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetRight(System::Windows::UIElement ^ element, double length);" />
      <MemberSignature Language="F#" Value="static member SetRight : System.Windows.UIElement * double -&gt; unit" Usage="System.Windows.Controls.InkCanvas.SetRight (element, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="length" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, dessen right-Eigenschaft festgelegt werden soll.</param>
        <param name="length">Die rechte Koordinate von <paramref name="element" />.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Controls.InkCanvas.Right" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Position einer <xref:System.Windows.Controls.Button>festgelegt wird.  
  
 [!code-csharp[InkCanvasSamples#30](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#30)]
 [!code-vb[InkCanvasSamples#30](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTop">
      <MemberSignature Language="C#" Value="public static void SetTop (System.Windows.UIElement element, double length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTop(class System.Windows.UIElement element, float64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetTop(System.Windows.UIElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTop (element As UIElement, length As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTop(System::Windows::UIElement ^ element, double length);" />
      <MemberSignature Language="F#" Value="static member SetTop : System.Windows.UIElement * double -&gt; unit" Usage="System.Windows.Controls.InkCanvas.SetTop (element, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="length" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, dessen top-Eigenschaft festgelegt werden soll.</param>
        <param name="length">Die obere Koordinate von <paramref name="element" />.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Controls.InkCanvas.Top" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Position einer <xref:System.Windows.Controls.Button>festgelegt wird.  
  
 [!code-csharp[InkCanvasSamples#27](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#27)]
 [!code-vb[InkCanvasSamples#27](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokeCollected">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasStrokeCollectedEventHandler StrokeCollected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasStrokeCollectedEventHandler StrokeCollected" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.StrokeCollected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StrokeCollected As InkCanvasStrokeCollectedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasStrokeCollectedEventHandler ^ StrokeCollected;" />
      <MemberSignature Language="F#" Value="member this.StrokeCollected : System.Windows.Controls.InkCanvasStrokeCollectedEventHandler " Usage="member this.StrokeCollected : System.Windows.Controls.InkCanvasStrokeCollectedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasStrokeCollectedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Controls.InkCanvas.Strokes" />-Eigenschaft ein vom Benutzer gezeichneter Strich hinzugefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn ein Benutzer einen Strich mithilfe eines Zeige Geräts abschließt. Ein Benutzer könnte z. b. nach dem Durchführen einer Bewegung einen Tablettstift von einem Digitalisierer erstellen und damit einen Strich abschließen.  
  
 Der Ereignishandler empfängt ein Argument vom Typ <xref:System.Windows.Controls.InkCanvasStrokeCollectedEventArgs>, das auf den abgeschlossenen Strich verweist. Der Strich wird auch der <xref:System.Windows.Controls.InkCanvas.Strokes%2A>-Eigenschaft der <xref:System.Windows.Controls.InkCanvas>hinzugefügt.  
  
 Durch das programmgesteuerte Hinzufügen eines <xref:System.Windows.Ink.Stroke> Objekts zur <xref:System.Windows.Controls.InkCanvas.Strokes%2A> Auflistung wird dieses Ereignis nicht angehoben.  
  
<a name="routedEventInfo_StrokeCollected"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.StrokeCollectedEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Controls.InkCanvasStrokeCollectedEventHandler>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Zeit als benutzerdefinierte Eigenschaft gespeichert, wenn ein Benutzer dem <xref:System.Windows.Controls.InkCanvas>einen Strich hinzufügt.  
  
 [!code-csharp[InkCanvasSamples#22](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#22)]
 [!code-vb[InkCanvasSamples#22](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Ink.Stroke.AddPropertyData(System.Guid,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="StrokeCollectedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StrokeCollectedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StrokeCollectedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.StrokeCollectedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StrokeCollectedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StrokeCollectedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StrokeCollectedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.StrokeCollectedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.Controls.InkCanvas.StrokeCollected" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokeErased">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler StrokeErased;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler StrokeErased" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.StrokeErased" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StrokeErased As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ StrokeErased;" />
      <MemberSignature Language="F#" Value="member this.StrokeErased : System.Windows.RoutedEventHandler " Usage="member this.StrokeErased : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer einen Strich löscht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, wenn ein Benutzer frei Hand Eingaben löscht, ob die <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>-Eigenschaft auf <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint> oder <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByStroke>festgelegt ist.  
  
<a name="routedEventInfo_StrokeErasing"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.StrokeErasedEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Anzahl der Striche in einer <xref:System.Windows.Controls.InkCanvas> gemeldet, wenn das <xref:System.Windows.Controls.InkCanvas.StrokeErased>-Ereignis auftritt. Wenn <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> auf <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint> festgelegt ist und der Benutzer die Mitte eines Strichs löscht, erhöht sich die Anzahl der Striche im <xref:System.Windows.Controls.InkCanvas>. Dies liegt daran, dass der alte Strich durch zwei neue Striche ersetzt wurde.  
  
 [!code-csharp[InkCanvasSamples#18](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#18)]
 [!code-vb[InkCanvasSamples#18](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokeErasedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StrokeErasedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StrokeErasedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.StrokeErasedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StrokeErasedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StrokeErasedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StrokeErasedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.StrokeErasedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.Controls.InkCanvas.StrokeErased" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokeErasing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasStrokeErasingEventHandler StrokeErasing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasStrokeErasingEventHandler StrokeErasing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.StrokeErasing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StrokeErasing As InkCanvasStrokeErasingEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasStrokeErasingEventHandler ^ StrokeErasing;" />
      <MemberSignature Language="F#" Value="member this.StrokeErasing : System.Windows.Controls.InkCanvasStrokeErasingEventHandler " Usage="member this.StrokeErasing : System.Windows.Controls.InkCanvasStrokeErasingEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event StrokeErasing As InkCanvasStrokeErasingEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasStrokeErasingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, unmittelbar bevor ein Benutzer einen Strich löscht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Behandeln Sie dieses Ereignis, wenn Sie überprüfen möchten, ob ein Strich gelöscht werden soll. Legen Sie die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A>-Eigenschaft auf `true` fest, wenn Sie verhindern möchten, dass der Strich gelöscht wird. Sie können dieses Verfahren verwenden, wenn die Eigenschaft <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> oder <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> auf <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByStroke> oder <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird verhindert, dass Striche, die als Hervorhebungen gerendert werden, gelöscht werden. Im Beispiel wird davon ausgegangen, dass die <xref:System.Windows.Controls.InkCanvas> mit dem-Ereignishandler verbunden ist.  
  
 [!code-csharp[DrawingAttributes#16](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingAttributes/CSharp/Window1.xaml.cs#16)]
 [!code-vb[DrawingAttributes#16](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingAttributes/VisualBasic/Window1.xaml.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Strokes">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.StrokeCollection Strokes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Ink.StrokeCollection Strokes" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Strokes" />
      <MemberSignature Language="VB.NET" Value="Public Property Strokes As StrokeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Ink::StrokeCollection ^ Strokes { System::Windows::Ink::StrokeCollection ^ get(); void set(System::Windows::Ink::StrokeCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Strokes : System.Windows.Ink.StrokeCollection with get, set" Usage="System.Windows.Controls.InkCanvas.Strokes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StrokeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung von Freihand-<see cref="T:System.Windows.Ink.Stroke" />-Objekten ab, die von der <see cref="T:System.Windows.Controls.InkCanvas" /> gesammelt wird, oder legt diese fest.</summary>
        <value>Die Auflistung der <see cref="T:System.Windows.Ink.Stroke" />-Objekte, die in der <see cref="T:System.Windows.Controls.InkCanvas" /> enthalten sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Strokes"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.StrokesProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie zwei <xref:System.Windows.Ink.StrokeCollection>-Objekte für denselben <xref:System.Windows.Controls.InkCanvas>verwendet werden. In diesem Beispiel verwenden Player One und Player Two jeweils eine einzelne "Eingangs Oberfläche", auch wenn Sie dieselbe <xref:System.Windows.Controls.InkCanvas>haben. In diesem Beispiel wird davon ausgegangen, dass das Click-Ereignis mit dem Ereignishandler verbunden ist, `switchPlayersButton_Click`.  
  
 [!code-csharp[InkCanvasSamples#15](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#15)]
 [!code-vb[InkCanvasSamples#15](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#15)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Windows.Controls.InkCanvas.Strokes%2A>-Eigenschaft einer <xref:System.Windows.Controls.InkCanvas> an eine andere <xref:System.Windows.Controls.InkCanvas>gebunden wird.  
  
 [!code-xaml[InkCanvasBindingSnippet#2](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasBindingSnippet/CS/Window2.xaml#2)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Ink.StrokeCollection" />
      </Docs>
    </Member>
    <Member MemberName="StrokesProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StrokesProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StrokesProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.StrokesProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StrokesProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StrokesProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StrokesProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.StrokesProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Controls.InkCanvas.Strokes" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokesReplaced">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasStrokesReplacedEventHandler StrokesReplaced;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasStrokesReplacedEventHandler StrokesReplaced" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.StrokesReplaced" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StrokesReplaced As InkCanvasStrokesReplacedEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasStrokesReplacedEventHandler ^ StrokesReplaced;" />
      <MemberSignature Language="F#" Value="member this.StrokesReplaced : System.Windows.Controls.InkCanvasStrokesReplacedEventHandler " Usage="member this.StrokesReplaced : System.Windows.Controls.InkCanvasStrokesReplacedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event StrokesReplaced As InkCanvasStrokesReplacedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasStrokesReplacedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="P:System.Windows.Controls.InkCanvas.Strokes" />-Eigenschaft ersetzt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie zwei <xref:System.Windows.Ink.StrokeCollection> Objekte verwendet werden, die sich auf demselben <xref:System.Windows.Controls.InkCanvas>befinden. In diesem Beispiel verwenden Player One und Player Two jeweils eine einzelne "Eingangs Oberfläche", auch wenn Sie dieselbe <xref:System.Windows.Controls.InkCanvas>haben. In diesem Beispiel wird davon ausgegangen, dass das `switchPlayersButton_Click`-Ereignis mit dem-Ereignishandler verbunden ist.  
  
 [!code-csharp[InkCanvasSamples#15](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#15)]
 [!code-vb[InkCanvasSamples#15](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das hinzuzufügende untergeordnete Objekt.</param>
        <summary>Fügt der <see cref="T:System.Windows.Controls.InkCanvas" /> das angegebene Objekt hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (textData As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ textData) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Nicht verwendet.</param>
        <summary>Fügt den Text innerhalb der Tags im Markup hinzu. Löst immer eine <see cref="T:System.ArgumentException" /> aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="see GetTop, and SetTop" />
      <MemberSignature Language="ILAsm" Value="see GetTop, and SetTop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Top" />
      <MemberSignature Language="VB.NET" Value="see GetTop, and SetTop" />
      <MemberSignature Language="F#" Value="see GetTop, and SetTop" Usage="see GetTop, and SetTop" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Abstand zwischen dem oberen Rand eines Elements und dem oberen Rand seiner übergeordneten <see cref="T:System.Windows.Controls.InkCanvas" /> ab oder legt diesen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Top"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.InkCanvas.TopProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
<a name="xamlAttributeUsage_Top"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object InkCanvas.Top="double"/>  
- or -  
<object InkCanvas.Top="qualifiedDouble"/>  
```  
  
<a name="xamlValues_Top"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 Zeichen folgen Darstellung eines <xref:System.Double> Werts. Dies wird als [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung interpretiert. Zeichen folgen müssen nicht explizit Dezimalstellen enthalten. Beispielsweise ist der Wert `1` akzeptabel.  
  
 *qualifiedDouble*  
 Ein *doppelter* Wert, wie oben beschrieben, gefolgt von einer der folgenden Einheiten Deklarations Zeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px` (Standard) ist [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll. 1In = = 96px  
  
 `cm` ist Zentimeter. 1cm = = (96/2,54) px  
  
 `pt` ist Punkte. 1pt = = (96/72) px  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Position einer <xref:System.Windows.Controls.Label> auf einem <xref:System.Windows.Controls.InkCanvas>festgelegt wird.  
  
 [!code-xml[InkCanvasSamples#35](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Controls.InkCanvas.Top" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseCustomCursor">
      <MemberSignature Language="C#" Value="public bool UseCustomCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseCustomCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.UseCustomCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property UseCustomCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseCustomCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseCustomCursor : bool with get, set" Usage="System.Windows.Controls.InkCanvas.UseCustomCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob die Standardfunktionalität des <see cref="T:System.Windows.Controls.InkCanvas" />-Cursors überschrieben werden soll, um einen benutzerdefinierten Cursor zu unterstützen, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Windows.Controls.InkCanvas" /> einen benutzerdefinierten Cursor verwendet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Controls.InkCanvas> ändert den Cursor Stil, um die aktuelle <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> widerzuspiegeln, während sich der Cursor innerhalb der Grenzen des <xref:System.Windows.Controls.InkCanvas>befindet. Wenn dieses Verhalten nicht erwünscht ist, z. b. wenn der <xref:System.Windows.Controls.InkCanvas> einen benutzerdefinierten Cursor verwendet, legen Sie diese Eigenschaft auf `true`fest, und der Cursor ändert sich nicht mit dem <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Cursor verwendet wird, der sich von dem <xref:System.Windows.Controls.InkCanvas>unterscheidet.  
  
 [!code-csharp[InkCanvasSamples#5](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#5)]
 [!code-vb[InkCanvasSamples#5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.Controls.InkCanvas.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der sichtbaren untergeordneten Elemente innerhalb dieses Elements ab.</summary>
        <value>Die Anzahl der sichtbaren untergeordneten Elemente für dieses Element.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      </Docs>
    </Member>
  </Members>
</Type>
