<Type Name="WebBrowser" FullName="System.Windows.Controls.WebBrowser">
  <Metadata><Meta Name="ms.openlocfilehash" Value="40bd0383dbe89e016cf42781ab8571e329fd6c31" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75174844" /></Metadata><TypeSignature Language="C#" Value="public sealed class WebBrowser : System.Windows.Interop.ActiveXHost" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed WebBrowser extends System.Windows.Interop.ActiveXHost" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.WebBrowser" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WebBrowser&#xA;Inherits ActiveXHost" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebBrowser sealed : System::Windows::Interop::ActiveXHost" />
  <TypeSignature Language="F#" Value="type WebBrowser = class&#xA;    inherit ActiveXHost" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Interop.ActiveXHost</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Docs>
    <summary>Hostet HTML-Dokumente und navigiert zwischen ihnen. Ermöglicht die Interoperabilität zwischen verwaltetem Code und HTML-Skript.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Controls.WebBrowser>-Steuerelement bietet die folgenden Funktionen:  
  
 **Navigation**: <xref:System.Windows.Controls.WebBrowser.Source%2A>, <xref:System.Windows.Controls.WebBrowser.Navigate%2A>, <xref:System.Windows.Controls.WebBrowser.NavigateToStream%2A>, <xref:System.Windows.Controls.WebBrowser.NavigateToString%2A>und <xref:System.Windows.Controls.WebBrowser.Refresh%2A>.  
  
 **Navigations Lebensdauer**: <xref:System.Windows.Controls.WebBrowser.Navigating>, <xref:System.Windows.Controls.WebBrowser.Navigated>und <xref:System.Windows.Controls.WebBrowser.LoadCompleted>.  
  
 **Navigations Journal**: <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A>, <xref:System.Windows.Controls.WebBrowser.GoBack%2A>, <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A>und <xref:System.Windows.Controls.WebBrowser.GoForward%2A>.  
  
 **WPF/HTML-Interoperabilität**: <xref:System.Windows.Controls.WebBrowser.InvokeScript%2A> und <xref:System.Windows.Controls.WebBrowser.ObjectForScripting%2A>und <xref:System.Windows.Controls.WebBrowser.Document%2A>.  
  
 <xref:System.Windows.Controls.WebBrowser> wird durch die Sicherheitseinschränkungen der [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Anwendung gebunden, die die <xref:System.Windows.Controls.WebBrowser>gehostet:  
  
-   Wenn <xref:System.Windows.Controls.WebBrowser> von einer vollständig vertrauenswürdigen [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Anwendung (z. b. einer eigenständigen Anwendung) gehostet wird, können <xref:System.Windows.Controls.WebBrowser> [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokumente von einem beliebigen Speicherort aus hosten.  
  
-   Wenn <xref:System.Windows.Controls.WebBrowser> durch eine teilweise vertrauenswürdige [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Anwendung (z. b. eine [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]) gehostet wird, können <xref:System.Windows.Controls.WebBrowser> nur Dokumente hosten, bei denen **es sich um** Anwendungs Datendateien handelt. Weitere Informationen finden Sie unter [WPF-Anwendungsressource, Inhalts- und Datendateien](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md).  
  
> [!CAUTION]
>  Das <xref:System.Windows.Controls.WebBrowser>-Steuerelement instanziiert intern das Native WebBrowser-ActiveX-Steuerelement. WPF ermöglicht Sicherheitsfeatures durch Anwenden von featuresteuerelementen auf das WebBrowser-ActiveX-Steuerelement. Die Funktions Steuerelemente, die angewendet werden, unterscheiden sich für XBAPs und eigenständige Anwendungen. Einige Anwendungen sollten zusätzliche Funktions Steuerelemente anwenden, um zu verhindern, dass böswillige Inhalte ausgeführt werden. Weitere Informationen finden Sie im Abschnitt "WebBrowser-Steuerelement und Funktions Steuerelemente" in der [Sicherheits Ansicht (WPF)](~/docs/framework/wpf/security-wpf.md) und [WebBrowser-Steuerelement Übersichten und Tutorials](https://go.microsoft.com/fwlink/?LinkId=179388).  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Controls.WebBrowser> mithilfe von Markup zum Navigieren zu einem [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokument konfiguriert wird.  
  
```xaml  
<!-- Web Browser Control that hosts a web page. -->  
<WebBrowser x:Name="webBrowser" Source="http://msdn.com"   
  Width="600" Height="600"  />  
```  
  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Controls.WebBrowser> mithilfe von Markup und Code Behind zum Navigieren zu einem Dokument konfiguriert wird.  
  
```xaml  
<StackPanel>  
    <StackPanel Orientation="Horizontal">  
        <TextBox x:Name="addressTextBox" Width="200" />  
        <Button Click="goNavigateButton_Click">Go</Button>  
    </StackPanel>  
    <WebBrowser x:Name="myWebBrowser" />  
</StackPanel>  
```  
  
```csharp  
private void goNavigateButton_Click(object sender, RoutedEventArgs e)  
{  
    // Get URI to navigate to  
    Uri uri = new Uri(this.addressTextBox.Text, UriKind.RelativeOrAbsolute);  
  
    // Only absolute URIs can be navigated to  
    if (!uri.IsAbsoluteUri)  
    {  
        MessageBox.Show("The Address URI must be absolute. For example, 'http://www.microsoft.com'");  
        return;  
    }  
  
    // Navigate to the desired URL by calling the .Navigate method  
    this.myWebBrowser.Navigate(uri);  
}  
```  
  
 Im folgenden Beispiel wird gezeigt, wie das `NewWindow2`-Ereignis und ähnliche Ereignisse mithilfe eines <xref:System.Windows.Controls.WebBrowser> Steuer Elements behandelt werden. Dieses Beispiel erfordert einen Verweis auf " **shdocvw. dll**", eine `using System.Runtime.InteropServices;`-Anweisung und ein <xref:System.Windows.Controls.WebBrowser>-Steuerelement mit dem Namen `webBrowser1`.  
  
```csharp  
public MainWindow()  
{  
    InitializeComponent();  
  
    var serviceProvider = (IServiceProvider)webBrowser1.Document;  
    if (serviceProvider != null)  
    {  
        Guid serviceGuid = new Guid("0002DF05-0000-0000-C000-000000000046");  
        Guid iid = typeof(SHDocVw.WebBrowser).GUID;  
        var webBrowserPtr = (SHDocVw.WebBrowser)serviceProvider  
            .QueryService(ref serviceGuid, ref iid);  
        if (webBrowserPtr != null)  
        {  
            webBrowserPtr.NewWindow2 += webBrowser1_NewWindow2;  
        }  
    }  
}  
  
private void webBrowser1_NewWindow2(ref object ppDisp, ref bool Cancel)  
{  
    // Handle the event.  
}  
  
[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]  
[Guid("6d5140c1-7436-11ce-8034-00aa006009fa")]  
internal interface IServiceProvider  
{  
    [return: MarshalAs(UnmanagedType.IUnknown)]  
    object QueryService(ref Guid guidService, ref Guid riid);  
}  
```  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160056">Beispiel für das XBAP-Hosting von Silverlight</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebBrowser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebBrowser();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.WebBrowser" />-Klasse.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.WebBrowserPermission">, um diese Methode aufzurufen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.WebBrowserPermissionLevel.Safe" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoBack : bool" Usage="System.Windows.Controls.WebBrowser.CanGoBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Dokument vorhanden ist, zu dem zurück navigiert werden kann.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob ein Dokument vorhanden ist, zu dem zurücknavigiert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie zurück zum vorherigen Dokument navigieren, indem Sie <xref:System.Windows.Controls.WebBrowser.GoBack%2A>aufrufen. Im Beispiel wird zuerst überprüft, ob Dokumente vorhanden sind, zu denen Sie navigieren können, indem Sie <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A>überprüfen.  
  
```csharp  
private void backButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the previous HTML document, if there is one  
  if (this.webBrowser.CanGoBack)  
  {  
    this.webBrowser.GoBack();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoBack" />
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoForward : bool" Usage="System.Windows.Controls.WebBrowser.CanGoForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Dokument vorhanden ist, zu dem vorwärts navigiert werden kann.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob ein Dokument vorhanden ist, zu dem vorwärts navigiert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie vorwärts zum nächsten [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokument navigiert wird, indem <xref:System.Windows.Controls.WebBrowser.GoForward%2A>aufgerufen wird. Im Beispiel wird zuerst überprüft, ob Dokumente vorhanden sind, zu denen navigiert werden soll, indem <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A>überprüft wird.  
  
```csharp  
private void forwardButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the next HTML document, if there is one  
  if (this.webBrowser.CanGoForward)  
  {  
    this.webBrowser.GoForward();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoForward" />
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoBack" />
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public object Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Document { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : obj" Usage="System.Windows.Controls.WebBrowser.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Document-Objekt ab, das die gehostete [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)]-Seite darstellt.</summary>
        <value>Ein Document-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Document-Objekt muss in die erwartete com-Schnittstelle umgewandelt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">, um diese Eigenschaft aufzurufen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberSignature Language="F#" Value="member this.GoBack : unit -&gt; unit" Usage="webBrowser.GoBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Navigiert zurück zum vorherigen Dokument (sofern vorhanden).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie <xref:System.Windows.Controls.WebBrowser.GoBack%2A> aufzurufen und keine Dokumente vorhanden sind, zu denen Sie zurück navigieren können, führt <xref:System.Windows.Controls.WebBrowser> keine Navigation aus, und es wird eine Ausnahme ausgelöst. Wenn erforderlich, können Sie den Wert der <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A>-Eigenschaft überprüfen, um zu bestimmen, ob Dokumente vorhanden sind, zu denen Sie zurück navigieren können.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie durch Aufrufen von <xref:System.Windows.Controls.WebBrowser.GoBack%2A>zurück zum vorherigen [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokument navigieren können. Im Beispiel wird zuerst überprüft, ob [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokumente zurück navigiert werden können, indem <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A>überprüft wird.  
  
```csharp  
private void backButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the previous HTML document, if there is one  
  if (this.webBrowser.CanGoBack)  
  {  
    this.webBrowser.GoBack();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Es ist kein Dokument vorhanden, zu dem zurücknavigiert werden kann.</exception>
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoBack" />
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberSignature Language="F#" Value="member this.GoForward : unit -&gt; unit" Usage="webBrowser.GoForward " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Navigiert vorwärts zum nächsten [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)]-Dokument (sofern vorhanden).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie <xref:System.Windows.Controls.WebBrowser.GoForward%2A> aufzurufen und keine Dokumente vorhanden sind, zu denen navigiert werden kann, führt <xref:System.Windows.Controls.WebBrowser> keine Navigation aus, und es wird eine Ausnahme ausgelöst. Wenn erforderlich, können Sie den Wert der <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A>-Eigenschaft überprüfen, um zu bestimmen, ob Dokumente vorhanden sind, zu denen navigiert werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie vorwärts zum nächsten Dokument navigiert wird, indem <xref:System.Windows.Controls.WebBrowser.GoForward%2A>aufgerufen wird. Im Beispiel wird zuerst überprüft, ob Dokumente vorhanden sind, zu denen navigiert werden soll, indem <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A>überprüft wird.  
  
```csharp  
private void forwardButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the next HTML document, if there is one  
  if (this.webBrowser.CanGoForward)  
  {  
    this.webBrowser.GoForward();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Es ist kein Dokument vorhanden, zu dem vorwärts navigiert werden kann.</exception>
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoForward" />
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoBack" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeScript">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine Skriptfunktion aus, die im derzeit geladenen Dokument definiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.InvokeScript(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string -&gt; obj" Usage="webBrowser.InvokeScript scriptName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scriptName">Der Name der auszuführenden Skriptfunktion.</param>
        <summary>Führt eine Skriptfunktion aus, die vom derzeit geladenen Dokument implementiert wird.</summary>
        <returns>Das Objekt, das durch den Active Scripting-Aufruf zurückgegeben wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%29> sollte nicht aufgerufen werden, bevor das Dokument, das es implementiert, das Laden abgeschlossen hat. Sie können erkennen, wenn ein Dokument den Ladevorgang abgeschlossen hat, indem Sie das <xref:System.Windows.Controls.WebBrowser.LoadCompleted>-Ereignis behandeln.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine Skriptfunktion in einem Dokument aus einer [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Anwendung mithilfe <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%29>aufgerufen wird. In diesem Beispiel weist die Skriptfunktion keine Parameter auf.  
  
 Im folgenden finden Sie das [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokument, das die Skriptfunktion implementiert, die von [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]aufgerufen wird.  
  
```html  
<html>  
    <head>  
        <script type="text/javascript">  
            // Function Without Parameters  
            function JavaScriptFunctionWithoutParameters()    
            {  
              outputID.innerHTML = "JavaScript function called!";  
            }  
        </script>  
    </head>  
    <body>  
    <div id="outputID" style="color:Red; font-size:16">  
        Hello from HTML document with script!  
    </div>  
    </body>  
</html>  
```  
  
 Im folgenden finden Sie die [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]-Implementierung zum Abrufen der Skriptfunktion im [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokument.  
  
```csharp  
private void callScriptFunctionNoParamButton_Click(object sender, RoutedEventArgs e)  
{  
  // Make sure the HTML document has loaded before attempting to  
  // invoke script of the document page. You could set loadCompleted  
  // to true when the LoadCompleted event on the WebBrowser fires.  
  if (this.loadCompleted)  
  {  
    try  
    {  
      this.webBrowser.InvokeScript("JavaScriptFunctionWithoutParameters");  
    }  
    catch (Exception ex)  
    {  
      string msg = "Could not call script: " +  
                   ex.Message +  
                  "\n\nPlease click the 'Load HTML Document with Script' button to load.";  
      MessageBox.Show(msg);  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Die Skriptfunktion ist nicht vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.InvokeScript(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string * obj[] -&gt; obj" Usage="webBrowser.InvokeScript (scriptName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="scriptName">Der Name der auszuführenden Skriptfunktion.</param>
        <param name="args">Die an die Skriptfunktion zu übergebenden Parameter.</param>
        <summary>Führt eine Skriptfunktion aus, die im derzeit geladenen Dokument definiert ist.</summary>
        <returns>Das Objekt, das durch den Active Scripting-Aufruf zurückgegeben wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%2CSystem.Object%5B%5D%29> sollte nicht aufgerufen werden, bevor das Dokument, das es implementiert, das Laden abgeschlossen hat. Sie können erkennen, wenn ein Dokument den Ladevorgang abgeschlossen hat, indem Sie das <xref:System.Windows.Controls.WebBrowser.LoadCompleted>-Ereignis behandeln.  
  
 Wenn Sie nicht genügend Parameterwerte an das Skript übergeben, das Sie aufrufen, haben die Parameter, an die Sie keine Werte übergeben, den undefinierten Wert. Wenn Sie zu viele Parameterwerte übergeben, werden die überzähligen Werte ignoriert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Skriptfunktionen in einem-Dokument aus einer-Anwendung mithilfe von <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%2CSystem.Object%5B%5D%29>aufgerufen werden. In diesem Beispiel erfordern die Skriptfunktionen Parameter.  
  
 Im folgenden finden Sie das Dokument, in dem die Skriptfunktionen implementiert werden, die von [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]aufgerufen werden.  
  
```html  
<html>  
    <head>  
        <script type="text/javascript">  
            // Function Without Parameters  
            function JavaScriptFunctionWithoutParameters()    
            {  
              outputID.innerHTML = "JavaScript function 'called: " + message + ".";  
            }  
        </script>  
    </head>  
    <body>  
    <div id="outputID" style="color:Red; font-size:16">  
        Hello from HTML document with script!  
    </div>  
    </body>  
</html>  
```  
  
 Im folgenden finden Sie die [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]-Implementierung zum aufzurufen der Skriptfunktionen im [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokument.  
  
```csharp  
private void callScriptFunctionNoParamButton_Click(object sender, RoutedEventArgs e)  
{  
  // Make sure the HTML document has loaded before attempting to  
  // invoke script of the document page. You could set loadCompleted  
  // to true when the LoadCompleted event on the WebBrowser fires.  
  if (this.loadCompleted)  
  {  
    try  
    {  
      this.webBrowser.InvokeScript("JavaScriptFunctionWithoutParameters", this.messageTextBox.Text);  
    }  
    catch (Exception ex)  
    {  
      string msg = "Could not call script: " +  
                   ex.Message +  
                  "\n\nPlease click the 'Load HTML Document with Script' button to load.";  
      MessageBox.Show(msg);  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Die Skriptfunktion ist nicht vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.WebBrowser.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Download des Dokuments abgeschlossen wurde, zu dem navigiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Navigations Ereignis Handlern wird eine Instanz der <xref:System.Windows.Navigation.NavigationEventArgs>-Klasse übermittelt, die Kontextinformationen über die Navigation bereitstellt, einschließlich Webantwort Details.  
  
 Dieses Ereignis wird nur für die Navigation auf oberster Ebene ausgelöst.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigating" />
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigated" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Navigiert asynchron zu dem Dokument am angegebenen <see cref="T:System.Uri" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(System::String ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : string -&gt; unit" Usage="webBrowser.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="source">Die URL, zu der navigiert werden soll.</param>
        <summary>Navigiert asynchron zu dem Dokument an der angegebenen URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%29>-Methode, um zu einer URL zu navigieren, die möglicherweise Escapezeichen enthält. Verwenden Sie die <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29>-Methode, um zu einer <xref:System.Uri> zu navigieren, die keine Escapezeichen enthält.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(Uri ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; unit" Usage="webBrowser.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">Der <see cref="T:System.Uri" />, zu dem navigiert werden soll.</param>
        <summary>Navigiert asynchron zu dem Dokument am angegebenen <see cref="T:System.Uri" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen von <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29> hat dieselbe Auswirkung wie das Festlegen der <xref:System.Windows.Controls.WebBrowser.Source%2A>-Eigenschaft. <xref:System.Windows.Controls.WebBrowser.Source%2A> wird von Entwicklern verwendet, die deklarativ das ursprüngliche Dokument angeben möchten, zu dem <xref:System.Windows.Controls.WebBrowser> navigiert, wenn <xref:System.Windows.Controls.WebBrowser> initialisiert wird.  
  
 Verwenden Sie die <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%29>-Methode, um zu einer URL zu navigieren, die möglicherweise Escapezeichen enthält. Verwenden Sie die <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29>-Methode, um zu einer <xref:System.Uri> zu navigieren, die keine Escapezeichen enthält.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Controls.WebBrowser> verwendet wird, um mithilfe der <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29>-Methode zu einem Dokument zu navigieren.  
  
```xaml  
<StackPanel>  
    <StackPanel Orientation="Horizontal">  
        <TextBox x:Name="addressTextBox" Width="200" />  
        <Button Click="goNavigateButton_Click">Go</Button>  
    </StackPanel>  
    <WebBrowser x:Name="myWebBrowser" />  
</StackPanel>  
```  
  
```csharp  
private void goNavigateButton_Click(object sender, RoutedEventArgs e)  
{  
    // Get URI to navigate to  
    Uri uri = new Uri(this.addressTextBox.Text, UriKind.RelativeOrAbsolute);  
  
    // Only absolute URIs can be navigated to  
    if (!uri.IsAbsoluteUri)  
    {  
        MessageBox.Show("The Address URI must be absolute. For example, 'http://www.microsoft.com'");  
        return;  
    }  
  
    // Navigate to the desired URL by calling the .Navigate method  
    this.myWebBrowser.Navigate(uri);  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.Security.SecurityException">Navigation aus einer Anwendung, die mit teilweiser Vertrauenswürdigkeit ausgeführt wird, zu einem <see cref="T:System.Uri" />, der sich nicht auf der Ursprungssite befindet.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (string source, string targetFrameName, byte[] postData, string additionalHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(string source, string targetFrameName, unsigned int8[] postData, string additionalHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.String,System.String,System.Byte[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As String, targetFrameName As String, postData As Byte(), additionalHeaders As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(System::String ^ source, System::String ^ targetFrameName, cli::array &lt;System::Byte&gt; ^ postData, System::String ^ additionalHeaders);" />
      <MemberSignature Language="F#" Value="member this.Navigate : string * string * byte[] * string -&gt; unit" Usage="webBrowser.Navigate (source, targetFrameName, postData, additionalHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="targetFrameName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="postData" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="additionalHeaders" Type="System.String" Index="3" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="source">Die URL, zu der navigiert werden soll.</param>
        <param name="targetFrameName">Der Name des Frames, in dem der Inhalt des Dokuments angezeigt werden soll.</param>
        <param name="postData">HTTP-POST-Daten, die beim Anfordern der Quelle an den Server gesendet werden sollen.</param>
        <param name="additionalHeaders">HTTP-Header, die beim Anfordern der Quelle an den Server gesendet werden sollen.</param>
        <summary>Navigiert asynchron zu dem Dokument an der angegebenen URL und gibt den Zielframe an, in den der Inhalt des Dokuments geladen werden soll. Weitere HTTP POST-Daten und HTTP-Header können im Rahmen der Navigationsanforderung an den Server gesendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29>-Methode, um zu einer URL zu navigieren, die möglicherweise Escapezeichen enthält. Verwenden Sie die <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29>-Methode, um zu einer <xref:System.Uri> zu navigieren, die keine Escapezeichen enthält.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (Uri source, string targetFrameName, byte[] postData, string additionalHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(class System.Uri source, string targetFrameName, unsigned int8[] postData, string additionalHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.Uri,System.String,System.Byte[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As Uri, targetFrameName As String, postData As Byte(), additionalHeaders As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(Uri ^ source, System::String ^ targetFrameName, cli::array &lt;System::Byte&gt; ^ postData, System::String ^ additionalHeaders);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * string * byte[] * string -&gt; unit" Usage="webBrowser.Navigate (source, targetFrameName, postData, additionalHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="targetFrameName" Type="System.String" />
        <Parameter Name="postData" Type="System.Byte[]" />
        <Parameter Name="additionalHeaders" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der <see cref="T:System.Uri" />, zu dem navigiert werden soll.</param>
        <param name="targetFrameName">Der Name des Frames, in dem der Inhalt des Dokuments angezeigt werden soll.</param>
        <param name="postData">HTTP-POST-Daten, die beim Anfordern der Quelle an den Server gesendet werden sollen.</param>
        <param name="additionalHeaders">HTTP-Header, die beim Anfordern der Quelle an den Server gesendet werden sollen.</param>
        <summary>Navigiert asynchron zu dem Dokument am angegebenen <see cref="T:System.Uri" /> und gibt den Zielframe an, in den der Inhalt des Dokuments geladen werden soll. Weitere HTTP POST-Daten und HTTP-Header können im Rahmen der Navigationsanforderung an den Server gesendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29>-Methode, um zu einer URL zu navigieren, die möglicherweise Escapezeichen enthält. Verwenden Sie die <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29>-Methode, um zu einer <xref:System.Uri> zu navigieren, die keine Escapezeichen enthält.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie zu einem Dokument navigieren und es in einem neuen Browserfenster öffnen, indem Sie das Ziel "about: blank" angeben.  
  
```xaml  
<StackPanel>  
    <StackPanel Orientation="Horizontal">  
        <TextBox x:Name="addressTextBox" Width="200" />  
        <Button Click="goNavigateButton_Click">Go</Button>  
    </StackPanel>  
    <WebBrowser x:Name="myWebBrowser" />  
</StackPanel>  
```  
  
```csharp  
private void goNavigateButton_Click(object sender, RoutedEventArgs e)  
{  
    // Get URI to navigate to  
    Uri uri = new Uri(this.addressTextBox.Text, UriKind.RelativeOrAbsolute);  
  
    // Only absolute URIs can be navigated to  
    if (!uri.IsAbsoluteUri)  
    {  
        MessageBox.Show("The Address URI must be absolute. For example, 'http://www.microsoft.com'");  
        return;  
    }  
  
    // Navigate to the desired URL by calling the .Navigate method  
    this.myWebBrowser.Navigate(uri, "_blank", null, null);  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.Security.SecurityException">Navigation aus einer Anwendung, die mit teilweiser Vertrauenswürdigkeit ausgeführt wird: 
–   Zu einem <see cref="T:System.Uri" />, der sich nicht auf der Ursprungssite befindet oder 
-   <paramref name="targetFrameName" />-Name ist nicht <see langword="null" /> oder leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.WebBrowser.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Dokument, zu dem navigiert wird, gefunden und der Download gestartet wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Navigations Ereignis Handlern wird eine Instanz der <xref:System.Windows.Navigation.NavigationEventArgs>-Klasse übermittelt, die Kontextinformationen über die Navigation bereitstellt, einschließlich Webantwort Details.  
  
 Dieses Ereignis wird nur für die Navigation auf oberster Ebene ausgelöst.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigating" />
        <altmember cref="E:System.Windows.Controls.WebBrowser.LoadCompleted" />
      </Docs>
    </Member>
    <Member MemberName="NavigateToStream">
      <MemberSignature Language="C#" Value="public void NavigateToStream (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NavigateToStream(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.NavigateToStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NavigateToStream(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.NavigateToStream : System.IO.Stream -&gt; unit" Usage="webBrowser.NavigateToStream stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Ein <see cref="T:System.IO.Stream" />, der den Inhalt für ein Dokument enthält.</param>
        <summary>Navigiert asynchron zu einem <see cref="T:System.IO.Stream" />, der den Inhalt für ein Dokument enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der `stream`-Parameter `null`ist, wechselt <xref:System.Windows.Controls.WebBrowser> zu einem leeren Dokument ("about: blank").  
  
 Wenn der Stream-Parameter nicht in einem gültigen [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Format vorliegt, wird er als nur-Text angezeigt.  
  
 Nach der Navigation werden <xref:System.Windows.Controls.WebBrowser.Source%2A> `null`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie zu einem Stream navigieren können, der ein Dokument enthält.  
  
```csharp  
private void goNavigateToStreamButton_Click(object sender, RoutedEventArgs e)  
{  
  // Load HTML document as a stream  
  Uri uri = new Uri(@"pack://application:,,,/HTMLDocumentWithScript.html", UriKind.Absolute);  
  Stream source = Application.GetResourceStream(uri).Stream;  
  
  // Navigate to HTML document stream  
  this.webBrowser.NavigateToStream(source);  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <altmember cref="M:System.Windows.Controls.WebBrowser.NavigateToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="NavigateToString">
      <MemberSignature Language="C#" Value="public void NavigateToString (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NavigateToString(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.NavigateToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub NavigateToString (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NavigateToString(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.NavigateToString : string -&gt; unit" Usage="webBrowser.NavigateToString text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Ein <see cref="T:System.String" />, der den Inhalt für ein Dokument enthält.</param>
        <summary>Navigiert asynchron zu einem <see cref="T:System.String" />, der den Inhalt für ein Dokument enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der `text`-Parameter `null`ist, wechselt <xref:System.Windows.Controls.WebBrowser> zu einem leeren Dokument ("about: blank").  
  
 Wenn der Text Parameter nicht in einem gültigen [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Format vorliegt, wird er als nur-Text angezeigt.  
  
 Nach der Navigation werden <xref:System.Windows.Controls.WebBrowser.Source%2A> `null`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie zu einer Zeichenfolge navigieren können, die ein Dokument enthält.  
  
```csharp  
private void goNavigateToStringButton_Click(object sender, RoutedEventArgs e)  
{  
  // Load HTML document as a string  
  Uri uri = new Uri(@"pack://application:,,,/HTMLDocumentWithoutScript.html", UriKind.Absolute);  
  Stream stream = Application.GetResourceStream(uri).Stream;  
  using (StreamReader reader = new StreamReader(stream))  
  {  
    // Navigate to HTML document string  
    this.webBrowser.NavigateToString(reader.ReadToEnd());  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <altmember cref="M:System.Windows.Controls.WebBrowser.NavigateToStream(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.WebBrowser.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt direkt vor der Navigation zu einem Dokument auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Navigation von Ereignis Handlern wird an eine Instanz der <xref:System.Windows.Navigation.NavigatingCancelEventArgs>-Klasse übermittelt. Sie können die Navigation abbrechen, indem Sie die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A>-Eigenschaft des <xref:System.Windows.Navigation.NavigatingCancelEventArgs>-Objekts auf `true`festlegen.  
  
 Dieses Ereignis wird nur für die Navigation auf oberster Ebene ausgelöst.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigated" />
        <altmember cref="E:System.Windows.Controls.WebBrowser.LoadCompleted" />
      </Docs>
    </Member>
    <Member MemberName="ObjectForScripting">
      <MemberSignature Language="C#" Value="public object ObjectForScripting { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ObjectForScripting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.ObjectForScripting" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectForScripting As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ObjectForScripting { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ObjectForScripting : obj with get, set" Usage="System.Windows.Controls.WebBrowser.ObjectForScripting" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Instanz einer von der Hostanwendung implementierten öffentlichen Klasse ab, auf die vom Skript aus einem gehosteten Dokument zugegriffen werden kann, oder legt diese Instanz fest.</summary>
        <value>Das <see cref="T:System.Object" />, das eine Instanz einer <see langword="public" />-Klasse darstellt, die von der Hostanwendung implementiert wird, auf die ein Skript aus einem gehosteten Dokument zugreifen kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann auf ein beliebiges com-sichtbares Objekt festgelegt werden, für das Sie öffentliche Eigenschaften und Methoden für Skriptcode verfügbar machen möchten. Sie können eine Klasse com-sichtbar machen, indem Sie Sie mit dem <xref:System.Runtime.InteropServices.ComVisibleAttribute>markieren.  
  
 Das-Objekt, das für die Skripterstellung festgelegt wird, wird vom [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dom mit der `window.external`-Eigenschaft für das aktuelle Dokument verfügbar gemacht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Windows.Controls.WebBrowser.ObjectForScripting" /> wird mit einer Instanz mit einem anderen Typ als <see langword="COMVisible" /> festgelegt.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt die aktuelle Seite erneut.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="webBrowser.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lädt die aktuelle Seite erneut.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (bool noCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(bool noCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Refresh(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (noCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(bool noCache);" />
      <MemberSignature Language="F#" Value="member this.Refresh : bool -&gt; unit" Usage="webBrowser.Refresh noCache" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="noCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="noCache">Gibt an, ob die Aktualisierung ohne Cachevalidierung ausgeführt werden soll.</param>
        <summary>Lädt die aktuelle Seite erneut mit optionaler Cachevalidierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `noCache` `true`ist, wird das <xref:System.Windows.Controls.WebBrowser>-Steuerelement ohne Cache Validierung aktualisiert, indem ein "Pragma: No-Cache"-Header an den Server gesendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.Controls.WebBrowser.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Uri" /> des aktuellen Dokuments ab, das im <see cref="T:System.Windows.Controls.WebBrowser" /> gehostet wird, oder legt diesen fest.</summary>
        <value>Der <see cref="T:System.Uri" /> für das aktuelle [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokument.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Festlegen der Source-Eigenschaft bewirkt, dass <xref:System.Windows.Controls.WebBrowser> zu dem vom <xref:System.Uri>angegebenen Dokument navigiert. Wenn die <xref:System.Uri> `null`ist, wird ein leeres Dokument angezeigt ("about: blank").  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Controls.WebBrowser> mithilfe von Markup zum Navigieren zu einem [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokument konfiguriert wird.  
  
```xaml  
<!-- Web Browser Control that hosts a web page. -->  
<WebBrowser x:Name="webBrowser" Source="http://msdn.com"   
  Width="600" Height="600"  />  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.Security.SecurityException">Navigation aus einer Anwendung, die mit teilweiser Vertrauenswürdigkeit ausgeführt wird, zu einem <see cref="T:System.Uri" />, der sich nicht auf der Ursprungssite befindet.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TabInto">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TabInto (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TabInto(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.System#Windows#Interop#IKeyboardInputSink#TabInto(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Function TabInto (request As TraversalRequest) As Boolean Implements IKeyboardInputSink.TabInto" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.TabInto(System::Windows::Input::TraversalRequest ^ request) = System::Windows::Interop::IKeyboardInputSink::TabInto;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Interop.IKeyboardInputSink.TabInto(System.Windows.Input.TraversalRequest)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5" />
      </Parameters>
      <Docs>
        <param name="request">Gibt an, ob der Fokus auf den ersten oder letzten Tabstopp festgelegt werden soll.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.Windows.Interop.IKeyboardInputSink.TabInto(System.Windows.Input.TraversalRequest)" />.</summary>
        <returns><see langword="true" />, wenn der Fokus wie angefordert festgelegt wurde, <see langword="false" />,wenn keine Tabstopps vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Controls.WebBrowser>-Instanz in eine <xref:System.Windows.Interop.IKeyboardInputSink>-Schnittstelle umgewandelt wird.

]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md">Übersicht über die Interaktion zwischen WPF und Win32</related>
        <related type="Article" href="~/docs/framework/wpf/advanced/input-overview.md">Übersicht über die Eingabe</related>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TranslateAccelerator (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.System#Windows#Interop#IKeyboardInputSink#TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Function TranslateAccelerator (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean Implements IKeyboardInputSink.TranslateAccelerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers) = System::Windows::Interop::IKeyboardInputSink::TranslateAccelerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG" RefType="ref" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" Index="1" FrameworkAlternate="netframework-3.0;netframework-3.5" />
      </Parameters>
      <Docs>
        <param name="msg">Die Meldung und die zugeordneten Daten. Ändern Sie diese Struktur nicht. Es wird als Verweis und nur aus Leistungsgründen übergeben.</param>
        <param name="modifiers">Modifizierertasten.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />.</summary>
        <returns><see langword="true" />, wenn die Meldung durch die Implementierung der Methode behandelt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Controls.WebBrowser>-Instanz in eine <xref:System.Windows.Interop.IKeyboardInputSink>-Schnittstelle umgewandelt wird.

]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md">Übersicht über die Interaktion zwischen WPF und Win32</related>
        <related type="Article" href="~/docs/framework/wpf/advanced/input-overview.md">Übersicht über die Eingabe</related>
      </Docs>
    </Member>
    <Member MemberName="TabIntoCore">
      <MemberSignature Language="C#" Value="protected override bool TabIntoCore (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool TabIntoCore(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.TabIntoCore(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function TabIntoCore (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool TabIntoCore(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.TabIntoCore : System.Windows.Input.TraversalRequest -&gt; bool" Usage="webBrowser.TabIntoCore request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="request">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslateAcceleratorCore">
      <MemberSignature Language="C#" Value="protected override bool TranslateAcceleratorCore (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool TranslateAcceleratorCore(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.TranslateAcceleratorCore(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function TranslateAcceleratorCore (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool TranslateAcceleratorCore(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers);" />
      <MemberSignature Language="F#" Value="override this.TranslateAcceleratorCore : MSG * System.Windows.Input.ModifierKeys -&gt; bool" Usage="webBrowser.TranslateAcceleratorCore (msg, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="msg">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
