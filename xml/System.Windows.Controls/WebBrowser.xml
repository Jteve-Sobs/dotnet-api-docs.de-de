<Type Name="WebBrowser" FullName="System.Windows.Controls.WebBrowser">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dc35b5eac17f1efd3da5bedd6d1bf86f5d5e1939" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56361441" /></Metadata><TypeSignature Language="C#" Value="public sealed class WebBrowser : System.Windows.Interop.ActiveXHost" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed WebBrowser extends System.Windows.Interop.ActiveXHost" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.WebBrowser" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WebBrowser&#xA;Inherits ActiveXHost" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebBrowser sealed : System::Windows::Interop::ActiveXHost" />
  <TypeSignature Language="F#" Value="type WebBrowser = class&#xA;    inherit ActiveXHost" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Interop.ActiveXHost</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Docs>
    <summary>Hostet HTML-Dokumente und navigiert zwischen ihnen. Ermöglicht die Interoperabilität zwischen verwaltetem Code und HTML-Skript.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.WebBrowser> Steuerelement bietet die folgenden Funktionen:  
  
 **Navigation**: <xref:System.Windows.Controls.WebBrowser.Source%2A>, <xref:System.Windows.Controls.WebBrowser.Navigate%2A>, <xref:System.Windows.Controls.WebBrowser.NavigateToStream%2A>, <xref:System.Windows.Controls.WebBrowser.NavigateToString%2A>und <xref:System.Windows.Controls.WebBrowser.Refresh%2A>.  
  
 **Navigationslebensdauer**: <xref:System.Windows.Controls.WebBrowser.Navigating>, <xref:System.Windows.Controls.WebBrowser.Navigated>, und <xref:System.Windows.Controls.WebBrowser.LoadCompleted>.  
  
 **Navigation Journaling**: <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A>, <xref:System.Windows.Controls.WebBrowser.GoBack%2A>, <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A>, und <xref:System.Windows.Controls.WebBrowser.GoForward%2A>.  
  
 **WPF/HTML-Interoperabilität**: <xref:System.Windows.Controls.WebBrowser.InvokeScript%2A> und <xref:System.Windows.Controls.WebBrowser.ObjectForScripting%2A>, und <xref:System.Windows.Controls.WebBrowser.Document%2A>.  
  
 <xref:System.Windows.Controls.WebBrowser> durch die sicherheitseinschränkungen gebunden ist die [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Anwendung gehostet wird, die die <xref:System.Windows.Controls.WebBrowser>:  
  
-   Wenn <xref:System.Windows.Controls.WebBrowser> gehostet wird, indem ein voll vertrauenswürdiges [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Anwendung (einer eigenständigen Anwendung, z. B.), <xref:System.Windows.Controls.WebBrowser> hosten [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokumente aus einem beliebigen Speicherort.  
  
-   Wenn <xref:System.Windows.Controls.WebBrowser> gehostet wird, indem Sie eine teilweise vertrauenswürdige [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Anwendung (ein [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)], z. B.), <xref:System.Windows.Controls.WebBrowser> können nur Dokumente hosten **Ursprungssite** Anwendungsdatendateien. Weitere Informationen finden Sie unter [WPF-Anwendungsressource, Inhalts- und Datendateien](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md).  
  
> [!CAUTION]
>  Die <xref:System.Windows.Controls.WebBrowser> Steuerelement intern instanziiert das native WebBrowser ActiveX-Steuerelement. WPF aktiviert Sicherheitsfunktionen, durch Anwenden von Funktionssteuerelemente für das WebBrowser ActiveX-Steuerelement. Die Feature-Steuerelemente, die angewendet werden, die für XBAPs und eigenständigen Anwendungen unterscheiden sich. Einige Anwendungen sollten zusätzliche Funktionssteuerelemente, um zu verhindern, dass böswillige Inhalte ausführen anwenden. Weitere Informationen finden Sie im Abschnitt "WebBrowser-Steuerelement und Funktionssteuerelemente" in [Sicherheit (WPF)](~/docs/framework/wpf/security-wpf.md) und [WebBrowser Control Overviews and Tutorials](https://go.microsoft.com/fwlink/?LinkId=179388).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie konfigurieren <xref:System.Windows.Controls.WebBrowser> , zu dem navigiert ein [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokuments mithilfe des workflowmarkups.  
  
```xaml  
<!-- Web Browser Control that hosts a web page. -->  
<WebBrowser x:Name="webBrowser" Source="http://msdn.com"   
  Width="600" Height="600"  />  
```  
  
 Das folgende Beispiel zeigt, wie Sie konfigurieren <xref:System.Windows.Controls.WebBrowser> navigieren Sie zu einem Dokument mithilfe von Markup und CodeBehind.  
  
```xaml  
<StackPanel>  
    <StackPanel Orientation="Horizontal">  
        <TextBox x:Name="addressTextBox" Width="200" />  
        <Button Click="goNavigateButton_Click">Go</Button>  
    </StackPanel>  
    <WebBrowser x:Name="myWebBrowser" />  
</StackPanel>  
```  
  
```csharp  
private void goNavigateButton_Click(object sender, RoutedEventArgs e)  
{  
    // Get URI to navigate to  
    Uri uri = new Uri(this.addressTextBox.Text, UriKind.RelativeOrAbsolute);  
  
    // Only absolute URIs can be navigated to  
    if (!uri.IsAbsoluteUri)  
    {  
        MessageBox.Show("The Address URI must be absolute eg 'http://www.microsoft.com'");  
        return;  
    }  
  
    // Navigate to the desired URL by calling the .Navigate method  
    this.myWebBrowser.Navigate(uri);  
}  
```  
  
 Das folgende Beispiel zeigt, wie Sie behandelt die `NewWindow2` Ereignis- und ähnliche Ereignisse, die mit einer <xref:System.Windows.Controls.WebBrowser> Steuerelement. In diesem Beispiel erfordert einen Verweis auf **"Shdocvw.dll"**, `using System.Runtime.InteropServices;` -Anweisung und eine <xref:System.Windows.Controls.WebBrowser> Steuerelement mit dem Namen `webBrowser1`.  
  
```csharp  
public MainWindow()  
{  
    InitializeComponent();  
  
    var serviceProvider = (IServiceProvider)webBrowser1.Document;  
    if (serviceProvider != null)  
    {  
        Guid serviceGuid = new Guid("0002DF05-0000-0000-C000-000000000046");  
        Guid iid = typeof(SHDocVw.WebBrowser).GUID;  
        var webBrowserPtr = (SHDocVw.WebBrowser)serviceProvider  
            .QueryService(ref serviceGuid, ref iid);  
        if (webBrowserPtr != null)  
        {  
            webBrowserPtr.NewWindow2 += webBrowser1_NewWindow2;  
        }  
    }  
}  
  
private void webBrowser1_NewWindow2(ref object ppDisp, ref bool Cancel)  
{  
    // Handle the event.  
}  
  
[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]  
[Guid("6d5140c1-7436-11ce-8034-00aa006009fa")]  
internal interface IServiceProvider  
{  
    [return: MarshalAs(UnmanagedType.IUnknown)]  
    object QueryService(ref Guid guidService, ref Guid riid);  
}  
```  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160056">XBAP Hosten von Silverlight-Beispiel</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebBrowser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebBrowser();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.WebBrowser" />-Klasse.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.WebBrowserPermission">Diese Methode aufgerufen wird. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.WebBrowserPermissionLevel.Safe" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoBack : bool" Usage="System.Windows.Controls.WebBrowser.CanGoBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Dokument vorhanden ist, zu dem zurücknavigiert werden kann.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob ein Dokument vorhanden ist, zu dem zurücknavigiert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie durch den Aufruf zurück zum vorherigen Dokument navigieren <xref:System.Windows.Controls.WebBrowser.GoBack%2A>. Im Beispiel wird zunächst überprüft, es Dokumente sind, zu dem zurücknavigiert werden soll, indem Sie überprüfen <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A>.  
  
```csharp  
private void backButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the previous HTML document, if there is one  
  if (this.webBrowser.CanGoBack)  
  {  
    this.webBrowser.GoBack();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoBack" />
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoForward : bool" Usage="System.Windows.Controls.WebBrowser.CanGoForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Dokument vorhanden ist, zu dem vorwärts navigiert werden kann.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob ein Dokument vorhanden ist, zu dem vorwärts navigiert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie weiter zur nächsten navigiert [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokument durch Aufrufen von <xref:System.Windows.Controls.WebBrowser.GoForward%2A>. Im Beispiel wird zuerst überprüft, dass die Dokumente zu dem vorwärts durch Überprüfen navigiert sind <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A>.  
  
```csharp  
private void forwardButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the next HTML document, if there is one  
  if (this.webBrowser.CanGoForward)  
  {  
    this.webBrowser.GoForward();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoForward" />
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoBack" />
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public object Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Document { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : obj" Usage="System.Windows.Controls.WebBrowser.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Document-Objekt ab, das die gehostete [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)]-Seite darstellt.</summary>
        <value>Ein Document-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Document-Objekt muss in der COM-Schnittstelle umgewandelt werden, die Sie erwarten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Diese Eigenschaft aufrufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberSignature Language="F#" Value="member this.GoBack : unit -&gt; unit" Usage="webBrowser.GoBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Navigiert zurück zum vorherigen Dokument (sofern vorhanden).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie aufrufen <xref:System.Windows.Controls.WebBrowser.GoBack%2A> und es sind keine Dokumente zurück zu navigieren <xref:System.Windows.Controls.WebBrowser> führt keine Navigation und eine Ausnahme ausgelöst. Wenn Sie möchten, können Sie den Wert der Untersuchen der <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A> Eigenschaft, um zu bestimmen, ob Dokumente, zu dem zurücknavigiert vorhanden sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie navigieren Sie zurück zur vorherigen [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokument durch Aufrufen von <xref:System.Windows.Controls.WebBrowser.GoBack%2A>. Im Beispiel wird zunächst überprüft, ob es sind [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokumente an, Navigieren zurück zum anhand <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A>.  
  
```csharp  
private void backButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the previous HTML document, if there is one  
  if (this.webBrowser.CanGoBack)  
  {  
    this.webBrowser.GoBack();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Es ist kein Dokument vorhanden, zu dem zurücknavigiert werden kann.</exception>
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoBack" />
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberSignature Language="F#" Value="member this.GoForward : unit -&gt; unit" Usage="webBrowser.GoForward " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Navigiert vorwärts zum nächsten [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)]-Dokument (sofern vorhanden).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie aufrufen <xref:System.Windows.Controls.WebBrowser.GoForward%2A> und es sind keine Dokumente zu dem vorwärts, navigiert <xref:System.Windows.Controls.WebBrowser> führt keine Navigation und eine Ausnahme ausgelöst. Wenn Sie möchten, können Sie den Wert der Untersuchen der <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A> Eigenschaft, um zu bestimmen, ob Dokumente, zu dem vorwärts navigiert sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie durch Aufrufen von vorwärts zum nächsten Dokument navigieren <xref:System.Windows.Controls.WebBrowser.GoForward%2A>. Im Beispiel wird zuerst überprüft, dass die Dokumente zu dem vorwärts durch Überprüfen navigiert sind <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A>.  
  
```csharp  
private void forwardButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the next HTML document, if there is one  
  if (this.webBrowser.CanGoForward)  
  {  
    this.webBrowser.GoForward();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Es ist kein Dokument vorhanden, zu dem vorwärts navigiert werden kann.</exception>
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoForward" />
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoBack" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeScript">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine Skriptfunktion aus, die im derzeit geladenen Dokument definiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.InvokeScript(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string -&gt; obj" Usage="webBrowser.InvokeScript scriptName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scriptName">Der Name der auszuführenden Skriptfunktion.</param>
        <summary>Führt eine Skriptfunktion aus, die vom derzeit geladenen Dokument implementiert wird.</summary>
        <returns>Das Objekt, das durch den Active Scripting-Aufruf zurückgegeben wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%29> sollte nicht aufgerufen werden, bevor das Dokument, das sie implementiert vollständig geladen wurde. Sie können erkennen, wenn ein Dokument durch Behandlung geladen wurde die <xref:System.Windows.Controls.WebBrowser.LoadCompleted> Ereignis.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine Skript für Funktion in einem Dokument aus Aufrufen einer [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Anwendung mit <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%29>. In diesem Beispiel hat die Skriptfunktion keine Parameter.  
  
 Im folgenden finden Sie die [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokument, das die Skriptfunktion, die aufgerufen wird implementiert, von [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].  
  
```html  
<html>  
    <head>  
        <script type="text/javascript">  
            // Function Without Parameters  
            function JavaScriptFunctionWithoutParameters()    
            {  
              outputID.innerHTML = "JavaScript function called!";  
            }  
        </script>  
    </head>  
    <body>  
    <div id="outputID" style="color:Red; font-size:16">  
        Hello from HTML document with script!  
    </div>  
    </body>  
</html>  
```  
  
 Im folgenden dargestellt die [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Implementierung, die die Skriptfunktion aufrufen, der [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokument.  
  
```csharp  
private void callScriptFunctionNoParamButton_Click(object sender, RoutedEventArgs e)  
{  
  // Make sure the HTML document has loaded before attempting to  
  // invoke script of the document page. You could set loadCompleted  
  // to true when the LoadCompleted event on the WebBrowser fires.  
  if (this.loadCompleted)  
  {  
    try  
    {  
      this.webBrowser.InvokeScript("JavaScriptFunctionWithoutParameters");  
    }  
    catch (Exception ex)  
    {  
      string msg = "Could not call script: " +  
                   ex.Message +  
                  "\n\nPlease click the 'Load HTML Document with Script' button to load.";  
      MessageBox.Show(msg);  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Die Skriptfunktion ist nicht vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.InvokeScript(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string * obj[] -&gt; obj" Usage="webBrowser.InvokeScript (scriptName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="scriptName">Der Name der auszuführenden Skriptfunktion.</param>
        <param name="args">Die an die Skriptfunktion zu übergebenden Parameter.</param>
        <summary>Führt eine Skriptfunktion aus, die im derzeit geladenen Dokument definiert ist.</summary>
        <returns>Das Objekt, das durch den Active Scripting-Aufruf zurückgegeben wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%2CSystem.Object%5B%5D%29> sollte nicht aufgerufen werden, bevor das Dokument, das sie implementiert vollständig geladen wurde. Sie können erkennen, wenn ein Dokument durch Behandlung geladen wurde die <xref:System.Windows.Controls.WebBrowser.LoadCompleted> Ereignis.  
  
 Wenn Sie nicht genügend Parameterwerte an das Skript, die Sie aufrufen übergeben, müssen die Parameter, denen Sie keine Werte übergeben den Wert undefined. Wenn Sie zu viele Parameterwerte übergeben, werden die überzähligen Werte ignoriert.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mithilfe von JavaScript-Funktionen in einem Dokument aus einer Anwendung aufrufen <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%2CSystem.Object%5B%5D%29>. In diesem Beispiel sind die Skriptfunktionen Parameter erforderlich.  
  
 Im folgenden finden Sie das Dokument, das die JavaScript-Funktionen, die aufgerufen wird implementiert, von [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].  
  
```html  
<html>  
    <head>  
        <script type="text/javascript">  
            // Function Without Parameters  
            function JavaScriptFunctionWithoutParameters()    
            {  
              outputID.innerHTML = "JavaScript function 'called: " + message + ".";  
            }  
        </script>  
    </head>  
    <body>  
    <div id="outputID" style="color:Red; font-size:16">  
        Hello from HTML document with script!  
    </div>  
    </body>  
</html>  
```  
  
 Im folgenden dargestellt die [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Implementierung zum Aufrufen der Funktionen in der [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokument.  
  
```csharp  
private void callScriptFunctionNoParamButton_Click(object sender, RoutedEventArgs e)  
{  
  // Make sure the HTML document has loaded before attempting to  
  // invoke script of the document page. You could set loadCompleted  
  // to true when the LoadCompleted event on the WebBrowser fires.  
  if (this.loadCompleted)  
  {  
    try  
    {  
      this.webBrowser.InvokeScript("JavaScriptFunctionWithoutParameters", this.messageTextBox.Text);  
    }  
    catch (Exception ex)  
    {  
      string msg = "Could not call script: " +  
                   ex.Message +  
                  "\n\nPlease click the 'Load HTML Document with Script' button to load.";  
      MessageBox.Show(msg);  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Die Skriptfunktion ist nicht vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.WebBrowser.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Download des Dokuments abgeschlossen wurde, zu dem navigiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Navigiert-Ereignishandler übergeben eine Instanz von der <xref:System.Windows.Navigation.NavigationEventArgs> -Klasse, die Kontextinformationen über die Navigation dar, einschließlich Web Antwortdetails enthält.  
  
 Dieses Ereignis wird nur für Navigationen der obersten Ebene ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigating" />
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigated" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Navigiert asynchron zu dem Dokument am angegebenen <see cref="T:System.Uri" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(System::String ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : string -&gt; unit" Usage="webBrowser.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Die URL, zu der navigiert werden soll.</param>
        <summary>Navigiert asynchron zu dem Dokument an der angegebenen URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%29> Methode, um die Navigation zu einer URL, die Escape-Zeichen enthalten können. Verwenden der <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29> Methode zum Navigieren zu einer <xref:System.Uri> , ist die Escape-Zeichen nicht enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(Uri ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; unit" Usage="webBrowser.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">Der <see cref="T:System.Uri" />, zu dem navigiert werden soll.</param>
        <summary>Navigiert asynchron zu dem Dokument am angegebenen <see cref="T:System.Uri" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29> hat dieselbe Wirkung wie das Festlegen der <xref:System.Windows.Controls.WebBrowser.Source%2A> Eigenschaft. <xref:System.Windows.Controls.WebBrowser.Source%2A> wird von Entwicklern, die deklarativ angeben der anfänglichen dokumentieren, die aus Markup verwendet <xref:System.Windows.Controls.WebBrowser> navigiert, wenn <xref:System.Windows.Controls.WebBrowser> initialisiert wird.  
  
 Verwenden der <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%29> Methode, um die Navigation zu einer URL, die Escape-Zeichen enthalten können. Verwenden der <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29> Methode zum Navigieren zu einer <xref:System.Uri> , ist die Escape-Zeichen nicht enthalten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit <xref:System.Windows.Controls.WebBrowser> , navigieren Sie zu einem Dokument mithilfe der <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29> Methode.  
  
```xaml  
<StackPanel>  
    <StackPanel Orientation="Horizontal">  
        <TextBox x:Name="addressTextBox" Width="200" />  
        <Button Click="goNavigateButton_Click">Go</Button>  
    </StackPanel>  
    <WebBrowser x:Name="myWebBrowser" />  
</StackPanel>  
```  
  
```csharp  
private void goNavigateButton_Click(object sender, RoutedEventArgs e)  
{  
    // Get URI to navigate to  
    Uri uri = new Uri(this.addressTextBox.Text, UriKind.RelativeOrAbsolute);  
  
    // Only absolute URIs can be navigated to  
    if (!uri.IsAbsoluteUri)  
    {  
        MessageBox.Show("The Address URI must be absolute eg 'http://www.microsoft.com'");  
        return;  
    }  
  
    // Navigate to the desired URL by calling the .Navigate method  
    this.myWebBrowser.Navigate(uri);  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.Security.SecurityException">Navigation aus einer Anwendung, die mit teilweiser Vertrauenswürdigkeit ausgeführt wird, zu einem <see cref="T:System.Uri" />, der sich nicht auf der Ursprungssite befindet.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (string source, string targetFrameName, byte[] postData, string additionalHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(string source, string targetFrameName, unsigned int8[] postData, string additionalHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.String,System.String,System.Byte[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As String, targetFrameName As String, postData As Byte(), additionalHeaders As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(System::String ^ source, System::String ^ targetFrameName, cli::array &lt;System::Byte&gt; ^ postData, System::String ^ additionalHeaders);" />
      <MemberSignature Language="F#" Value="member this.Navigate : string * string * byte[] * string -&gt; unit" Usage="webBrowser.Navigate (source, targetFrameName, postData, additionalHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="targetFrameName" Type="System.String" />
        <Parameter Name="postData" Type="System.Byte[]" />
        <Parameter Name="additionalHeaders" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Die URL, zu der navigiert werden soll.</param>
        <param name="targetFrameName">Der Name des Frames, in dem der Inhalt des Dokuments angezeigt werden soll.</param>
        <param name="postData">HTTP-POST-Daten, die beim Anfordern der Quelle an den Server gesendet werden sollen.</param>
        <param name="additionalHeaders">HTTP-Header, die beim Anfordern der Quelle an den Server gesendet werden sollen.</param>
        <summary>Navigiert asynchron zu dem Dokument an der angegebenen URL und gibt den Zielframe an, in den der Inhalt des Dokuments geladen werden soll. Weitere HTTP POST-Daten und HTTP-Header können im Rahmen der Navigationsanforderung an den Server gesendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29> Methode, um die Navigation zu einer URL, die Escape-Zeichen enthalten können. Verwenden der <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29> Methode zum Navigieren zu einer <xref:System.Uri> , ist die Escape-Zeichen nicht enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (Uri source, string targetFrameName, byte[] postData, string additionalHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(class System.Uri source, string targetFrameName, unsigned int8[] postData, string additionalHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.Uri,System.String,System.Byte[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As Uri, targetFrameName As String, postData As Byte(), additionalHeaders As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(Uri ^ source, System::String ^ targetFrameName, cli::array &lt;System::Byte&gt; ^ postData, System::String ^ additionalHeaders);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * string * byte[] * string -&gt; unit" Usage="webBrowser.Navigate (source, targetFrameName, postData, additionalHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="targetFrameName" Type="System.String" />
        <Parameter Name="postData" Type="System.Byte[]" />
        <Parameter Name="additionalHeaders" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Der <see cref="T:System.Uri" />, zu dem navigiert werden soll.</param>
        <param name="targetFrameName">Der Name des Frames, in dem der Inhalt des Dokuments angezeigt werden soll.</param>
        <param name="postData">HTTP-POST-Daten, die beim Anfordern der Quelle an den Server gesendet werden sollen.</param>
        <param name="additionalHeaders">HTTP-Header, die beim Anfordern der Quelle an den Server gesendet werden sollen.</param>
        <summary>Navigiert asynchron zu dem Dokument am angegebenen <see cref="T:System.Uri" /> und gibt den Zielframe an, in den der Inhalt des Dokuments geladen werden soll. Weitere HTTP POST-Daten und HTTP-Header können im Rahmen der Navigationsanforderung an den Server gesendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29> Methode, um die Navigation zu einer URL, die Escape-Zeichen enthalten können. Verwenden der <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29> Methode zum Navigieren zu einer <xref:System.Uri> , ist die Escape-Zeichen nicht enthalten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Navigieren zu einem Dokument, und öffnen Sie es in ein neues Browserfenster, durch Angeben der "zu: leere" Ziel.  
  
```xaml  
<StackPanel>  
    <StackPanel Orientation="Horizontal">  
        <TextBox x:Name="addressTextBox" Width="200" />  
        <Button Click="goNavigateButton_Click">Go</Button>  
    </StackPanel>  
    <WebBrowser x:Name="myWebBrowser" />  
</StackPanel>  
```  
  
```csharp  
private void goNavigateButton_Click(object sender, RoutedEventArgs e)  
{  
    // Get URI to navigate to  
    Uri uri = new Uri(this.addressTextBox.Text, UriKind.RelativeOrAbsolute);  
  
    // Only absolute URIs can be navigated to  
    if (!uri.IsAbsoluteUri)  
    {  
        MessageBox.Show("The Address URI must be absolute eg 'http://www.microsoft.com'");  
        return;  
    }  
  
    // Navigate to the desired URL by calling the .Navigate method  
    this.myWebBrowser.Navigate(uri, "_blank", null, null);  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.Security.SecurityException">Navigation aus einer Anwendung, die mit teilweiser Vertrauenswürdigkeit ausgeführt wird: 
–   Zu einem <see cref="T:System.Uri" />, der sich nicht auf der Ursprungssite befindet oder 
-   <paramref name="targetFrameName" />-Name ist nicht <see langword="null" /> oder leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.WebBrowser.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Dokument, zu dem navigiert wird, gefunden und der Download gestartet wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Navigiert-Ereignishandler übergeben eine Instanz von der <xref:System.Windows.Navigation.NavigationEventArgs> -Klasse, die Kontextinformationen über die Navigation dar, einschließlich Web Antwortdetails enthält.  
  
 Dieses Ereignis wird nur für Navigationen der obersten Ebene ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigating" />
        <altmember cref="E:System.Windows.Controls.WebBrowser.LoadCompleted" />
      </Docs>
    </Member>
    <Member MemberName="NavigateToStream">
      <MemberSignature Language="C#" Value="public void NavigateToStream (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NavigateToStream(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.NavigateToStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NavigateToStream(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.NavigateToStream : System.IO.Stream -&gt; unit" Usage="webBrowser.NavigateToStream stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Ein <see cref="T:System.IO.Stream" />, der den Inhalt für ein Dokument enthält.</param>
        <summary>Navigiert asynchron zu einem <see cref="T:System.IO.Stream" />, der den Inhalt für ein Dokument enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `stream` Parameter `null`, <xref:System.Windows.Controls.WebBrowser> navigiert wird, um ein leeres Dokument ("zu: leere").  
  
 Wenn der Stream-Parameter nicht in einen gültigen ist [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] -Format wird als nur-Text angezeigt.  
  
 Nach der Navigation <xref:System.Windows.Controls.WebBrowser.Source%2A> werden `null`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie in einen Stream navigieren, in dem ein Dokument enthält.  
  
```csharp  
private void goNavigateToStreamButton_Click(object sender, RoutedEventArgs e)  
{  
  // Load HTML document as a stream  
  Uri uri = new Uri(@"pack://application:,,,/HTMLDocumentWithScript.html", UriKind.Absolute);  
  Stream source = Application.GetResourceStream(uri).Stream;  
  
  // Navigate to HTML document stream  
  this.webBrowser.NavigateToStream(source);  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <altmember cref="M:System.Windows.Controls.WebBrowser.NavigateToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="NavigateToString">
      <MemberSignature Language="C#" Value="public void NavigateToString (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NavigateToString(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.NavigateToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub NavigateToString (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NavigateToString(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.NavigateToString : string -&gt; unit" Usage="webBrowser.NavigateToString text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Ein <see cref="T:System.String" />, der den Inhalt für ein Dokument enthält.</param>
        <summary>Navigiert asynchron zu einem <see cref="T:System.String" />, der den Inhalt für ein Dokument enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `text` Parameter `null`, <xref:System.Windows.Controls.WebBrowser> navigiert wird, um ein leeres Dokument ("zu: leere").  
  
 Ist der Textparameter nicht in gültigem [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] -Format wird als nur-Text angezeigt.  
  
 Nach der Navigation <xref:System.Windows.Controls.WebBrowser.Source%2A> werden `null`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie in eine Zeichenfolge zu navigieren, in dem ein Dokument enthält.  
  
```csharp  
private void goNavigateToStringButton_Click(object sender, RoutedEventArgs e)  
{  
  // Load HTML document as a string  
  Uri uri = new Uri(@"pack://application:,,,/HTMLDocumentWithoutScript.html", UriKind.Absolute);  
  Stream stream = Application.GetResourceStream(uri).Stream;  
  using (StreamReader reader = new StreamReader(stream))  
  {  
    // Navigate to HTML document string  
    this.webBrowser.NavigateToString(reader.ReadToEnd());  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <altmember cref="M:System.Windows.Controls.WebBrowser.NavigateToStream(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.WebBrowser.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt direkt vor der Navigation zu einem Dokument auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Navigation-Ereignishandler übergeben eine Instanz von der <xref:System.Windows.Navigation.NavigatingCancelEventArgs> Klasse. Sie können die Navigation Abbrechen, indem Sie die Einstellung der <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft der <xref:System.Windows.Navigation.NavigatingCancelEventArgs> -Objekt `true`.  
  
 Dieses Ereignis wird nur für Navigationen der obersten Ebene ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigated" />
        <altmember cref="E:System.Windows.Controls.WebBrowser.LoadCompleted" />
      </Docs>
    </Member>
    <Member MemberName="ObjectForScripting">
      <MemberSignature Language="C#" Value="public object ObjectForScripting { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ObjectForScripting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.ObjectForScripting" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectForScripting As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ObjectForScripting { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ObjectForScripting : obj with get, set" Usage="System.Windows.Controls.WebBrowser.ObjectForScripting" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Instanz einer von der Hostanwendung implementierten öffentlichen Klasse ab, auf die vom Skript aus einem gehosteten Dokument zugegriffen werden kann, oder legt diese Instanz fest.</summary>
        <value>Das <see cref="T:System.Object" />, das eine Instanz einer <see langword="public" />-Klasse darstellt, die von der Hostanwendung implementiert wird, auf die ein Skript aus einem gehosteten Dokument zugreifen kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann auf alle COM-sichtbaren Objekt festgelegt werden, für die dessen öffentliche Eigenschaften und Methoden für Skriptcode verfügbar gemacht werden sollen. Sie können eine Klasse, die COM-sichtbar machen, indem Sie markieren sie mit der <xref:System.Runtime.InteropServices.ComVisibleAttribute>.  
  
 Das Objekt, das festgelegt wird, für die Skripterstellung für das aktuelle Dokument verfügbar gemacht wird die [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] DOM mithilfe der `window.external` Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Windows.Controls.WebBrowser.ObjectForScripting" /> wird mit einer Instanz mit einem anderen Typ als <see langword="COMVisible" /> festgelegt.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt die aktuelle Seite erneut.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="webBrowser.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lädt die aktuelle Seite erneut.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (bool noCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(bool noCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Refresh(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (noCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(bool noCache);" />
      <MemberSignature Language="F#" Value="member this.Refresh : bool -&gt; unit" Usage="webBrowser.Refresh noCache" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="noCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="noCache">Gibt an, ob die Aktualisierung ohne Cachevalidierung ausgeführt werden soll.</param>
        <summary>Lädt die aktuelle Seite erneut mit optionaler Cachevalidierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `noCache` ist `true`, <xref:System.Windows.Controls.WebBrowser> steuern Sie die Aktualisierung ohne cachevalidierung ausgeführt, indem Sie senden eine "Pragma:no-Cache"-Header an den Server.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.Controls.WebBrowser.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Uri" /> des aktuellen Dokuments ab, das im <see cref="T:System.Windows.Controls.WebBrowser" /> gehostet wird, oder legt diesen fest.</summary>
        <value>Die <see cref="T:System.Uri" /> für die aktuelle [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokument.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen der Quelleigenschaft bewirkt, dass <xref:System.Windows.Controls.WebBrowser> navigieren Sie auf das Dokument anhand der <xref:System.Uri>. Wenn die <xref:System.Uri> ist `null`, ein leeres Dokument wird angezeigt ("zu: leere").  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie konfigurieren <xref:System.Windows.Controls.WebBrowser> , zu dem navigiert ein [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] Dokuments mithilfe des workflowmarkups.  
  
```xaml  
<!-- Web Browser Control that hosts a web page. -->  
<WebBrowser x:Name="webBrowser" Source="http://msdn.com"   
  Width="600" Height="600"  />  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Windows.Controls.WebBrowser" />-Instanz ist nicht mehr gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Verweis auf den zugrunde liegenden nativen <c>WebBrowser</c> konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.Security.SecurityException">Navigation aus einer Anwendung, die mit teilweiser Vertrauenswürdigkeit ausgeführt wird, zu einem <see cref="T:System.Uri" />, der sich nicht auf der Ursprungssite befindet.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TabInto">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TabInto (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TabInto(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.System#Windows#Interop#IKeyboardInputSink#TabInto(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Function TabInto (request As TraversalRequest) As Boolean Implements IKeyboardInputSink.TabInto" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.TabInto(System::Windows::Input::TraversalRequest ^ request) = System::Windows::Interop::IKeyboardInputSink::TabInto;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Interop.IKeyboardInputSink.TabInto(System.Windows.Input.TraversalRequest)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Gibt an, ob der Fokus auf den ersten oder letzten Tabstopp festgelegt werden soll.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.Windows.Interop.IKeyboardInputSink.TabInto(System.Windows.Input.TraversalRequest)" />.</summary>
        <returns><see langword="true" />, wenn der Fokus wie angefordert festgelegt wurde, <see langword="false" />,wenn keine Tabstopps vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Controls.WebBrowser>-Instanz in eine <xref:System.Windows.Interop.IKeyboardInputSink>-Schnittstelle umgewandelt wird.

]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md">WPF und Win32-Interoperation-Übersicht</related>
        <related type="Article" href="~/docs/framework/wpf/advanced/input-overview.md">Übersicht über die Eingabe</related>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TranslateAccelerator (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.System#Windows#Interop#IKeyboardInputSink#TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Function TranslateAccelerator (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean Implements IKeyboardInputSink.TranslateAccelerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers) = System::Windows::Interop::IKeyboardInputSink::TranslateAccelerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">Die Meldung und die zugeordneten Daten. Ändern Sie diese Struktur nicht. Es wird als Verweis und nur aus Leistungsgründen übergeben.</param>
        <param name="modifiers">Modifizierertasten.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />.</summary>
        <returns><see langword="true" />, wenn die Meldung durch die Implementierung der Methode behandelt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Controls.WebBrowser>-Instanz in eine <xref:System.Windows.Interop.IKeyboardInputSink>-Schnittstelle umgewandelt wird.

]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md">WPF und Win32-Interoperation-Übersicht</related>
        <related type="Article" href="~/docs/framework/wpf/advanced/input-overview.md">Übersicht über die Eingabe</related>
      </Docs>
    </Member>
    <Member MemberName="TabIntoCore">
      <MemberSignature Language="C#" Value="protected override bool TabIntoCore (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool TabIntoCore(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.TabIntoCore(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function TabIntoCore (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool TabIntoCore(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.TabIntoCore : System.Windows.Input.TraversalRequest -&gt; bool" Usage="webBrowser.TabIntoCore request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslateAcceleratorCore">
      <MemberSignature Language="C#" Value="protected override bool TranslateAcceleratorCore (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool TranslateAcceleratorCore(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.TranslateAcceleratorCore(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function TranslateAcceleratorCore (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool TranslateAcceleratorCore(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers);" />
      <MemberSignature Language="F#" Value="override this.TranslateAcceleratorCore :  * System.Windows.Input.ModifierKeys -&gt; bool" Usage="webBrowser.TranslateAcceleratorCore (msg, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>