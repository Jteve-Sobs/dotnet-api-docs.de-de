<Type Name="IComSoapPublisher" FullName="System.EnterpriseServices.Internal.IComSoapPublisher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2f4ed5c55f002e0539bfb490ba5f807d67d234fa" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30410084" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IComSoapPublisher" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IComSoapPublisher" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="VB.NET" Value="Public Interface IComSoapPublisher" />
  <TypeSignature Language="C++ CLI" Value="public interface class IComSoapPublisher" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("d8013eee-730b-45e2-ba24-874b7242c425")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Veröffentlicht COM-Schnittstellen für SOAP-fähige COM+-Anwendungen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Implementierung der <xref:System.EnterpriseServices.Internal.IComSoapPublisher> ist <xref:System.EnterpriseServices.Internal.Publish>; finden Sie unter diesem Thema die Einzelheiten.  
  
 <xref:System.EnterpriseServices.Internal.IComSoapPublisher> wird intern von .NET Framework verwendet werden. Sie müssen nicht direkt im Code verwenden.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CreateMailBox">
      <MemberSignature Language="C#" Value="public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateMailBox(string RootMailServer, string MailBox, [out] string&amp; SmtpName, [out] string&amp; Domain, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMailBox (RootMailServer As String, MailBox As String, ByRef SmtpName As String, ByRef Domain As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % SmtpName, [Runtime::InteropServices::Out] System::String ^ % Domain, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(6)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="SmtpName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Domain" Type="System.String&amp;" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Die URL für den Stamm-Mailserver.</param>
        <param name="MailBox">Das zu erstellende Postfach.</param>
        <param name="SmtpName">Nach dem Beenden dieser Methode enthält dieser Parameter den Namen des SMTP (Simple Mail Transfer Protocol)-Servers, der das Postfach enthält.</param>
        <param name="Domain">Nach dem Beenden dieser Methode enthält dieser Parameter die Domäne des SMTP-Servers.</param>
        <param name="PhysicalPath">Nach dem Beenden dieser Methode enthält dieser Parameter den Dateisystempfad für das Postfach.</param>
        <param name="Error">Nach dem Beenden dieser Methode enthält dieser Parameter eine Fehlermeldung, wenn ein Problem aufgetreten ist.</param>
        <summary>Erstellt ein SOAP-fähiges COM+-Anwendungspostfach an einer angegebenen URL. Nicht vollständig implementiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nicht vollständig implementiert. ein Postfach erstellt nicht aktuell. Gibt die Fehlermeldung "COM+-SOAP-Dienste, die SMTP-Veröffentlichung nicht unterstützt wird."  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateVirtualRoot">
      <MemberSignature Language="C#" Value="public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateVirtualRoot(string Operation, string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateVirtualRoot (Operation As String, FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateVirtualRoot(System::String ^ Operation, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(4)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String&amp;" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String&amp;" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="Operation">Der auszuführende Vorgang.</param>
        <param name="FullUrl">Die vollständige URL-Adresse für das virtuelle Stammverzeichnis.</param>
        <param name="BaseUrl">Nach dem Beenden dieser Methode enthält dieser Parameter die URL-Basisadresse.</param>
        <param name="VirtualRoot">Nach dem Beenden dieser Methode enthält dieser Parameter den Namen des virtuellen Stammverzeichnisses.</param>
        <param name="PhysicalPath">Nach dem Beenden dieser Methode enthält dieser Parameter den Dateipfad für das virtuelle Stammverzeichnis.</param>
        <param name="Error">Nach dem Beenden dieser Methode enthält dieser Parameter eine Fehlermeldung, wenn ein Problem aufgetreten ist.</param>
        <summary>Erstellt ein virtuelles Stammverzeichnis einer SOAP-fähigen COM+-Anwendung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird empfohlen, <xref:System.EnterpriseServices.Internal.ISoapServerVRoot.CreateVirtualRootEx%2A> anstelle von <xref:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.  
  
 - oder -   
  
 Der Aufrufer besitzt keine Zugriffsberechtigungen für DNS (Domain Name System)-Informationen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="FullUrl" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Auflösen des lokalen Hostnamens ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="FullUrl" /> ist leer.  
  
 - oder -   
  
 Das in <paramref name="FullUrl" /> angegebene Schema ist ungültig.  
  
 - oder -   
  
 <paramref name="FullUrl" /> enthält mehr als zwei aufeinander folgende Schrägstriche.  
  
 - oder -   
  
 Das in <paramref name="FullUrl" /> angegebene Kennwort ist ungültig.  
  
 - oder -   
  
 Der in <paramref name="FullUrl" /> angegebene Hostname ist ungültig.  
  
 - oder -   
  
 Der in <paramref name="FullUrl" /> angegebene Dateiname ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteMailBox">
      <MemberSignature Language="C#" Value="public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteMailBox(string RootMailServer, string MailBox, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteMailBox(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteMailBox (RootMailServer As String, MailBox As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(7)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Die URL für den Stamm-Mailserver.</param>
        <param name="MailBox">Das zu löschende Postfach.</param>
        <param name="Error">Nach dem Beenden dieser Methode enthält dieser Parameter eine Fehlermeldung, wenn ein Problem aufgetreten ist.</param>
        <summary>Löscht ein SOAP-fähiges COM+-Anwendungspostfach an einer angegebenen URL. Nicht vollständig implementiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nicht vollständig implementiert. das Postfach wird nicht gelöscht werden. Gibt die Fehlermeldung "COM+-SOAP-Dienste, die SMTP-Veröffentlichung nicht unterstützt wird."  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteVirtualRoot">
      <MemberSignature Language="C#" Value="public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteVirtualRoot(string RootWebServer, string FullUrl, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteVirtualRoot(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteVirtualRoot (RootWebServer As String, FullUrl As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteVirtualRoot(System::String ^ RootWebServer, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(5)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootWebServer" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootWebServer">Der Stammwebserver.</param>
        <param name="FullUrl">Die vollständige URL-Adresse für das virtuelle Stammverzeichnis.</param>
        <param name="Error">Nach dem Beenden dieser Methode enthält dieser Parameter eine Fehlermeldung, wenn ein Problem aufgetreten ist.</param>
        <summary>Löscht ein virtuelles Stammverzeichnis einer SOAP-fähigen COM+-Anwendung. Nicht vollständig implementiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionalität für <xref:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot%2A> ist noch nicht verfügbar.  
  
> [!CAUTION]
>  Die Methode wird zurzeit ohne einen Fehler zurück, das virtuelle Stammverzeichnis wird jedoch nicht gelöscht.  
  
 Wenn die Funktionalität zur Verfügung steht, werden die empfohlene Methode <xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.</exception>
      </Docs>
    </Member>
    <Member MemberName="GacInstall">
      <MemberSignature Language="C#" Value="public void GacInstall (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacInstall(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GacInstall(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacInstall (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GacInstall(System::String ^ AssemblyPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(13)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Der Dateisystempfad für die Assembly.</param>
        <summary>Installiert eine Assembly im globalen Assemblycache.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.</exception>
      </Docs>
    </Member>
    <Member MemberName="GacRemove">
      <MemberSignature Language="C#" Value="public void GacRemove (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacRemove(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GacRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacRemove (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GacRemove(System::String ^ AssemblyPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(14)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Der Dateisystempfad für die Assembly.</param>
        <summary>Entfernt eine Assembly aus dem globalen Assemblycache.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="AssemblyPath" /> ist leer.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="AssemblyPath" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> ist keine gültige Assembly.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyNameForCache">
      <MemberSignature Language="C#" Value="public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAssemblyNameForCache(string TypeLibPath, [out] string&amp; CachePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GetAssemblyNameForCache(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetAssemblyNameForCache (TypeLibPath As String, ByRef CachePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetAssemblyNameForCache(System::String ^ TypeLibPath, [Runtime::InteropServices::Out] System::String ^ % CachePath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(15)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="TypeLibPath" Type="System.String" />
        <Parameter Name="CachePath" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="TypeLibPath">Der Pfad der Datei, die die Typbibliothek enthält.</param>
        <param name="CachePath">Nach dem Beenden dieser Methode enthält dieser Parameter den vollständigen Pfad der Proxyassembly im SoapCache-Verzeichnis.</param>
        <summary>Gibt den vollständigen Pfad für eine signierte generierte Assembly mit starkem Namen im SoapCache-Verzeichnis zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für eine nicht verwaltete COM+-Komponente, die über .NET Remoting als SOAP-Endpunkt veröffentlicht werden muss ein Proxy generiert werden, um die nicht verwalteten Komponenten für .NET Framework verfügbar zu machen. Dies geschieht, indem Sie die gleichen Schritte wie Type Library Importer-Tool (Tlbimp.exe) programmgesteuert Ausführen der [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)] Tool, das verwendet wird, um nicht verwaltete COM+-Typbibliotheken in Assemblys der Proxy-Metadaten zu konvertieren. Für die Clientaktivierung über SOAP erfolgreich ausgeführt werden kann müssen Client- und Servercomputern jedoch die gleichen mit starkem Namen signierte Metadatenproxys freigeben. Aus diesem Grund beim Generieren einer verwalteten Proxyassembly für eine nicht verwaltete COM+-Komponente, ein Schlüssel mit starkem Namen auch generiert und zum Signieren der Proxyassembly verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="TypeLibPath" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">Der Dateiname ist leer, enthält nur Leerzeichen oder enthält ungültige Zeichen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf <paramref name="TypeLibPath" /> wird verweigert.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="TypeLibPath" /> enthält einen Doppelpunkt (:) innerhalb der Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeNameFromProgId">
      <MemberSignature Language="C#" Value="public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeNameFromProgId(string AssemblyPath, string ProgId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GetTypeNameFromProgId(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeNameFromProgId (AssemblyPath As String, ProgId As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTypeNameFromProgId(System::String ^ AssemblyPath, System::String ^ ProgId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(10)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
        <Parameter Name="ProgId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Der Dateisystempfad für die Assembly.</param>
        <param name="ProgId">Der programmatische Bezeichner der Klasse.</param>
        <summary>Reflektiert außerhalb einer Assembly und gibt den der ProgID entsprechenden Typnamen zurück.</summary>
        <returns>Der der ProgID entsprechende Typname.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessClientTlb">
      <MemberSignature Language="C#" Value="public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessClientTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessClientTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, VRoot As String, BaseUrl As String, Mode As String, Transport As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProcessClientTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ VRoot, System::String ^ BaseUrl, System::String ^ Mode, System::String ^ Transport, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(9)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="VRoot" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" />
        <Parameter Name="Mode" Type="System.String" />
        <Parameter Name="Transport" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="TypeName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Der programmatische Bezeichner der Klasse.</param>
        <param name="SrcTlbPath">Der Pfad der Datei, die die Typbibliothek enthält.</param>
        <param name="PhysicalPath">Das Verzeichnis der Webanwendung.</param>
        <param name="VRoot">Der Name des virtuellen Stammverzeichnisses.</param>
        <param name="BaseUrl">Der Basis-URL, der das virtuelle Stammverzeichnis enthält.</param>
        <param name="Mode">Der Aktivierungsmodus.</param>
        <param name="Transport">Nicht verwendet. Geben Sie für diesen Parameter <see langword="null" /> an.</param>
        <param name="AssemblyName">Nach dem Beenden dieser Methode enthält dieser Parameter den Anzeigenamen der Assembly.</param>
        <param name="TypeName">Nach dem Beenden dieser Methode enthält dieser Parameter den voll gekennzeichneten Typnamen der Assembly.</param>
        <param name="Error">Nach dem Beenden dieser Methode enthält dieser Parameter eine Fehlermeldung, wenn ein Problem aufgetreten ist.</param>
        <summary>Verarbeitet eine Clienttypbibliothek und erstellt eine Konfigurationsdatei auf dem Client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird beim Import einer Client-Proxy verwendet, um eine Remoting-Konfigurationsdatei zu generieren.  
  
 In der Implementierung Wenn die `Mode` ist "Wellknownobject" oder eine leere Zeichenfolge (""), ein bekanntes Objekt wird davon ausgegangen, dass; Andernfalls wird die Clientaktivierung ausgegangen.  
  
 Es wird empfohlen, <xref:System.EnterpriseServices.Internal.ISoapClientImport.ProcessClientTlbEx%2A> anstelle von <xref:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessServerTlb">
      <MemberSignature Language="C#" Value="public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessServerTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessServerTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, Operation As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProcessServerTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ Operation, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(8)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="TypeName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Der programmatische Bezeichner der Klasse.</param>
        <param name="SrcTlbPath">Der Pfad der Datei, die die Typbibliothek enthält.</param>
        <param name="PhysicalPath">Das Verzeichnis der Webanwendung.</param>
        <param name="Operation">Der auszuführende Vorgang.</param>
        <param name="AssemblyName">Nach dem Beenden dieser Methode enthält dieser Parameter den Anzeigenamen der Assembly.</param>
        <param name="TypeName">Nach dem Beenden dieser Methode enthält dieser Parameter den voll gekennzeichneten Typnamen der Assembly.</param>
        <param name="Error">Nach dem Beenden dieser Methode enthält dieser Parameter eine Fehlermeldung, wenn ein Problem aufgetreten ist.</param>
        <summary>Verarbeitet eine Servertypbibliothek, indem den Dateien Web.config und Default.disco Einträge hinzugefügt oder daraus gelöscht werden. Generiert einen Proxy, sofern erforderlich.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generiert die Datei "Web.config" und Default.disco-Dateieinträge für COM+-Komponenten. Generiert einen Proxy, sofern erforderlich.  
  
 Es wird empfohlen, <xref:System.EnterpriseServices.Internal.ISoapServerTlb.AddServerTlb%2A> und <xref:System.EnterpriseServices.Internal.ISoapServerTlb.DeleteServerTlb%2A> anstelle von <xref:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.</exception>
        <exception cref="T:System.EnterpriseServices.ServicedComponentException">Der <paramref name="SrcTlbPath" />-Parameter enthielt einen Verweis auf scrobj.dll. Daher wird die SOAP-Veröffentlichung von Skriptkomponenten nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public void RegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(11)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Der Dateisystempfad für die Assembly.</param>
        <summary>Registriert eine Assembly für COM-Interop.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Implementierung der <xref:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly%2A> Assembly Registration-Tool (Regasm.exe) verwendet, um die erstellbaren Klassen in der Assembly zu registrieren. Weitere Informationen finden Sie unter [Regasm.exe (Assembly Registration-Tool)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.EnterpriseServices.RegistrationException">Die Eingabeassembly besitzt keinen starken Namen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.  
  
 - oder -   
  
 Eine CodeBase, die nicht mit "file://" beginnt, wurde ohne die erforderliche <see cref="T:System.Net.WebPermission" /> angegeben.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="AssemblyPath" /> wurde nicht gefunden, oder es wurde keine Dateinamenerweiterung angegeben.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> ist keine gültige Assembly.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen, oder der Assemblyname ist länger als MAX_PATH Zeichen.</exception>
        <exception cref="T:System.InvalidOperationException">Eine mit <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> gekennzeichnete Methode ist nicht <see langword="static" />.  
  
 - oder -   
  
 Auf einer bestimmten Ebene der Hierarchie sind mehrere mit <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> markierte Methoden vorhanden.  
  
 - oder -   
  
 Die Signatur der mit <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> gekennzeichneten Methode ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnRegisterAssembly">
      <MemberSignature Language="C#" Value="public void UnRegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnRegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnRegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnRegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(12)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Der Dateisystempfad für die Assembly.</param>
        <summary>Hebt die Registrierung einer COM-Interop-Assembly auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Implementierung der <xref:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly%2A> Regasm.exe beim Aufheben der Registrierung der erstellbaren Klassen in der Assembly verwendet. Weitere Informationen finden Sie unter [Regasm.exe (Assembly Registration-Tool)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.  
  
 - oder -   
  
 Eine CodeBase, die nicht mit "file://" beginnt, wurde ohne die erforderliche <see cref="T:System.Net.WebPermission" /> angegeben.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="AssemblyPath" /> wurde nicht gefunden, oder es wurde keine Dateinamenerweiterung angegeben.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> ist keine gültige Assembly.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen, oder der Assemblyname ist länger als MAX_PATH Zeichen.</exception>
        <exception cref="T:System.InvalidOperationException">Eine mit <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> gekennzeichnete Methode ist nicht <see langword="static" />.  
  
 - oder -   
  
 Auf einer bestimmten Ebene der Hierarchie sind mehrere mit <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> markierte Methoden vorhanden.  
  
 - oder -   
  
 Die Signatur der mit <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> gekennzeichneten Methode ist ungültig.</exception>
      </Docs>
    </Member>
  </Members>
</Type>