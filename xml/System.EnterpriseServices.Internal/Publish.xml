<Type Name="Publish" FullName="System.EnterpriseServices.Internal.Publish">
  <Metadata><Meta Name="ms.openlocfilehash" Value="021ea4f3fe93694e754a55f2c3e9233861da1548" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69359025" /></Metadata><TypeSignature Language="C#" Value="public class Publish : System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Publish extends System.Object implements class System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.Publish" />
  <TypeSignature Language="VB.NET" Value="Public Class Publish&#xA;Implements IComSoapPublisher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Publish : System::EnterpriseServices::Internal::IComSoapPublisher" />
  <TypeSignature Language="F#" Value="type Publish = class&#xA;    interface IComSoapPublisher" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.EnterpriseServices.Internal.IComSoapPublisher</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("d8013eef-730b-45e2-ba24-874b7242c425")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Veröffentlicht COM-Schnittstellen für SOAP-fähige COM+-Anwendungen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish>wird intern vom .NET Framework verwendet. Sie müssen Sie nicht direkt in Ihrem Code verwenden.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Publish ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Publish();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.EnterpriseServices.Internal.Publish" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMailBox">
      <MemberSignature Language="C#" Value="public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateMailBox(string RootMailServer, string MailBox, [out] string&amp; SmtpName, [out] string&amp; Domain, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMailBox (RootMailServer As String, MailBox As String, ByRef SmtpName As String, ByRef Domain As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % SmtpName, [Runtime::InteropServices::Out] System::String ^ % Domain, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateMailBox : string * string *  *  *  *  -&gt; unit&#xA;override this.CreateMailBox : string * string *  *  *  *  -&gt; unit" Usage="publish.CreateMailBox (RootMailServer, MailBox, SmtpName, Domain, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="SmtpName" Type="System.String" RefType="out" />
        <Parameter Name="Domain" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Die URL für den Stamm-Mailserver.</param>
        <param name="MailBox">Das zu erstellende Postfach.</param>
        <param name="SmtpName">Nach dem Beenden dieser Methode enthält dieser Parameter den Namen des SMTP (Simple Mail Transfer Protocol)-Servers, der das Postfach enthält.</param>
        <param name="Domain">Nach dem Beenden dieser Methode enthält dieser Parameter die Domäne des SMTP-Servers.</param>
        <param name="PhysicalPath">Nach dem Beenden dieser Methode enthält dieser Parameter den Dateisystempfad für das Postfach.</param>
        <param name="Error">Nach dem Beenden dieser Methode enthält dieser Parameter eine Fehlermeldung, wenn ein Problem aufgetreten ist.</param>
        <summary>Erstellt ein SOAP-fähiges COM+-Anwendungspostfach an einer angegebenen URL. Nicht vollständig implementiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nicht vollständig implementiert. erstellt kein Postfach. Gibt die Fehlermeldung "com+ SOAP-Dienste-SMTP-Veröffentlichung wird nicht unterstützt" zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateVirtualRoot">
      <MemberSignature Language="C#" Value="public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateVirtualRoot(string Operation, string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateVirtualRoot (Operation As String, FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateVirtualRoot(System::String ^ Operation, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateVirtualRoot : string * string *  *  *  *  -&gt; unit&#xA;override this.CreateVirtualRoot : string * string *  *  *  *  -&gt; unit" Usage="publish.CreateVirtualRoot (Operation, FullUrl, BaseUrl, VirtualRoot, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="Operation">Der auszuführende Vorgang.</param>
        <param name="FullUrl">Die vollständige URL-Adresse für das virtuelle Stammverzeichnis.</param>
        <param name="BaseUrl">Nach dem Beenden dieser Methode enthält dieser Parameter die URL-Basisadresse.</param>
        <param name="VirtualRoot">Nach dem Beenden dieser Methode enthält dieser Parameter den Namen des virtuellen Stammverzeichnisses.</param>
        <param name="PhysicalPath">Nach dem Beenden dieser Methode enthält dieser Parameter den Dateipfad für das virtuelle Stammverzeichnis.</param>
        <param name="Error">Nach dem Beenden dieser Methode enthält dieser Parameter eine Fehlermeldung, wenn ein Problem aufgetreten ist.</param>
        <summary>Erstellt ein virtuelles Stammverzeichnis einer SOAP-fähigen COM+-Anwendung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird empfohlen, <xref:System.EnterpriseServices.Internal.SoapServerVRoot.CreateVirtualRootEx%2A> anstelle von <xref:System.EnterpriseServices.Internal.Publish.CreateVirtualRoot%2A>zu verwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.  
  
 - oder -  
  
 Der Aufrufer besitzt keine Zugriffsberechtigungen für DNS-Informationen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="FullUrl" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Auflösen des lokalen Hostnamens ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="FullUrl" /> ist leer.  
  
- oder - 
Das in <paramref name="FullUrl" /> angegebene Schema ist ungültig.  
  
- oder - 
 <paramref name="FullUrl" /> enthält mehr als zwei aufeinander folgende Schrägstriche.  
  
- oder - 
Das in <paramref name="FullUrl" /> angegebene Kennwort ist ungültig.  
  
- oder - 
Der in <paramref name="FullUrl" /> angegebene Hostname ist ungültig.  
  
- oder - 
Der in <paramref name="FullUrl" /> angegebene Dateiname ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Konfiguration der Remoting-Infrastruktur. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteMailBox">
      <MemberSignature Language="C#" Value="public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteMailBox(string RootMailServer, string MailBox, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.DeleteMailBox(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteMailBox (RootMailServer As String, MailBox As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteMailBox : string * string *  -&gt; unit&#xA;override this.DeleteMailBox : string * string *  -&gt; unit" Usage="publish.DeleteMailBox (RootMailServer, MailBox, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteMailBox(System.String,System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Die URL für den Stamm-Mailserver.</param>
        <param name="MailBox">Das zu löschende Postfach.</param>
        <param name="Error">Nach dem Beenden dieser Methode enthält dieser Parameter eine Fehlermeldung, wenn ein Problem aufgetreten ist.</param>
        <summary>Löscht ein SOAP-fähiges COM+-Anwendungspostfach an einer angegebenen URL. Nicht vollständig implementiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nicht vollständig implementiert, löscht das Postfach nicht. Gibt die Fehlermeldung "com+ SOAP-Dienste-SMTP-Veröffentlichung wird nicht unterstützt" zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteVirtualRoot">
      <MemberSignature Language="C#" Value="public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteVirtualRoot(string RootWebServer, string FullUrl, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteVirtualRoot (RootWebServer As String, FullUrl As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteVirtualRoot(System::String ^ RootWebServer, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteVirtualRoot : string * string *  -&gt; unit&#xA;override this.DeleteVirtualRoot : string * string *  -&gt; unit" Usage="publish.DeleteVirtualRoot (RootWebServer, FullUrl, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteVirtualRoot(System.String,System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootWebServer" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootWebServer">Der Stammwebserver.</param>
        <param name="FullUrl">Die vollständige URL-Adresse für das virtuelle Stammverzeichnis.</param>
        <param name="Error">Nach dem Beenden dieser Methode enthält dieser Parameter eine Fehlermeldung, wenn ein Problem aufgetreten ist.</param>
        <summary>Löscht ein virtuelles Stammverzeichnis einer SOAP-fähigen COM+-Anwendung. Nicht vollständig implementiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionalität für <xref:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot%2A> ist noch nicht verfügbar.  
  
> [!CAUTION]
>  Die Methode wird zurzeit ohne Fehler zurückgegeben, das virtuelle Stammverzeichnis wird jedoch nicht gelöscht.  
  
 Wenn die Funktionalität verfügbar wird, wird <xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A>die empfohlene Methode verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GacInstall">
      <MemberSignature Language="C#" Value="public void GacInstall (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacInstall(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GacInstall(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacInstall (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GacInstall(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacInstall : string -&gt; unit&#xA;override this.GacInstall : string -&gt; unit" Usage="publish.GacInstall AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GacInstall(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Der Dateisystempfad für die Assembly.</param>
        <summary>Installiert eine Assembly im globalen Assemblycache.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GacRemove">
      <MemberSignature Language="C#" Value="public void GacRemove (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacRemove(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GacRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacRemove (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GacRemove(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacRemove : string -&gt; unit&#xA;override this.GacRemove : string -&gt; unit" Usage="publish.GacRemove AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GacRemove(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Der Dateisystempfad für die Assembly.</param>
        <summary>Entfernt eine Assembly aus dem globalen Assemblycache.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.  
  
 - oder -  
  
 Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen zur Pfadsuche.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="AssemblyPath" /> ist leer.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="AssemblyPath" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" /> ist keine gültige Assembly.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyNameForCache">
      <MemberSignature Language="C#" Value="public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAssemblyNameForCache(string TypeLibPath, [out] string&amp; CachePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetAssemblyNameForCache(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetAssemblyNameForCache (TypeLibPath As String, ByRef CachePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetAssemblyNameForCache(System::String ^ TypeLibPath, [Runtime::InteropServices::Out] System::String ^ % CachePath);" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblyNameForCache : string *  -&gt; unit&#xA;override this.GetAssemblyNameForCache : string *  -&gt; unit" Usage="publish.GetAssemblyNameForCache (TypeLibPath, CachePath)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GetAssemblyNameForCache(System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="TypeLibPath" Type="System.String" />
        <Parameter Name="CachePath" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="TypeLibPath">Der Pfad der Datei, die die Typbibliothek enthält.</param>
        <param name="CachePath">Nach dem Beenden dieser Methode enthält dieser Parameter den Namen des Verzeichnisses SoapCache.</param>
        <summary>Gibt den vollständigen Pfad für eine signierte generierte Assembly mit starkem Namen im SoapCache-Verzeichnis zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Damit eine nicht verwaltete COM+-Komponente über .NET Remoting als SOAP-Endpunkt veröffentlicht werden kann, muss ein Proxy generiert werden, um die nicht verwalteten Komponenten für den .NET Framework verfügbar zu machen. Dies erfolgt durch programmgesteuerte Ausführung der gleichen Schritte wie bei der Typbibliothek (Tlbimp. exe), das [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)] Tool, das zum Konvertieren nicht verwalteter COM+-Typbibliotheken in proxymetadatenassemblys verwendet wird. Damit die Client Aktivierung über SOAP erfolgreich durchgeführt werden kann, müssen Client-und Server Computer jedoch dieselben mit einem starken Namen signierten Metadatenproxys verwenden. Wenn für eine nicht verwaltete COM+-Komponente eine verwaltete Proxyassembly generiert wird, wird aus diesem Grund auch ein Schlüssel mit starkem Namen generiert und zum Signieren der Proxyassembly verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="TypeLibPath" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">Der Dateiname ist leer, enthält nur Leerzeichen oder enthält ungültige Zeichen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf <paramref name="TypeLibPath" /> wurde verweigert.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="TypeLibPath" /> enthält einen Doppelpunkt (:) innerhalb der Zeichenfolge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen von Dateien. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetClientPhysicalPath">
      <MemberSignature Language="C#" Value="public static string GetClientPhysicalPath (bool CreateDir);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClientPhysicalPath(bool CreateDir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClientPhysicalPath (CreateDir As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClientPhysicalPath(bool CreateDir);" />
      <MemberSignature Language="F#" Value="static member GetClientPhysicalPath : bool -&gt; string" Usage="System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath CreateDir" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="CreateDir" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="CreateDir">Legen Sie den Wert auf <see langword="true" /> fest, um das Verzeichnis zu erstellen, und auf <see langword="false" />, um den Pfad zurückzugeben, aber kein Verzeichnis zu erstellen.</param>
        <summary>Gibt den Pfad des Verzeichnisses zum Speichern von Clientkonfigurationsdateien zurück.</summary>
        <returns>Der Pfad des Verzeichnisses für die Konfigurationsdateien.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt die Verzeichnisse "\com\soapassembly\\" unter dem System Verzeichnis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeNameFromProgId">
      <MemberSignature Language="C#" Value="public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeNameFromProgId(string AssemblyPath, string ProgId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetTypeNameFromProgId(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeNameFromProgId (AssemblyPath As String, ProgId As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeNameFromProgId(System::String ^ AssemblyPath, System::String ^ ProgId);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeNameFromProgId : string * string -&gt; string&#xA;override this.GetTypeNameFromProgId : string * string -&gt; string" Usage="publish.GetTypeNameFromProgId (AssemblyPath, ProgId)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GetTypeNameFromProgId(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
        <Parameter Name="ProgId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Der Dateisystempfad für die Assembly.</param>
        <param name="ProgId">Der programmatische Bezeichner der Klasse.</param>
        <summary>Reflektiert außerhalb einer Assembly und gibt den der ProgID entsprechenden Typnamen zurück.</summary>
        <returns>Der der ProgID entsprechende Typname.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ParseUrl">
      <MemberSignature Language="C#" Value="public static void ParseUrl (string FullUrl, out string BaseUrl, out string VirtualRoot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ParseUrl(string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ParseUrl(System.String,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ParseUrl (FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ParseUrl(System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot);" />
      <MemberSignature Language="F#" Value="static member ParseUrl : string *  *  -&gt; unit" Usage="System.EnterpriseServices.Internal.Publish.ParseUrl (FullUrl, BaseUrl, VirtualRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="FullUrl">Die vollständige URL-Adresse für das virtuelle Stammverzeichnis.</param>
        <param name="BaseUrl">Nach dem Beenden dieser Methode enthält dieser Parameter die URL-Basisadresse.</param>
        <param name="VirtualRoot">Nach dem Beenden dieser Methode enthält dieser Parameter den Namen des virtuellen Stammverzeichnisses.</param>
        <summary>Analysiert eine URL und gibt die Basis-URL sowie Teile des virtuellen Stammverzeichnisses zurück.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="FullUrl" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Auflösen des lokalen Hostnamens ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer besitzt keine Zugriffsberechtigungen für DNS-Informationen.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="FullUrl" /> ist leer.  
  
- oder - 
Das in <paramref name="FullUrl" /> angegebene Schema ist ungültig.  
  
- oder - 
 <paramref name="FullUrl" /> enthält zu viele Schrägstriche (/).  
  
- oder - 
Das in <paramref name="FullUrl" /> angegebene Kennwort ist ungültig.  
  
- oder - 
Der in <paramref name="FullUrl" /> angegebene Hostname ist ungültig.  
  
- oder - 
Der in <paramref name="FullUrl" /> angegebene Dateiname ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessClientTlb">
      <MemberSignature Language="C#" Value="public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessClientTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessClientTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, VRoot As String, BaseUrl As String, Mode As String, Transport As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessClientTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ VRoot, System::String ^ BaseUrl, System::String ^ Mode, System::String ^ Transport, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessClientTlb : string * string * string * string * string * string * string *  *  *  -&gt; unit&#xA;override this.ProcessClientTlb : string * string * string * string * string * string * string *  *  *  -&gt; unit" Usage="publish.ProcessClientTlb (ProgId, SrcTlbPath, PhysicalPath, VRoot, BaseUrl, Mode, Transport, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="VRoot" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" />
        <Parameter Name="Mode" Type="System.String" />
        <Parameter Name="Transport" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Der programmatische Bezeichner der Klasse.</param>
        <param name="SrcTlbPath">Der Pfad der Datei, die die Typbibliothek enthält.</param>
        <param name="PhysicalPath">Das Verzeichnis der Webanwendung.</param>
        <param name="VRoot">Der Name des virtuellen Stammverzeichnisses.</param>
        <param name="BaseUrl">Der Basis-URL, der das virtuelle Stammverzeichnis enthält.</param>
        <param name="Mode">Der Aktivierungsmodus.</param>
        <param name="Transport">Wird nicht verwendet. Geben Sie für diesen Parameter <see langword="null" /> an.</param>
        <param name="AssemblyName">Nach dem Beenden dieser Methode enthält dieser Parameter den Anzeigenamen der Assembly.</param>
        <param name="TypeName">Nach dem Beenden dieser Methode enthält dieser Parameter den voll gekennzeichneten Typnamen der Assembly.</param>
        <param name="Error">Nach dem Beenden dieser Methode enthält dieser Parameter eine Fehlermeldung, wenn ein Problem aufgetreten ist.</param>
        <summary>Verarbeitet eine Clienttypbibliothek und erstellt eine Konfigurationsdatei auf dem Client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für einen Client Proxy Import verwendet, um eine remotingkonfigurationsdatei zu generieren.  
  
 Wenn der `Mode` Parameter entweder "wellknownobject" oder eine leere Zeichenfolge ("") ist, wird davon ausgegangen, dass es sich um ein bekanntes Objekt handelt. Andernfalls wird die Client Aktivierung angenommen.  
  
 Es wird empfohlen, <xref:System.EnterpriseServices.Internal.SoapClientImport.ProcessClientTlbEx%2A> anstelle von <xref:System.EnterpriseServices.Internal.Publish.ProcessClientTlb%2A>zu verwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessServerTlb">
      <MemberSignature Language="C#" Value="public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string strAssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessServerTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, [out] string&amp; strAssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessServerTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, Operation As String, ByRef strAssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessServerTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ Operation, [Runtime::InteropServices::Out] System::String ^ % strAssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessServerTlb : string * string * string * string *  *  *  -&gt; unit&#xA;override this.ProcessServerTlb : string * string * string * string *  *  *  -&gt; unit" Usage="publish.ProcessServerTlb (ProgId, SrcTlbPath, PhysicalPath, Operation, strAssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="strAssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Der programmatische Bezeichner der Klasse.</param>
        <param name="SrcTlbPath">Der Pfad der Datei, die die Typbibliothek enthält.</param>
        <param name="PhysicalPath">Das Verzeichnis der Webanwendung.</param>
        <param name="Operation">Der auszuführende Vorgang.</param>
        <param name="strAssemblyName">Nach dem Beenden dieser Methode enthält dieser Parameter den Anzeigenamen der Assembly.</param>
        <param name="TypeName">Nach dem Beenden dieser Methode enthält dieser Parameter den voll gekennzeichneten Typnamen der Assembly.</param>
        <param name="Error">Nach dem Beenden dieser Methode enthält dieser Parameter eine Fehlermeldung, wenn ein Problem aufgetreten ist.</param>
        <summary>Verarbeitet eine Servertypbibliothek, indem den Dateien Web.config und Default.disco Einträge hinzugefügt oder daraus gelöscht werden. Generiert einen Proxy, sofern erforderlich.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.ProcessServerTlb%2A>Fügt der Ermittlungs Datei und der Datei "Web. config" für die Komponenten in der Typbibliothek einen Eintrag hinzu und generiert oder kopiert einen Proxy für nicht verwaltete Komponenten in das bin-Verzeichnis. Wenn `Operation` "Delete" ist, werden die Komponenten Einträge aus den Dateien "Web. config" und "default. Disco" entfernt.  
  
 Es wird empfohlen, <xref:System.EnterpriseServices.Internal.SoapServerTlb.AddServerTlb%2A> und <xref:System.EnterpriseServices.Internal.SoapServerTlb.DeleteServerTlb%2A> anstelle von <xref:System.EnterpriseServices.Internal.Publish.ProcessServerTlb%2A>zu verwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.</exception>
        <exception cref="T:System.EnterpriseServices.ServicedComponentException">Der <paramref name="SrcTlbPath" />-Parameter enthielt einen Verweis auf scrobj.dll. Daher wird die SOAP-Veröffentlichung von Skriptkomponenten nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public void RegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.RegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAssembly : string -&gt; unit&#xA;override this.RegisterAssembly : string -&gt; unit" Usage="publish.RegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Der Dateisystempfad für die Assembly.</param>
        <summary>Registriert eine Assembly für COM-Interop.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.RegisterAssembly%2A>verwendet das Assembly Registration-Tool (Regasm. exe), um die erstellbar baren Klassen in der Assembly zu registrieren. Weitere Informationen finden Sie unter [Regasm. exe (Assembly Registration-Tool)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.EnterpriseServices.RegistrationException">Die Eingabeassembly besitzt keinen starken Namen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.  
  
- oder - 
Eine Codebasis, die nicht mit "file://" beginnt, wurde ohne die erforderliche <see cref="T:System.Net.WebPermission" /> angegeben.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="AssemblyPath" /> wurde nicht gefunden, oder eine Dateinamenerweiterung wurde nicht angegeben.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" /> ist keine gültige Assembly.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen, oder der Assemblyname überschreitet die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.InvalidOperationException">Eine mit <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> gekennzeichnete Methode ist nicht <see langword="static" />.  
  
- oder - 
Auf einer bestimmten Ebene der Hierarchie sind mehrere mit <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> markierte Methoden vorhanden.  
  
- oder - 
Die Signatur der mit <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> gekennzeichneten Methode ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, auf die Registrierung zuzugreifen. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">zum Ermitteln des aktuellen Verzeichnisses. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.AllAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen eines URIs, der mit "file://" beginnt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">zum Lesen eines URIs, der nicht mit "file://" beginnt.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnRegisterAssembly">
      <MemberSignature Language="C#" Value="public void UnRegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnRegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.UnRegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnRegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnRegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member UnRegisterAssembly : string -&gt; unit&#xA;override this.UnRegisterAssembly : string -&gt; unit" Usage="publish.UnRegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Der Dateisystempfad für die Assembly.</param>
        <summary>Hebt die Registrierung einer COM-Interop-Assembly auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.UnRegisterAssembly%2A>verwendet Regasm. exe, um die Registrierung der erstellbar baren Klassen in der Assembly aufzuheben. Weitere Informationen finden Sie unter [Regasm. exe (Assembly Registration-Tool)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufkette verfügt nicht über die Berechtigung für den Zugriff auf nicht verwalteten Code.  
  
- oder - 
Eine Codebasis, die nicht mit "file://" beginnt, wurde ohne die erforderliche <see cref="T:System.Net.WebPermission" /> angegeben.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="AssemblyPath" /> wurde nicht gefunden, oder es wurde keine Dateinamenerweiterung angegeben.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" /> ist keine gültige Assembly.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen, oder der Assemblyname überschreitet die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.InvalidOperationException">Eine mit <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> gekennzeichnete Methode ist nicht <see langword="static" />.  
  
- oder - 
Auf einer bestimmten Ebene der Hierarchie sind mehrere mit <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> markierte Methoden vorhanden.  
  
- oder - 
Die Signatur der mit <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> gekennzeichneten Methode ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, auf die Registrierung zuzugreifen. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">zum Ermitteln des aktuellen Verzeichnisses. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.AllAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen eines URIs, der mit "file://" beginnt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">zum Lesen eines URIs, der nicht mit "file://" beginnt.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
