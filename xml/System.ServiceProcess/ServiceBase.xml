<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d659a5675f8e308404ab56d663607e4230bf1530" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530904" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Basisklasse für einen Dienst als Teil einer Dienstanwendung bereit. <see cref="T:System.ServiceProcess.ServiceBase" /> muss abgeleitet werden, wenn eine neue Dienstklasse erstellt wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ableiten von <xref:System.ServiceProcess.ServiceBase> beim Definieren Ihrer Dienstklasse in einer dienstanwendung. Sinnvoller Dienst Außerkraftsetzungen der <xref:System.ServiceProcess.ServiceBase.OnStart%2A> und <xref:System.ServiceProcess.ServiceBase.OnStop%2A> Methoden. Sie können zusätzliche Funktionen überschreiben <xref:System.ServiceProcess.ServiceBase.OnPause%2A> und <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> mit bestimmten Verhalten als Reaktion auf Änderungen im Status "Dienst".  
  
 Ein Dienst ist eine lang ausgeführte ausführbare Datei, die eine Benutzeroberfläche nicht unterstützt und welche möglicherweise nicht unter dem Konto des angemeldeten Benutzers ausgeführt. Der Dienst kann ohne dass ein Benutzer auf dem Computer angemeldet wird ausgeführt.  
  
 Führen Sie Dienste standardmäßig unter dem Systemkonto, die nicht identisch mit dem Administratorkonto an. Sie können die Rechte des Systemkontos nicht ändern. Alternativ können Sie eine <xref:System.ServiceProcess.ServiceProcessInstaller> ein Benutzerkonto angeben, unter dem der Dienst ausgeführt wird.  
  
 Eine ausführbare Datei kann mehrere Dienste enthalten, jedoch muss ein separates enthalten <xref:System.ServiceProcess.ServiceInstaller> für jeden Dienst. Die <xref:System.ServiceProcess.ServiceInstaller> Instanz registriert den Dienst im System. Das Installationsprogramm ordnet jedem Dienst mit einem Ereignisprotokoll, die Sie verwenden können, um Befehle aufzuzeichnen. Die `main()` Funktion in der ausführbaren Datei definiert, welche Dienste ausgeführt werden sollen. Das aktuelle Arbeitsverzeichnis des Diensts ist das Systemverzeichnis nicht das Verzeichnis, in dem sich die ausführbare Datei befindet.  
  
 Wenn Sie einen Dienst starten, wird das System die ausführbaren Datei sucht und führt die <xref:System.ServiceProcess.ServiceBase.OnStart%2A> Methode für diesen Dienst, in die ausführbare Datei enthalten sind. Allerdings ist mit dem Dienst nicht identisch mit der Ausführung der ausführbaren Datei. Die ausführbare Datei lädt nur den Dienst. Der Dienst wird über den Dienststeuerungs-Manager (z. B. gestartet oder beendet) zugegriffen.  
  
 Die ausführbare Datei ruft der <xref:System.ServiceProcess.ServiceBase> abgeleitete Klasse Konstruktor das erste Mal auf den Dienst starten aufrufen. Die <xref:System.ServiceProcess.ServiceBase.OnStart%2A> befehlsverarbeitung-Methode wird aufgerufen, sobald der Konstruktor führt. Der Konstruktor wird nicht erneut nach dem ersten Mal mit der Dienst geladen wurde, ausgeführt, daher ist es erforderlich, unterteilen die Verarbeitung durch den Konstruktor aus, die durchgeführt <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Alle Ressourcen, die durch freigegeben werden können <xref:System.ServiceProcess.ServiceBase.OnStop%2A> erstellt werden soll, im <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Erstellen von Ressourcen im Konstruktor verhindert, dass sie ordnungsgemäß erstellt werden, wenn der Dienst gestartet wurde, erneut nach <xref:System.ServiceProcess.ServiceBase.OnStop%2A> wurde die Ressourcen freigegeben.  
  
 Der Dienststeuerungs-Manager (SCM) bietet eine Möglichkeit, mit dem Dienst interagieren. SCM können Sie starten, beenden, anhalten, fortsetzen oder benutzerdefinierte Befehle an den Dienst übergeben. SCM verwendet die Werte der <xref:System.ServiceProcess.ServiceBase.CanStop%2A> und <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> bestimmt, ob der Dienst, beenden akzeptiert, Anhalten oder Fortsetzen von Befehlen. Beenden, Anhalten und fortsetzen sind aktiviert, in dem SCM Kontext Menüs nur, wenn die entsprechende Eigenschaft <xref:System.ServiceProcess.ServiceBase.CanStop%2A> oder <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `true` in die Dienstklasse. Wenn aktiviert, wird der Befehl an den Dienst übergeben und <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, oder <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> aufgerufen wird. Wenn <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, oder <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `false`, die entsprechende befehlsverarbeitung-Methode (z. B. <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) nicht verarbeitet werden, auch wenn Sie die Methode implementiert haben.  
  
 Sie können die <xref:System.ServiceProcess.ServiceController> Klasse, um programmgesteuert tun, was den SCM verfügt über eine Benutzeroberfläche. Sie können in der Konsole verfügbaren Tasks automatisieren. Wenn <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, oder <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `true` , aber Sie haben eine entsprechende befehlsverarbeitung-Methode nicht implementiert (z. B. <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) des Systems löst eine Ausnahme aus und ignoriert den Befehl.  
  
 Sie müssen nicht implementieren <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, oder eine andere Methode in <xref:System.ServiceProcess.ServiceBase>. Allerdings ist das Verhalten des Diensts in beschriebenen <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, sodass mindestens bei diesem Member überschrieben werden sollte. Die `main()` Funktion der ausführbaren Datei registriert den Dienst in der ausführbaren Datei mit dem Dienststeuerungs-Manager durch Aufrufen der <xref:System.ServiceProcess.ServiceBase.Run%2A> Methode. Die <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Eigenschaft der <xref:System.ServiceProcess.ServiceBase> , übergeben die <xref:System.ServiceProcess.ServiceBase.Run%2A> Methode muss übereinstimmen. die <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> Eigenschaft des Service-Installers für diesen Dienst.  
  
 Sie können `InstallUtil.exe` Dienste auf Ihrem System installiert.  
  
> [!NOTE]
>  Sie können angeben, dass ein Protokoll als das Anwendungsereignisprotokoll, um Benachrichtigungen Dienstaufrufe jedoch weder die <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> noch die <xref:System.ServiceProcess.ServiceBase.EventLog%2A> Eigenschaft in ein benutzerdefiniertes Protokoll schreiben kann. Legen Sie <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> zu `false` , wenn Sie nicht automatische Protokollierung verwenden möchten.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.ServiceProcess.ServiceBase" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellen Sie eine Instanz der nicht der <xref:System.ServiceProcess.ServiceBase> Klasse. Leiten Sie stattdessen von <xref:System.ServiceProcess.ServiceBase> und die abgeleitete Klasse instanziieren. Die minimale müssen Sie im Konstruktor implementieren, für eine Klasse geerbt <xref:System.ServiceProcess.ServiceBase> besteht darin, die <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> in der Komponente. Keine weitere Verarbeitung ist insbesondere in den Konstruktor erforderlich. Sie sollten die meisten Initialisierung in behandeln <xref:System.ServiceProcess.ServiceBase.OnStart%2A> anstatt im Konstruktor. Andernfalls besteht keine Garantie, die die Objekte erneut initialisiert werden, wenn Sie einen Dienst neu starten, nachdem er beendet wurde.  
  
 Wenn Sie den Konstruktor in der abgeleiteten Klasse überschreiben, rufen Sie den Basisklassenkonstruktor im Code.  
  
 Die <xref:System.ServiceProcess.ServiceBase> Standardkonstruktor legt <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> auf `true`. Wenn Sie nicht automatisch Aufrufe an den Dienst aus der Service Control Manager (SCM) protokollieren möchten, legen Sie <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> auf `false`.  
  
 Wenn die ausführbare Datei einen einzelnen Dienst enthält, ruft das System Konstruktor des Dienstes aus, wenn Start, die von der SCM ausgewählt ist, und den Destruktor ausgeführt wird, wenn die Beendigung aufgerufen wird.  
  
 Wenn die ausführbare Datei mehrere Dienste enthält, beginnt, einen Dienst aufrufen bewirkt, dass die Konstruktoren für alle Dienste in der ausführbaren Datei aufgerufen werden, aber nur der angegebene Dienst wurde gestartet. Destruktoren für die Dienste werden zusammen ausgeführt werden, wenn alle Dienste, nicht einzeln angehalten wurden, wenn jeder Dienst beendet wird.  
  
> [!NOTE]
>  Wenn Sie den Konstruktor der Basisklasse überschreiben, müssen Sie explizit im Konstruktor der abgeleiteten Klasse aufrufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob die Befehle Starten, Beenden, Anhalten und Fortsetzen im Ereignisprotokoll aufgezeichnet werden sollen.</summary>
        <value>
          <see langword="true" />, wenn Informationen im Ereignisprotokoll aufgezeichnet werden sollen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen von <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> auf `true` weist den Dienst das Anwendungsereignisprotokoll Bericht Befehl Fehlern sowie auf statusänderungsinformationen für Start, Stop, Pause, und Ereignisse auf dem Dienst fortfahren. Der Name des Diensts wird verwendet, als des Protokolls <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>.  
  
 Informationen zum Windows-Anwendungsprotokoll, anstatt ein benutzerdefiniertes Ereignisprotokoll zu melden, legen Sie <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> auf `false` und Schreiben von Anweisungen innerhalb der Behandlungsmethoden für Befehl <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, oder <xref:System.ServiceProcess.ServiceBase.OnStop%2A> an das entsprechende Protokoll.  
  
> [!NOTE]
>  Die <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, der die Quellzeichenfolge für das Ereignisprotokoll bereitstellt, muss festgelegt werden, bevor der Dienst versucht, in das Ereignisprotokoll schreiben. Bei dem Versuch, die Zugriff auf das Ereignisprotokoll, bevor der Quellname festgelegt wird, löst eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Dienst Benachrichtigungen über Änderungen im Energiestatus des Computers verarbeiten kann, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der Dienst die in der <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />-Klasse angegebenen Änderungen im Energiestatus des Computers verarbeitet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Computer Power Status ändert, Service Control Manager (SCM) wird überprüft, ob der Dienst mit dem Wert des Ereignis-einschaltbefehle akzeptiert <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> ist `true`, der Befehl an den Dienst übergeben wird und die <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> Methode wird aufgerufen, wenn definiert. Wenn <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> ist nicht implementiert in der abgeleiteten Klasse behandelt die SCM der Power-Ereignis über die leere Basisklasse <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wird geändert, nachdem der Dienst gestartet wurde.</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Dienst Sitzungsänderungsereignisse aus einer Terminal Server-Sitzung behandeln kann, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der Dienst Terminal Server-Sitzungsänderungsereignisse behandeln kann; andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wird geändert, nachdem der Dienst gestartet wurde.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Dienst angehalten und wieder aufgenommen werden kann, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der Dienst angehalten werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie den Wert, der die <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> Eigenschaft im Konstruktor für den Dienst.  
  
 Wenn ein Dienst angehalten wird, hält er an, welche Aufgaben sie ausführen. Wenn Sie den Dienst (entweder über den Dienststeuerungs-Manager oder programmgesteuert), weiterhin <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> ausgeführt wird.  
  
 Eine Anforderung zum Anhalten der an den Dienst senden kann Systemressourcen sparen. Anhalten möglicherweise nicht alle Systemressourcen frei, jedoch wird beendet. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> und <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> werden häufig implementiert, um weniger Verarbeitungszeit als <xref:System.ServiceProcess.ServiceBase.OnStop%2A> und <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `true`, außer Kraft setzen <xref:System.ServiceProcess.ServiceBase.OnPause%2A> und <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> die Verarbeitung an, die ausgeführt werden soll, wenn der Dienststeuerungs-Manager (SCM) eine Anforderung zum Anhalten oder fortsetzen an den Dienst übergeben. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> implementiert werden sollte, um die Verarbeitung in rückgängig machen <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `false`, übergibt die SCM nicht anhalten oder fortsetzen Anforderungen an den Dienst, sodass die <xref:System.ServiceProcess.ServiceBase.OnPause%2A> und <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> Methoden werden nicht aufgerufen werden, auch wenn sie implementiert werden. Im dienststeuerungs-Manager der `Pause` und `Continue` Steuerelemente sind deaktiviert, wenn <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde bereits gestartet. Die <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />-Eigenschaft kann nach dem Start des Diensts nicht mehr geändert werden.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Dienst beim Herunterfahren des Systems benachrichtigt werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der Dienst beim Herunterfahren des Systems benachrichtigt werden soll, andernfalls <see langword="false" />.  Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> ist `true`, der Dienst wird benachrichtigt, wenn das System heruntergefahren wird. Beim Herunterfahren der <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> Methode wird aufgerufen, wenn es in der abgeleiteten Klasse implementiert wurde.  
  
> [!NOTE]
>  Nur das System sollte dazu führen, dass die <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> Methode für die Ausführung der Dienst aufrufen, aber dies wird nicht empfohlen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde bereits gestartet. Die <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />-Eigenschaft kann nach dem Start des Diensts nicht mehr geändert werden.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Dienst nach dem Starten beendet werden kann, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der Dienst angehalten und die <see cref="M:System.ServiceProcess.ServiceBase.OnStop" />-Methode aufgerufen werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Beenden eines Diensts aufgerufen wird, wird der Dienststeuerungs-Manager (SCM) überprüft, ob es sich bei der Dienst beenden-Befehle, die mit dem Wert des akzeptiert <xref:System.ServiceProcess.ServiceBase.CanStop%2A>. Für die meisten Dienste, die den Wert der <xref:System.ServiceProcess.ServiceBase.CanStop%2A> ist `true`, aber einige Betriebssystemdiensten können z. B. nicht den Benutzer, die sie beenden.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanStop%2A> ist `true`, wird der Befehl zum Beenden an den Dienst übergeben und die <xref:System.ServiceProcess.ServiceBase.OnStop%2A> Methode wird aufgerufen, wenn er definiert ist. Wenn <xref:System.ServiceProcess.ServiceBase.OnStop%2A> ist nicht in der abgeleiteten Klasse, die SCM-Handles, die zum Beenden der Befehl über die leere Basisklasse implementiert <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde bereits gestartet. Die <see cref="P:System.ServiceProcess.ServiceBase.CanStop" />-Eigenschaft kann nach dem Start des Diensts nicht mehr geändert werden.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.ServiceProcess.ServiceBase" />-Klasse verwendeten Ressourcen (mit Ausnahme des Speichers) frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.ServiceProcess.ServiceBase.Dispose%2A> in die abgeleitete Klasse (und dadurch in die <xref:System.ServiceProcess.ServiceBase> Klasse) Sie abschließend die abgeleitete Klasse verwenden. Die <xref:System.ServiceProcess.ServiceBase.Dispose%2A> Methode bewirkt, dass die abgeleitete Klasse in einem nicht verwendbaren Zustand. Nach dem Aufruf <xref:System.ServiceProcess.ServiceBase.Dispose%2A>, müssen Sie alle Verweise auf die abgeleitete Klasse freigeben und <xref:System.ServiceProcess.ServiceBase> , damit der belegte Arbeitsspeicher von der Garbagecollection wieder zugänglich gemacht werden kann.  
  
> [!NOTE]
>  Rufen Sie immer <xref:System.ServiceProcess.ServiceBase.Dispose%2A> , bevor Sie den letzten Verweis auf die Klasse abgeleitet freigeben <xref:System.ServiceProcess.ServiceBase>. Andernfalls, die Ressourcen <xref:System.ServiceProcess.ServiceBase> und die abgeleitete Klasse wird nicht freigegeben werden, bis die Garbagecollection den Destruktor des Objekts aufruft.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> wird häufig implementiert, um den Code in verarbeiten <xref:System.ServiceProcess.ServiceBase.OnPause%2A>kombiniert mit einem Aufruf von <xref:System.ServiceProcess.ServiceBase.Dispose%2A>. Wenn Sie dazu in der abgeleiteten Klasse auswählen, wird normalerweise implementiert, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> zuweisen nach Belieben <xref:System.ServiceProcess.ServiceBase.Dispose%2A> freigegeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Ereignisprotokoll ab, mit dem Sie Benachrichtigungen über Aufrufe von Dienstbefehlen wie Starten und Beenden in das Anwendungsereignisprotokoll schreiben können.</summary>
        <value>Eine <see cref="T:System.Diagnostics.EventLog" />-Instanz, deren Quelle im Anwendungsprotokoll registriert ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Konstruktor initialisiert die <xref:System.ServiceProcess.ServiceBase.EventLog%2A> Eigenschaft zu einer Instanz mit der <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> und <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> festgelegten Eigenschaften. Die Quelle ist die <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> des Diensts, und das Protokoll ist Anwendungsprotokoll des Computers. Diese Werte werden automatisch festgelegt und können nicht geändert werden, für die automatische Protokollierung von Dienstbefehlen.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> ist `true`, starten, beenden, anhalten, fortsetzen und benutzerdefinierte Befehle werden automatisch in das Anwendungsereignisprotokoll aufgezeichnet. Sie können die <xref:System.ServiceProcess.ServiceBase.EventLog%2A> Eigenschaft in dieses Protokoll auch zusätzliche Nachrichten schreiben. Die Komponente ruft <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> mit diesem <xref:System.ServiceProcess.ServiceBase.EventLog%2A> Member.  
  
 Informationen zum Windows-Anwendungsprotokoll, anstatt ein benutzerdefiniertes Ereignisprotokoll zu melden, legen Sie <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> auf `false` und Schreiben von Anweisungen innerhalb der Behandlungsmethoden für Befehl <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, oder <xref:System.ServiceProcess.ServiceBase.OnStop%2A> an das entsprechende Protokoll.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Exitcode für den Dienst ab oder legt diesen fest.</summary>
        <value>Der Exitcode für den Dienst.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie die <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> Eigenschaft auf einen Wert ungleich 0 (null) vor dem Beenden des Diensts zur Anzeige ein Fehlers mit dem Dienststeuerungs-Manager.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>Gibt die maximale Größe für einen Dienstnamen an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName und DisplayName haben beide Größe Einschränkungen müssen, beim Festlegen der Eigenschaften auf die Dienstklasse berücksichtigt werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bei der Implementierung in einer abgeleiteten Klasse wird <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> ausgeführt, wenn der Dienststeuerungs-Manager einen Befehl zum Fortsetzen an den Dienst sendet. Gibt Aktionen an, die durchgeführt werden müssen, wenn der normale Betrieb eines Diensts nach dem Anhalten wieder aufgenommen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementieren <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> zum Spiegeln von Ihrer Anwendung als Antwort auf <xref:System.ServiceProcess.ServiceBase.OnPause%2A>. Wenn Sie den Dienst (entweder programmgesteuert oder mit der Konsole Dienste), weiterhin die <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> Verarbeitung ausgeführt wird und der Dienst wird wieder aktiviert.  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> Wenn außer Kraft gesetzt werden soll die <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> Eigenschaft ist `true`.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `false`, übergibt die SCM nicht anhalten oder fortsetzen Anforderungen an den Dienst, sodass die <xref:System.ServiceProcess.ServiceBase.OnPause%2A> und <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> Methoden werden nicht aufgerufen werden, auch wenn sie implementiert werden. Im dienststeuerungs-Manager der `Pause` und `Continue` Steuerelemente sind deaktiviert, wenn <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">Die an den Dienst gesendete Befehlsnachricht.</param>
        <summary>Bei der Implementierung in einer abgeleiteten Klasse wird <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> ausgeführt, wenn der Dienststeuerungs-Manager einen benutzerdefinierten Befehl an den Dienst übergibt. Gibt an, welche Aktionen auszuführen sind, wenn ein Befehl mit dem angegebenen Parameter auftritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> können Sie zusätzliche Funktionalität jenseits von starten, beenden, Anhalten und fortsetzen Dienste angeben.  
  
 SCM ist nicht untersuchen Sie die benutzerdefinierten Befehls zu überprüfen, ob der Dienst unterstützt die `command` übergebene Parameter. Den benutzerdefinierten Befehl übergibt direkt an den Dienst. Wenn der Dienst nicht erkennt die `command` Parameter, es wird keine Aktion ausgeführt.  
  
 Benutzerdefinierte Befehle werden ausgelöst, indem ein <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> -Anweisung in einer <xref:System.ServiceProcess.ServiceController> Komponente. Verwenden Sie eine Switch-Anweisung oder, wenn... Klicken Sie dann Bedingung, die benutzerdefinierte Befehle zu verarbeiten, die Sie für Ihren Dienst definieren.  
  
 Nur die Werte für einen benutzerdefinierten Befehl, die Sie in Ihrer Anwendung definieren oder verwenden Sie in <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> sind diejenigen zwischen 128 und 255. Ganze Zahlen unter 128 entsprechen Werten System reserviert.  
  
 Wenn die <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> Eigenschaft `true`, Schreiben von benutzerdefinierten Befehlen, wie alle anderen Befehle Einträge in das Ereignisprotokoll zum melden, ob die Ausführung der Methode erfolgreich war oder nicht.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird bei der Implementierung in einer abgeleiteten Klasse ausgeführt, wenn der Dienststeuerungs-Manager einen Befehl zum Anhalten an den Dienst sendet. Gibt Aktionen an, die beim Anhalten eines Diensts durchgeführt werden müssen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.ServiceProcess.ServiceBase.OnPause%2A> die Verarbeitung an, das auftritt, wenn der Dienst einen Befehl zum Anhalten empfängt. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> Wenn außer Kraft gesetzt werden soll die <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> Eigenschaft ist `true`.  
  
 Wenn Sie einen angehaltenen Dienst (entweder programmgesteuert oder mit der Konsole Dienste), weiterhin die <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> Verarbeitung ausgeführt wird, und der Dienst wird wieder aktiviert.  
  
 Der Befehl "Pause" kann nur die Anwendung, auf ein bestimmtes Ereignis zu reagieren. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> führt keine Aktion an den Dienst, den Sie nicht mit dem definieren.  
  
 Eine Anforderung zum Anhalten der an den Dienst senden kann Systemressourcen beibehalten werden, da anhalten nicht alle Systemressourcen freigeben muss. Wenn Threads sein, durch den Prozess geöffnet worden, einen Dienst anhalten, anstatt durch beendet die Threads geöffnet bleiben kann sodass z. B. die Notwendigkeit, sie neu zuordnen, wenn der Dienst weiterhin auf. Wenn Sie anhalten, um Systemressourcen freizugeben definieren, verhält er wie ein Befehl zum Beenden.  
  
 Legen Sie <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> auf `true`, und überschreiben <xref:System.ServiceProcess.ServiceBase.OnPause%2A> und <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> an, die auftreten soll, wenn die SCM eine Anforderung zum Anhalten oder Fortsetzen mit dem Dienst übergibt die Verarbeitung. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> implementiert werden sollte, um die Verarbeitung in rückgängig machen <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `false`, übergibt die SCM nicht anhalten oder fortsetzen Anforderungen an den Dienst, sodass die <xref:System.ServiceProcess.ServiceBase.OnPause%2A> und <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> Methoden werden nicht aufgerufen werden, auch wenn implementiert. Im dienststeuerungs-Manager der `Pause` und `Continue` Steuerelemente sind deaktiviert, wenn <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">Ein <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />, der eine Benachrichtigung des Systems über dessen Energiestatus angibt.</param>
        <summary>Wird bei der Implementierung in einer abgeleiteten Klasse ausgeführt, wenn sich der Energiestatus des Computers geändert hat. Dies gilt für Laptops, wenn diese in den Standbymodus wechseln. Dieser entspricht nicht dem Herunterfahren des Systems.</summary>
        <returns>Bei Implementierung in einer abgeleiteten Klasse bestimmen die Anforderungen der Anwendung, welcher Wert zurückzugeben ist. Wenn beispielsweise ein <see langword="QuerySuspend" />-Broadcaststatus übergeben wird, können Sie die Anwendung veranlassen, die Abfrage durch Rückgabe <see langword="false" /> abzulehnen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> an tritt auf, wenn das Systemereignis in angegeben. die Verarbeitung der <xref:System.ServiceProcess.PowerBroadcastStatus> Enumeration auftritt – z. B. wenn der Computer im angehaltenen Modus befindet oder niedriger Batteriestand angibt.  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> Wenn außer Kraft gesetzt werden soll die <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> Eigenschaft ist `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" />
      </Parameters>
      <Docs>
        <param name="changeDescription">Eine -Struktur, die den Änderungstyp angibt.</param>
        <summary>Wird ausgeführt, wenn ein Änderungsereignis von einer Terminal Server-Sitzung empfangen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen festlegen, die <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> Eigenschaft, um `true` So aktivieren Sie die Ausführung dieser Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird bei der Implementierung in einer abgeleiteten Klasse beim Herunterfahren des Systems ausgeführt. Gibt an, welche Vorgänge unmittelbar vor dem Herunterfahren des Systems ausgeführt werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> die Verarbeitung an, das auftritt, wenn das System heruntergefahren wird.  
  
 Dieses Ereignis tritt nur auf, wenn das Betriebssystem heruntergefahren ist, nicht verwendet werden, wenn der Computer ausgeschaltet ist.  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> Wenn außer Kraft gesetzt werden soll die <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> Eigenschaft ist `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Vom Befehl zum Starten übergebene Daten.</param>
        <summary>Wird bei der Implementierung in einer abgeleiteten Klasse ausgeführt, wenn der Dienststeuerungs-Manager einen Befehl zum Starten an den Dienst sendet oder wenn das Betriebssystem gestartet wird (diese gilt für Dienste, die automatisch gestartet werden). Gibt Aktionen an, die beim Starten des Diensts ausgeführt werden müssen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.ServiceProcess.ServiceBase.OnStart%2A> die Verarbeitung an, das auftritt, wenn der Dienst einen Befehl zum Starten empfängt. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> ist die Methode, in der Sie das Verhalten des Diensts angeben. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> können Argumente als eine Möglichkeit, Daten zu übergeben, aber diese Verwendung ist selten.  
  
> [!CAUTION]
>  Verwenden Sie den Konstruktor nicht Verarbeitungen ausführen, die in sollten <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Verwendung <xref:System.ServiceProcess.ServiceBase.OnStart%2A> alle Initialisierung des Diensts zu behandeln. Der Konstruktor wird aufgerufen, wenn die Anwendung der ausführbaren ausgeführt wird, nicht verwendet werden, wenn der Dienst ausgeführt wird. Die ausführbare Datei ausgeführt wird, bevor Sie <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Wenn Sie, z. B. Fortfahren wird der Konstruktor nicht erneut aufgerufen, da der SCM das Objekt bereits im Arbeitsspeicher enthält. Wenn <xref:System.ServiceProcess.ServiceBase.OnStop%2A> in den Konstruktor statt im reservierten Ressourcen frei <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, würde die erforderlichen Ressourcen nicht erneut das zweite Mal wird der Dienst aufgerufen erstellt werden.  
  
 Für Dienste kann festgelegt werden, für den automatischen start beim Neustart des Computers durch Festlegen der <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> auf den Dienst-Installer, um <xref:System.ServiceProcess.ServiceStartMode.Automatic>. In einer solchen Situation <xref:System.ServiceProcess.ServiceBase.OnStart%2A> beim Systemstart aufgerufen.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> muss in der abgeleiteten Klasse außer Kraft gesetzt werden. Für den Dienst sind aussagekräftig sind, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> und <xref:System.ServiceProcess.ServiceBase.OnStop%2A> muss sowohl in Ihrer Dienstklasse implementiert werden.  
  
 Verarbeiten von Initialisierungsargumente für den Dienst in der <xref:System.ServiceProcess.ServiceBase.OnStart%2A> Methode nicht in der Main-Methode. Die Argumente in der `args` Parameterarray kann manuell im Fenster "Eigenschaften" für den Dienst in der Konsole Dienste festgelegt werden. In der Konsole eingegebenen Argumente werden nicht gespeichert. Sie werden an den Dienst einmalig übergeben, wenn der Dienst über die Systemsteuerung gestartet wird. Argumente, die vorhanden sein müssen, wenn der Dienst automatisch gestartet, platziert werden können, in die ImagePath-Zeichenfolgenwert für den Dienst-Registrierungsschlüssel (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\ * \< Dienstname >*). Sie erhalten die Argumente aus der Registrierung mithilfe der <xref:System.Environment.GetCommandLineArgs%2A> Methode, zum Beispiel: `string[] imagePathArgs = Environment.GetCommandLineArgs();`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird bei der Implementierung in einer abgeleiteten Klasse ausgeführt, wenn der Dienststeuerungs-Manager einen Befehl zum Beenden an den Dienst sendet. Gibt Aktionen an, die beim Beenden eines Diensts auszuführen sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.ServiceProcess.ServiceBase.OnStop%2A> die Verarbeitung an, das auftritt, wenn der Dienst einen Befehl zum Beenden empfängt.  
  
 Wenn der SCM einen Befehl zum Beenden empfängt, verwendet Sie den Wert der <xref:System.ServiceProcess.ServiceBase.CanStop%2A> zu überprüfen, ob der Dienst beenden Befehle akzeptiert. Wenn <xref:System.ServiceProcess.ServiceBase.CanStop%2A> ist `true`, wird der Befehl zum Beenden an den Dienst übergeben und die <xref:System.ServiceProcess.ServiceBase.OnStop%2A> Methode wird aufgerufen, wenn er definiert ist. Wenn <xref:System.ServiceProcess.ServiceBase.OnStop%2A> ist nicht implementiert der Dienst behandelt SCM Befehl zum Beenden.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanStop%2A> ist `false`, der SCM, ignoriert der Befehl zum Beenden. Es ist nicht an den Dienst übergeben. Der Befehl zum Beenden gibt zurück und löst eine Ausnahme aus.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> muss in der abgeleiteten Klasse außer Kraft gesetzt werden. Für den Dienst sind aussagekräftig sind, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> und <xref:System.ServiceProcess.ServiceBase.OnStop%2A> muss sowohl in Ihrer Dienstklasse implementiert werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Die angeforderte Zeit in Millisekunden.</param>
        <summary>Fordert zusätzliche Zeit für eine ausstehende Operation an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> Methode aufgerufen werden soll von der überschriebenen <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, oder <xref:System.ServiceProcess.ServiceBase.OnStop%2A> Methoden, um zusätzliche Zeit für einen ausstehenden Vorgang, um zu verhindern, dass der Dienststeuerungs-Manager (SCM)-Kennzeichnung Anfordern der der Dienst reagiert nicht mehr.  Wenn der ausstehende Vorgang keine fortfahren, anhalten, starten oder beenden, ist ein <xref:System.InvalidOperationException> ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Dienst steht nicht aus.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stellt den Haupteinstiegspunkt für die ausführbare Datei eines Diensts bereit.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">Eine <see cref="T:System.ServiceProcess.ServiceBase" />, die einen zu startenden Dienst angibt.</param>
        <summary>Registriert die ausführbare Datei für einen Dienst im Dienststeuerungs-Manager.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Überladung in der `main()` Funktion, der den Dienst mit dem Dienststeuerungs-Manager registrieren ausführbaren Dienstdatei. Nach dem Aufruf <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>, der Dienstkontroll-Manager stellt einen Befehl zum Starten, dies zu einem Aufruf führt der <xref:System.ServiceProcess.ServiceBase.OnStart%2A> Methode im Dienst. Der Dienst wird nicht gestartet, bis der Startbefehl ausgeführt wird.  
  
 Die <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> Methode wird aufgerufen, in die gleiche Weise wie <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> für Windows Forms-Anwendungen.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> ist `true`, wird ein Eintrag in das Ereignisprotokoll geschrieben, wenn der Dienst vom angegebenen der `service` Parameter nicht gestartet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="service" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">Ein Array von ServiceBase-Instanzen, die zu startende Dienste angeben.</param>
        <summary>Registriert die ausführbare Datei für mehrere Dienste im Dienststeuerungs-Manager.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Überladung in der `main()` Funktion des Diensts, die ausführbare Datei, um die Dienste mit dem Dienststeuerungs-Manager zu registrieren. Nach dem Aufruf <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>, der Dienstkontroll-Manager gibt die Start-Befehle, in aufrufen, wodurch die <xref:System.ServiceProcess.ServiceBase.OnStart%2A> Methoden in den Diensten. Die Dienste werden nicht gestartet werden, bis die Start-Befehle ausgeführt werden.  
  
 Die <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> Methode wird aufgerufen, in die gleiche Weise wie die <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> Methode für Windows Forms-Anwendungen.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> ist `true`, wird ein Eintrag in das Ereignisprotokoll geschrieben, wenn ein Dienst im Array nicht gestartet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Sie haben keinen zu startenden Dienst angegeben. Das Array ist u. U. <see langword="null" /> oder leer.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Dienststeuerungshandle für den Dienst ab.</summary>
        <value>Eine <see cref="T:System.IntPtr" />-Struktur, die das Dienststeuerungshandle für den Dienst enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Kontrollpunkt Service dient zum Kommunizieren mit dem Dienststeuerungs-Manager (SCM).  Das Handle kann zum Aktualisieren des dienststeuerungs-Manager-Statusinformationen für den aufrufenden Dienst mithilfe der nicht verwalteten `SetServiceStatus` Funktion.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" />
        <Parameter Name="argPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="argCount">Die Anzahl der Argumente im Argumentarray.</param>
        <param name="argPointer">Eine <see cref="T:System.IntPtr" />-Struktur, die auf ein Array von Argumenten zeigt.</param>
        <summary>Registriert den Befehlshandler und startet den Dienst.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zur Bezeichnung des Diensts beim System verwendeten kurzen Namen ab oder legt diesen fest.</summary>
        <value>Der Name des Diensts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> identifiziert den Dienst mit dem Dienststeuerungs-Manager. Der Wert dieser Eigenschaft muss identisch mit dem Namen für den Dienst in der <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> Eigenschaft des entsprechenden Installerklasse. Im Code der <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> des Diensts wird in der Regel legen Sie der `main()` Funktion der ausführbaren Datei.  
  
 Die <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> dient auch zum Angeben der <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> zugeordneten der <xref:System.ServiceProcess.ServiceBase.EventLog%2A> Eigenschaft. Dies <xref:System.ServiceProcess.ServiceBase.EventLog%2A> ist eine Instanz, die die Informationen zum Befehl in das Anwendungsprotokoll schreibt.  
  
 Die <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, der die Quellzeichenfolge für das Ereignisprotokoll bereitstellt, muss festgelegt werden, bevor der Dienst in das Ereignisprotokoll schreibt. Beim Versuch, das Ereignisprotokoll zugreifen, bevor der Quellname festgelegt wird, eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde bereits gestartet. Die <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" />-Eigenschaft kann nach dem Start des Diensts nicht mehr geändert werden.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Name ist eine Zeichenfolge der Länge 0 (null) oder ist länger als <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />, oder der angegebene Name enthält Schrägstriche oder umgekehrte Schrägstriche.</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet den ausgeführten Dienst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ServiceProcess.ServiceBase.Stop%2A> Methode legt fest, den Status des Dienstes an, dass eine Beenden steht aus und ruft die <xref:System.ServiceProcess.ServiceBase.OnStop%2A> Methode.  Nachdem die Anwendung beendet ist, wird der Dienstzustand auf beendet festgelegt. Wenn die Anwendung einen gehosteten Dienst ist, wird die Anwendungsdomäne entladen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>