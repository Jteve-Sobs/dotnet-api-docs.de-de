<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5b1aaccb64f4a9857d9314205565f907757c1f09" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49158381" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Basisklasse für einen Dienst als Teil einer Dienstanwendung bereit. <see cref="T:System.ServiceProcess.ServiceBase" /> muss abgeleitet werden, wenn eine neue Dienstklasse erstellt wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leiten Sie von <xref:System.ServiceProcess.ServiceBase> beim Definieren Ihrer Dienstklasse in einer dienstanwendung. Sinnvoller Dienst Außerkraftsetzungen der <xref:System.ServiceProcess.ServiceBase.OnStart%2A> und <xref:System.ServiceProcess.ServiceBase.OnStop%2A> Methoden. Sie können zusätzliche Funktionen, überschreiben <xref:System.ServiceProcess.ServiceBase.OnPause%2A> und <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> mit bestimmten Verhalten als Reaktion auf Änderungen in den Status des Dienstes.  
  
 Ein Dienst ist eine lang ausgeführte ausführbare Datei, die Benutzeroberfläche nicht unterstützt und welche möglicherweise nicht unter dem Konto des angemeldeten Benutzers ausgeführt. Der Dienst kann ohne beliebiger Benutzer angemeldet wird, auf dem Computer ausgeführt.  
  
 Führen in der Standardeinstellung Dienste unter dem Konto System, das nicht ist identisch mit dem Administratorkonto an. Sie können die Rechte von dem Konto System nicht ändern. Alternativ können Sie verwenden eine <xref:System.ServiceProcess.ServiceProcessInstaller> an ein Benutzerkonto, unter dem der Dienst ausgeführt wird.  
  
 Eine ausführbare Datei kann mehr als ein Dienst muss enthalten allerdings ein separates <xref:System.ServiceProcess.ServiceInstaller> für jeden Dienst. Die <xref:System.ServiceProcess.ServiceInstaller> Instanz registriert den Dienst im System. Das Installationsprogramm ordnet jedem Dienst mit einem Ereignisprotokoll, die Sie zum Zeichnen-Befehle verwenden können. Die `main()` Funktion in der ausführbaren Datei definiert, welche Dienste ausgeführt werden soll. Das aktuelle Arbeitsverzeichnis des Diensts ist das Systemverzeichnis und nicht das Verzeichnis, in dem sich die ausführbare Datei befindet.  
  
 Wenn Sie einen Dienst starten, wird das System sucht nach der ausführbaren Datei und führt die <xref:System.ServiceProcess.ServiceBase.OnStart%2A> Methode für diesen Dienst, in die ausführbare Datei enthalten sind. Allerdings ist der Dienst ausgeführt wird nicht dasselbe wie das Ausführen der ausführbaren Datei. Die ausführbare Datei lädt nur den Dienst. Der Dienst wird über den Dienststeuerungs-Manager (z. B. gestartet oder beendet) zugegriffen.  
  
 Die ausführbare Datei ruft der <xref:System.ServiceProcess.ServiceBase> abgeleitete Klasse Konstruktor das erste Mal auf den Dienst starten aufrufen. Die <xref:System.ServiceProcess.ServiceBase.OnStart%2A> Befehlsbehandlung Methode wird aufgerufen, unmittelbar nach dem Ausführen des Konstruktors. Der Konstruktor wird nicht nach der ersten Zeit, die der Dienst geladen wurde, erneut ausgeführt, daher ist es erforderlich, trennen Sie die Verarbeitung durch den Konstruktor aus, die ausgeführt werden, indem <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Alle Ressourcen, die durch freigegeben werden können <xref:System.ServiceProcess.ServiceBase.OnStop%2A> erstellt werden soll, im <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Erstellen von Ressourcen im Konstruktor verhindert, dass sie ordnungsgemäß erstellt wird, wenn der Dienst, später gestartet wurde <xref:System.ServiceProcess.ServiceBase.OnStop%2A> Freigabe der Ressourcen.  
  
 Das Service Control Manager (SCM) bietet eine Möglichkeit, mit dem Dienst interagieren. Sie können den dienststeuerungs-Manager verwenden, zu starten, beenden, anhalten, fortsetzen oder benutzerdefinierte Befehle an den Dienst übergeben. Dienststeuerungs-Manager verwendet die Werte der <xref:System.ServiceProcess.ServiceBase.CanStop%2A> und <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> um zu bestimmen, ob der Dienst, beenden akzeptiert, Anhalten oder Fortsetzen von Befehlen. Beenden, Anhalten und fortsetzen aktiviert sind, in den dienststeuerungs-Manager-Kontext Menüs nur, wenn die entsprechende Eigenschaft <xref:System.ServiceProcess.ServiceBase.CanStop%2A> oder <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `true` in der Dienstklasse. Wenn aktiviert, wird der Befehl an den Dienst übergeben und <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, oder <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> aufgerufen wird. Wenn <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, oder <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `false`, die entsprechende Methode für die Behandlung von Befehlen (z. B. <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) wird nicht verarbeitet werden, auch wenn Sie die Methode implementiert haben.  
  
 Sie können die <xref:System.ServiceProcess.ServiceController> Klasse programmgesteuert welche dienststeuerungs-Manager, verfügt über eine Benutzeroberfläche. Sie können in der Konsole verfügbaren Tasks automatisieren. Wenn <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, oder <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `true` jedoch eine entsprechende Befehlsbehandlung-Methode nicht implementiert haben (z. B. <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) das System löst eine Ausnahme aus und ignoriert den Befehl.  
  
 Sie müssen keine implementieren <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, oder eine andere Methode im <xref:System.ServiceProcess.ServiceBase>. Verhalten des Diensts wird jedoch beschrieben, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, sodass mindestens dieser Member überschrieben werden soll. Die `main()` Funktion der ausführbaren Datei registriert den Dienst in der ausführbaren Datei mit dem Dienststeuerungs-Manager durch Aufrufen der <xref:System.ServiceProcess.ServiceBase.Run%2A> Methode. Die <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Eigenschaft der <xref:System.ServiceProcess.ServiceBase> , übergeben die <xref:System.ServiceProcess.ServiceBase.Run%2A> Methode entsprechen muss die <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> Eigenschaft das Dienstinstallationsprogramm für diesen Dienst.  
  
 Sie können `InstallUtil.exe` Dienste auf Ihrem System installieren.  
  
> [!NOTE]
>  Sie können angeben, dass ein anderes Protokoll als das Ereignisprotokoll der Anwendung zum Empfangen von Benachrichtigungen über Dienstaufrufe, aber keine der <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> noch die <xref:System.ServiceProcess.ServiceBase.EventLog%2A> Eigenschaft in ein benutzerdefiniertes Protokoll schreiben. Legen Sie <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> zu `false` , wenn Sie keine automatische Protokollierung verwenden möchten.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.ServiceProcess.ServiceBase" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellen Sie eine Instanz der nicht der <xref:System.ServiceProcess.ServiceBase> Klasse. Leiten Sie stattdessen von <xref:System.ServiceProcess.ServiceBase> und die abgeleitete Klasse zu instanziieren. Das Minimum implementiert werden müssen im Konstruktor für eine Klasse von geerbt <xref:System.ServiceProcess.ServiceBase> Festlegen der <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> in der Komponente. Ohne weitere Verarbeitung ist insbesondere in den Konstruktor erforderlich. Sie sollten die meisten Initialisierung in behandeln <xref:System.ServiceProcess.ServiceBase.OnStart%2A> anstatt im Konstruktor. Andernfalls besteht keine Garantie dafür, die die Objekte erneut initialisiert werden, wenn Sie einen Dienst neu starten, nachdem er beendet wurde.  
  
 Wenn Sie den Konstruktor in der abgeleiteten Klasse überschreiben, rufen Sie den Basisklassenkonstruktor in Ihrem Code.  
  
 Die <xref:System.ServiceProcess.ServiceBase> Kopierkonstruktor legt <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> zu `true`. Wenn Sie nicht automatisch Aufrufe an den Dienst aus der Service Control Manager (SCM) protokollieren möchten, legen Sie <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> zu `false`.  
  
 Wenn die ausführbare Datei auf einen einzelnen Dienst enthält, ruft das System Konstruktor des Diensts an, wenn Start, der vom dienststeuerungs-Manager aktiviert ist, und den Destruktor ausgeführt wird, wenn Stop aufgerufen wird.  
  
 Wenn die ausführbare Datei mehrere Dienste enthält, starten für einen Dienst aufrufen führt dazu, dass die Konstruktoren für alle Dienste in der ausführbaren Datei aufgerufen werden, aber nur der angegebene Dienst wurde gestartet. Destruktoren für die Dienste werden gemeinsam ausgeführt werden, wenn alle Dienste, nicht einzeln angehalten wurden, wenn jeder Dienst beendet wird.  
  
> [!NOTE]
>  Wenn Sie den Konstruktor der Basisklasse überschreiben, sollte Sie explizit im Konstruktor einer abgeleiteten Klasse aufrufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob die Befehle Starten, Beenden, Anhalten und Fortsetzen im Ereignisprotokoll aufgezeichnet werden sollen.</summary>
        <value>
          <see langword="true" />, wenn Informationen im Ereignisprotokoll aufgezeichnet werden sollen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen von <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> zu `true` weist den Dienst verwenden Sie das Anwendungsereignisprotokoll auf Befehl Fehler auftreten, sowie statusänderungsinformationen für starten, beenden, Anhalten und Ereignisse für den Dienst weiterhin. Der Name des Diensts wird als des Protokolls verwendet <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>.  
  
 Zum Melden von Informationen an das Anwendungsprotokoll, anstatt ein benutzerdefiniertes Ereignisprotokoll legen <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> zu `false` und Schreiben von Anweisungen in Methoden Befehlsbehandlung <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, oder <xref:System.ServiceProcess.ServiceBase.OnStop%2A> , die an das entsprechende Protokoll gesendet.  
  
> [!NOTE]
>  Die <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, der die Quellzeichenfolge für das Ereignisprotokoll bereitstellt, muss festgelegt werden, bevor der Dienst versucht, in das Ereignisprotokoll schreiben. Versuchen, auf das Ereignisprotokoll zuzugreifen, bevor der Name der Datenquelle festgelegt wird, löst eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Dienst Benachrichtigungen über Änderungen im Energiestatus des Computers verarbeiten kann, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der Dienst die in der <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />-Klasse angegebenen Änderungen im Energiestatus des Computers verarbeitet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Computer Änderungen im Energiestatus des, den Service Control Manager (SCM) wird überprüft, ob der Dienst einschaltbefehle-Ereignis mit dem Wert des akzeptiert <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> ist `true`, der Befehl an den Dienst übergeben wird und die <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> Methode wird aufgerufen, wenn definiert. Wenn <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> wurde nicht implementiert. in der abgeleiteten Klasse verarbeitet dienststeuerungs-Manager das Power-Ereignis, durch die leere Basisklasse <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wird geändert, nachdem der Dienst gestartet wurde.</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Dienst Sitzungsänderungsereignisse aus einer Terminal Server-Sitzung behandeln kann, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der Dienst Terminal Server-Sitzungsänderungsereignisse behandeln kann; andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wird geändert, nachdem der Dienst gestartet wurde.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Dienst angehalten und wieder aufgenommen werden kann, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der Dienst angehalten werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie den Wert, der die <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> Eigenschaft im Konstruktor für den Dienst.  
  
 Wenn ein Dienst angehalten wird, hält er an, wozu es dient. Wenn Sie fortfahren, den Dienst (entweder über den Dienststeuerungs-Manager oder programmgesteuert), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> ausgeführt wird.  
  
 Senden einer Anforderung zum Anhalten des Diensts kann Systemressourcen. Anhalten möglicherweise nicht alle Systemressourcen freigeben, aber beendet wird. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> und <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> werden häufig implementiert, um weniger Verarbeitungszeit als <xref:System.ServiceProcess.ServiceBase.OnStop%2A> und <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `true`, außer Kraft setzen <xref:System.ServiceProcess.ServiceBase.OnPause%2A> und <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> an die Verarbeitung, die auftreten soll, wenn das Service Control Manager (SCM) eine Anforderung zum Anhalten oder fortsetzen an den Dienst übergibt. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> sollte implementiert werden, um die Verarbeitung in rückgängig zu machen <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `false`, dienststeuerungs-Manager übergibt nicht anhalten oder fortsetzen Anforderungen an den Dienst, also die <xref:System.ServiceProcess.ServiceBase.OnPause%2A> und <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> Methoden werden nicht aufgerufen werden, auch wenn sie implementiert werden. Im dienststeuerungs-Manager der `Pause` und `Continue` Steuerelemente sind deaktiviert, wenn <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde bereits gestartet. Die <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />-Eigenschaft kann nach dem Start des Diensts nicht mehr geändert werden.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Dienst beim Herunterfahren des Systems benachrichtigt werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der Dienst beim Herunterfahren des Systems benachrichtigt werden soll, andernfalls <see langword="false" />.  Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> ist `true`, der Dienst wird benachrichtigt, wenn das System heruntergefahren wird. Beim Herunterfahren der <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> Methode wird aufgerufen, wenn sie in der abgeleiteten Klasse implementiert wurde.  
  
> [!NOTE]
>  Nur das System sollte dazu führen, dass die <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> Methode für die Ausführung des Diensts können sie aufrufen, aber dies wird nicht empfohlen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde bereits gestartet. Die <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />-Eigenschaft kann nach dem Start des Diensts nicht mehr geändert werden.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Dienst nach dem Starten beendet werden kann, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der Dienst angehalten und die <see cref="M:System.ServiceProcess.ServiceBase.OnStop" />-Methode aufgerufen werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn für einen Dienst beenden aufgerufen wird, den Service Control Manager (SCM) überprüft, ob der Dienst beenden-Befehle, die mit dem Wert des akzeptiert <xref:System.ServiceProcess.ServiceBase.CanStop%2A>. Für die meisten Dienste, die den Wert der <xref:System.ServiceProcess.ServiceBase.CanStop%2A> ist `true`, aber einige Betriebssystemdienste, lassen beispielsweise nicht den Benutzer abgebrochen.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanStop%2A> ist `true`, wird der Befehl zum Beenden an den Dienst übergeben und die <xref:System.ServiceProcess.ServiceBase.OnStop%2A> Methode wird aufgerufen, wenn er definiert ist. Wenn <xref:System.ServiceProcess.ServiceBase.OnStop%2A> ist nicht in der abgeleiteten Klasse, die SCM-Handles, die Beendigung des Befehls über die leere Basisklasse implementiert <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde bereits gestartet. Die <see cref="P:System.ServiceProcess.ServiceBase.CanStop" />-Eigenschaft kann nach dem Start des Diensts nicht mehr geändert werden.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.ServiceProcess.ServiceBase" />-Klasse verwendeten Ressourcen (mit Ausnahme des Speichers) frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.ServiceProcess.ServiceBase.Dispose%2A> in der abgeleiteten Klasse (und somit in der <xref:System.ServiceProcess.ServiceBase> Klasse) Sie abschließend die abgeleitete Klasse verwenden. Die <xref:System.ServiceProcess.ServiceBase.Dispose%2A> -Methode bewirkt, dass die abgeleitete Klasse in einem nicht verwendbaren Zustand. Nach dem Aufruf <xref:System.ServiceProcess.ServiceBase.Dispose%2A>, Sie müssen alle Verweise auf die abgeleitete Klasse freigeben und <xref:System.ServiceProcess.ServiceBase> , damit der belegte Speicher durch die Garbagecollection wieder zugänglich gemacht werden kann.  
  
> [!NOTE]
>  Rufen Sie immer <xref:System.ServiceProcess.ServiceBase.Dispose%2A> bereits vor der Veröffentlichung des letzten Verweis auf die Klasse, die von abgeleiteten <xref:System.ServiceProcess.ServiceBase>. Andernfalls die Ressourcen <xref:System.ServiceProcess.ServiceBase> und die abgeleitete Klasse wird nicht freigegeben werden, bis die Garbagecollection den Destruktor des Objekts aufruft.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> wird häufig implementiert, um den Code in verarbeiten <xref:System.ServiceProcess.ServiceBase.OnPause%2A>kombiniert mit einem Aufruf von <xref:System.ServiceProcess.ServiceBase.Dispose%2A>. Wenn Sie dazu in der abgeleiteten Klasse auswählen, ist es üblich, implementieren Sie <xref:System.ServiceProcess.ServiceBase.OnStart%2A> zuweisen was <xref:System.ServiceProcess.ServiceBase.Dispose%2A> veröffentlicht.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Ereignisprotokoll ab, mit dem Sie Benachrichtigungen über Aufrufe von Dienstbefehlen wie Starten und Beenden in das Anwendungsereignisprotokoll schreiben können.</summary>
        <value>Eine <see cref="T:System.Diagnostics.EventLog" />-Instanz, deren Quelle im Anwendungsprotokoll registriert ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Konstruktor initialisiert die <xref:System.ServiceProcess.ServiceBase.EventLog%2A> Eigenschaft, um eine Instanz mit der <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> und <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> festgelegten Eigenschaften. Die Quelle ist die <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> des Diensts, und das Protokoll ist Anwendungsprotokoll des Computers. Diese Werte werden automatisch festgelegt und können nicht für die automatische Protokollierung von Befehlen von legacysprachdiensten geändert werden.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> ist `true`, starten, beenden, anhalten, fortsetzen und benutzerdefinierte Befehle werden automatisch in das Anwendungsereignisprotokoll aufgezeichnet. Sie können die <xref:System.ServiceProcess.ServiceBase.EventLog%2A> Eigenschaft, um zusätzliche Nachrichten in das Protokoll auch zu schreiben. Die Komponente ruft <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> mit diesem <xref:System.ServiceProcess.ServiceBase.EventLog%2A> Member.  
  
 Zum Melden von Informationen an das Anwendungsprotokoll, anstatt ein benutzerdefiniertes Ereignisprotokoll legen <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> zu `false` und Schreiben von Anweisungen in Methoden Befehlsbehandlung <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, oder <xref:System.ServiceProcess.ServiceBase.OnStop%2A> , die an das entsprechende Protokoll gesendet.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Exitcode für den Dienst ab oder legt diesen fest.</summary>
        <value>Der Exitcode für den Dienst.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie die <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> Eigenschaft mit einem Wert ungleich 0 vor dem Beenden des Diensts zur Anzeige eines Fehlers mit dem Dienststeuerungs-Manager.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>Gibt die maximale Größe für einen Dienstnamen an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName und "DisplayName" haben beide größeneinschränkungen müssen, beim Festlegen der Eigenschaften auf die Dienstklasse berücksichtigt werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bei der Implementierung in einer abgeleiteten Klasse wird <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> ausgeführt, wenn der Dienststeuerungs-Manager einen Befehl zum Fortsetzen an den Dienst sendet. Gibt Aktionen an, die durchgeführt werden müssen, wenn der normale Betrieb eines Diensts nach dem Anhalten wieder aufgenommen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementieren <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> zum Spiegeln von Ihrer Anwendung als Antwort auf <xref:System.ServiceProcess.ServiceBase.OnPause%2A>. Wenn Sie fortfahren, den Dienst (entweder über die Dienstkonsole oder programmgesteuert), die <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> Verarbeitung ausgeführt wird und der Dienst wird wieder aktiviert.  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> Wenn überschrieben werden soll die <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> Eigenschaft `true`.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `false`, dienststeuerungs-Manager übergibt nicht anhalten oder fortsetzen Anforderungen an den Dienst, also die <xref:System.ServiceProcess.ServiceBase.OnPause%2A> und <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> Methoden werden nicht aufgerufen werden, auch wenn sie implementiert werden. Im dienststeuerungs-Manager der `Pause` und `Continue` Steuerelemente sind deaktiviert, wenn <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">Die an den Dienst gesendete Befehlsnachricht.</param>
        <summary>Bei der Implementierung in einer abgeleiteten Klasse wird <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> ausgeführt, wenn der Dienststeuerungs-Manager einen benutzerdefinierten Befehl an den Dienst übergibt. Gibt an, welche Aktionen auszuführen sind, wenn ein Befehl mit dem angegebenen Parameter auftritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> können Sie Funktionalität zusätzlich zu starten, beenden, Anhalten und Wiederaufnehmen von Diensten angeben.  
  
 Dienststeuerungs-Manager untersucht den benutzerdefinierten Befehl zu überprüfen, ob der Dienst unterstützt nicht die `command` übergebene Parameter. Sie übergibt den benutzerdefinierten Befehl direkt an den Dienst. Wenn der Dienst nicht erkennt die `command` -Parameter und hat keine Auswirkungen.  
  
 Benutzerdefinierte Befehle werden erstellt, indem ein <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> -Anweisung in einem <xref:System.ServiceProcess.ServiceController> Komponente. Verwenden Sie eine Switch-Anweisung oder... Klicken Sie dann Bedingung, die die benutzerdefinierte Befehle zu verarbeiten, die Sie für Ihren Dienst zu definieren.  
  
 Nur die Werte für einen benutzerdefinierten Befehl, die Sie in Ihrer Anwendung definieren können, oder verwenden Sie in <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> sind diejenigen zwischen 128 bis 255. Ganze Zahlen unter 128 entsprechen Werte vom System reservierte.  
  
 Wenn die <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> Eigenschaft `true`, benutzerdefinierte Befehle, wie alle anderen Befehle schreiben Einträge in das Ereignisprotokoll zum melden, ob die Ausführung der Methode erfolgreich war oder nicht.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird bei der Implementierung in einer abgeleiteten Klasse ausgeführt, wenn der Dienststeuerungs-Manager einen Befehl zum Anhalten an den Dienst sendet. Gibt Aktionen an, die beim Anhalten eines Diensts durchgeführt werden müssen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.ServiceProcess.ServiceBase.OnPause%2A> die Verarbeitung an, das auftritt, wenn der Dienst einen Befehl zum Anhalten erhält. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> Wenn überschrieben werden soll die <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> Eigenschaft `true`.  
  
 Wenn Sie fortfahren, einen angehaltenen Dienst (entweder über die Dienstkonsole oder programmgesteuert), die <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> Verarbeitung ausgeführt wird und der Dienst wird wieder aktiviert.  
  
 Der Befehl "Pause" kann nur Ihre Anwendung auf ein bestimmtes Ereignis zu reagieren. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> hat keine Auswirkungen auf den Dienst, den er nicht definiert sind.  
  
 Senden einer Anforderung zum Anhalten des Diensts kann Systemressourcen beibehalten werden, da anhalten nicht alle Systemressourcen freigeben muss. Z. B. wenn Threads, durch den Prozess, der einen Dienst anhalten geöffnet wurden, anstatt sie beenden die Threads geöffnet bleiben kann macht so haarige überflüssig müssen sie zum erneuten zuweisen, wenn der Dienst fortgesetzt wird. Wenn Sie anhalten, um alle Systemressourcen freigeben definieren, verhält er sich wie ein Befehl zum Beenden.  
  
 Legen Sie <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> zu `true`, und überschreiben <xref:System.ServiceProcess.ServiceBase.OnPause%2A> und <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> an auftreten soll, wenn der dienststeuerungs-Manager eine Anforderung zum Anhalten oder fortsetzen an den Dienst übergibt die Verarbeitung. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> sollte implementiert werden, um die Verarbeitung in rückgängig zu machen <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `false`, dienststeuerungs-Manager übergibt nicht anhalten oder fortsetzen Anforderungen an den Dienst, also die <xref:System.ServiceProcess.ServiceBase.OnPause%2A> und <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> Methoden werden nicht aufgerufen werden, auch wenn implementiert. Im dienststeuerungs-Manager der `Pause` und `Continue` Steuerelemente sind deaktiviert, wenn <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ist `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">Ein <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />, der eine Benachrichtigung des Systems über dessen Energiestatus angibt.</param>
        <summary>Wird bei der Implementierung in einer abgeleiteten Klasse ausgeführt, wenn sich der Energiestatus des Computers geändert hat. Dies gilt für Laptops, wenn diese in den Standbymodus wechseln. Dieser entspricht nicht dem Herunterfahren des Systems.</summary>
        <returns>Bei Implementierung in einer abgeleiteten Klasse bestimmen die Anforderungen der Anwendung, welcher Wert zurückzugeben ist. Wenn beispielsweise ein <see langword="QuerySuspend" />-Broadcaststatus übergeben wird, können Sie die Anwendung veranlassen, die Abfrage durch Rückgabe <see langword="false" /> abzulehnen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> an tritt auf, wenn das Systemereignis in angegeben. die Verarbeitung der <xref:System.ServiceProcess.PowerBroadcastStatus> Enumeration auftritt – z.B. wenn der Computer im angehaltenen Modus befindet oder niedriger Ladezustand des Akkus.  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> Wenn überschrieben werden soll die <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> Eigenschaft `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" />
      </Parameters>
      <Docs>
        <param name="changeDescription">Eine -Struktur, die den Änderungstyp angibt.</param>
        <summary>Wird ausgeführt, wenn ein Änderungsereignis von einer Terminal Server-Sitzung empfangen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen festlegen, die <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> Eigenschaft `true` um die Ausführung dieser Methode ermöglichen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird bei der Implementierung in einer abgeleiteten Klasse beim Herunterfahren des Systems ausgeführt. Gibt an, welche Vorgänge unmittelbar vor dem Herunterfahren des Systems ausgeführt werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> die Verarbeitung an, das auftritt, wenn das System heruntergefahren wird.  
  
 Dieses Ereignis tritt nur auf, wenn das Betriebssystem heruntergefahren ist, nicht verwendet werden, wenn der Computer ausgeschaltet ist.  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> Wenn überschrieben werden soll die <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> Eigenschaft `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Vom Befehl zum Starten übergebene Daten.</param>
        <summary>Wird bei der Implementierung in einer abgeleiteten Klasse ausgeführt, wenn der Dienststeuerungs-Manager einen Befehl zum Starten an den Dienst sendet oder wenn das Betriebssystem gestartet wird (diese gilt für Dienste, die automatisch gestartet werden). Gibt Aktionen an, die beim Starten des Diensts ausgeführt werden müssen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.ServiceProcess.ServiceBase.OnStart%2A> die Verarbeitung an, das auftritt, wenn der Dienst einen Befehl zum Starten empfängt. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> ist die Methode, in der Sie das Verhalten des Diensts angeben. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> können Argumente als eine Möglichkeit, Daten zu übergeben, aber diese Verwendung ist selten.  
  
> [!CAUTION]
>  Verwenden Sie den Konstruktor nicht Verarbeitung ausführen, die in sollten <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Verwendung <xref:System.ServiceProcess.ServiceBase.OnStart%2A> alle Initialisierung des Diensts zu verarbeiten. Der Konstruktor wird aufgerufen, wenn die Anwendung der ausführbaren ausgeführt wird, nicht verwendet werden, wenn der Dienst ausgeführt wird. Die ausführbare Datei ausgeführt wird, bevor Sie <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Wenn Sie, z. B. Fortfahren wird der Konstruktor nicht erneut aufgerufen, weil der dienststeuerungs-Manager bereits auf das Objekt im Arbeitsspeicher enthält. Wenn <xref:System.ServiceProcess.ServiceBase.OnStop%2A> Ressourcen zugeordnet, in, anstatt im Konstruktor <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, würde die erforderlichen Ressourcen nicht erneut zweiten Mal der Dienst aufgerufen wird, erstellt werden.  
  
 Für Dienste kann festgelegt werden, für den automatischen start bei einem Neustart des Computers durch Festlegen der <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> im des Diensts-Installationsprogramm auf <xref:System.ServiceProcess.ServiceStartMode.Automatic>. In einem solchen Fall <xref:System.ServiceProcess.ServiceBase.OnStart%2A> würde beim Systemstart aufgerufen werden.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> wird erwartet, in der abgeleiteten Klasse außer Kraft gesetzt werden. Für den Dienst sinnvolle <xref:System.ServiceProcess.ServiceBase.OnStart%2A> und <xref:System.ServiceProcess.ServiceBase.OnStop%2A> muss sowohl in Ihrer Dienstklasse implementiert werden.  
  
 Verarbeiten Sie die Initialisierung von Argumenten für den Dienst in der <xref:System.ServiceProcess.ServiceBase.OnStart%2A> -Methode, nicht in der Main-Methode. Die Argumente in der `args` Parameterarray kann manuell im Fenster "Eigenschaften" für den Dienst in der Konsole Dienste festgelegt werden. In der Konsole eingegebenen Argumente werden nicht gespeichert. Sie werden an den Dienst einmalig übergeben, wenn der Dienst in der Systemsteuerung gestartet wird. Argumente, die vorhanden sein müssen, wenn der Dienst automatisch gestartet wird, die in die ImagePath-Zeichenfolgenwert für den Dienst-Registrierungsschlüssel eingefügt werden können (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\  *\< Dienstname >*). Sie erhalten die Argumente aus der Registrierung mithilfe der <xref:System.Environment.GetCommandLineArgs%2A> Methode, z. B.: `string[] imagePathArgs = Environment.GetCommandLineArgs();`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird bei der Implementierung in einer abgeleiteten Klasse ausgeführt, wenn der Dienststeuerungs-Manager einen Befehl zum Beenden an den Dienst sendet. Gibt Aktionen an, die beim Beenden eines Diensts auszuführen sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.ServiceProcess.ServiceBase.OnStop%2A> die Verarbeitung an, das auftritt, wenn der Dienst einen Befehl zum Beenden empfängt.  
  
 Wenn der dienststeuerungs-Manager einen Befehl zum Beenden empfängt, verwendet er den Wert der <xref:System.ServiceProcess.ServiceBase.CanStop%2A> zu überprüfen, ob der Dienst beendet Befehle akzeptiert. Wenn <xref:System.ServiceProcess.ServiceBase.CanStop%2A> ist `true`, wird der Befehl zum Beenden an den Dienst übergeben und die <xref:System.ServiceProcess.ServiceBase.OnStop%2A> Methode wird aufgerufen, wenn er definiert ist. Wenn <xref:System.ServiceProcess.ServiceBase.OnStop%2A> ist nicht implementiert im Dienst dienststeuerungs-Manager den Befehl zum Beenden verarbeitet.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.CanStop%2A> ist `false`, dienststeuerungs-Manager, ignoriert den Stop-Befehl. Es wird nicht an den Dienst übergeben. Der Befehl zum Beenden gibt zurück, und löst eine Ausnahme aus.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> wird erwartet, in der abgeleiteten Klasse außer Kraft gesetzt werden. Für den Dienst sinnvolle <xref:System.ServiceProcess.ServiceBase.OnStart%2A> und <xref:System.ServiceProcess.ServiceBase.OnStop%2A> muss sowohl in Ihrer Dienstklasse implementiert werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Die angeforderte Zeit in Millisekunden.</param>
        <summary>Fordert zusätzliche Zeit für eine ausstehende Operation an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> Methode aufgerufen werden soll von der überschriebenen <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, oder <xref:System.ServiceProcess.ServiceBase.OnStop%2A> Methoden, um zusätzliche Zeit für einen ausstehenden Vorgang, um zu verhindern, dass das Service Control Manager (SCM) markieren zu Anfordern der der Dienst reagiert nicht mehr.  Wenn der ausstehende Vorgang keine fortfahren, anhalten, starten oder beenden, ist ein <xref:System.InvalidOperationException> ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Dienst steht nicht aus.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stellt den Haupteinstiegspunkt für die ausführbare Datei eines Diensts bereit.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">Eine <see cref="T:System.ServiceProcess.ServiceBase" />, die einen zu startenden Dienst angibt.</param>
        <summary>Registriert die ausführbare Datei für einen Dienst im Dienststeuerungs-Manager.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Überladung der `main()` Funktion der ausführbaren Datei, um den Dienst mit dem Dienststeuerungs-Manager registrieren des Service. Nach dem Aufruf von <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>, der Dienststeuerungs-Manager stellt einen Befehl zum Starten, was in einem Aufruf führt die <xref:System.ServiceProcess.ServiceBase.OnStart%2A> -Methode in den Dienst. Der Dienst wird nicht gestartet werden, bis der Befehl "Start" ausgeführt wird.  
  
 Die <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> Methode wird aufgerufen, in die gleiche Weise wie <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> für Windows Forms-Anwendungen.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> ist `true`, ein Eintrag wird in das Ereignisprotokoll geschrieben, wenn der angegebene Dienst von der `service` Parameter kann nicht gestartet werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="service" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">Ein Array von ServiceBase-Instanzen, die zu startende Dienste angeben.</param>
        <summary>Registriert die ausführbare Datei für mehrere Dienste im Dienststeuerungs-Manager.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Überladung der `main()` Funktionalität des Diensts für ausführbare Datei, um die Dienste mit dem Dienststeuerungs-Manager zu registrieren. Nach dem Aufruf von <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>, der Dienststeuerungs-Manager gibt die Start-Befehle, die führen Aufrufe an die <xref:System.ServiceProcess.ServiceBase.OnStart%2A> Methoden in den Diensten. Die Dienste werden nicht gestartet werden, bis die Start-Befehle ausgeführt werden.  
  
 Die <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> Methode wird aufgerufen, in die gleiche Weise wie die <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> -Methode für Windows Forms-Anwendungen.  
  
 Wenn <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> ist `true`, ein Eintrag wird in das Ereignisprotokoll geschrieben, wenn ein Dienst im Array nicht gestartet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Sie haben keinen zu startenden Dienst angegeben. Das Array ist u. U. <see langword="null" /> oder leer.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Dienststeuerungshandle für den Dienst ab.</summary>
        <value>Eine <see cref="T:System.IntPtr" />-Struktur, die das Dienststeuerungshandle für den Dienst enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Dienststeuerungshandle wird verwendet, für die Kommunikation mit den Service Control Manager (SCM).  Das Handle kann zum Aktualisieren des dienststeuerungs-Manager-Statusinformationen für den aufrufenden Dienst mithilfe der nicht verwalteten `SetServiceStatus` Funktion.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff von nicht verwaltetem Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" />
        <Parameter Name="argPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="argCount">Die Anzahl der Argumente im Argumentarray.</param>
        <param name="argPointer">Eine <see cref="T:System.IntPtr" />-Struktur, die auf ein Array von Argumenten zeigt.</param>
        <summary>Registriert den Befehlshandler und startet den Dienst.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zur Bezeichnung des Diensts beim System verwendeten kurzen Namen ab oder legt diesen fest.</summary>
        <value>Der Name des Diensts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> identifiziert den Dienst mit dem Dienststeuerungs-Manager. Der Wert dieser Eigenschaft muss identisch mit dem Namen für den Dienst in der <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> Eigenschaft der entsprechenden Installerklasse. Im Code die <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> des Diensts wird in der Regel legen Sie der `main()` Funktion der ausführbaren Datei.  
  
 Die <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> dient auch zum Angeben der <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> zugeordneten der <xref:System.ServiceProcess.ServiceBase.EventLog%2A> Eigenschaft. Dies <xref:System.ServiceProcess.ServiceBase.EventLog%2A> ist eine Instanz, die Befehlsinformationen in das Anwendungsprotokoll schreibt.  
  
 Die <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, der die Quellzeichenfolge für das Ereignisprotokoll bereitstellt, muss festgelegt werden, bevor der Dienst in das Ereignisprotokoll schreibt. Versuchen, auf das Ereignisprotokoll zuzugreifen, bevor der Name der Datenquelle festgelegt wird, wird eine Ausnahme ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde bereits gestartet. Die <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" />-Eigenschaft kann nach dem Start des Diensts nicht mehr geändert werden.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Name ist eine Zeichenfolge der Länge 0 (null) oder ist länger als <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />, oder der angegebene Name enthält Schrägstriche oder umgekehrte Schrägstriche.</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet den ausgeführten Dienst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ServiceProcess.ServiceBase.Stop%2A> Methode legt fest, die Zustand des Diensts an, dass eine Beenden steht aus und ruft die <xref:System.ServiceProcess.ServiceBase.OnStop%2A> Methode.  Nachdem die Anwendung beendet wird, wird der Dienststatus auf beendet festgelegt. Wenn die Anwendung eines gehosteten Diensts ist, wird die Anwendungsdomäne entladen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>