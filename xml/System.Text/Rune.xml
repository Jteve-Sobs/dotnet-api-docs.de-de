<Type Name="Rune" FullName="System.Text.Rune">
  <Metadata><Meta Name="ms.openlocfilehash" Value="42b41b8d153f7b2e4020c8c855ffc108f2cdb62f" /><Meta Name="ms.sourcegitcommit" Value="11306e8bb61e44463a969897211724e18107ac96" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/12/2020" /><Meta Name="ms.locfileid" Value="88139951" /></Metadata><TypeSignature Language="C#" Value="public struct Rune : IComparable&lt;System.Text.Rune&gt;, IEquatable&lt;System.Text.Rune&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Rune extends System.ValueType implements class System.IComparable`1&lt;valuetype System.Text.Rune&gt;, class System.IEquatable`1&lt;valuetype System.Text.Rune&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Text.Rune" />
  <TypeSignature Language="VB.NET" Value="Public Structure Rune&#xA;Implements IComparable(Of Rune), IEquatable(Of Rune)" />
  <TypeSignature Language="C++ CLI" Value="public value class Rune : IComparable&lt;System::Text::Rune&gt;, IEquatable&lt;System::Text::Rune&gt;" />
  <TypeSignature Language="F#" Value="type Rune = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Text.Rune&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Text.Rune&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="dc568-101">Stellt einen Unicode-Skalarwert dar ( [ U+0000..U+D7FF ], einschlie√ülich; oder [ U+E000..U+10FFFF ], einschlie√ülich).</span><span class="sxs-lookup"><span data-stu-id="dc568-101">Represents a Unicode scalar value ([ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive).</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-102">Eine- <xref:System.Text.Rune> Instanz stellt einen Unicode-Skalarwert dar, d. h. einen beliebigen Codepunkt ohne den Ersatzbereich (U + D800 und. U + DFFF).</span><span class="sxs-lookup"><span data-stu-id="dc568-102">A <xref:System.Text.Rune> instance represents a Unicode scalar value, which means any code point excluding the surrogate range (U+D800..U+DFFF).</span></span> <span data-ttu-id="dc568-103">Die Konstruktoren und Konvertierungs Operatoren des Typs √ºberpr√ºfen die Eingabe, sodass Consumer die APIs abrufen k√∂nnen, vorausgesetzt, dass die zugrunde liegende <xref:System.Text.Rune> Instanz wohl geformt ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-103">The type's constructors and conversion operators validate the input, so consumers can call the APIs assuming that the underlying <xref:System.Text.Rune> instance is well formed.</span></span>

<span data-ttu-id="dc568-104">Wenn Sie mit den Begriffen Unicode-Skalarwert, Codepunkt, Ersatz Zeichenbereich und wohl geformt nicht vertraut sind, finden Sie unter Einf√ºhrung in die [Zeichencodierung in .net](/dotnet/standard/base-types/character-encoding-introduction)Weitere Informationen.</span><span class="sxs-lookup"><span data-stu-id="dc568-104">If you aren't familiar with the terms Unicode scalar value, code point, surrogate range, and well-formed, see [Introduction to character encoding in .NET](/dotnet/standard/base-types/character-encoding-introduction).</span></span>

<span data-ttu-id="dc568-105">In den folgenden Abschnitten wird Folgendes erl√§utert:</span><span class="sxs-lookup"><span data-stu-id="dc568-105">The following sections explain:</span></span>

* [<span data-ttu-id="dc568-106">Verwendung des Rune-Typs</span><span class="sxs-lookup"><span data-stu-id="dc568-106">When to use the Rune type</span></span>](#when-to-use-the-rune-type)
* [<span data-ttu-id="dc568-107">Wann nicht der Rune-Typ verwendet werden soll</span><span class="sxs-lookup"><span data-stu-id="dc568-107">When not to use the Rune type</span></span>](#when-not-to-use-rune)
* [<span data-ttu-id="dc568-108">Instanziieren einer Rune</span><span class="sxs-lookup"><span data-stu-id="dc568-108">How to instantiate a Rune</span></span>](#how-to-instantiate-a-rune)
* [<span data-ttu-id="dc568-109">Abfragen von Eigenschaften einer Rune-Instanz</span><span class="sxs-lookup"><span data-stu-id="dc568-109">How to query properties of a Rune instance</span></span>](#query-properties-of-a-rune)
* [<span data-ttu-id="dc568-110">Konvertieren `Rune` von in UTF-8 oder UTF-16</span><span class="sxs-lookup"><span data-stu-id="dc568-110">Convert a `Rune` to UTF-8 or UTF-16</span></span>](#convert-a-rune-to-utf-8-or-utf-16)
* [<span data-ttu-id="dc568-111">Rune in .net im Vergleich zu anderen Sprachen</span><span class="sxs-lookup"><span data-stu-id="dc568-111">Rune in .NET vs. other languages</span></span>](#rune-in-net-vs-other-languages)

### <a name="when-to-use-the-rune-type"></a><span data-ttu-id="dc568-112">Verwendung des Rune-Typs</span><span class="sxs-lookup"><span data-stu-id="dc568-112">When to use the Rune type</span></span>

<span data-ttu-id="dc568-113">Verwenden Sie ggf. den `Rune` Typ, wenn Ihr Code Folgendes</span><span class="sxs-lookup"><span data-stu-id="dc568-113">Consider using the `Rune` type if your code:</span></span>

* <span data-ttu-id="dc568-114">Ruft APIs auf, die Unicode-skalare Werte erfordern.</span><span class="sxs-lookup"><span data-stu-id="dc568-114">Calls APIs that require Unicode scalar values</span></span>
* <span data-ttu-id="dc568-115">Behandelt Ersatzpaare explizit.</span><span class="sxs-lookup"><span data-stu-id="dc568-115">Explicitly handles surrogate pairs</span></span>

#### <a name="apis-that-require-unicode-scalar-values"></a><span data-ttu-id="dc568-116">APIs, die Unicode-skalare Werte erfordern</span><span class="sxs-lookup"><span data-stu-id="dc568-116">APIs that require Unicode scalar values</span></span>

<span data-ttu-id="dc568-117">Wenn Ihr Code die- `char` Instanzen in einem `string` oder einem durch `ReadOnlySpan<char>` l√§uft, funktionieren einige der- `char` Methoden f√ºr- `char` Instanzen, die sich im Ersatzbereich befinden, nicht ordnungsgem√§√ü.</span><span class="sxs-lookup"><span data-stu-id="dc568-117">If your code iterates through the `char` instances in a `string` or a `ReadOnlySpan<char>`, some of the `char` methods won't work correctly on `char` instances that are in the surrogate range.</span></span> <span data-ttu-id="dc568-118">Beispielsweise erfordern die folgenden APIs einen Skalarwert `char` , um ordnungsgem√§√ü zu funktionieren:</span><span class="sxs-lookup"><span data-stu-id="dc568-118">For example, the following APIs require a scalar value `char` to work correctly:</span></span>

* <xref:System.Char.GetNumericValue%2A?displayProperty=nameWithType>
* <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType>
* <xref:System.Char.IsDigit%2A?displayProperty=nameWithType>
* <xref:System.Char.IsLetter%2A?displayProperty=nameWithType>
* <xref:System.Char.IsLetterOrDigit%2A?displayProperty=nameWithType>
* <xref:System.Char.IsLower%2A?displayProperty=nameWithType>
* <xref:System.Char.IsNumber%2A?displayProperty=nameWithType>
* <xref:System.Char.IsPunctuation%2A?displayProperty=nameWithType>
* <xref:System.Char.IsSymbol%2A?displayProperty=nameWithType>
* <xref:System.Char.IsUpper%2A?displayProperty=nameWithType>

<span data-ttu-id="dc568-119">Das folgende Beispiel zeigt Code, der nicht ordnungsgem√§√ü funktioniert, wenn eine der- `char` Instanzen Ersatz Code Punkte ist:</span><span class="sxs-lookup"><span data-stu-id="dc568-119">The following example shows code that won't work correctly if any of the `char` instances are surrogate code points:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/CountLettersInString.cs" id="SnippetBadExample":::

<span data-ttu-id="dc568-120">Der folgende Code entspricht dem folgenden Code `ReadOnlySpan<char>` :</span><span class="sxs-lookup"><span data-stu-id="dc568-120">Here's equivalent code that works with a `ReadOnlySpan<char>`:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/CountLettersInSpan.cs" id="SnippetBadExample":::

<span data-ttu-id="dc568-121">Der vorangehende Code funktioniert ordnungsgem√§√ü mit einigen Sprachen, wie z. b. Englisch:</span><span class="sxs-lookup"><span data-stu-id="dc568-121">The preceding code works correctly with some languages such as English:</span></span>

```csharp
CountLettersInString("Hello")
// Returns 5
```

<span data-ttu-id="dc568-122">Dies funktioniert jedoch nicht ordnungsgem√§√ü f√ºr Sprachen au√üerhalb der grundlegenden mehrsprachigen Ebene, wie z. b. Osage:</span><span class="sxs-lookup"><span data-stu-id="dc568-122">But it won't work correctly for languages outside the Basic Multilingual Plane, such as Osage:</span></span>

```csharp
CountLettersInString("êìèêìòêìªêìòêìªêìü êíªêìü")
// Returns 0
```

<span data-ttu-id="dc568-123">Der Grund, warum diese Methode falsche Ergebnisse f√ºr den Osage-Text zur√ºckgibt, ist, dass die `char` Instanzen f√ºr Osage-Buchstaben Ersatz Code Punkte sind.</span><span class="sxs-lookup"><span data-stu-id="dc568-123">The reason this method returns incorrect results for Osage text is that the `char` instances for Osage letters are surrogate code points.</span></span> <span data-ttu-id="dc568-124">Kein einzelner Ersatz Code Punkt verf√ºgt √ºber gen√ºgend Informationen, um zu bestimmen, ob es sich um einen Buchstaben handelt.</span><span class="sxs-lookup"><span data-stu-id="dc568-124">No single surrogate code point has enough information to determine if it's a letter.</span></span>

<span data-ttu-id="dc568-125">Wenn Sie diesen Code f√ºr die Verwendung `Rune` von anstelle von √§ndern `char` , funktioniert die Methode ordnungsgem√§√ü mit Code Punkten au√üerhalb der grundlegenden mehrsprachigen Ebene:</span><span class="sxs-lookup"><span data-stu-id="dc568-125">If you change this code to use `Rune` instead of `char`, the method works correctly with code points outside the Basic Multilingual Plane:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/CountLettersInString.cs" id="SnippetGoodExample":::

<span data-ttu-id="dc568-126">Der folgende Code entspricht dem folgenden Code `ReadOnlySpan<char>` :</span><span class="sxs-lookup"><span data-stu-id="dc568-126">Here's equivalent code that works with a `ReadOnlySpan<char>`:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/CountLettersInSpan.cs" id="SnippetGoodExample":::

<span data-ttu-id="dc568-127">Im vorangehenden Code werden Osage-Buchstaben ordnungsgem√§√ü gez√§hlt:</span><span class="sxs-lookup"><span data-stu-id="dc568-127">The preceding code counts Osage letters correctly:</span></span>

```csharp
CountLettersInString("êìèêìòêìªêìòêìªêìü êíªêìü")
// Returns 8
```

#### <a name="code-that-explicitly-handles-surrogate-pairs"></a><span data-ttu-id="dc568-128">Code, der Ersatzpaare explizit behandelt</span><span class="sxs-lookup"><span data-stu-id="dc568-128">Code that explicitly handles surrogate pairs</span></span>

<span data-ttu-id="dc568-129">Verwenden Sie ggf. den- `Rune` Typ, wenn der Code APIs aufruft, die explizit auf Ersatz Code Punkte angewendet werden, z. b. die folgenden Methoden:</span><span class="sxs-lookup"><span data-stu-id="dc568-129">Consider using the `Rune` type if your code calls APIs that explicitly operate on surrogate code points, such as the following methods:</span></span>

* <xref:System.Char.IsSurrogate%2A?displayProperty=nameWithType>
* <xref:System.Char.IsSurrogatePair%2A?displayProperty=nameWithType>
* <xref:System.Char.IsHighSurrogate%2A?displayProperty=nameWithType>
* <xref:System.Char.IsLowSurrogate%2A?displayProperty=nameWithType>
* <xref:System.Char.ConvertFromUtf32%2A?displayProperty=nameWithType>
* <xref:System.Char.ConvertToUtf32%2A?displayProperty=nameWithType>

<span data-ttu-id="dc568-130">Beispielsweise verf√ºgt die folgende Methode √ºber eine spezielle Logik, um Ersatz `char` Paare zu behandeln:</span><span class="sxs-lookup"><span data-stu-id="dc568-130">For example, the following method has special logic to deal with surrogate `char` pairs:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/WorkWithSurrogates.cs" id="SnippetUseChar":::

<span data-ttu-id="dc568-131">Dieser Code ist einfacher, wenn er verwendet `Rune` , wie im folgenden Beispiel gezeigt:</span><span class="sxs-lookup"><span data-stu-id="dc568-131">Such code is simpler if it uses `Rune`, as in the following example:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/WorkWithSurrogates.cs" id="SnippetUseRune":::

### <a name="when-not-to-use-rune"></a><span data-ttu-id="dc568-132">Wann nicht zu verwenden `Rune`</span><span class="sxs-lookup"><span data-stu-id="dc568-132">When not to use `Rune`</span></span>

<span data-ttu-id="dc568-133">Sie m√ºssen den-Typ nicht verwenden, `Rune` Wenn Ihr Code Folgendes:</span><span class="sxs-lookup"><span data-stu-id="dc568-133">You don't need to use the `Rune` type if your code:</span></span>

* <span data-ttu-id="dc568-134">Sucht nach genauen `char` √úbereinstimmungen.</span><span class="sxs-lookup"><span data-stu-id="dc568-134">Looks for exact `char` matches</span></span>
* <span data-ttu-id="dc568-135">Unterteilt eine Zeichenfolge mit einem bekannten Char-Wert.</span><span class="sxs-lookup"><span data-stu-id="dc568-135">Splits a string on a known char value</span></span>

<span data-ttu-id="dc568-136">Die Verwendung des `Rune` Typs gibt m√∂glicherweise falsche Ergebnisse zur√ºck, wenn Ihr Code Folgendes:</span><span class="sxs-lookup"><span data-stu-id="dc568-136">Using the `Rune` type may return incorrect results if your code:</span></span>

* <span data-ttu-id="dc568-137">Z√§hlt die Anzahl der Anzeige Zeichen in einem `string`</span><span class="sxs-lookup"><span data-stu-id="dc568-137">Counts the number of display characters in a `string`</span></span>

#### <a name="look-for-exact-char-matches"></a><span data-ttu-id="dc568-138">Nach exakten `char` √úbereinstimmungen suchen</span><span class="sxs-lookup"><span data-stu-id="dc568-138">Look for exact `char` matches</span></span>

<span data-ttu-id="dc568-139">Der folgende Code durchl√§uft eine `string` Suche nach bestimmten Zeichen und gibt den Index der ersten √úbereinstimmung zur√ºck.</span><span class="sxs-lookup"><span data-stu-id="dc568-139">The following code iterates through a `string` looking for specific characters, returning the index of the first match.</span></span> <span data-ttu-id="dc568-140">Es ist nicht erforderlich, diesen Code f√ºr die Verwendung zu √§ndern `Rune` , da der Code nach Zeichen sucht, die durch einen einzelnen dargestellt werden `char` .</span><span class="sxs-lookup"><span data-stu-id="dc568-140">There's no need to change this code to use `Rune`, as the code is looking for characters that are represented by a single `char`.</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/FindFirstLetter.cs" id="SnippetExample":::

#### <a name="split-a-string-on-a-known-char"></a><span data-ttu-id="dc568-141">Teilen einer Zeichenfolge auf ein bekanntes `char`</span><span class="sxs-lookup"><span data-stu-id="dc568-141">Split a string on a known `char`</span></span>

<span data-ttu-id="dc568-142">Es ist √ºblich `string.Split` `' '` , wie im folgenden Beispiel Trennzeichen wie (Leerzeichen) oder (Komma) aufzurufen und zu verwenden `','` :</span><span class="sxs-lookup"><span data-stu-id="dc568-142">It's common to call `string.Split` and use delimiters such as `' '` (space) or `','` (comma), as in the following example:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/SplitStringOnChar.cs" id="SnippetExample":::

<span data-ttu-id="dc568-143">Hier ist die Verwendung nicht erforderlich `Rune` , da der Code nach Zeichen sucht, die von einem einzelnen dargestellt werden `char` .</span><span class="sxs-lookup"><span data-stu-id="dc568-143">There is no need to use `Rune` here, because the code is looking for characters that are represented by a single `char`.</span></span>

#### <a name="count-the-number-of-display-characters-in-a-string"></a><span data-ttu-id="dc568-144">Z√§hlen der Anzahl der Anzeige Zeichen in einem `string`</span><span class="sxs-lookup"><span data-stu-id="dc568-144">Count the number of display characters in a `string`</span></span>

<span data-ttu-id="dc568-145">Die Anzahl der `Rune` Instanzen in einer Zeichenfolge stimmt m√∂glicherweise nicht mit der Anzahl der Benutzer ab, die beim Anzeigen der Zeichenfolge angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="dc568-145">The number of `Rune` instances in a string might not match the number of user-perceivable characters shown when displaying the string.</span></span>

<span data-ttu-id="dc568-146">Da- `Rune` Instanzen Unicode-Skalarwerte darstellen, k√∂nnen Komponenten, die den [Unicode-Text Segmentierungs Richtlinien](https://www.unicode.org/reports/tr29/) folgen, `Rune` als Baustein zum z√§hlen von Anzeige Zeichen verwenden.</span><span class="sxs-lookup"><span data-stu-id="dc568-146">Since `Rune` instances represent Unicode scalar values, components that follow the [Unicode text segmentation guidelines](https://www.unicode.org/reports/tr29/) can use `Rune` as a building block for counting display characters.</span></span>

<span data-ttu-id="dc568-147">Der- <xref:System.Globalization.StringInfo> Typ kann zum z√§hlen von Anzeige Zeichen verwendet werden, aber in anderen .net-Implementierungen als .net 5 wird er nicht in allen Szenarien ordnungsgem√§√ü gez√§hlt.</span><span class="sxs-lookup"><span data-stu-id="dc568-147">The <xref:System.Globalization.StringInfo> type can be used to count display characters, but in implementations of .NET other than .NET 5 it doesn't count correctly in all scenarios.</span></span>

<span data-ttu-id="dc568-148">Weitere Informationen finden Sie unter [Grapheme-Cluster](/dotnet/standard/base-types/character-encoding-introduction#grapheme-clusters).</span><span class="sxs-lookup"><span data-stu-id="dc568-148">For more information, see [Grapheme clusters](/dotnet/standard/base-types/character-encoding-introduction#grapheme-clusters).</span></span>

### <a name="how-to-instantiate-a-rune"></a><span data-ttu-id="dc568-149">Vorgehensweise beim Instanziieren eines `Rune`</span><span class="sxs-lookup"><span data-stu-id="dc568-149">How to instantiate a `Rune`</span></span>

<span data-ttu-id="dc568-150">Es gibt mehrere M√∂glichkeiten, um eine-Instanz zu erhalten `Rune` .</span><span class="sxs-lookup"><span data-stu-id="dc568-150">There are several ways to get a `Rune` instance.</span></span> <span data-ttu-id="dc568-151">Sie k√∂nnen einen Konstruktor verwenden, um `Rune` direkt aus zu erstellen:</span><span class="sxs-lookup"><span data-stu-id="dc568-151">You can use a constructor to create a `Rune` directly from:</span></span>

* <span data-ttu-id="dc568-152">Ein Codepunkt.</span><span class="sxs-lookup"><span data-stu-id="dc568-152">A code point.</span></span>

  :::code language="csharp" source="~/snippets/System.Text/Rune/csharp/InstantiateRunes.cs" id="SnippetCodePoint":::

* <span data-ttu-id="dc568-153">Eine einzelne `char`.</span><span class="sxs-lookup"><span data-stu-id="dc568-153">A single `char`.</span></span>

  :::code language="csharp" source="~/snippets/System.Text/Rune/csharp/InstantiateRunes.cs" id="SnippetChar":::

* <span data-ttu-id="dc568-154">Ein Ersatz Zeichen `char` Paar.</span><span class="sxs-lookup"><span data-stu-id="dc568-154">A surrogate `char` pair.</span></span>

  :::code language="csharp" source="~/snippets/System.Text/Rune/csharp/InstantiateRunes.cs" id="SnippetSurrogate":::

<span data-ttu-id="dc568-155">Alle Konstruktoren l√∂sen eine aus, `ArgumentException` Wenn die Eingabe keinen g√ºltigen Unicode-Skalarwert darstellt.</span><span class="sxs-lookup"><span data-stu-id="dc568-155">All of the constructors throw an `ArgumentException` if the input doesn't represent a valid Unicode scalar value.</span></span>

<span data-ttu-id="dc568-156">Es stehen <xref:System.Text.Rune.TryCreate%2A?displayProperty=nameWithType> Methoden f√ºr Aufrufer zur Verf√ºgung, die keine Ausnahmen bei einem Fehler ausl√∂sen m√∂chten.</span><span class="sxs-lookup"><span data-stu-id="dc568-156">There are <xref:System.Text.Rune.TryCreate%2A?displayProperty=nameWithType> methods available for callers who don't want exceptions to be thrown on failure.</span></span>

<span data-ttu-id="dc568-157">`Rune` Instanzen k√∂nnen auch aus vorhandenen Eingabe Sequenzen gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="dc568-157">`Rune` instances can also be read from existing input sequences.</span></span> <span data-ttu-id="dc568-158">Wenn Beispiels `ReadOnlySpan<char>` Weise ein-Wert mit UTF-16-Daten darstellt, gibt die- <xref:System.Text.Rune.DecodeFromUtf16%2A?displayProperty=nameWithType> Methode die erste `Rune` Instanz am Anfang der Eingabe Spanne zur√ºck.</span><span class="sxs-lookup"><span data-stu-id="dc568-158">For instance, given a `ReadOnlySpan<char>` that represents UTF-16 data, the <xref:System.Text.Rune.DecodeFromUtf16%2A?displayProperty=nameWithType> method returns the first `Rune` instance at the beginning of the input span.</span></span> <span data-ttu-id="dc568-159">Die- <xref:System.Text.Rune.DecodeFromUtf8%2A?displayProperty=nameWithType> Methode funktioniert √§hnlich und akzeptiert einen `ReadOnlySpan<byte>` Parameter, der UTF-8-Daten darstellt.</span><span class="sxs-lookup"><span data-stu-id="dc568-159">The <xref:System.Text.Rune.DecodeFromUtf8%2A?displayProperty=nameWithType> method operates similarly, accepting a `ReadOnlySpan<byte>` parameter that represents UTF-8 data.</span></span> <span data-ttu-id="dc568-160">Es gibt √§quivalente Methoden zum Lesen vom Ende der Spanne anstelle des Anfangs der Spanne.</span><span class="sxs-lookup"><span data-stu-id="dc568-160">There are equivalent methods to read from the end of the span instead of the beginning of the span.</span></span>

### <a name="query-properties-of-a-rune"></a><span data-ttu-id="dc568-161">Abfrage Eigenschaften eines `Rune`</span><span class="sxs-lookup"><span data-stu-id="dc568-161">Query properties of a `Rune`</span></span>

<span data-ttu-id="dc568-162">Um den ganzzahligen Code Punkt Wert einer-Instanz zu erhalten `Rune` , verwenden Sie die- <xref:System.Text.Rune.Value?displayProperty=nameWithType> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dc568-162">To get the integer code point value of a `Rune` instance, use the <xref:System.Text.Rune.Value?displayProperty=nameWithType> property.</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/InstantiateRunes.cs" id="SnippetValue":::

<span data-ttu-id="dc568-163">Viele der statischen APIs, die f√ºr den `char` Typ verf√ºgbar sind, sind auch f√ºr den- `Rune` Typ verf√ºgbar.</span><span class="sxs-lookup"><span data-stu-id="dc568-163">Many of the static APIs available on the `char` type are also available on the `Rune` type.</span></span> <span data-ttu-id="dc568-164">Beispielsweise <xref:System.Text.Rune.IsWhiteSpace%2A?displayProperty=nameWithType> sind und <xref:System.Text.Rune.GetUnicodeCategory%2A?displayProperty=nameWithType> Entsprechungen zu <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> -und- <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> Methoden.</span><span class="sxs-lookup"><span data-stu-id="dc568-164">For instance, <xref:System.Text.Rune.IsWhiteSpace%2A?displayProperty=nameWithType> and <xref:System.Text.Rune.GetUnicodeCategory%2A?displayProperty=nameWithType> are equivalents to <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> and <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="dc568-165">Die `Rune` Methoden behandeln Ersatzpaare ordnungsgem√§√ü.</span><span class="sxs-lookup"><span data-stu-id="dc568-165">The `Rune` methods correctly handle surrogate pairs.</span></span>

<span data-ttu-id="dc568-166">Der folgende Beispielcode nimmt `ReadOnlySpan<char>` sowohl als Eingabe als auch als sowohl aus dem Anfang als auch dem Ende der Spanne jede, bei der es `Rune` sich nicht um einen Buchstaben oder eine Ziffer handelt.</span><span class="sxs-lookup"><span data-stu-id="dc568-166">The following example code takes a `ReadOnlySpan<char>` as input and trims from both the start and the end of the span every `Rune` that isn't a letter or a digit.</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/TrimNonLettersAndNonDigits.cs" id="SnippetExample":::

<span data-ttu-id="dc568-167">Es gibt einige API-Unterschiede zwischen `char` und `Rune` .</span><span class="sxs-lookup"><span data-stu-id="dc568-167">There are some API differences between `char` and `Rune`.</span></span> <span data-ttu-id="dc568-168">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="dc568-168">For example:</span></span>

* <span data-ttu-id="dc568-169">Es gibt keine `Rune` Entsprechung <xref:System.Char.IsSurrogate(System.Char)?displayProperty=nameWithType> von, da `Rune` Instanzen definitionsgem√§√ü nie Ersatz Code Punkte sein k√∂nnen.</span><span class="sxs-lookup"><span data-stu-id="dc568-169">There is no `Rune` equivalent  to <xref:System.Char.IsSurrogate(System.Char)?displayProperty=nameWithType>, since `Rune` instances by definition can never be surrogate code points.</span></span>
* <span data-ttu-id="dc568-170"><xref:System.Text.Rune.GetUnicodeCategory%2A?displayProperty=nameWithType>Gibt nicht immer dasselbe Ergebnis wie zur√ºck <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="dc568-170">The <xref:System.Text.Rune.GetUnicodeCategory%2A?displayProperty=nameWithType> doesn't always return the same result as <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dc568-171">Er gibt den gleichen Wert wie zur√ºck <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="dc568-171">It does return the same value as <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dc568-172">Weitere Informationen finden **Sie in den** hinweisen zu <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="dc568-172">For more information, see the **Remarks** on <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType>.</span></span>

### <a name="convert-a-rune-to-utf-8-or-utf-16"></a><span data-ttu-id="dc568-173">Konvertieren `Rune` von in UTF-8 oder UTF-16</span><span class="sxs-lookup"><span data-stu-id="dc568-173">Convert a `Rune` to UTF-8 or UTF-16</span></span>

<span data-ttu-id="dc568-174">Da ein `Rune` ein Unicode-Skalarwert ist, kann er in UTF-8-, UTF-16-oder UTF-32-Codierung konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="dc568-174">Since a `Rune` is a Unicode scalar value, it can be converted to UTF-8, UTF-16, or UTF-32 encoding.</span></span> <span data-ttu-id="dc568-175">Der `Rune` -Typ verf√ºgt √ºber integrierte Unterst√ºtzung f√ºr die Konvertierung in UTF-8 und UTF-16.</span><span class="sxs-lookup"><span data-stu-id="dc568-175">The `Rune` type has built-in support for conversion to UTF-8 and UTF-16.</span></span>

<span data-ttu-id="dc568-176"><xref:System.Text.Rune.EncodeToUtf16%2A?displayProperty=nameWithType>Konvertiert eine- `Rune` Instanz in- `char` Instanzen.</span><span class="sxs-lookup"><span data-stu-id="dc568-176">The <xref:System.Text.Rune.EncodeToUtf16%2A?displayProperty=nameWithType> converts a `Rune` instance to `char` instances.</span></span> <span data-ttu-id="dc568-177">Verwenden Sie die-Eigenschaft, um die Anzahl von Instanzen abzufragen, die sich `char` aus der Umstellung einer- `Rune` Instanz in UTF-16 ergeben w√ºrden <xref:System.Text.Rune.Utf16SequenceLength?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="dc568-177">To query the number of `char` instances that would result from converting a `Rune` instance to UTF-16, use the <xref:System.Text.Rune.Utf16SequenceLength?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="dc568-178">√Ñhnliche Methoden sind f√ºr die UTF-8-Konvertierung vorhanden.</span><span class="sxs-lookup"><span data-stu-id="dc568-178">Similar methods exist for UTF-8 conversion.</span></span>

<span data-ttu-id="dc568-179">Im folgenden Beispiel wird eine- `Rune` Instanz in ein- `char` Array konvertiert.</span><span class="sxs-lookup"><span data-stu-id="dc568-179">The following example converts a `Rune` instance to a `char` array.</span></span> <span data-ttu-id="dc568-180">Der Code setzt voraus, dass Sie √ºber eine- `Rune` Instanz in der- `rune` Variable verf√ºgen</span><span class="sxs-lookup"><span data-stu-id="dc568-180">The code assumes you have a `Rune` instance in the `rune` variable:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/EncodeRune.cs" id="SnippetUtf16CharArray":::

<span data-ttu-id="dc568-181">Da eine `string` eine Sequenz von UTF-16-Zeichen ist, wird im folgenden Beispiel auch eine- `Rune` Instanz in UTF-16 konvertiert:</span><span class="sxs-lookup"><span data-stu-id="dc568-181">Since a `string` is a sequence of UTF-16 chars, the following example also converts a `Rune` instance to UTF-16:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/EncodeRune.cs" id="SnippetUtf16String":::

<span data-ttu-id="dc568-182">Im folgenden Beispiel wird eine- `Rune` Instanz in ein `UTF-8` Bytearray konvertiert:</span><span class="sxs-lookup"><span data-stu-id="dc568-182">The following example converts a `Rune` instance to a `UTF-8` byte array:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/EncodeRune.cs" id="SnippetUtf8ByteArray":::

<span data-ttu-id="dc568-183">Die <xref:System.Text.Rune.EncodeToUtf16%2A?displayProperty=nameWithType> - <xref:System.Text.Rune.EncodeToUtf8%2A?displayProperty=nameWithType> Methode und die-Methode geben die tats√§chliche Anzahl der geschriebenen Elemente zur√ºck.</span><span class="sxs-lookup"><span data-stu-id="dc568-183">The <xref:System.Text.Rune.EncodeToUtf16%2A?displayProperty=nameWithType> and <xref:System.Text.Rune.EncodeToUtf8%2A?displayProperty=nameWithType> methods return the actual number of elements written.</span></span> <span data-ttu-id="dc568-184">Sie l√∂sen eine Ausnahme aus, wenn der Ziel Puffer zu kurz ist, um das Ergebnis zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="dc568-184">They throw an exception if the destination buffer is too short to contain the result.</span></span> <span data-ttu-id="dc568-185">Es gibt auch nicht ausl√∂sende <xref:System.Text.Rune.TryEncodeToUtf8%2A> Methoden und f√ºr Aufrufer <xref:System.Text.Rune.EncodeToUtf16%2A> , die Ausnahmen vermeiden m√∂chten.</span><span class="sxs-lookup"><span data-stu-id="dc568-185">There are non-throwing <xref:System.Text.Rune.TryEncodeToUtf8%2A> and <xref:System.Text.Rune.EncodeToUtf16%2A> methods as well for callers who want to avoid exceptions.</span></span>

### <a name="rune-in-net-vs-other-languages"></a><span data-ttu-id="dc568-186">Rune in .net im Vergleich zu anderen Sprachen</span><span class="sxs-lookup"><span data-stu-id="dc568-186">Rune in .NET vs. other languages</span></span>

<span data-ttu-id="dc568-187">Der Begriff "Rune" ist im Unicode-Standard nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="dc568-187">The term "rune" is not defined in the Unicode Standard.</span></span> <span data-ttu-id="dc568-188">Der Begriff ist zur√ºck auf [die Erstellung von UTF-8](https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt).</span><span class="sxs-lookup"><span data-stu-id="dc568-188">The term dates back to [the creation of UTF-8](https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt).</span></span> <span data-ttu-id="dc568-189">Rob Pike und Ken Thompson suchten nach einem Begriff, der beschreibt, was schlie√ülich als Codepunkt bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="dc568-189">Rob Pike and Ken Thompson were looking for a term to describe what would eventually become known as a code point.</span></span> <span data-ttu-id="dc568-190">[Sie sind auf den Begriff "Rune" festgelegt](https://twitter.com/rob_pike/status/732353233474064384), und der sp√§tere Einfluss von Rob Pike auf die go-Programmiersprache half dabei, den Begriff zu popularisieren.</span><span class="sxs-lookup"><span data-stu-id="dc568-190">[They settled on the term "rune"](https://twitter.com/rob_pike/status/732353233474064384), and Rob Pike's later influence over the Go programming language helped popularize the term.</span></span>

<span data-ttu-id="dc568-191">Der .net- `Rune` Typ ist jedoch nicht das √Ñquivalent zum Go- `rune` Typ.</span><span class="sxs-lookup"><span data-stu-id="dc568-191">However, the .NET `Rune` type is not the equivalent of the Go `rune` type.</span></span> <span data-ttu-id="dc568-192">In Go ist der `rune` Typ ein [Alias f√ºr `int32` ](https://blog.golang.org/strings).</span><span class="sxs-lookup"><span data-stu-id="dc568-192">In Go, the `rune` type is an [alias for `int32`](https://blog.golang.org/strings).</span></span> <span data-ttu-id="dc568-193">Eine Go-Rune ist f√ºr die Darstellung eines Unicode-Code Punkts gedacht, kann jedoch ein beliebiger 32-Bit-Wert sein, einschlie√ülich Ersatz Code Punkten und Werten, die keine zul√§ssigen Unicode-Code Punkte sind.</span><span class="sxs-lookup"><span data-stu-id="dc568-193">A Go rune is intended to represent a Unicode code point, but it can be any 32-bit value, including surrogate code points and values that are not legal Unicode code points.</span></span>

<span data-ttu-id="dc568-194">Informationen zu √§hnlichen Typen in anderen Programmiersprachen finden Sie unter der [primitive `char` Typ von Rust](https://doc.rust-lang.org/std/primitive.char.html) oder der [SWIFT- `Unicode.Scalar` Typ](https://developer.apple.com/documentation/swift/unicode/scalar), die beide Unicode-Skalarwerte darstellen.</span><span class="sxs-lookup"><span data-stu-id="dc568-194">For similar types in other programming languages, see [Rust's primitive `char` type](https://doc.rust-lang.org/std/primitive.char.html) or [Swift's `Unicode.Scalar` type](https://developer.apple.com/documentation/swift/unicode/scalar), both of which represent Unicode scalar values.</span></span> <span data-ttu-id="dc568-195">Sie bieten √§hnliche Funktionen wie. Der `Rune` Netzwerktyp, und Sie k√∂nnen keine Instanziierung von Werten zulassen, die keine zul√§ssigen Unicode-Skalarwerte sind.</span><span class="sxs-lookup"><span data-stu-id="dc568-195">They provide functionality similar to .NET's `Rune` type, and they disallow instantiation of values that are not legal Unicode scalar values.</span></span>

          ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(char ch);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : char -&gt; System.Text.Rune" Usage="new System.Text.Rune ch" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch"><span data-ttu-id="dc568-196">Eine UTF-16-Codeeinheit.</span><span class="sxs-lookup"><span data-stu-id="dc568-196">A UTF-16 code unit.</span></span></param>
        <summary><span data-ttu-id="dc568-197">Erstellt eine <see cref="T:System.Text.Rune" />-Struktur aus der bereitgestellten UTF-16-Codeeinheit.</span><span class="sxs-lookup"><span data-stu-id="dc568-197">Creates a <see cref="T:System.Text.Rune" /> from the provided UTF-16 code unit.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="dc568-198"><paramref name="ch" /> stellt ein Ersatzzeichen f√ºr einen UTF-16-Codepunkt dar (U+D800..U+DFFF, einschlie√ülich).</span><span class="sxs-lookup"><span data-stu-id="dc568-198"><paramref name="ch" /> represents a UTF-16 surrogate code point (U+D800..U+DFFF, inclusive).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(int value);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : int -&gt; System.Text.Rune" Usage="new System.Text.Rune value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-199">Ein Unicode-Skalarwert.</span><span class="sxs-lookup"><span data-stu-id="dc568-199">A Unicode scalar value.</span></span></param>
        <summary><span data-ttu-id="dc568-200">Erstellt eine <see cref="T:System.Text.Rune" />-Struktur aus der angegebenen 32-Bit-Ganzzahl, die einen Unicode-Skalarwert darstellt.</span><span class="sxs-lookup"><span data-stu-id="dc568-200">Creates a <see cref="T:System.Text.Rune" /> from the specified 32-bit integer that represents a Unicode scalar value.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="dc568-201"><paramref name="value" /> stellt keinen Unicode-Skalarwert dar.</span><span class="sxs-lookup"><span data-stu-id="dc568-201"><paramref name="value" /> does not represent a Unicode scalar value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : uint32 -&gt; System.Text.Rune" Usage="new System.Text.Rune value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-202">Ein Unicode-Skalarwert.</span><span class="sxs-lookup"><span data-stu-id="dc568-202">A Unicode scalar value.</span></span></param>
        <summary><span data-ttu-id="dc568-203">Erstellt eine <see cref="T:System.Text.Rune" />-Struktur aus der angegebenen 32-Bit-Ganzzahl ohne Vorzeichen, die einen Unicode-Skalarwert darstellt.</span><span class="sxs-lookup"><span data-stu-id="dc568-203">Creates a <see cref="T:System.Text.Rune" /> from the specified 32-bit unsigned integer that represents a Unicode scalar value.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="dc568-204"><paramref name="value" /> stellt keinen Unicode-Skalarwert dar.</span><span class="sxs-lookup"><span data-stu-id="dc568-204"><paramref name="value" /> does not represent a Unicode scalar value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (highSurrogate As Char, lowSurrogate As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : char * char -&gt; System.Text.Rune" Usage="new System.Text.Rune (highSurrogate, lowSurrogate)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="highSurrogate"><span data-ttu-id="dc568-205">Das hohe Ersatzzeichen des Ersatzzeichenpaars.</span><span class="sxs-lookup"><span data-stu-id="dc568-205">The high surrogate of the surrogate pair.</span></span></param>
        <param name="lowSurrogate"><span data-ttu-id="dc568-206">Das niedrige Ersatzzeichen des Ersatzzeichenpaars.</span><span class="sxs-lookup"><span data-stu-id="dc568-206">The low surrogate of the surrogate pair.</span></span></param>
        <summary><span data-ttu-id="dc568-207">Erstellt eine <see cref="T:System.Text.Rune" />-Struktur aus dem bereitgestellten UTF-16-Ersatzzeichenpaar.</span><span class="sxs-lookup"><span data-stu-id="dc568-207">Creates a <see cref="T:System.Text.Rune" /> from the provided UTF-16 surrogate pair.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="dc568-208"><paramref name="highSurrogate" /> stellt kein hohes Ersatzzeichen f√ºr einen UTF-16-Codepunkt dar.</span><span class="sxs-lookup"><span data-stu-id="dc568-208"><paramref name="highSurrogate" /> does not represent a UTF-16 high surrogate code point.</span></span>
          
<span data-ttu-id="dc568-209">-¬†oder¬†-</span><span class="sxs-lookup"><span data-stu-id="dc568-209">-or-</span></span>

<span data-ttu-id="dc568-210"><paramref name="lowSurrogate" /> stellt kein niedriges Ersatzzeichen f√ºr einen UTF-16-Codepunkt dar.</span><span class="sxs-lookup"><span data-stu-id="dc568-210"><paramref name="lowSurrogate" /> does not represent a UTF-16 low surrogate code point.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Text.Rune other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Text.Rune other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.CompareTo(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Rune) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Text::Rune other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Text.Rune -&gt; int&#xA;override this.CompareTo : System.Text.Rune -&gt; int" Usage="rune.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="dc568-211">Die Instanz, die mit der aktuellen Instanz verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc568-211">The instance to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="dc568-212">Vergleicht die aktuelle Instanz mit dem angegebenen <see cref="T:System.Text.Rune" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="dc568-212">Compares the current instance to the specified <see cref="T:System.Text.Rune" /> instance.</span></span></summary>
        <returns><span data-ttu-id="dc568-213">Eine ganze Zahl mit Vorzeichen, die die Position dieser Instanz in der Sortierreihenfolge in Bezug auf <paramref name="other" /> angibt:</span><span class="sxs-lookup"><span data-stu-id="dc568-213">A signed integer indicating the position of this instance in the sort order in relation to <paramref name="other" />:</span></span> <br /><span data-ttu-id="dc568-214">Kleiner als 0: Diese Instanz ist <paramref name="other" /> vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="dc568-214">- Less than zero: This instance precedes <paramref name="other" />.</span></span> 
<br /><span data-ttu-id="dc568-215">0: Die Instanz hat in der Sortierreihenfolge dieselbe Position wie <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-215">- Zero: The instance has the same position in the sort order as <paramref name="other" />.</span></span>
<br /><span data-ttu-id="dc568-216">Gr√∂√üer als 0: Diese Instanz folgt <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-216">- Greater than zero: This instance follows <paramref name="other" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeFromUtf16">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeFromUtf16 (ReadOnlySpan&lt;char&gt; source, out System.Text.Rune result, out int charsConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeFromUtf16(valuetype System.ReadOnlySpan`1&lt;char&gt; source, [out] valuetype System.Text.Rune&amp; result, [out] int32&amp; charsConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeFromUtf16 (source As ReadOnlySpan(Of Char), ByRef result As Rune, ByRef charsConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeFromUtf16(ReadOnlySpan&lt;char&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % result, [Runtime::InteropServices::Out] int % charsConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeFromUtf16 : ReadOnlySpan&lt;char&gt; * Rune * int -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeFromUtf16 (source, result, charsConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="charsConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="dc568-217">Eine schreibgesch√ºtzte UTF-16-Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="dc568-217">A read-only UTF-16 character span.</span></span></param>
        <param name="result"><span data-ttu-id="dc568-218">Die decodierte Rune bei R√ºckgabe dieser Methode.</span><span class="sxs-lookup"><span data-stu-id="dc568-218">When this method returns, the decoded rune.</span></span></param>
        <param name="charsConsumed"><span data-ttu-id="dc568-219">Die Anzahl der zur Erstellung der Rune gelesenen Zeichen bei R√ºckgabe dieser Methode.</span><span class="sxs-lookup"><span data-stu-id="dc568-219">When this method returns, the number of characters read to create the rune.</span></span></param>
        <summary><span data-ttu-id="dc568-220">Decodiert das <see cref="T:System.Text.Rune" />-Element am Anfang des bereitgestellten UTF-16-Quellpuffers.</span><span class="sxs-lookup"><span data-stu-id="dc568-220">Decodes the <see cref="T:System.Text.Rune" /> at the beginning of the provided UTF-16 source buffer.</span></span></summary>
        <returns><span data-ttu-id="dc568-221"><see cref="F:System.Buffers.OperationStatus.Done" />, wenn der Quellpuffer mit einem g√ºltigen, UTF-16-codierten Skalarwert beginnt.</span><span class="sxs-lookup"><span data-stu-id="dc568-221"><see cref="F:System.Buffers.OperationStatus.Done" /> if the source buffer begins with a valid UTF-16 encoded scalar value.</span></span> <span data-ttu-id="dc568-222"><paramref name="result" /> enth√§lt dann die decodierte <see cref="T:System.Text.Rune" />-Eigenschaft und <paramref name="charsConsumed" /> die Anzahl an <see cref="T:System.Char" />-Werten, die in dem Eingabepuffer zur Codierung der <see cref="T:System.Text.Rune" />-Struktur verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dc568-222"><paramref name="result" /> then contains the decoded <see cref="T:System.Text.Rune" />, and <paramref name="charsConsumed" /> contains the number of <see cref="T:System.Char" /> values used in the input buffer to encode the <see cref="T:System.Text.Rune" />.</span></span>
            
<span data-ttu-id="dc568-223"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" />, wenn der Quellpuffer leer ist oder nur ein eigenst√§ndiges hohe UTF-16-Ersatzzeichen enth√§lt.</span><span class="sxs-lookup"><span data-stu-id="dc568-223"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" /> if the source buffer is empty or contains only a standalone UTF-16 high surrogate character.</span></span> <span data-ttu-id="dc568-224"><paramref name="result" /> enth√§lt dann <see cref="P:System.Text.Rune.ReplacementChar" /> und <paramref name="charsConsumed" /> enth√§lt die L√§nge des Eingabepuffers.</span><span class="sxs-lookup"><span data-stu-id="dc568-224"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="charsConsumed" /> contains the length of the input buffer.</span></span>
            
<span data-ttu-id="dc568-225"><see cref="F:System.Buffers.OperationStatus.InvalidData" />, wenn der Quellpuffer mit einem falsch formatierten, UTF-16-codierten Skalarwert beginnt.</span><span class="sxs-lookup"><span data-stu-id="dc568-225"><see cref="F:System.Buffers.OperationStatus.InvalidData" /> if the source buffer begins with an ill-formed UTF-16 encoded scalar value.</span></span> <span data-ttu-id="dc568-226"><paramref name="result" /> enth√§lt dann <see cref="P:System.Text.Rune.ReplacementChar" /> und <paramref name="charsConsumed" /> enth√§lt die Anzahl von <see cref="T:System.Char" />-Werten, die zum Codieren der falsch formatierten Sequenz verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dc568-226"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="charsConsumed" /> contains the number of <see cref="T:System.Char" /> values used to encode the ill-formed sequence.</span></span>
<span data-ttu-id="dc568-227">.</span><span class="sxs-lookup"><span data-stu-id="dc568-227">.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-228">Die allgemeine Konvention besteht darin, diese Methode in einer-Schleife aufzurufen und den `source` Puffer in `charsConsumed` jeder Iterations Schleife durch Elemente aufzuteilen.</span><span class="sxs-lookup"><span data-stu-id="dc568-228">The general convention is to call this method in a loop, slicing the `source` buffer by `charsConsumed` elements on each iteration of the loop.</span></span> <span data-ttu-id="dc568-229">Enth√§lt bei jeder Iterationen der Schleife `result` den echten Skalarwert, wenn die Daten erfolgreich decodiert wurden, oder enth√§lt, <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> Wenn die Daten nicht erfolgreich decodiert wurden.</span><span class="sxs-lookup"><span data-stu-id="dc568-229">On each iteration of the loop, `result` contains the real scalar value if the data was successfully decoded, or it contains <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> if the data was not successfully decoded.</span></span> <span data-ttu-id="dc568-230">Dieses Muster bietet bequeme automatische U + FFFD-Ersetzung ung√ºltiger Sequenzen beim Durchlaufen der Schleife.</span><span class="sxs-lookup"><span data-stu-id="dc568-230">This pattern provides convenient automatic U+FFFD substitution of invalid sequences while iterating through the loop.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeFromUtf8">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeFromUtf8 (ReadOnlySpan&lt;byte&gt; source, out System.Text.Rune result, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeFromUtf8(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] valuetype System.Text.Rune&amp; result, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeFromUtf8 (source As ReadOnlySpan(Of Byte), ByRef result As Rune, ByRef bytesConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeFromUtf8(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % result, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeFromUtf8 : ReadOnlySpan&lt;byte&gt; * Rune * int -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeFromUtf8 (source, result, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="dc568-231">Eine schreibgesch√ºtzte UTF-8-codierte Bytespanne.</span><span class="sxs-lookup"><span data-stu-id="dc568-231">A read-only UTF-8 encoded byte span.</span></span></param>
        <param name="result"><span data-ttu-id="dc568-232">Die decodierte Rune bei R√ºckgabe dieser Methode.</span><span class="sxs-lookup"><span data-stu-id="dc568-232">When this method returns, the decoded rune.</span></span></param>
        <param name="bytesConsumed"><span data-ttu-id="dc568-233">Die Anzahl von Bytes, die bei der Erstellung der Rune gelesen werden, wenn diese Methode zur√ºckgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dc568-233">When this method returns, the number of bytes read to create the rune.</span></span></param>
        <summary><span data-ttu-id="dc568-234">Decodiert das <see cref="T:System.Text.Rune" />-Element am Anfang des bereitgestellten UTF-8-Quellpuffers.</span><span class="sxs-lookup"><span data-stu-id="dc568-234">Decodes the <see cref="T:System.Text.Rune" /> at the beginning of the provided UTF-8 source buffer.</span></span></summary>
        <returns><span data-ttu-id="dc568-235"><see cref="F:System.Buffers.OperationStatus.Done" />, wenn der Quellpuffer mit einem g√ºltigen, UTF-8-codierten Skalarwert beginnt.</span><span class="sxs-lookup"><span data-stu-id="dc568-235"><see cref="F:System.Buffers.OperationStatus.Done" /> if the source buffer begins with a valid UTF-8 encoded scalar value.</span></span> <span data-ttu-id="dc568-236"><paramref name="result" /> enth√§lt dann die decodierte <see cref="T:System.Text.Rune" />-Eigenschaft und <paramref name="bytesConsumed" /> die Anzahl an <see cref="T:System.Byte" />-Werten, die in dem Eingabepuffer zur Codierung der <see cref="T:System.Text.Rune" />-Struktur verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dc568-236"><paramref name="result" /> then contains the decoded <see cref="T:System.Text.Rune" />, and <paramref name="bytesConsumed" /> contains the number of <see cref="T:System.Byte" /> values used in the input buffer to encode the <see cref="T:System.Text.Rune" />.</span></span>
            
<span data-ttu-id="dc568-237"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" />, wenn der Quellpuffer leer ist oder nur ein eigenst√§ndiges hohe UTF-8-Ersatzzeichen enth√§lt.</span><span class="sxs-lookup"><span data-stu-id="dc568-237"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" /> if the source buffer is empty or contains only a standalone UTF-8 high surrogate character.</span></span> <span data-ttu-id="dc568-238"><paramref name="result" /> enth√§lt dann <see cref="P:System.Text.Rune.ReplacementChar" /> und <paramref name="bytesConsumed" /> enth√§lt die L√§nge des Eingabepuffers.</span><span class="sxs-lookup"><span data-stu-id="dc568-238"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="bytesConsumed" /> contains the length of the input buffer.</span></span>
            
<span data-ttu-id="dc568-239"><see cref="F:System.Buffers.OperationStatus.InvalidData" />, wenn der Quellpuffer mit einem falsch formatierten, UTF-8-codierten Skalarwert beginnt.</span><span class="sxs-lookup"><span data-stu-id="dc568-239"><see cref="F:System.Buffers.OperationStatus.InvalidData" /> if the source buffer begins with an ill-formed UTF-8 encoded scalar value.</span></span> <span data-ttu-id="dc568-240"><paramref name="result" /> enth√§lt dann <see cref="P:System.Text.Rune.ReplacementChar" /> und <paramref name="bytesConsumed" /> enth√§lt die Anzahl von <see cref="T:System.Byte" />-Werten, die im Eingabepuffer zum Codieren der falsch formatierten Sequenz verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dc568-240"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="bytesConsumed" /> contains the number of <see cref="T:System.Byte" /> values used in the input buffer to encode the ill-formed sequence.</span></span>
<span data-ttu-id="dc568-241">.</span><span class="sxs-lookup"><span data-stu-id="dc568-241">.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-242">Die allgemeine Konvention besteht darin, diese Methode in einer-Schleife aufzurufen und den `source` Puffer in `bytesConsumed` jeder Iterations Schleife durch Elemente aufzuteilen.</span><span class="sxs-lookup"><span data-stu-id="dc568-242">The general convention is to call this method in a loop, slicing the `source` buffer by `bytesConsumed` elements on each iteration of the loop.</span></span> <span data-ttu-id="dc568-243">Enth√§lt bei jeder Iterationen der Schleife `result` den echten Skalarwert, wenn er erfolgreich decodiert wurde, oder enth√§lt, <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> Wenn die Daten nicht erfolgreich decodiert werden konnten.</span><span class="sxs-lookup"><span data-stu-id="dc568-243">On each iteration of the loop, `result` contains the real scalar value if successfully decoded, or it contains <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> if the data could not be successfully decoded.</span></span> <span data-ttu-id="dc568-244">Dieses Muster bietet bequeme automatische U + FFFD-Ersetzung ung√ºltiger Sequenzen beim Durchlaufen der Schleife.</span><span class="sxs-lookup"><span data-stu-id="dc568-244">This pattern provides convenient automatic U+FFFD substitution of invalid sequences while iterating through the loop.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeLastFromUtf16">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeLastFromUtf16 (ReadOnlySpan&lt;char&gt; source, out System.Text.Rune result, out int charsConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeLastFromUtf16(valuetype System.ReadOnlySpan`1&lt;char&gt; source, [out] valuetype System.Text.Rune&amp; result, [out] int32&amp; charsConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeLastFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeLastFromUtf16 (source As ReadOnlySpan(Of Char), ByRef result As Rune, ByRef charsConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeLastFromUtf16(ReadOnlySpan&lt;char&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % result, [Runtime::InteropServices::Out] int % charsConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeLastFromUtf16 : ReadOnlySpan&lt;char&gt; * Rune * int -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeLastFromUtf16 (source, result, charsConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="charsConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="dc568-245">Eine schreibgesch√ºtzte UTF-16-codierte Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="dc568-245">A read-only UTF-16 encoded character span.</span></span></param>
        <param name="result"><span data-ttu-id="dc568-246">Die decodierte Rune bei R√ºckgabe dieser Methode.</span><span class="sxs-lookup"><span data-stu-id="dc568-246">When this method returns, the decoded rune.</span></span></param>
        <param name="charsConsumed"><span data-ttu-id="dc568-247">Die Anzahl von Bytes, die bei der Erstellung der Rune gelesen werden, wenn diese Methode zur√ºckgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dc568-247">When this method returns, the number of bytes read to create the rune.</span></span></param>
        <summary><span data-ttu-id="dc568-248">Decodiert das <see cref="T:System.Text.Rune" />-Element am Ende des bereitgestellten UTF-16-Quellpuffers.</span><span class="sxs-lookup"><span data-stu-id="dc568-248">Decodes the <see cref="T:System.Text.Rune" /> at the end of the provided UTF-16 source buffer.</span></span></summary>
        <returns><span data-ttu-id="dc568-249"><see cref="F:System.Buffers.OperationStatus.Done" />, wenn der Quellpuffer mit einem g√ºltigen, UTF-16-codierten Skalarwert beginnt.</span><span class="sxs-lookup"><span data-stu-id="dc568-249"><see cref="F:System.Buffers.OperationStatus.Done" /> if the source buffer begins with a valid UTF-16 encoded scalar value.</span></span> <span data-ttu-id="dc568-250"><paramref name="result" /> enth√§lt dann die decodierte <see cref="T:System.Text.Rune" />-Eigenschaft und <paramref name="charsConsumed" /> die Anzahl an <see cref="T:System.Char" />-Werten, die in dem Eingabepuffer zur Codierung der <see cref="T:System.Text.Rune" />-Struktur verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dc568-250"><paramref name="result" /> then contains the decoded <see cref="T:System.Text.Rune" />, and <paramref name="charsConsumed" /> contains the number of <see cref="T:System.Char" /> values used in the input buffer to encode the <see cref="T:System.Text.Rune" />.</span></span>
            
<span data-ttu-id="dc568-251"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" />, wenn der Quellpuffer leer ist oder nur ein eigenst√§ndiges hohe UTF-16-Ersatzzeichen enth√§lt.</span><span class="sxs-lookup"><span data-stu-id="dc568-251"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" /> if the source buffer is empty or contains only a standalone UTF-16 high surrogate character.</span></span> <span data-ttu-id="dc568-252"><paramref name="result" /> enth√§lt dann <see cref="P:System.Text.Rune.ReplacementChar" /> und <paramref name="charsConsumed" /> enth√§lt die L√§nge des Eingabepuffers.</span><span class="sxs-lookup"><span data-stu-id="dc568-252"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="charsConsumed" /> contains the length of the input buffer.</span></span>
            
<span data-ttu-id="dc568-253"><see cref="F:System.Buffers.OperationStatus.InvalidData" />, wenn der Quellpuffer mit einem falsch formatierten, UTF-16-codierten Skalarwert beginnt.</span><span class="sxs-lookup"><span data-stu-id="dc568-253"><see cref="F:System.Buffers.OperationStatus.InvalidData" /> if the source buffer begins with an ill-formed UTF-16 encoded scalar value.</span></span> <span data-ttu-id="dc568-254"><paramref name="result" /> enth√§lt dann <see cref="P:System.Text.Rune.ReplacementChar" /> und <paramref name="charsConsumed" /> enth√§lt die Anzahl von <see cref="T:System.Char" />-Werten, die zum Codieren der falsch formatierten Sequenz verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dc568-254"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="charsConsumed" /> contains the number of <see cref="T:System.Char" /> values used to encode the ill-formed sequence.</span></span>
<span data-ttu-id="dc568-255">.</span><span class="sxs-lookup"><span data-stu-id="dc568-255">.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-256">Diese Methode ist sehr √§hnlich <xref:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)> , mit der Ausnahme, dass der Aufrufer anstelle von vorw√§rts eine Schleife r√ºckw√§rts durchlaufen kann.</span><span class="sxs-lookup"><span data-stu-id="dc568-256">This method is very similar to <xref:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)>, except it allows the caller to loop backward instead of forward.</span></span> <span data-ttu-id="dc568-257">Die typische Aufruf Konvention besteht darin, dass der Aufrufer bei jeder Iteration der Schleife die abschlie√üenden `charsConsumed` Elemente des Puffers segmentieren soll `source` .</span><span class="sxs-lookup"><span data-stu-id="dc568-257">The typical calling convention is that on each iteration of the loop, the caller should slice off the final `charsConsumed` elements of the `source` buffer.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeLastFromUtf8">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeLastFromUtf8 (ReadOnlySpan&lt;byte&gt; source, out System.Text.Rune value, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeLastFromUtf8(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] valuetype System.Text.Rune&amp; value, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeLastFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeLastFromUtf8 (source As ReadOnlySpan(Of Byte), ByRef value As Rune, ByRef bytesConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeLastFromUtf8(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % value, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeLastFromUtf8 : ReadOnlySpan&lt;byte&gt; * Rune * int -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeLastFromUtf8 (source, value, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="dc568-258">Eine schreibgesch√ºtzte UTF-8-codierte Bytespanne.</span><span class="sxs-lookup"><span data-stu-id="dc568-258">A read-only UTF-8 encoded byte span.</span></span></param>
        <param name="value"><span data-ttu-id="dc568-259">Die decodierte Rune bei R√ºckgabe dieser Methode.</span><span class="sxs-lookup"><span data-stu-id="dc568-259">When this method returns, the decoded rune.</span></span></param>
        <param name="bytesConsumed"><span data-ttu-id="dc568-260">Die Anzahl von Bytes, die bei der Erstellung der Rune gelesen werden, wenn diese Methode zur√ºckgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dc568-260">When this method returns, the number of bytes read to create the rune.</span></span></param>
        <summary><span data-ttu-id="dc568-261">Decodiert das <see cref="T:System.Text.Rune" />-Element am Ende des bereitgestellten UTF-8-Quellpuffers.</span><span class="sxs-lookup"><span data-stu-id="dc568-261">Decodes the <see cref="T:System.Text.Rune" /> at the end of the provided UTF-8 source buffer.</span></span></summary>
        <returns><span data-ttu-id="dc568-262"><see cref="F:System.Buffers.OperationStatus.Done" />, wenn der Quellpuffer mit einem g√ºltigen, UTF-8-codierten Skalarwert endet.</span><span class="sxs-lookup"><span data-stu-id="dc568-262"><see cref="F:System.Buffers.OperationStatus.Done" /> if the source buffer ends with a valid UTF-8 encoded scalar value.</span></span> <span data-ttu-id="dc568-263"><paramref name="result" /> enth√§lt dann die decodierte <see cref="T:System.Text.Rune" />-Eigenschaft und <paramref name="bytesConsumed" /> die Anzahl an <see cref="T:System.Byte" />-Werten, die in dem Eingabepuffer zur Codierung der <see cref="T:System.Text.Rune" />-Struktur verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dc568-263"><paramref name="result" /> then contains the decoded <see cref="T:System.Text.Rune" />, and <paramref name="bytesConsumed" /> contains the number of <see cref="T:System.Byte" /> values used in the input buffer to encode the <see cref="T:System.Text.Rune" />.</span></span>
            
<span data-ttu-id="dc568-264"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" />, wenn der Quellpuffer leer ist oder nur ein eigenst√§ndiges hohe UTF-8-Ersatzzeichen enth√§lt.</span><span class="sxs-lookup"><span data-stu-id="dc568-264"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" /> if the source buffer is empty or contains only a standalone UTF-8 high surrogate character.</span></span> <span data-ttu-id="dc568-265"><paramref name="result" /> enth√§lt dann <see cref="P:System.Text.Rune.ReplacementChar" /> und <paramref name="bytesConsumed" /> enth√§lt die L√§nge des Eingabepuffers.</span><span class="sxs-lookup"><span data-stu-id="dc568-265"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="bytesConsumed" /> contains the length of the input buffer.</span></span>
            
<span data-ttu-id="dc568-266"><see cref="F:System.Buffers.OperationStatus.InvalidData" />, wenn der Quellpuffer mit einem falsch formatierten, UTF-8-codierten Skalarwert endet.</span><span class="sxs-lookup"><span data-stu-id="dc568-266"><see cref="F:System.Buffers.OperationStatus.InvalidData" /> if the source buffer ends with an ill-formed UTF-8 encoded scalar value.</span></span> <span data-ttu-id="dc568-267"><paramref name="result" /> enth√§lt dann <see cref="P:System.Text.Rune.ReplacementChar" /> und <paramref name="bytesConsumed" /> enth√§lt die Anzahl von <see cref="T:System.Byte" />-Werten, die im Eingabepuffer zum Codieren der falsch formatierten Sequenz verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dc568-267"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="bytesConsumed" /> contains the number of <see cref="T:System.Byte" /> values used in the input buffer to encode the ill-formed sequence.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-268">Diese Methode ist sehr √§hnlich <xref:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)> , mit der Ausnahme, dass der Aufrufer anstelle von vorw√§rts eine Schleife r√ºckw√§rts durchlaufen kann.</span><span class="sxs-lookup"><span data-stu-id="dc568-268">This method is very similar to <xref:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)>, except it allows the caller to loop backward instead of forward.</span></span> <span data-ttu-id="dc568-269">Die typische Aufruf Konvention besteht darin, dass der Aufrufer bei jeder Iteration der Schleife die abschlie√üenden `bytesConsumed` Elemente des Puffers segmentieren soll `source` .</span><span class="sxs-lookup"><span data-stu-id="dc568-269">The typical calling convention is that on each iteration of the loop, the caller should slice off the final `bytesConsumed` elements of the `source` buffer.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncodeToUtf16">
      <MemberSignature Language="C#" Value="public int EncodeToUtf16 (Span&lt;char&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EncodeToUtf16(valuetype System.Span`1&lt;char&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.EncodeToUtf16(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function EncodeToUtf16 (destination As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EncodeToUtf16(Span&lt;char&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.EncodeToUtf16 : Span&lt;char&gt; -&gt; int" Usage="rune.EncodeToUtf16 destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="dc568-270">Der Puffer, in den dieser Wert im UTF-16-Format geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc568-270">The buffer to which to write this value as UTF-16.</span></span></param>
        <summary><span data-ttu-id="dc568-271">Codiert diese <see cref="T:System.Text.Rune" />-Struktur in einen Zielpuffer im UTF-16-Format.</span><span class="sxs-lookup"><span data-stu-id="dc568-271">Encodes this <see cref="T:System.Text.Rune" /> to a UTF-16 destination buffer.</span></span></summary>
        <returns><span data-ttu-id="dc568-272">Die Anzahl der <see cref="T:System.Char" />-Werte, die in <paramref name="destination" /> geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="dc568-272">The number of <see cref="T:System.Char" /> values written to <paramref name="destination" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dc568-273"><paramref name="destination" /> ist nicht gro√ü genug, um die Ausgabe aufzunehmen.</span><span class="sxs-lookup"><span data-stu-id="dc568-273"><paramref name="destination" /> is not large enough to hold the output.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EncodeToUtf8">
      <MemberSignature Language="C#" Value="public int EncodeToUtf8 (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EncodeToUtf8(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.EncodeToUtf8(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function EncodeToUtf8 (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EncodeToUtf8(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.EncodeToUtf8 : Span&lt;byte&gt; -&gt; int" Usage="rune.EncodeToUtf8 destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="dc568-274">Der Puffer, in den dieser Wert im UTF-8-Format geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc568-274">The buffer to which to write this value as UTF-8.</span></span></param>
        <summary><span data-ttu-id="dc568-275">Codiert diese <see cref="T:System.Text.Rune" />-Struktur in einen Zielpuffer im UTF-8-Format.</span><span class="sxs-lookup"><span data-stu-id="dc568-275">Encodes this <see cref="T:System.Text.Rune" /> to a UTF-8 destination buffer.</span></span></summary>
        <returns><span data-ttu-id="dc568-276">Die Anzahl der <see cref="T:System.Byte" />-Werte, die in <paramref name="destination" /> geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="dc568-276">The number of <see cref="T:System.Byte" /> values written to <paramref name="destination" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dc568-277"><paramref name="destination" /> ist nicht gro√ü genug, um die Ausgabe aufzunehmen.</span><span class="sxs-lookup"><span data-stu-id="dc568-277"><paramref name="destination" /> is not large enough to hold the output.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="rune.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="dc568-278">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc568-278">The object to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="dc568-279">Gibt einen Wert zur√ºck, der angibt, ob die aktuelle Instanz und ein angegebenes Objekt gleich sind.</span><span class="sxs-lookup"><span data-stu-id="dc568-279">Returns a value that indicates whether the current instance and a specified object are equal.</span></span></summary>
        <returns><span data-ttu-id="dc568-280"><see langword="true" />, wenn <paramref name="obj" /> gleich dem Typ <see cref="T:System.Text.Rune" /> und der aktuellen Instanz ist; anderenfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-280"><see langword="true" /> if <paramref name="obj" /> is of type <see cref="T:System.Text.Rune" /> and is equal to the current instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.Rune other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Text.Rune other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.Equals(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Text::Rune other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.Rune -&gt; bool" Usage="rune.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="dc568-281">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc568-281">The object to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="dc568-282">Gibt einen Wert zur√ºck, der angibt, ob die aktuelle Instanz und eine angegebene Rune gleich sind.</span><span class="sxs-lookup"><span data-stu-id="dc568-282">Returns a value that indicates whether the current instance and a specified rune are equal.</span></span></summary>
        <returns><span data-ttu-id="dc568-283"><see langword="true" />, wenn die angegebene Instanz und <paramref name="other" /> gleich sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-283"><see langword="true" /> if the current instance and <paramref name="other" /> are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="rune.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dc568-284">Gibt den Hashcode f√ºr diese Instanz zur√ºck.</span><span class="sxs-lookup"><span data-stu-id="dc568-284">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="dc568-285">Der Hashcode f√ºr diese Instanz.</span><span class="sxs-lookup"><span data-stu-id="dc568-285">The hash code for this instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetNumericValue(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (value As Rune) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member GetNumericValue : System.Text.Rune -&gt; double" Usage="System.Text.Rune.GetNumericValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-286">Die Rune, f√ºr die der numerische Wert abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc568-286">The rune for which to get the numeric value.</span></span></param>
        <summary><span data-ttu-id="dc568-287">Ruft den numerischen Wert ab, der der angegebenen Rune zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-287">Gets the numeric value associated with the specified rune.</span></span></summary>
        <returns><span data-ttu-id="dc568-288">Der numerische Wert, der <paramref name="value" /> zugeordnet ist, oder ‚Äû-1‚Äú, wenn <paramref name="value" /> kein numerisches Zeichen darstellt.</span><span class="sxs-lookup"><span data-stu-id="dc568-288">The numeric value associated with <paramref name="value" />, or -1 if <paramref name="value" /> doesn't represent a numeric character.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-289">Diese Methode hat ein Verhalten, das entspricht <xref:System.Globalization.CharUnicodeInfo.GetNumericValue%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="dc568-289">This method has behavior equivalent to <xref:System.Globalization.CharUnicodeInfo.GetNumericValue%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dc568-290">Weitere Informationen finden Sie in dieser Dokumentation.</span><span class="sxs-lookup"><span data-stu-id="dc568-290">Refer to that documentation for more information.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRuneAt">
      <MemberSignature Language="C#" Value="public static System.Text.Rune GetRuneAt (string input, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune GetRuneAt(string input, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetRuneAt(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRuneAt (input As String, index As Integer) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune GetRuneAt(System::String ^ input, int index);" />
      <MemberSignature Language="F#" Value="static member GetRuneAt : string * int -&gt; System.Text.Rune" Usage="System.Text.Rune.GetRuneAt (input, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="dc568-291">Die Zeichenfolge, aus der die Rune erstellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc568-291">The string from which to create the rune.</span></span></param>
        <param name="index"><span data-ttu-id="dc568-292">Die Anfangsposition in <paramref name="input" />, an der die Rune erstellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc568-292">The starting position in <paramref name="input" /> at which to create the rune.</span></span></param>
        <summary><span data-ttu-id="dc568-293">Ruft die <see cref="T:System.Text.Rune" />-Struktur ab, die an der angegebenen Position in einer Zeichenfolge beginnt.</span><span class="sxs-lookup"><span data-stu-id="dc568-293">Gets the <see cref="T:System.Text.Rune" /> that begins at a specified position in a string.</span></span></summary>
        <returns><span data-ttu-id="dc568-294">Die aus <paramref name="input" /> abgerufene Rune unter dem angegebenen <paramref name="index" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-294">The rune obtained from <paramref name="input" /> at the specified <paramref name="index" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-295">L√∂st eine Ausnahme `input` `null` aus, wenn ist, `index` au√üerhalb des g√ºltigen Bereichs liegt oder `index` nicht auf den Anfang eines g√ºltigen skalarwerts in verweist `input` .</span><span class="sxs-lookup"><span data-stu-id="dc568-295">Throws an exception if `input` is `null`, `index` is out of range, or `index` does not reference the start of a valid scalar value within `input`.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dc568-296"><paramref name="input" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-296"><paramref name="input" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dc568-297"><paramref name="index" /> verweist nicht auf den Anfang eines g√ºltigen Skalarwerts in <paramref name="input" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-297"><paramref name="index" /> does not reference the start of a valid scalar value in <paramref name="input" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="dc568-298"><paramref name="index" /> liegt au√üerhalb des Bereichs von <paramref name="input" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-298"><paramref name="index" /> is outside the range of <paramref name="input" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (value As Rune) As UnicodeCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member GetUnicodeCategory : System.Text.Rune -&gt; System.Globalization.UnicodeCategory" Usage="System.Text.Rune.GetUnicodeCategory value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-299">Die Rune, f√ºr die die Unicode-Kategorie abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc568-299">The rune for which to get the Unicode category.</span></span></param>
        <summary><span data-ttu-id="dc568-300">Ruft die Unicode-Kategorie ab, die der angegebenen Rune zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-300">Gets the Unicode category associated with the specified rune.</span></span></summary>
        <returns><span data-ttu-id="dc568-301">Die Unicode-Kategorie, die <paramref name="value" /> zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-301">The Unicode category associated with <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-302">Diese Methode hat ein Verhalten, das entspricht <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="dc568-302">This method has behavior equivalent to <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dc568-303">Weitere Informationen finden Sie in dieser Dokumentation.</span><span class="sxs-lookup"><span data-stu-id="dc568-303">Refer to that documentation for more information.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAscii">
      <MemberSignature Language="C#" Value="public bool IsAscii { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAscii" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.IsAscii" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAscii As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAscii { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAscii : bool" Usage="System.Text.Rune.IsAscii" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dc568-304">Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Text.Rune" /> zugeordnete Skalarwert innerhalb des ASCII-Codierungsbereichs liegt.</span><span class="sxs-lookup"><span data-stu-id="dc568-304">Gets a value that indicates whether the scalar value associated with this <see cref="T:System.Text.Rune" /> is within the ASCII encoding range.</span></span></summary>
        <value><span data-ttu-id="dc568-305"><see langword="true" /> , wenn der zugeordnete Skalarwert innerhalb des ASCII-Codierungs Bereichs ([U + 0000.. U + 007F]) liegt und daher durch eine einzelne UTF-8-Code Einheit darstellbar ist. andernfalls <see langword="false" /> .</span><span class="sxs-lookup"><span data-stu-id="dc568-305"><see langword="true" /> if the scalar value associated is within the ASCII encoding range ([ U+0000..U+007F ]) and therefore representable by a single UTF-8 code unit; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBmp">
      <MemberSignature Language="C#" Value="public bool IsBmp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBmp" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.IsBmp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBmp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBmp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBmp : bool" Usage="System.Text.Rune.IsBmp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dc568-306">Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Text.Rune" /> zugeordnete Skalarwert innerhalb des BMP-Codierungsbereichs liegt.</span><span class="sxs-lookup"><span data-stu-id="dc568-306">Gets a value that indicates whether the scalar value associated with this <see cref="T:System.Text.Rune" /> is within the BMP encoding range.</span></span></summary>
        <value><span data-ttu-id="dc568-307"><see langword="true" /> , wenn der zugeordnete Skalarwert innerhalb des BMP-Codierungs Bereichs ([U + 0000.. U + FFFF]) liegt und daher durch eine einzelne UTF-16-Code Einheit darstellbar ist. andernfalls <see langword="false" /> .</span><span class="sxs-lookup"><span data-stu-id="dc568-307"><see langword="true" /> if the scalar value associated is within the BMP encoding range ([ U+0000..U+FFFF ]) and therefore representable by a single UTF-16 code unit; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsControl(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsControl : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsControl value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-308">Die auszuwertende Rune.</span><span class="sxs-lookup"><span data-stu-id="dc568-308">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="dc568-309">Gibt einen Wert zur√ºck, der angibt, ob die angegebene Rune als Steuerzeichen kategorisiert ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-309">Returns a value that indicates whether the specified rune is categorized as a control character.</span></span></summary>
        <returns><span data-ttu-id="dc568-310"><see langword="true" />, wenn <paramref name="value" /> ein Steuerzeichen ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-310"><see langword="true" /> if <paramref name="value" /> is a control character; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-311">Diese Methode entspricht <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> dem Abfragen und Vergleichen des Ergebnisses mit <xref:System.Globalization.UnicodeCategory.Control> .</span><span class="sxs-lookup"><span data-stu-id="dc568-311">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against <xref:System.Globalization.UnicodeCategory.Control>.</span></span>

<span data-ttu-id="dc568-312">Gem√§√ü [Unicode-Stabilit√§tsrichtlinien](https://www.unicode.org/policies/stability_policy.html)wird der Satz von Steuerzeichen permanent als die Vereinigung von und fest `[ U+0000..U+001F ]` gelegt `[ U+007F..U+009F ]` .</span><span class="sxs-lookup"><span data-stu-id="dc568-312">Per [Unicode stability policies](https://www.unicode.org/policies/stability_policy.html), the set of control characters is permanently fixed to be the union of `[ U+0000..U+001F ]` and `[ U+007F..U+009F ]`.</span></span>

<span data-ttu-id="dc568-313">Weitere Informationen finden Sie unter <xref:System.Char.IsControl%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dc568-313">For more information, see <xref:System.Char.IsControl%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsDigit(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsDigit : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsDigit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-314">Die auszuwertende Rune.</span><span class="sxs-lookup"><span data-stu-id="dc568-314">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="dc568-315">Gibt einen Wert zur√ºck, der angibt, ob die angegebene Rune als Dezimalzahl kategorisiert ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-315">Returns a value that indicates whether the specified rune is categorized as a decimal digit.</span></span></summary>
        <returns><span data-ttu-id="dc568-316"><see langword="true" />, wenn <paramref name="value" /> eine Dezimalzahl ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-316"><see langword="true" /> if <paramref name="value" /> is a decimal digit; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-317">Diese Methode entspricht <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> dem Abfragen und Vergleichen des Ergebnisses mit <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber> .</span><span class="sxs-lookup"><span data-stu-id="dc568-317">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>.</span></span>

<span data-ttu-id="dc568-318">Weitere Informationen finden Sie unter <xref:System.Char.IsDigit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dc568-318">For more information, see <xref:System.Char.IsDigit%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsLetter(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsLetter : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsLetter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-319">Die auszuwertende Rune.</span><span class="sxs-lookup"><span data-stu-id="dc568-319">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="dc568-320">Gibt einen Wert zur√ºck, der angibt, ob die angegebene Rune als Buchstabe kategorisiert ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-320">Returns a value that indicates whether the specified rune is categorized as a letter.</span></span></summary>
        <returns><span data-ttu-id="dc568-321"><see langword="true" />, wenn <paramref name="value" /> ein Buchstabe ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-321"><see langword="true" /> if <paramref name="value" /> is a letter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-322">Diese Methode entspricht dem Abfragen <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> und Vergleichen des Ergebnisses mit den Werten,,, <xref:System.Globalization.UnicodeCategory.UppercaseLetter> <xref:System.Globalization.UnicodeCategory.LowercaseLetter> <xref:System.Globalization.UnicodeCategory.TitlecaseLetter> <xref:System.Globalization.UnicodeCategory.ModifierLetter> und <xref:System.Globalization.UnicodeCategory.OtherLetter> .</span><span class="sxs-lookup"><span data-stu-id="dc568-322">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.UppercaseLetter>, <xref:System.Globalization.UnicodeCategory.LowercaseLetter>, <xref:System.Globalization.UnicodeCategory.TitlecaseLetter>, <xref:System.Globalization.UnicodeCategory.ModifierLetter>, and <xref:System.Globalization.UnicodeCategory.OtherLetter>.</span></span>

<span data-ttu-id="dc568-323">Weitere Informationen finden Sie unter <xref:System.Char.IsLetter%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dc568-323">For more information, see <xref:System.Char.IsLetter%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsLetterOrDigit(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsLetterOrDigit : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsLetterOrDigit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-324">Die auszuwertende Rune.</span><span class="sxs-lookup"><span data-stu-id="dc568-324">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="dc568-325">Gibt einen Wert zur√ºck, der angibt, ob die angegebene Rune als Buchstabe oder Dezimalzahl kategorisiert ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-325">Returns a value that indicates whether the specified rune is categorized as a letter or a decimal digit.</span></span></summary>
        <returns><span data-ttu-id="dc568-326"><see langword="true" />, wenn <paramref name="value" /> ein Buchstabe oder eine Dezimalzahl ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-326"><see langword="true" /> if <paramref name="value" /> is a letter or a decimal digit; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-327">Diese Methode entspricht dem Abfragen <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> und Vergleichen des Ergebnisses mit den Werten,,, <xref:System.Globalization.UnicodeCategory.UppercaseLetter> <xref:System.Globalization.UnicodeCategory.LowercaseLetter> <xref:System.Globalization.UnicodeCategory.TitlecaseLetter> <xref:System.Globalization.UnicodeCategory.ModifierLetter> , <xref:System.Globalization.UnicodeCategory.OtherLetter> und <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber> .</span><span class="sxs-lookup"><span data-stu-id="dc568-327">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.UppercaseLetter>, <xref:System.Globalization.UnicodeCategory.LowercaseLetter>, <xref:System.Globalization.UnicodeCategory.TitlecaseLetter>, <xref:System.Globalization.UnicodeCategory.ModifierLetter>, <xref:System.Globalization.UnicodeCategory.OtherLetter>, and <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>.</span></span>

<span data-ttu-id="dc568-328">Weitere Informationen finden Sie unter <xref:System.Char.IsLetterOrDigit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dc568-328">For more information, see <xref:System.Char.IsLetterOrDigit%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsLower(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsLower : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsLower value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-329">Die auszuwertende Rune.</span><span class="sxs-lookup"><span data-stu-id="dc568-329">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="dc568-330">Gibt einen Wert zur√ºck, der angibt, ob die angegebene Rune als Kleinbuchstabe kategorisiert ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-330">Returns a value that indicates whether the specified rune is categorized as a lowercase letter.</span></span></summary>
        <returns><span data-ttu-id="dc568-331"><see langword="true" />, wenn <paramref name="value" /> ein Kleinbuchstabe ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-331"><see langword="true" /> if <paramref name="value" /> is a lowercase letter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-332">Diese Methode entspricht <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> dem Abfragen und Vergleichen des Ergebnisses mit <xref:System.Globalization.UnicodeCategory.LowercaseLetter> .</span><span class="sxs-lookup"><span data-stu-id="dc568-332">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against <xref:System.Globalization.UnicodeCategory.LowercaseLetter>.</span></span>

<span data-ttu-id="dc568-333">Weitere Informationen finden Sie unter <xref:System.Char.IsLower%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dc568-333">For more information, see <xref:System.Char.IsLower%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsNumber(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsNumber : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsNumber value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-334">Die auszuwertende Rune.</span><span class="sxs-lookup"><span data-stu-id="dc568-334">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="dc568-335">Gibt einen Wert zur√ºck, der angibt, ob die angegebene Rune als Zahl kategorisiert ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-335">Returns a value that indicates whether the specified rune is categorized as a number.</span></span></summary>
        <returns><span data-ttu-id="dc568-336"><see langword="true" />, wenn <paramref name="value" /> eine Zahl ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-336"><see langword="true" /> if <paramref name="value" /> is a number; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-337">Diese Methode entspricht dem Abfragen <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> und Vergleichen des Ergebnisses mit den Werten <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber> , <xref:System.Globalization.UnicodeCategory.LetterNumber> und <xref:System.Globalization.UnicodeCategory.OtherNumber> .</span><span class="sxs-lookup"><span data-stu-id="dc568-337">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>, <xref:System.Globalization.UnicodeCategory.LetterNumber>, and <xref:System.Globalization.UnicodeCategory.OtherNumber>.</span></span>

<span data-ttu-id="dc568-338">Weitere Informationen finden Sie unter <xref:System.Char.IsNumber%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dc568-338">For more information, see <xref:System.Char.IsNumber%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsPunctuation(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsPunctuation : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsPunctuation value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-339">Die auszuwertende Rune.</span><span class="sxs-lookup"><span data-stu-id="dc568-339">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="dc568-340">Gibt einen Wert zur√ºck, der angibt, ob die angegebene Rune als Satzzeichen kategorisiert ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-340">Returns a value that indicates whether the specified rune is categorized as a punctuation mark.</span></span></summary>
        <returns><span data-ttu-id="dc568-341"><see langword="true" />, wenn <paramref name="value" /> ein Satzzeichen ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-341"><see langword="true" /> if <paramref name="value" /> is a punctuation mark; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-342">Diese Methode entspricht dem Abfragen <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> und Vergleichen des Ergebnisses mit den Werten,,,, <xref:System.Globalization.UnicodeCategory.ConnectorPunctuation> , <xref:System.Globalization.UnicodeCategory.DashPunctuation> <xref:System.Globalization.UnicodeCategory.OpenPunctuation> <xref:System.Globalization.UnicodeCategory.ClosePunctuation> <xref:System.Globalization.UnicodeCategory.InitialQuotePunctuation> <xref:System.Globalization.UnicodeCategory.FinalQuotePunctuation> und <xref:System.Globalization.UnicodeCategory.OtherPunctuation> .</span><span class="sxs-lookup"><span data-stu-id="dc568-342">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.ConnectorPunctuation>, <xref:System.Globalization.UnicodeCategory.DashPunctuation>, <xref:System.Globalization.UnicodeCategory.OpenPunctuation>, <xref:System.Globalization.UnicodeCategory.ClosePunctuation>, <xref:System.Globalization.UnicodeCategory.InitialQuotePunctuation>, <xref:System.Globalization.UnicodeCategory.FinalQuotePunctuation>, and <xref:System.Globalization.UnicodeCategory.OtherPunctuation>.</span></span>

<span data-ttu-id="dc568-343">Weitere Informationen finden Sie unter <xref:System.Char.IsPunctuation%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dc568-343">For more information, see <xref:System.Char.IsPunctuation%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsSeparator(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsSeparator : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsSeparator value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-344">Die auszuwertende Rune.</span><span class="sxs-lookup"><span data-stu-id="dc568-344">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="dc568-345">Gibt einen Wert zur√ºck, der angibt, ob die angegebene Rune als Trennzeichen kategorisiert ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-345">Returns a value that indicates whether the specified rune is categorized as a separator character.</span></span></summary>
        <returns><span data-ttu-id="dc568-346"><see langword="true" />, wenn <paramref name="value" /> ein Trennzeichen ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-346"><see langword="true" /> if <paramref name="value" /> is a separator character; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-347">Diese Methode entspricht dem Abfragen <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> und Vergleichen des Ergebnisses mit den Werten <xref:System.Globalization.UnicodeCategory.SpaceSeparator> , <xref:System.Globalization.UnicodeCategory.LineSeparator> und <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> .</span><span class="sxs-lookup"><span data-stu-id="dc568-347">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.SpaceSeparator>, <xref:System.Globalization.UnicodeCategory.LineSeparator>, and <xref:System.Globalization.UnicodeCategory.ParagraphSeparator>.</span></span>

<span data-ttu-id="dc568-348">Weitere Informationen finden Sie unter <xref:System.Char.IsSeparator%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dc568-348">For more information, see <xref:System.Char.IsSeparator%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsSymbol(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsSymbol : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsSymbol value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-349">Die auszuwertende Rune.</span><span class="sxs-lookup"><span data-stu-id="dc568-349">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="dc568-350">Gibt einen Wert zur√ºck, der angibt, ob die angegebene Rune als Symbolzeichen kategorisiert ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-350">Returns a value that indicates whether the specified rune is categorized as a symbol character.</span></span></summary>
        <returns><span data-ttu-id="dc568-351"><see langword="true" />, wenn <paramref name="value" /> ein Symbolzeichen ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-351"><see langword="true" /> if <paramref name="value" /> is a symbol character; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-352">Diese Methode entspricht dem Abfragen <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> und Vergleichen des Ergebnisses mit den Werten <xref:System.Globalization.UnicodeCategory.MathSymbol> ,, <xref:System.Globalization.UnicodeCategory.CurrencySymbol> <xref:System.Globalization.UnicodeCategory.ModifierSymbol> und <xref:System.Globalization.UnicodeCategory.OtherSymbol> .</span><span class="sxs-lookup"><span data-stu-id="dc568-352">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.MathSymbol>, <xref:System.Globalization.UnicodeCategory.CurrencySymbol>, <xref:System.Globalization.UnicodeCategory.ModifierSymbol>, and <xref:System.Globalization.UnicodeCategory.OtherSymbol>.</span></span>

<span data-ttu-id="dc568-353">Weitere Informationen finden Sie unter <xref:System.Char.IsSymbol%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dc568-353">For more information, see <xref:System.Char.IsSymbol%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsUpper(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsUpper : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsUpper value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-354">Die auszuwertende Rune.</span><span class="sxs-lookup"><span data-stu-id="dc568-354">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="dc568-355">Gibt einen Wert zur√ºck, der angibt, ob die angegebene Rune als Gro√übuchstabe kategorisiert ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-355">Returns a value that indicates whether the specified rune is categorized as an uppercase letter.</span></span></summary>
        <returns><span data-ttu-id="dc568-356"><see langword="true" />, wenn <paramref name="value" /> ein Gro√übuchstabe ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-356"><see langword="true" /> if <paramref name="value" /> is an uppercase letter; otherwise,<see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-357">Diese Methode entspricht <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> dem Abfragen und Vergleichen des Ergebnisses mit <xref:System.Globalization.UnicodeCategory.UppercaseLetter> .</span><span class="sxs-lookup"><span data-stu-id="dc568-357">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against <xref:System.Globalization.UnicodeCategory.UppercaseLetter>.</span></span>

<span data-ttu-id="dc568-358">Weitere Informationen finden Sie unter <xref:System.Char.IsUpper%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dc568-358">For more information, see <xref:System.Char.IsUpper%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public static bool IsValid (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValid(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsValid(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValid (value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValid(int value);" />
      <MemberSignature Language="F#" Value="static member IsValid : int -&gt; bool" Usage="System.Text.Rune.IsValid value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-359">Der Unicode-Skalarwert.</span><span class="sxs-lookup"><span data-stu-id="dc568-359">The Unicode scalar value.</span></span></param>
        <summary><span data-ttu-id="dc568-360">Gibt einen Wert zur√ºck, der angibt, ob eine 32-Bit-Ganzzahl mit Vorzeichen einen g√ºltigen Unicode-Skalarwert darstellt. Dieser liegt im Bereich [ U+0000..U+D7FF ], einschlie√ülich; oder [ U+E000..U+10FFFF ], einschlie√ülich.</span><span class="sxs-lookup"><span data-stu-id="dc568-360">Returns a value that indicates whether a 32-bit signed integer represents a valid Unicode scalar value; that is, it is in the range [ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive.</span></span></summary>
        <returns><span data-ttu-id="dc568-361"><see langword="true" />, wenn <paramref name="value" /> ein g√ºltiger Unicode-Skalarwert ist; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-361"><see langword="true" /> if <paramref name="value" /> is a valid Unicode scalar value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public static bool IsValid (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValid(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsValid(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValid (value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValid(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member IsValid : uint32 -&gt; bool" Usage="System.Text.Rune.IsValid value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-362">Der Unicode-Skalarwert.</span><span class="sxs-lookup"><span data-stu-id="dc568-362">The Unicode scalar value.</span></span></param>
        <summary><span data-ttu-id="dc568-363">Gibt einen Wert zur√ºck, der angibt, ob eine 32-Bit-Ganzzahl ohne Vorzeichen einen g√ºltigen Unicode-Skalarwert darstellt. Dieser liegt im Bereich [ U+0000..U+D7FF ], einschlie√ülich; oder [ U+E000..U+10FFFF ], einschlie√ülich.</span><span class="sxs-lookup"><span data-stu-id="dc568-363">Returns a value that indicates whether a 32-bit unsigned integer represents a valid Unicode scalar value; that is, it is in the range [ U+0000..U+D7FF ], inclusive, or [ U+E000..U+10FFFF ], inclusive.</span></span></summary>
        <returns><span data-ttu-id="dc568-364"><see langword="true" />, wenn <paramref name="value" /> ein g√ºltiger Unicode-Skalarwert ist; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-364"><see langword="true" /> if <paramref name="value" /> is a valid Unicode scalar value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsWhiteSpace(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-365">Die auszuwertende Rune.</span><span class="sxs-lookup"><span data-stu-id="dc568-365">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="dc568-366">Gibt einen Wert zur√ºck, der angibt, ob die angegebene Rune als Leerzeichen kategorisiert ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-366">Returns a value that indicates whether the specified rune is categorized as a white space character.</span></span></summary>
        <returns><span data-ttu-id="dc568-367"><see langword="true" />, wenn <paramref name="value" /> ein Leerzeichen ist; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-367"><see langword="true" /> if <paramref name="value" /> is a white space character; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-368">Diese Methode entspricht im allgemeinen <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> dem Abfragen und Vergleichen des Ergebnisses mit den Werten <xref:System.Globalization.UnicodeCategory.SpaceSeparator> , <xref:System.Globalization.UnicodeCategory.LineSeparator> und <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> .</span><span class="sxs-lookup"><span data-stu-id="dc568-368">This method is generally equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.SpaceSeparator>, <xref:System.Globalization.UnicodeCategory.LineSeparator>, and <xref:System.Globalization.UnicodeCategory.ParagraphSeparator>.</span></span> <span data-ttu-id="dc568-369">Es gibt jedoch einige <xref:System.Text.Rune> in der Kategorie, <xref:System.Globalization.UnicodeCategory.Control> die auch als leer Raum Zeichen klassifiziert werden, und diese Methode ber√ºcksichtigt diese Werte.</span><span class="sxs-lookup"><span data-stu-id="dc568-369">However, there are some <xref:System.Text.Rune>s in the <xref:System.Globalization.UnicodeCategory.Control> category which are also classified as white space characters, and this method accounts for those values.</span></span>

<span data-ttu-id="dc568-370">Weitere Informationen finden Sie unter <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dc568-370">For more information, see <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Equality(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="dc568-371">Der erste zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="dc568-371">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="dc568-372">Der zweite zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="dc568-372">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="dc568-373">Gibt einen Wert zur√ºck, der angibt, ob zwei <see cref="T:System.Text.Rune" />-Instanzen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="dc568-373">Returns a value that indicates whether two <see cref="T:System.Text.Rune" /> instances are equal.</span></span></summary>
        <returns><span data-ttu-id="dc568-374"><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-374"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Text.Rune (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Text.Rune op_Explicit(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Explicit(System.Char)~System.Text.Rune" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (ch As Char) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Text::Rune(char ch);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : char -&gt; System.Text.Rune" Usage="System.Text.Rune.op_Explicit ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch"><span data-ttu-id="dc568-375">Das zu konvertierende 16-Bit-Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dc568-375">The 16-bit Unicode character to convert.</span></span></param>
        <summary><span data-ttu-id="dc568-376">Definiert eine explizite Konvertierung eines 16-Bit-Unicode-Zeichens in eine <see cref="T:System.Text.Rune" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-376">Defines an explicit conversion of a 16-bit Unicode character to a <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="dc568-377"><paramref name="ch" /> als 32-Bit-Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dc568-377"><paramref name="ch" /> as a 32-bit Unicode character.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="dc568-378"><paramref name="ch" /> ist ein Unicode-Skalar, der f√ºr einen Ersatzcodepunkt steht.</span><span class="sxs-lookup"><span data-stu-id="dc568-378"><paramref name="ch" /> is a Unicode scalar that represents a surrogate code point.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Text.Rune (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Text.Rune op_Explicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Explicit(System.Int32)~System.Text.Rune" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Integer) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Text::Rune(int value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : int -&gt; System.Text.Rune" Usage="System.Text.Rune.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-379">Die zu konvertierende 32-Bit-Ganzzahl mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="dc568-379">The 32-bit signed integer to convert.</span></span></param>
        <summary><span data-ttu-id="dc568-380">Definiert eine explizite Konvertierung einer 32-Bit-Ganzzahl mit Vorzeichen in den Wert einer <see cref="T:System.Text.Rune" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-380">Defines an explicit conversion of a 32-bit signed integer to a <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="dc568-381"><paramref name="value" /> als 32-Bit-Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dc568-381"><paramref name="value" /> as a 32-bit Unicode character.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="dc568-382"><paramref name="value" /> ist ein ung√ºltiger Unicode-Skalar.</span><span class="sxs-lookup"><span data-stu-id="dc568-382"><paramref name="value" /> is an invalid Unicode scalar.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Text.Rune (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Text.Rune op_Explicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Explicit(System.UInt32)~System.Text.Rune" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInteger) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Text::Rune(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : uint32 -&gt; System.Text.Rune" Usage="System.Text.Rune.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-383">Die zu konvertierende 32-Bit-Ganzzahl mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="dc568-383">The 32-bit signed integer to convert.</span></span></param>
        <summary><span data-ttu-id="dc568-384">Definiert eine explizite Konvertierung einer 32-Bit-Ganzzahl ohne Vorzeichen in den Wert einer <see cref="T:System.Text.Rune" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-384">Defines an explicit conversion of a 32-bit unsigned integer to a <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="dc568-385"><paramref name="value" /> als 32-Bit-Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dc568-385"><paramref name="value" /> as a 32-bit Unicode character.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="dc568-386"><paramref name="value" /> ist ein ung√ºltiger Unicode-Skalar.</span><span class="sxs-lookup"><span data-stu-id="dc568-386"><paramref name="value" /> is an invalid Unicode scalar.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_GreaterThan(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="dc568-387">Der erste zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="dc568-387">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="dc568-388">Der zweite zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="dc568-388">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="dc568-389">Gibt einen Wert zur√ºck, der angibt, ob ein angegebenes <see cref="T:System.Text.Rune" /> gr√∂√üer als eine anderes angegebenes <see cref="T:System.Text.Rune" /> ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-389">Returns a value indicating whether a specified <see cref="T:System.Text.Rune" /> is greater than another specified <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="dc568-390"><see langword="true" />, wenn <paramref name="left" /> gr√∂√üer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-390"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_GreaterThanOrEqual(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="dc568-391">Der erste zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="dc568-391">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="dc568-392">Der zweite zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="dc568-392">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="dc568-393">Gibt einen Wert zur√ºck, der angibt, ob ein angegebenes <see cref="T:System.Text.Rune" /> gr√∂√üer oder gleich einem anderen angegebenen <see cref="T:System.Text.Rune" /> ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-393">Returns a value indicating whether a specified <see cref="T:System.Text.Rune" /> is greater than or equal to another specified <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="dc568-394"><see langword="true" />, wenn <paramref name="left" /> gr√∂√üer oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-394"><see langword="true" /> if <paramref name="left" /> is greater than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Inequality(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="System.Text.Rune.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="dc568-395">Der erste zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="dc568-395">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="dc568-396">Der zweite zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="dc568-396">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="dc568-397">Gibt einen Wert zur√ºck, der angibt, ob zwei <see cref="T:System.Text.Rune" />-Instanzen √ºber unterschiedliche Werte verf√ºgen.</span><span class="sxs-lookup"><span data-stu-id="dc568-397">Returns a value that indicates whether two <see cref="T:System.Text.Rune" /> instances have different values.</span></span></summary>
        <returns><span data-ttu-id="dc568-398"><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-398"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_LessThan(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="dc568-399">Der erste zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="dc568-399">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="dc568-400">Der zweite zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="dc568-400">the second value to compare.</span></span></param>
        <summary><span data-ttu-id="dc568-401">Gibt einen Wert zur√ºck, der angibt, ob ein angegebenes <see cref="T:System.Text.Rune" /> kleiner als ein anderes angegebenes <see cref="T:System.Text.Rune" /> ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-401">Returns a value indicating whether a specified <see cref="T:System.Text.Rune" /> is less than another specified <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="dc568-402"><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-402"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_LessThanOrEqual(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="dc568-403">Der erste zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="dc568-403">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="dc568-404">Der zweite zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="dc568-404">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="dc568-405">Gibt einen Wert zur√ºck, der angibt, ob ein angegebenes <see cref="T:System.Text.Rune" /> kleiner oder gleich einem anderen angegebenen <see cref="T:System.Text.Rune" /> ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-405">Returns a value indicating whether a specified <see cref="T:System.Text.Rune" /> is less than or equal to another specified <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="dc568-406"><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-406"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Plane">
      <MemberSignature Language="C#" Value="public int Plane { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Plane" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Plane" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Plane As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Plane { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Plane : int" Usage="System.Text.Rune.Plane" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dc568-407">Ruft die Unicode-Ebene (0 bis einschlie√ülich 16) ab, die diesen Skalar enth√§lt.</span><span class="sxs-lookup"><span data-stu-id="dc568-407">Gets the Unicode plane (0 to 16, inclusive) that contains this scalar.</span></span></summary>
        <value><span data-ttu-id="dc568-408">Die Unicode-Ebene (0 bis 16, einschlie√ülich), die diesen skalaren enth√§lt.</span><span class="sxs-lookup"><span data-stu-id="dc568-408">The Unicode plane (0 to 16, inclusive) that contains this scalar.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplacementChar">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ReplacementChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Text.Rune ReplacementChar" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.ReplacementChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ReplacementChar As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Rune ReplacementChar { System::Text::Rune get(); };" />
      <MemberSignature Language="F#" Value="member this.ReplacementChar : System.Text.Rune" Usage="System.Text.Rune.ReplacementChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dc568-409">Ruft eine <see cref="T:System.Text.Rune" />-Instanz ab, die das Unicode-Ersatzzeichen U+FFFD darstellt.</span><span class="sxs-lookup"><span data-stu-id="dc568-409">Gets a <see cref="T:System.Text.Rune" /> instance that represents the Unicode replacement character U+FFFD.</span></span></summary>
        <value><span data-ttu-id="dc568-410">Eine <see cref="T:System.Text.Rune" />-Instanz, die das Unicode-Ersatzzeichen U+FFFD darstellt.</span><span class="sxs-lookup"><span data-stu-id="dc568-410">A <see cref="T:System.Text.Rune" /> instance that represents the Unicode replacement character U+FFFD.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToLower (System.Text.Rune value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToLower(valuetype System.Text.Rune value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToLower(System.Text.Rune,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (value As Rune, culture As CultureInfo) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToLower(System::Text::Rune value, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToLower : System.Text.Rune * System.Globalization.CultureInfo -&gt; System.Text.Rune" Usage="System.Text.Rune.ToLower (value, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-411">Das zu konvertierende 32-Bit-Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dc568-411">The 32-bit Unicode character to convert.</span></span></param>
        <param name="culture"><span data-ttu-id="dc568-412">Ein Objekt, das kulturspezifische Regeln zur Gro√ü- und Kleinschreibung bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="dc568-412">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="dc568-413">Gibt eine in Kleinbuchstaben konvertierte Kopie der angegebenen <see cref="T:System.Text.Rune" /> zur√ºck, wobei die Regeln der Gro√ü- und Kleinschreibung der angegebenen Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dc568-413">Returns a copy of the specified <see cref="T:System.Text.Rune" /> converted to lowercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="dc568-414">Die Entsprechung von <paramref name="value" /> in Kleinbuchstaben.</span><span class="sxs-lookup"><span data-stu-id="dc568-414">The lowercase equivalent of <paramref name="value" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToLowerInvariant (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToLowerInvariant(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToLowerInvariant(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLowerInvariant (value As Rune) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToLowerInvariant(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member ToLowerInvariant : System.Text.Rune -&gt; System.Text.Rune" Usage="System.Text.Rune.ToLowerInvariant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-415">Das zu konvertierende 32-Bit-Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dc568-415">The 32-bit Unicode character to convert.</span></span></param>
        <summary><span data-ttu-id="dc568-416">Gibt eine in Kleinbuchstaben konvertierte Kopie der angegebenen <see cref="T:System.Text.Rune" /> zur√ºck, wobei die Regeln der Gro√ü- und Kleinschreibung der invarianten Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dc568-416">Returns a copy of the specified <see cref="T:System.Text.Rune" /> converted to lowercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="dc568-417">Die Entsprechung von <paramref name="value" /> in Kleinbuchstaben.</span><span class="sxs-lookup"><span data-stu-id="dc568-417">The lowercase equivalent of <paramref name="value" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="rune.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dc568-418">Gibt die Zeichenfolgendarstellung dieser <see cref="T:System.Text.Rune" />-Instanz zur√ºck.</span><span class="sxs-lookup"><span data-stu-id="dc568-418">Returns the string representation of this <see cref="T:System.Text.Rune" /> instance.</span></span></summary>
        <returns><span data-ttu-id="dc568-419">Die Zeichenfolgendarstellung f√ºr diese Rune.</span><span class="sxs-lookup"><span data-stu-id="dc568-419">The string representation of this rune.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToUpper (System.Text.Rune value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToUpper(valuetype System.Text.Rune value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToUpper(System.Text.Rune,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (value As Rune, culture As CultureInfo) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToUpper(System::Text::Rune value, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToUpper : System.Text.Rune * System.Globalization.CultureInfo -&gt; System.Text.Rune" Usage="System.Text.Rune.ToUpper (value, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-420">Das zu konvertierende 32-Bit-Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dc568-420">The 32-bit Unicode character to convert.</span></span></param>
        <param name="culture"><span data-ttu-id="dc568-421">Ein Objekt, das kulturspezifische Regeln zur Gro√ü- und Kleinschreibung bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="dc568-421">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="dc568-422">Gibt eine in Gro√übuchstaben konvertierte Kopie der angegebenen <see cref="T:System.Text.Rune" /> zur√ºck, wobei die Regeln der Gro√ü- und Kleinschreibung der angegebenen Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dc568-422">Returns a copy of the specified <see cref="T:System.Text.Rune" /> converted to uppercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="dc568-423">Die Entsprechung von <paramref name="value" /> in Gro√übuchstaben.</span><span class="sxs-lookup"><span data-stu-id="dc568-423">The uppercase equivalent of <paramref name="value" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToUpperInvariant (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToUpperInvariant(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToUpperInvariant(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpperInvariant (value As Rune) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToUpperInvariant(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member ToUpperInvariant : System.Text.Rune -&gt; System.Text.Rune" Usage="System.Text.Rune.ToUpperInvariant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-424">Das zu konvertierende 32-Bit-Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dc568-424">The 32-bit Unicode character to convert.</span></span></param>
        <summary><span data-ttu-id="dc568-425">Gibt eine in Gro√übuchstaben konvertierte Kopie der angegebenen <see cref="T:System.Text.Rune" /> zur√ºck, wobei die Regeln der Gro√ü- und Kleinschreibung der invarianten Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dc568-425">Returns a copy of the specified <see cref="T:System.Text.Rune" /> converted to uppercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="dc568-426">Die Entsprechung von <paramref name="value" /> in Gro√übuchstaben.</span><span class="sxs-lookup"><span data-stu-id="dc568-426">The uppercase equivalent of <paramref name="value" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (char ch, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(char ch, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.Char,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (ch As Char, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(char ch, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : char * Rune -&gt; bool" Usage="System.Text.Rune.TryCreate (ch, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ch"><span data-ttu-id="dc568-427">Das Zeichen, aus dem die Rune erstellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc568-427">The character from which to create the rune.</span></span></param>
        <param name="result"><span data-ttu-id="dc568-428">Die Rune, die <paramref name="ch" /> entspricht, wenn diese Methode zur√ºckgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dc568-428">When this method returns, the rune that corresponds to <paramref name="ch" />.</span></span></param>
        <summary><span data-ttu-id="dc568-429">Versucht, eine <see cref="T:System.Text.Rune" />-Struktur aus einem angegebenen Zeichen zu erstellen, und gibt einen Wert zur√ºck, der angibt, ob der Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="dc568-429">Attempts to create a <see cref="T:System.Text.Rune" /> from a specified character and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="dc568-430"><see langword="true" />, wenn die Methode erfolgreich ausgef√ºhrt wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-430"><see langword="true" /> if the method succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (int value, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(int32 value, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.Int32,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (value As Integer, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(int value, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : int * Rune -&gt; bool" Usage="System.Text.Rune.TryCreate (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-431">Der Unicode-Skalarwert.</span><span class="sxs-lookup"><span data-stu-id="dc568-431">The Unicode scalar value.</span></span></param>
        <param name="result"><span data-ttu-id="dc568-432">Die Rune, die <paramref name="value" /> entspricht, wenn diese Methode zur√ºckgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dc568-432">When this method returns, the rune that corresponds to <paramref name="value" />.</span></span></param>
        <summary><span data-ttu-id="dc568-433">Versucht, eine <see cref="T:System.Text.Rune" />-Struktur aus der angegebenen ganzen Zahl mit Vorzeichen zu erstellen, die einen Unicode-Skalarwert darstellt.</span><span class="sxs-lookup"><span data-stu-id="dc568-433">Attempts to create a <see cref="T:System.Text.Rune" /> from a specified signed integer that represents a Unicode scalar value.</span></span></summary>
        <returns><span data-ttu-id="dc568-434"><see langword="true" />, wenn die Methode erfolgreich ausgef√ºhrt wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-434"><see langword="true" /> if the method succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (uint value, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(unsigned int32 value, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.UInt32,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (value As UInteger, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::UInt32 value, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : uint32 * Rune -&gt; bool" Usage="System.Text.Rune.TryCreate (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dc568-435">Der Unicode-Skalarwert.</span><span class="sxs-lookup"><span data-stu-id="dc568-435">The Unicode scalar value.</span></span></param>
        <param name="result"><span data-ttu-id="dc568-436">Die Rune, die <paramref name="value" /> entspricht, wenn diese Methode zur√ºckgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dc568-436">When this method returns, the rune that corresponds to <paramref name="value" />.</span></span></param>
        <summary><span data-ttu-id="dc568-437">Versucht, eine <see cref="T:System.Text.Rune" />-Struktur aus der angegebenen 32-Bit-Ganzzahl ohne Vorzeichen zu erstellen, die einen Unicode-Skalarwert darstellt.</span><span class="sxs-lookup"><span data-stu-id="dc568-437">Attempts to create a <see cref="T:System.Text.Rune" /> from the specified 32-bit unsigned integer that represents a Unicode scalar value.</span></span></summary>
        <returns><span data-ttu-id="dc568-438"><see langword="true" />, wenn die Methode erfolgreich ausgef√ºhrt wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-438"><see langword="true" /> if the method succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (char highSurrogate, char lowSurrogate, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(char highSurrogate, char lowSurrogate, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.Char,System.Char,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (highSurrogate As Char, lowSurrogate As Char, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(char highSurrogate, char lowSurrogate, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : char * char * Rune -&gt; bool" Usage="System.Text.Rune.TryCreate (highSurrogate, lowSurrogate, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="highSurrogate"><span data-ttu-id="dc568-439">Das hohe Ersatzzeichen des Ersatzzeichenpaars.</span><span class="sxs-lookup"><span data-stu-id="dc568-439">The high surrogate of the surrogate pair.</span></span></param>
        <param name="lowSurrogate"><span data-ttu-id="dc568-440">Das niedrige Ersatzzeichen des Ersatzzeichenpaars.</span><span class="sxs-lookup"><span data-stu-id="dc568-440">The low surrogate of the surrogate pair.</span></span></param>
        <param name="result"><span data-ttu-id="dc568-441">Die Rune, die dem angegebenen Ersatzzeichenpaar entspricht.</span><span class="sxs-lookup"><span data-stu-id="dc568-441">The rune that corresponds to the specified surrogate pair.</span></span></param>
        <summary><span data-ttu-id="dc568-442">Versucht, eine <see cref="T:System.Text.Rune" />-Struktur aus einem angegebenen UTF-16-Ersatzzeichenpaar zu erstellen, und gibt einen Wert zur√ºck, der angibt, ob der Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="dc568-442">Attempts to create a <see cref="T:System.Text.Rune" /> from the specified UTF-16 surrogate pair and returns a value that indicates whether the operation was successful.</span></span></summary>
        <returns><span data-ttu-id="dc568-443"><see langword="true" />, wenn der Vorgang erfolgreich war; <see langword="false" />, wenn die Eingabewerte kein richtig formatiertes UTF-16-Ersatzzeichenpaar darstellen.</span><span class="sxs-lookup"><span data-stu-id="dc568-443"><see langword="true" /> if the operation succeeded; <see langword="false" /> if the input values don't represent a well-formed UTF-16 surrogate pair.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEncodeToUtf16">
      <MemberSignature Language="C#" Value="public bool TryEncodeToUtf16 (Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEncodeToUtf16(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryEncodeToUtf16(System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEncodeToUtf16 (destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEncodeToUtf16(Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="member this.TryEncodeToUtf16 : Span&lt;char&gt; * int -&gt; bool" Usage="rune.TryEncodeToUtf16 (destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="dc568-444">Der Puffer, in den dieser Wert im UTF-16-Format geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc568-444">The buffer to which to write this value as UTF-16 encoded value.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="dc568-445">Die Anzahl von <see cref="T:System.Char" /> in <paramref name="destination" /> geschriebenen Werte, oder 0, wenn der Zielpuffer nicht gro√ü genug ist, um die Ausgabe zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="dc568-445">The number of <see cref="T:System.Char" /> values written to <paramref name="destination" />, or 0 if the destination buffer is not large enough to contain the output.</span></span></param>
        <summary><span data-ttu-id="dc568-446">Codiert diese <see cref="T:System.Text.Rune" />-Struktur in einen verschl√ºsselten Zielpuffer im UTF-16-Format.</span><span class="sxs-lookup"><span data-stu-id="dc568-446">Encodes this <see cref="T:System.Text.Rune" /> to a UTF-16 encoded destination buffer.</span></span></summary>
        <returns><span data-ttu-id="dc568-447"><see langword="true" />, wenn der Wert in den Puffer geschrieben wurde; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-447"><see langword="true" /> if the value was written to the buffer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks

<span data-ttu-id="dc568-448">Die- <xref:System.Text.Rune.Utf16SequenceLength> Eigenschaft kann im Voraus abgefragt werden, um die erforderliche Gr√∂√üe des `destination` Puffers zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="dc568-448">The <xref:System.Text.Rune.Utf16SequenceLength> property can be queried ahead of time to determine the required size of the `destination` buffer.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEncodeToUtf8">
      <MemberSignature Language="C#" Value="public bool TryEncodeToUtf8 (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEncodeToUtf8(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryEncodeToUtf8(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEncodeToUtf8 (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEncodeToUtf8(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryEncodeToUtf8 : Span&lt;byte&gt; * int -&gt; bool" Usage="rune.TryEncodeToUtf8 (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="dc568-449">Der Puffer, in der Wert im UTF-8-Format geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc568-449">The buffer to which to write the UTF-8 encoded value.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="dc568-450">Die Anzahl von <see cref="T:System.Byte" /> in <paramref name="destination" /> geschriebenen Werte, oder 0, wenn der Zielpuffer nicht gro√ü genug ist, um die Ausgabe zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="dc568-450">The number of <see cref="T:System.Byte" /> values written to <paramref name="destination" />, or 0 if the destination buffer is not large enough to contain the output.</span></span></param>
        <summary><span data-ttu-id="dc568-451">Codiert diese <see cref="T:System.Text.Rune" />-Struktur in einen Zielpuffer im UTF-8-Format.</span><span class="sxs-lookup"><span data-stu-id="dc568-451">Encodes this <see cref="T:System.Text.Rune" /> to a UTF-8 encoded destination buffer.</span></span></summary>
        <returns><span data-ttu-id="dc568-452"><see langword="true" />, wenn der Wert in den Puffer geschrieben wurde; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-452"><see langword="true" /> if the value was written to the buffer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks

<span data-ttu-id="dc568-453">Die- <xref:System.Text.Rune.Utf8SequenceLength> Eigenschaft kann im Voraus abgefragt werden, um die erforderliche Gr√∂√üe des `destination` Puffers zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="dc568-453">The <xref:System.Text.Rune.Utf8SequenceLength> property can be queried ahead of time to determine the required size of the `destination` buffer.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetRuneAt">
      <MemberSignature Language="C#" Value="public static bool TryGetRuneAt (string input, int index, out System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetRuneAt(string input, int32 index, [out] valuetype System.Text.Rune&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryGetRuneAt(System.String,System.Int32,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetRuneAt (input As String, index As Integer, ByRef value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetRuneAt(System::String ^ input, int index, [Runtime::InteropServices::Out] System::Text::Rune % value);" />
      <MemberSignature Language="F#" Value="static member TryGetRuneAt : string * int * Rune -&gt; bool" Usage="System.Text.Rune.TryGetRuneAt (input, index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="dc568-454">Die Zeichenfolge, aus der die Rune extrahiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc568-454">The string from which to extract the rune.</span></span></param>
        <param name="index"><span data-ttu-id="dc568-455">Der nullbasierte Index, aus dem die Rune extrahiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc568-455">The zero-based index from which to extract the rune.</span></span></param>
        <param name="value"><span data-ttu-id="dc568-456">Die decodierte Rune bei R√ºckgabe dieser Methode.</span><span class="sxs-lookup"><span data-stu-id="dc568-456">When this method returns, the decoded rune.</span></span></param>
        <summary><span data-ttu-id="dc568-457">Versucht, die <see cref="T:System.Text.Rune" />-Klasse abzurufen, die an der angegebenen Position in einer Zeichenfolge beginnt und einen Wert zur√ºckgibt, der angibt, ob der Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="dc568-457">Attempts to get the <see cref="T:System.Text.Rune" /> that begins at a specified position in a string, and return a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="dc568-458"><see langword="true" />, wenn ein Skalarwert erfolgreich aus dem angegebenen Index extrahiert wurde; <see langword="false" />, wenn ein Wert aufgrund ung√ºltiger Daten nicht extrahiert werden konnte.</span><span class="sxs-lookup"><span data-stu-id="dc568-458"><see langword="true" /> if a scalar value was successfully extracted from the specified index; <see langword="false" /> if a value could not be extracted because of invalid data.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-459">L√∂st eine Ausnahme aus, wenn den Wert hat `input` `null` oder `index` au√üerhalb des zul√§ssigen Bereichs liegt.</span><span class="sxs-lookup"><span data-stu-id="dc568-459">Throws an exception if `input` is `null` or `index` is out of range.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dc568-460"><paramref name="input" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-460"><paramref name="input" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="dc568-461"><paramref name="index" /> liegt au√üerhalb des Bereichs von <paramref name="input" />.</span><span class="sxs-lookup"><span data-stu-id="dc568-461"><paramref name="index" /> is out of the range of <paramref name="input" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Utf16SequenceLength">
      <MemberSignature Language="C#" Value="public int Utf16SequenceLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Utf16SequenceLength" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Utf16SequenceLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Utf16SequenceLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Utf16SequenceLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Utf16SequenceLength : int" Usage="System.Text.Rune.Utf16SequenceLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dc568-462">Ruft die L√§nge in Codeeinheiten (<see cref="T:System.Char" />) der UTF-16-Sequenz ab, die zur Darstellung dieses Skalarwerts erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-462">Gets the length in code units (<see cref="T:System.Char" />) of the UTF-16 sequence required to represent this scalar value.</span></span></summary>
        <value><span data-ttu-id="dc568-463">Gibt die L√§nge in Codeeinheiten (<see cref="T:System.Char" />) der UTF-16-Sequenz zur√ºck, die zur Darstellung dieses Skalarwerts erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-463">The length in code units (<see cref="T:System.Char" />) of the UTF-16 sequence required to represent this scalar value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-464">Der R√ºckgabewert ist "1" oder "2".</span><span class="sxs-lookup"><span data-stu-id="dc568-464">The return value will be 1 or 2.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Utf8SequenceLength">
      <MemberSignature Language="C#" Value="public int Utf8SequenceLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Utf8SequenceLength" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Utf8SequenceLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Utf8SequenceLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Utf8SequenceLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Utf8SequenceLength : int" Usage="System.Text.Rune.Utf8SequenceLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dc568-465">Ruft die L√§nge in Codeeinheiten der UTF-8-Sequenz ab, die zur Darstellung dieses Skalarwerts erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-465">Gets the length in code units of the UTF-8 sequence required to represent this scalar value.</span></span></summary>
        <value><span data-ttu-id="dc568-466">Die L√§nge in den Code Einheiten der UTF-8-Sequenz, die f√ºr die Darstellung dieses skalarwerts erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="dc568-466">The length in code units of the UTF-8 sequence required to represent this scalar value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="dc568-467">Der R√ºckgabewert ist 1 bis 4 (einschlie√ülich).</span><span class="sxs-lookup"><span data-stu-id="dc568-467">The return value will be 1 through 4, inclusive.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public int Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Value" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Value { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : int" Usage="System.Text.Rune.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dc568-468">Ruft den Unicode-Skalarwert als ganze Zahl ab.</span><span class="sxs-lookup"><span data-stu-id="dc568-468">Gets the Unicode scalar value as an integer.</span></span></summary>
        <value><span data-ttu-id="dc568-469">Der Unicode-Skalarwert als ganze Zahl.</span><span class="sxs-lookup"><span data-stu-id="dc568-469">The Unicode scalar value as an integer.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
