<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e3c91724ff6dad5916829d444df2a9e5fff19850" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36409198" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a mutable string of characters. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse stellt einen Zeichenfolge-ähnliches Objekt, dessen Wert eine änderbare Sequenz von Zeichen dar.  
  
 In diesem Abschnitt  
  
-   [Zeichenfolgen-und StringBuilder](#StringAndSB)  
  
-   [Funktionsweise von StringBuilder](#HowWorks)  
  
-   [Speicherreservierung](#Memory)  
  
-   [Instanziieren eines StringBuilder-Objekts](#Instantiating)  
  
-   [StringBuilder-Methoden aufrufen](#Calling)  
  
-   [StringBuilder-Vorgänge](#Operations)  
  
    -   [Durchlaufen von StringBuilder-Zeichen](#Iterating)  
  
    -   [Hinzufügen von Text in ein StringBuilder-Objekt](#Adding)  
  
    -   [Löschen von Text in ein StringBuilder-Objekt](#Deleting)  
  
    -   [Ändern den Text in ein StringBuilder-Objekt](#Modifying)  
  
-   [Suchen den Text in ein StringBuilder-Objekt](#Searching)  
  
-   [Konvertieren der StringBuilder-Objekt in eine Zeichenfolge](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>Zeichenfolgen-und StringBuilder  
 Obwohl <xref:System.Text.StringBuilder> und <xref:System.String> beide Stellen Sequenzen von Zeichen d. h., sie anders implementiert werden. <xref:System.String> ist ein unveränderlicher Typ an. D. h., jeder Vorgang, der angezeigt wird, so ändern Sie eine <xref:System.String> Objekt tatsächlich eine neue Zeichenfolge erstellt.  
  
 Z. B. der Aufruf der <xref:System.String.Concat%2A?displayProperty=nameWithType> -Methode im folgenden C#-Beispiel wird angezeigt, zum Ändern des Werts, der eine Zeichenfolgenvariable mit dem Namen `value`. In der Tat die <xref:System.String.Concat%2A> Methode gibt ein `value` Objekt mit einem anderen Wert und einer Adresse aus der `value` Objekt, das an die Methode übergeben wurde. Beachten Sie, dass das Beispiel kompiliert werden muss, mit der `/unsafe` -Compileroption.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 Für Routinen, die eine umfangreiche zeichenfolgenbearbeitung (z. B. apps, die eine Zeichenfolge in einer Schleife mehrere Male ändern) ausführen, kann die Änderung einer Zeichenfolge wiederholt erhebliche Leistungseinbußen genau. Die Alternative ist die Verwendung <xref:System.Text.StringBuilder>, also eine veränderbare Zeichenfolge-Klasse. Veränderlichkeit bedeutet, dass eine Instanz der Klasse erstellt wurde, geändert werden können durch Anfügen, ersetzen oder Einfügen von Zeichen. Ein <xref:System.Text.StringBuilder> -Objekt verwaltet einen Puffer um Erweiterungen in der Zeichenfolge aufzunehmen. Neue Daten werden in den Puffer angefügt, wenn ausreichend Platz verfügbar ist; andernfalls erhält ein neuen Puffer, Daten aus dem ursprünglichen Puffer in den neuen Puffer kopiert und die neuen Daten dann in den neuen Puffer angefügt ist.  
  
> [!IMPORTANT]
>  Obwohl die <xref:System.Text.StringBuilder> Klasse bietet im Allgemeinen eine bessere Leistung als die <xref:System.String> -Klasse, Sie sollten nicht automatisch ersetzen <xref:System.String> mit <xref:System.Text.StringBuilder> immer, wenn Sie Zeichenfolgen bearbeiten möchten. Leistung hängt von der Größe der Zeichenfolge, die Größe des Arbeitsspeichers für die neue Zeichenfolge, das System, in dem die app ausgeführt wird, und der Typ des Vorgangs zugeordnet werden soll. Sie sollten darauf vorbereitet sein, Testen Ihrer Anwendung zu bestimmen, ob <xref:System.Text.StringBuilder> tatsächlich bietet eine deutliche leistungsverbesserung.  
  
 Erwägen Sie die <xref:System.String> Klasse unter diesen Bedingungen:  
  
-   Wenn die Anzahl der Änderungen, die Ihre app in eine Zeichenfolge werden klein ist. In diesen Fällen <xref:System.Text.StringBuilder> möglicherweise Angebot unerheblich oder keine leistungsverbesserung über <xref:System.String>.  
  
-   Wenn Sie eine feste Anzahl von Verkettungsvorgänge, insbesondere mit Zeichenfolgenliteralen durchführen. In diesem Fall kann der Compiler die Verkettungsvorgänge in einem einzigen Vorgang kombiniert werden.  
  
-   Wenn Sie umfangreiche Suchvorgänge ausführen beim Erstellen der Zeichenfolge müssen. Die <xref:System.Text.StringBuilder> Klasse besitzt Suchmethoden wie z. B. `IndexOf` oder `StartsWith`. Stehen Ihnen zum Konvertieren der <xref:System.Text.StringBuilder> -Objekt an eine <xref:System.String> für diese Vorgänge, wodurch sich der Leistungsvorteil von der Verwendung negieren können <xref:System.Text.StringBuilder>. Weitere Informationen finden Sie unter der [suchen den Text in ein StringBuilder-Objekt](#Searching) Abschnitt.  
  
 Erwägen Sie die <xref:System.Text.StringBuilder> Klasse unter diesen Bedingungen:  
  
-   Wenn Sie erwarten, dass Ihre app stellen eine unbekannte Anzahl von Änderungen in eine Zeichenfolge zur Entwurfszeit (z. B., wenn Sie eine Schleife verwenden, um eine zufällige Zahl von Zeichenfolgen zu verketten, die Benutzereingaben enthalten).  
  
-   Wenn Sie Ihrer app nach, eine erhebliche Anzahl von Änderungen in eine Zeichenfolge erwarten.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>Funktionsweise von StringBuilder  
 Die <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> Eigenschaft gibt die Anzahl von Zeichen an der <xref:System.Text.StringBuilder> Objekt zurzeit enthält. Wenn Sie die Zeichen zum Hinzufügen der <xref:System.Text.StringBuilder> -Objekt, dessen Länge erhöht, bis sie die Größe der entspricht der <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> Eigenschaft, die die Anzahl der Zeichen definiert, die das Objekt enthalten kann. Wenn die Anzahl der hinzugefügten Zeichen bewirkt, die Länge des dass der <xref:System.Text.StringBuilder> Objekt größer als die aktuelle Kapazität, neuen Speicher belegt wurde, ist den Wert des der <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft verdoppelt, neue Zeichen hinzugefügt werden die <xref:System.Text.StringBuilder> Objekt und seine <xref:System.Text.StringBuilder.Length%2A>Eigenschaft angepasst wird. Erhöhung der Speicherkapazität die <xref:System.Text.StringBuilder> Objekt wird dynamisch reserviert, bis den Wert von definierten erreicht die <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> Eigenschaft. Wenn die maximale Kapazität erreicht ist, kann keine weiteren Arbeitsspeicher zugeordnet werden, für die <xref:System.Text.StringBuilder> -Objekt, und versuchen, Hinzufügen von Zeichen, oder erweitern ihn über die maximale Kapazität löst entweder eine <xref:System.ArgumentOutOfRangeException> oder ein <xref:System.OutOfMemoryException> Ausnahme.  
  
 Im folgende Beispiel wird veranschaulicht, wie ein <xref:System.Text.StringBuilder> Objekt neuen Speicher reserviert und dynamisch seine Kapazität erhöht, wenn die Zeichenfolge, die dem Objekt zugewiesene erweitert wird. Der Code erstellt ein <xref:System.Text.StringBuilder> Objekt durch Aufrufen der (parameterlose) Standardkonstruktor. Die festgelegte Standardkapazität dieses Objekts ist 16 Zeichen enthalten, und die maximale Kapazität ist mehr als 2 Milliarden Zeichen. Anfügen der Zeichenfolge "This is eines Satzes." führt eine neue speicherbelegung, weil die Zeichenfolgenlänge (19 Zeichen) die Standardkapazität überschreitet die <xref:System.Text.StringBuilder> Objekt. Die Kapazität des Objekts auf 32 Zeichen verdoppelt wird, wird die neue Zeichenfolge hinzugefügt, und die Länge des Objekts entspricht jetzt 19 Zeichen. Der Code fügt dann die Zeichenfolge "This is einen zusätzlichen Satz". auf den Wert, der die <xref:System.Text.StringBuilder> 11 Mal-Objekt. Wenn der Anfügevorgang bewirkt die Länge des der <xref:System.Text.StringBuilder> Objekt größer als seine Kapazität, die vorhandenen Kapazität wird verdoppelt und die <xref:System.Text.StringBuilder.Append%2A> Operation erfolgreich ausgeführt wird.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>Speicherreservierung  
 Die Standardkapazität ein <xref:System.Text.StringBuilder> Objekt ist 16 Zeichen enthalten, und die standardmäßige maximale Kapazität ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Diese Standardwerte werden verwendet, wenn Sie rufen die <xref:System.Text.StringBuilder.%23ctor> und <xref:System.Text.StringBuilder.%23ctor%28System.String%29> Konstruktoren.  
  
 Sie können die Anfangskapazität des explizit definieren eine <xref:System.Text.StringBuilder> Objekt auf folgende Weise:  
  
-   Durch das Aufrufen einer von der <xref:System.Text.StringBuilder> Konstruktoren, die enthält eine `capacity` -Parameter, wenn das Objekt zu erstellen.  
  
-   Indem Sie explizit einen neuen Wert zuweisen der <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> zu erweiternden einer vorhandenen Eigenschaft <xref:System.Text.StringBuilder> Objekt. Beachten Sie, dass die Eigenschaft eine Ausnahme auslöst, wenn die neue Kapazität kleiner als der vorhandenen Kapazität oder größer als ist die <xref:System.Text.StringBuilder> maximale Kapazität des Objekts.  
  
-   Durch Aufrufen der <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> -Methode durch die neue Kapazität. Die neue Kapazität muss größer als die <xref:System.Text.StringBuilder> maximale Kapazität des Objekts. Jedoch im Gegensatz zu einer Zuordnung zu den <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft <xref:System.Text.StringBuilder.EnsureCapacity%2A> löst keine Ausnahme aus, wenn die gewünschte neue Kapazität ist kleiner als die vorhandenen Kapazität; in diesem Fall dem Aufruf der Methode hat keine Auswirkungen.  
  
 Wenn die Länge der Zeichenfolge zugewiesen der <xref:System.Text.StringBuilder> Objekt im Konstruktoraufruf überschreitet die festgelegte Standardkapazität oder der angegebenen Kapazität der <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaftensatz auf die Länge der Zeichenfolge angegeben wird, mit der `value` Parameter.  
  
 Sie können die maximale Kapazität des explizit definieren eine <xref:System.Text.StringBuilder> Objekt durch Aufrufen der <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> Konstruktor. Sie können nicht die maximale Kapazität ändern, indem Sie einen neuen Wert zuweisen der <xref:System.Text.StringBuilder.MaxCapacity%2A> -Eigenschaft, da sie schreibgeschützt ist.  
  
 Wie im vorherigen Abschnitt gezeigt, wenn die vorhandene Kapazität unzureichend, ist weiterer Arbeitsspeicher reserviert wird und die Kapazität der eine <xref:System.Text.StringBuilder> -Objekt Double-Werte bis zu dem Wert, der definiert, indem Sie die <xref:System.Text.StringBuilder.MaxCapacity%2A> Eigenschaft.  
  
 Im Allgemeinen sind die Standardkapazität und die maximale Kapazität bei den meisten apps ausreichend. Sie sollten erwägen, diese Werte in den folgenden Situationen festlegen:  
  
-   Wenn der endgültigen Größe der <xref:System.Text.StringBuilder> Objekt unterscheidet sich wahrscheinlich in der Regel mehr als einige Megabyte äußerst groß werden. In diesem Fall gibt es möglicherweise einige Leistungsvorteil von der Festlegung der anfänglichen <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft, um eine deutlich hohen Schwellenwert auf zu viele neuzuordnungen von Arbeitsspeicher erforderlich.  
  
-   Wenn Ihre app auf einem System mit begrenzter Speicher ausgeführt wird. In diesem Fall kann es sinnvoll sein, erwägen Sie, ob die <xref:System.Text.StringBuilder.MaxCapacity%2A> Eigenschaft, um weniger als <xref:System.Int32.MaxValue?displayProperty=nameWithType> Wenn Ihre app große Zeichenfolgen behandelt, die sie zum Ausführen in einer Umgebung mit eingeschränktem Arbeitsspeicher führen kann.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>Instanziieren eines StringBuilder-Objekts  
 Instanziieren Sie ein <xref:System.Text.StringBuilder> Objekt durch Aufrufen einer ihrer sechs überladene Klassenkonstruktoren, die in der folgenden Tabelle aufgeführt sind. Drei Konstruktoren Instanziieren einer <xref:System.Text.StringBuilder> Objekt, dessen Wert eine leere Zeichenfolge festgelegt, aber seine <xref:System.Text.StringBuilder.Capacity%2A> und <xref:System.Text.StringBuilder.MaxCapacity%2A> Werte unterschiedlich. Die verbleibenden drei Konstruktoren definieren eine <xref:System.Text.StringBuilder> -Objekt, das einen bestimmten Zeichenfolgenwert und Kapazität verfügt. Zwei der drei Konstruktoren verwenden Sie die standardmäßige maximale Kapazität des <xref:System.Int32.MaxValue?displayProperty=nameWithType>, während das dritte, die Sie die maximale Kapazität festlegen kann.  
  
|Konstruktor|Zeichenfolgenwert|Kapazität|Maximale Kapazität|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Definiert durch den `capacity` Parameter|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Definiert durch den `capacity` Parameter|Definiert durch den `maxCapacity` Parameter|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Definiert durch den `value` Parameter|16 oder `value`. <xref:System.String.Length%2A>, welcher Wert größer ist.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Definiert durch den `value` Parameter|Definiert durch die `capacity` Parameter oder `value`. <xref:System.String.Length%2A>, welcher Wert größer ist.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Definiert durch `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Definiert durch die `capacity` Parameter oder `value`. <xref:System.String.Length%2A>, welcher Wert größer ist.|Definiert durch den `maxCapacity` Parameter|  
  
 Das folgende Beispiel verwendet drei der folgenden Konstruktorüberladungen instanziieren <xref:System.Text.StringBuilder> Objekte.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>StringBuilder-Methoden aufrufen  
 Die meisten Methoden, ändern die Zeichenfolge in, eine <xref:System.Text.StringBuilder> Instanz einen Verweis auf die gleiche Instanz zurückgeben. Dadurch können Sie rufen <xref:System.Text.StringBuilder> Methoden auf zwei Arten:  
  
-   Sie können einzelne Methodenaufrufe und den Rückgabewert zu ignorieren, wie im folgenden Beispiel wird der Fall ist.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   Sie können eine Reihe von Methodenaufrufen in einer einzelnen Anweisung vornehmen. Dies ist besonders angenehm Wunsch eine einzige Anweisung zu schreiben, die aufeinander folgende Operationen verkettet ist. Im folgende Beispiel werden drei Methodenaufrufe aus dem vorherigen Beispiel in eine einzige Codezeile konsolidiert.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>StringBuilder-Vorgänge  
 Können Sie die Methoden der <xref:System.Text.StringBuilder> Klasse zu durchlaufen, hinzufügen, löschen oder Ändern von Zeichen in eine <xref:System.Text.StringBuilder> Objekt.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>Durchlaufen von StringBuilder-Zeichen  
 Sie erreichen die Zeichen in einem <xref:System.Text.StringBuilder> Objekt mithilfe der <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> Eigenschaft. In c# <xref:System.Text.StringBuilder.Chars%2A> ist ein Indexer; in Visual Basic ist es die Standardeigenschaft eines der <xref:System.Text.StringBuilder> Klasse. Dadurch können Sie festlegen oder Abrufen der einzelne Zeichen mithilfe ihres Indexes nur ohne explizit verweisen auf die <xref:System.Text.StringBuilder.Chars%2A> Eigenschaft. Zeichen in einem <xref:System.Text.StringBuilder> Objekt bei Index 0 (null) beginnen und die zu indizierenden fortsetzen <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Chars%2A> Eigenschaft. Es fügt zehn zufällige Zahlen zu einer <xref:System.Text.StringBuilder> Objekt, und klicken Sie dann durchläuft jedes Zeichen. Wenn das Zeichen Unicode-Kategorie ist <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, nimmt er die Zahl um 1 (oder die Anzahl bis 9 geändert, wenn der Wert 0 ist). Das Beispiel zeigt den Inhalt der <xref:System.Text.StringBuilder> -Objekt sowohl vor und nach dem die Werte der einzelnen Zeichen geändert wurden.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>Hinzufügen von Text in ein StringBuilder-Objekt  
 Die <xref:System.Text.StringBuilder> Klasse enthält die folgenden Methoden zum Erweitern den Inhalt einer <xref:System.Text.StringBuilder> Objekt:  
  
-   Die <xref:System.Text.StringBuilder.Append%2A> Methode fügt eine Zeichenfolge, eine Teilzeichenfolge, ein Array von Zeichen, die einen Teil eines Arrays von Zeichen, mehrere Male wiederholt, ein einzelnes Zeichen oder die angegebene Zeichenfolgendarstellung einer primitiven Datentyps für einen <xref:System.Text.StringBuilder> Objekt.  
  
-   Die <xref:System.Text.StringBuilder.AppendLine%2A> Methode fügt ein Zeilenabschlusszeichen oder einer Zeichenfolge zusammen mit einem Zeilenabschluss in einem <xref:System.Text.StringBuilder> Objekt.  
  
-   Die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode fügt einen auf einem <xref:System.Text.StringBuilder> Objekt. Die zeichenfolgendarstellungen von Objekten, die in der Ergebniszeichenfolge enthalten, können die Formatierungskonventionen der aktuellen Systemkultur oder einer angegebenen Kultur widerspiegeln.  
  
-   Die <xref:System.Text.StringBuilder.Insert%2A> Methode fügt eine Zeichenfolge, die eine Teilzeichenfolge, die mehrere Wiederholungen einer Zeichenfolge, ein Array von Zeichen, die einen Teil eines Arrays von Zeichen oder die angegebene Zeichenfolgendarstellung einer primitiven Datentyps Geben Sie an einer angegebenen Position in der <xref:System.Text.StringBuilder> Objekt. Die Position wird durch einen nullbasierten Index definiert.  
  
 Im folgenden Beispiel wird die <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, und <xref:System.Text.StringBuilder.Insert%2A> Methoden, um den Text der Erweitern einer <xref:System.Text.StringBuilder> Objekt.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>Löschen von Text in ein StringBuilder-Objekt  
 Die <xref:System.Text.StringBuilder> Klasse enthält Methoden, die die Größe des aktuellen reduzieren können <xref:System.Text.StringBuilder> Instanz. Die <xref:System.Text.StringBuilder.Clear%2A> -Methode entfernt alle Zeichen und legt die <xref:System.Text.StringBuilder.Length%2A> Eigenschaft auf 0 (null). Die <xref:System.Text.StringBuilder.Remove%2A> -Methode löscht eine angegebene Anzahl von Zeichen ab einer bestimmten Indexposition. Darüber hinaus können Sie Zeichen vom Ende Entfernen einer <xref:System.Text.StringBuilder> Objekt durch Festlegen seiner <xref:System.Text.StringBuilder.Length%2A> Eigenschaft auf einen Wert, der kleiner als die Länge der aktuellen Instanz ist.  
  
 Im folgenden Beispiel wird ein Teil des Texts aus einer <xref:System.Text.StringBuilder> -Objekt, zeigt die resultierenden Kapazität, maximale Kapazität und Länge Eigenschaftswerte, und ruft anschließend die <xref:System.Text.StringBuilder.Clear%2A> -Methode entfernt alle Zeichen aus der <xref:System.Text.StringBuilder> Objekt.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Ändern den Text in ein StringBuilder-Objekt  
 Die <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> Methode ersetzt alle Vorkommen eines Zeichens oder einer Zeichenfolge in der gesamten <xref:System.Text.StringBuilder> Objekt oder in einem Bereich von bestimmten Zeichen. Im folgenden Beispiel wird die <xref:System.Text.StringBuilder.Replace%2A> -Methode zum Ersetzen von allen Ausrufezeichen (!) durch Fragezeichen (?) in der <xref:System.Text.StringBuilder> Objekt.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Suchen den Text in ein StringBuilder-Objekt  
 Die <xref:System.Text.StringBuilder> Klasse enthält keine Methoden, die ähnlich wie die <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, und <xref:System.String.StartsWith%2A?displayProperty=nameWithType> bereitgestellten Methoden die <xref:System.String> -Klasse, die Sie das Objekt für ein bestimmtes Zeichen oder eine Teilzeichenfolge durchsuchen können. Bestimmen das Vorhandensein oder Zeichen, die Anfangsposition einer Teilzeichenfolge erfordert, dass Sie suchen einen <xref:System.String> Wert mithilfe einer Zeichenfolge Search-Methode oder eine Methode mit regulären Ausdrücken. Es gibt vier Möglichkeiten zum Implementieren von solchen nach Daten suchen, wie in der folgenden Tabelle gezeigt.  
  
|Vorgehensweise|IT-Spezialisten|Nachteile|  
|---------------|----------|----------|  
|Suchen von Zeichenfolgenwerten vor dem Hinzufügen der <xref:System.Text.StringBuilder> Objekt.|Nützlich, um zu bestimmen, ob eine Teilzeichenfolge vorhanden ist.|Kann nicht verwendet werden, wenn der Index einer Teilzeichenfolge wichtig ist.|  
|Rufen Sie <xref:System.Text.StringBuilder.ToString%2A> , und suchen Sie das zurückgegebene <xref:System.String> Objekt.|Einfach zu verwenden, wenn Sie alle Text zum Zuweisen einer <xref:System.Text.StringBuilder> Objekt, und beginnen dann, diese zu ändern.|Mühsam wiederholt aufrufen <xref:System.Text.StringBuilder.ToString%2A> Wenn Sie Änderungen vornehmen müssen, bevor alle Text hinzugefügt wird die <xref:System.Text.StringBuilder> Objekt.<br /><br /> Sie denken, arbeiten am Ende der <xref:System.Text.StringBuilder> Text des Objekts, wenn Sie Änderungen vornehmen möchten.|  
|Verwenden der <xref:System.Text.StringBuilder.Chars%2A> Eigenschaft um einen Bereich von Zeichen sequenziell zu suchen.|Nützlich, wenn Sie einzelne Zeichen oder eine kleine Teilzeichenfolge dürfte sind.|Umständlich, wenn die Anzahl der zu suchenden Zeichen groß ist oder die Suchlogik komplex ist.<br /><br />/ / Ergibt eine sehr schlechte Leistung für Objekte, die durch wiederholte Aufrufe sehr groß geworden sind.  |  
|Konvertieren der <xref:System.Text.StringBuilder> -Objekt an eine <xref:System.String> Objekt, und führen Sie die Änderungen auf die <xref:System.String> Objekt.|Nützlich, wenn die Anzahl der Änderungen klein ist.|Negiert die Leistungsvorteile der <xref:System.Text.StringBuilder> Klasse, wenn die Anzahl der Änderungen groß ist.|  
  
 Sehen wir uns diese Techniken ausführlicher.  
  
-   Wenn das Ziel der Suche wird, um zu bestimmen, ob eine bestimmte Teilzeichenfolge vorhanden ist (d. h., wenn Sie nicht die Position der Teilzeichenfolge interessiert sind), können Sie Zeichenfolgen durchsuchen, vor dem Speichern in der <xref:System.Text.StringBuilder> Objekt. Das folgende Beispiel veranschaulicht eine mögliche Implementierung. Definiert eine `StringBuilderFinder` Klasse übergeben wird, dessen Konstruktor wird einen Verweis auf eine <xref:System.Text.StringBuilder> -Objekt und die Teilzeichenfolge in der Zeichenfolge gesucht. In diesem Fall im Beispiel wird versucht, um festzustellen, ob das aufgezeichnete Temperaturen in Fahrenheit oder Celsius sind, und fügt den entsprechenden Einführungstext am Anfang der <xref:System.Text.StringBuilder> Objekt. Ein Zufallszahlengenerator wird verwendet, um ein Array auszuwählen, die Daten in Grad Celsius oder Grad Fahrenheit enthält.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   Rufen Sie die <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> -Methode zum Konvertieren der <xref:System.Text.StringBuilder> -Objekt an eine <xref:System.String> Objekt. Sie können die Zeichenfolge suchen, indem Sie mit Methoden wie <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> oder <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, oder Sie können reguläre Ausdrücke verwenden und die <xref:System.Text.RegularExpressions.Regex> Klasse zu suchende Muster. Da beide <xref:System.Text.StringBuilder> und <xref:System.String> Objekte verwenden UTF-16-Codierung, die zum Speichern von Zeichen, die Indexpositionen der Zeichen der Teilzeichenfolgen, und reguläre Ausdrücke Übereinstimmungen sind in beide Objekte identisch. Dies ermöglicht Ihnen die Verwendung <xref:System.Text.StringBuilder> Methoden zu Änderungen an der gleichen Position, an dem dieser Text, in gefunden wird, der <xref:System.String> Objekt.  
  
    > [!NOTE]
    >  Wenn Sie diesen Ansatz verwenden, sollten Sie arbeiten, am Ende der <xref:System.Text.StringBuilder> -Objekt, dessen ab, damit Sie nicht wiederholt konvertieren die <xref:System.Text.StringBuilder> Objekt in eine Zeichenfolge.  
  
     Dieser Ansatz wird anhand des folgenden Beispiels veranschaulicht. Sie speichert vier Vorkommen jedes Buchstaben des englischen Alphabets in einem <xref:System.Text.StringBuilder> Objekt. Anschließend konvertiert den Text, der eine <xref:System.String> -Objekt und verwendet einen regulären Ausdruck, um die Anfangsposition der einzelnen vier Zeichen bestehende Folge zu identifizieren. Schließlich Fügt einen Unterstrich vor jeder Sequenz vier Zeichen mit Ausnahme der ersten Sequenz und konvertiert das erste Zeichen der Sequenz in Großbuchstaben.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   Verwenden der <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> Eigenschaft, um einen Bereich von Zeichen in sequenziell suchen eine <xref:System.Text.StringBuilder> Objekt. Dieser Ansatz möglicherweise nicht praktikabel die Anzahl der Zeichen, die durchsucht werden bei großen oder Suchlogik besonders komplex ist. Für die Leistungseinbußen bei der Zeichen für Zeichen indexbasierte Zugriff für sehr große, chunked <xref:System.Text.StringBuilder> Objekte finden Sie in der Dokumentation für die <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> Eigenschaft. 
  
     Im folgenden Beispiel wird dieselbe Funktion wie das vorherige Beispiel jedoch unterschiedlich implementiert. Er verwendet die <xref:System.Text.StringBuilder.Chars%2A> Eigenschaft erkennen, wenn ein Zeichenwert geändert hat, einen Unterstrich an dieser Position eingefügt, und das erste Zeichen in der neuen Reihenfolge in Großbuchstaben konvertiert.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   Speichern Sie den nicht geänderten Text in die <xref:System.Text.StringBuilder> -Objekt, rufen Sie die <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> -Methode zum Konvertieren der <xref:System.Text.StringBuilder> -Objekt an eine <xref:System.String> Objekt, und führen Sie die Änderungen auf die <xref:System.String> Objekt. Sie können diesen Ansatz verwenden, wenn Sie nur wenige Änderungen haben; Andernfalls kann die Kosten für das Arbeiten mit unveränderlichen Zeichenfolgen die Leistungsvorteile des Einsatzes von Negieren einer <xref:System.Text.StringBuilder> Objekt.  
  
     Im folgenden Beispiel wird dieselbe Funktion wie die beiden vorangehenden Beispielen jedoch unterschiedlich implementiert. Erstellt eine <xref:System.Text.StringBuilder> -Objekt, konvertiert sie in einem <xref:System.String> Objekt und klicken Sie dann alle verbleibenden Änderungen, die die Zeichenfolge ausführen mithilfe eines regulären Ausdrucks. Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Methode verwendet einen Lambda-Ausdruck für den Ersetzungsvorgang für jede Übereinstimmung.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Konvertieren der StringBuilder-Objekt in eine Zeichenfolge  
 Sie müssen das <xref:System.Text.StringBuilder>-Objekt in ein <xref:System.String>-Objekt konvertieren, bevor Sie die vom <xref:System.Text.StringBuilder>-Objekt dargestellte Zeichenfolge an eine Methode mit einem <xref:System.String>-Parameter übergeben können oder diese auf der Benutzeroberfläche anzeigen. Sie führen diese Konvertierung durch Aufrufen der <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> Methode. Veranschaulicht, finden Sie im vorherigen Beispiel, das Aufrufe der <xref:System.Text.StringBuilder.ToString%2A> -Methode zum Konvertieren einer <xref:System.Text.StringBuilder> Objekt in eine Zeichenfolge, sodass er an eine Methode für reguläre Ausdrücke übergeben werden kann.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie viele der definierten Methoden aufrufen, die <xref:System.Text.StringBuilder> Klasse.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
    </block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zeichenfolgenwert dieser Instanz wird festgelegt, um <xref:System.String.Empty?displayProperty=nameWithType>, und die Kapazität auf die implementierungsspezifische Standardkapazität festgelegt ist.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Aufrufen der <xref:System.Text.StringBuilder.%23ctor%2A> Konstruktor ohne Parameter.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">The suggested starting size of this instance.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class using the specified capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `capacity` Parameter definiert die maximale Anzahl von Zeichen, die im von der aktuellen Instanz reservierten Speicher gespeichert werden können. Der Wert zugewiesen ist die <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft. Dies überschreitet die Anzahl der Zeichen in der aktuellen Instanz zu speichernde `capacity` Wert, der <xref:System.Text.StringBuilder> Objekt weist den zusätzlichen Arbeitsspeicher, um sie zu speichern.  
  
 Der Zeichenfolgenwert dieser Instanz wird festgelegt, um <xref:System.String.Empty?displayProperty=nameWithType>. Wenn `capacity` NULL ist, wird die implementierungsspezifische Standardkapazität verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Aufrufen der <xref:System.Text.StringBuilder.%23ctor%2A> Konstruktor mit einer angegebenen Kapazität.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is less than zero.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string used to initialize the value of the instance. If <c>value</c> is <see langword="null" />, the new <see cref="T:System.Text.StringBuilder" /> will contain the empty string (that is, it contains <see cref="F:System.String.Empty" />).</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class using the specified string.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `value` `null` ist, enthält der neue <xref:System.Text.StringBuilder> die leere Zeichenfolge (d. h., er enthält <xref:System.String.Empty>).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Aufrufen der <xref:System.Text.StringBuilder.%23ctor%2A> Konstruktor mit der angegebenen Zeichenfolge.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">The suggested starting size of the <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">The maximum number of characters the current string can contain.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class that starts with a specified capacity and can grow to a specified maximum.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `capacity` Parameter definiert die maximale Anzahl von Zeichen, die im von der aktuellen Instanz reservierten Speicher gespeichert werden können. Der Wert zugewiesen ist die <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft. Dies überschreitet die Anzahl der Zeichen in der aktuellen Instanz zu speichernde `capacity` Wert, der <xref:System.Text.StringBuilder> Objekt weist den zusätzlichen Arbeitsspeicher, um sie zu speichern.  
  
 Wenn `capacity` NULL ist, wird die implementierungsspezifische Standardkapazität verwendet.  
  
 Die `maxCapacity` Eigenschaft definiert die maximale Anzahl von Zeichen, die die aktuelle Instanz enthalten kann. Der Wert zugewiesen ist die <xref:System.Text.StringBuilder.MaxCapacity%2A> Eigenschaft. Dies überschreitet die Anzahl der Zeichen in der aktuellen Instanz zu speichernde `maxCapacity` Wert, der <xref:System.Text.StringBuilder> Objekt zusätzlichen Arbeitsspeicher nicht die Zuordnung, sondern stattdessen löst eine Ausnahme aus.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Aufrufen der <xref:System.Text.StringBuilder.%23ctor%2A> Konstruktor mit einer angegebenen Kapazität und die maximale Kapazität.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxCapacity" /> is less than one, <paramref name="capacity" /> is less than zero, or <paramref name="capacity" /> is greater than <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The string used to initialize the value of the instance. If <c>value</c> is <see langword="null" />, the new <see cref="T:System.Text.StringBuilder" /> will contain the empty string (that is, it contains <see cref="F:System.String.Empty" />).</param>
        <param name="capacity">The suggested starting size of the <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class using the specified string and capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `capacity` Parameter definiert die maximale Anzahl von Zeichen, die im von der aktuellen Instanz reservierten Speicher gespeichert werden können. Der Wert zugewiesen ist die <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft. Dies überschreitet die Anzahl der Zeichen in der aktuellen Instanz zu speichernde `capacity` Wert, der <xref:System.Text.StringBuilder> Objekt weist den zusätzlichen Arbeitsspeicher, um sie zu speichern.  
  
 Wenn `capacity` NULL ist, wird die implementierungsspezifische Standardkapazität verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Aufrufen der <xref:System.Text.StringBuilder.%23ctor%2A> Konstruktor mit einer anfänglichen Zeichenfolge und einer angegebenen Kapazität.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is less than zero.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The string that contains the substring used to initialize the value of this instance. If <c>value</c> is <see langword="null" />, the new <see cref="T:System.Text.StringBuilder" /> will contain the empty string (that is, it contains <see cref="F:System.String.Empty" />).</param>
        <param name="startIndex">The position within <c>value</c> where the substring begins.</param>
        <param name="length">The number of characters in the substring.</param>
        <param name="capacity">The suggested starting size of the <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class from the specified substring and capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `capacity` Parameter definiert die maximale Anzahl von Zeichen, die im von der aktuellen Instanz reservierten Speicher gespeichert werden können. Der Wert zugewiesen ist die <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft. Dies überschreitet die Anzahl der Zeichen in der aktuellen Instanz zu speichernde `capacity` Wert, der <xref:System.Text.StringBuilder> Objekt weist den zusätzlichen Arbeitsspeicher, um sie zu speichern.  
  
 Wenn `capacity` NULL ist, wird die implementierungsspezifische Standardkapazität verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Aufrufen der <xref:System.Text.StringBuilder.%23ctor%2A> Konstruktor mit der angegebenen Zeichenfolge.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is less than zero.  -or-  <paramref name="startIndex" /> plus <paramref name="length" /> is not a position within <paramref name="value" />.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Appends the string representation of a specified object to this instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">The Boolean value to append.</param>
        <summary>Appends the string representation of a specified Boolean value to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Methodenaufrufe der <xref:System.Boolean.ToString?displayProperty=nameWithType> Methode zum Abrufen der Zeichenfolgendarstellung `value`. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 8-bit unsigned integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Byte%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Byte%29> Methodenaufrufe der <xref:System.Byte.ToString%28System.IFormatProvider%29> Methode zum Abrufen der Zeichenfolgendarstellung `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">The UTF-16-encoded code unit to append.</param>
        <summary>Appends the string representation of a specified <see cref="T:System.Char" /> object to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Char%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">The array of characters to append.</param>
        <summary>Appends the string representation of the Unicode characters in a specified array to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt alle Zeichen im angegebenen Array mit der aktuellen Instanz in der gleichen Reihenfolge wie im `value`. Wenn `value` ist `null`, werden keine Änderungen vorgenommen.  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified decimal number to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Methodenaufrufe der <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> Methode zum Abrufen der Zeichenfolgendarstellung `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified double-precision floating-point number to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Double%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Double%29> Methodenaufrufe der <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> Methode zum Abrufen der Zeichenfolgendarstellung `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 16-bit signed integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Int16%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Int16%29> Methodenaufrufe der <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> Methode zum Abrufen der Zeichenfolgendarstellung `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 32-bit signed integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Int32%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Int32%29> Methodenaufrufe der <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> Methode zum Abrufen der Zeichenfolgendarstellung `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 64-bit signed integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Int64%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Int64%29> Methodenaufrufe der <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> die Zeichenfolgendarstellung des abzurufenden `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object to append.</param>
        <summary>Appends the string representation of a specified object to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Object%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht. Definiert eine `Dog` Klasse, erstellt eine `Dog` Objekt und drei Aufrufe der <xref:System.Text.StringBuilder.Append%2A> Methode, um eine Zeichenfolge zu erstellen, die Namen und den optimalen des Hund enthält.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Object%29> Methodenaufrufe der <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode zum Abrufen der Zeichenfolgendarstellung `value`. Wenn `value` ist `null`, werden keine Änderungen vorgenommen, um die <xref:System.Text.StringBuilder> Objekt.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 8-bit signed integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.SByte%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.SByte%29> Methodenaufrufe der <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> Methode zum Abrufen der Zeichenfolgendarstellung `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified single-precision floating-point number to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Single%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Single%29> Methodenaufrufe der <xref:System.Single.ToString%2A?displayProperty=nameWithType> Methode zum Abrufen der Zeichenfolgendarstellung `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to append.</param>
        <summary>Appends a copy of the specified string to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.String%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Wenn `value` ist `null`, werden keine Änderungen vorgenommen.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 16-bit unsigned integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Methodenaufrufe der <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> Methode zum Abrufen der Zeichenfolgendarstellung `value`. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 32-bit unsigned integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Aufrufe der <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> Methode zum Abrufen der Zeichenfolgendarstellung `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 64-bit unsigned integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Methodenaufrufe der <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> Methode zum Abrufen der Zeichenfolgendarstellung `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The character to append.</param>
        <param name="repeatCount">The number of times to append <c>value</c>.</param>
        <summary>Appends a specified number of copies of the string representation of a Unicode character to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="repeatCount" /> is less than zero.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Out of memory.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A pointer to an array of characters.</param>
        <param name="valueCount">The number of characters in the array.</param>
        <summary>Appends an array of Unicode characters starting at a specified address to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt `valueCount` Zeichen beginnend am Adresse `value` mit der aktuellen Instanz.  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> Objekt.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="valueCount" /> is less than zero.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> is a null pointer.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A character array.</param>
        <param name="startIndex">The starting position in <c>value</c>.</param>
        <param name="charCount">The number of characters to append.</param>
        <summary>Appends the string representation of a specified subarray of Unicode characters to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt den angegebenen Bereich von Zeichen in `value` mit der aktuellen Instanz. Wenn `value` ist `null` und `startIndex` und `count` sind beide 0 (null), keine Änderungen vorgenommen werden.  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />, and <paramref name="startIndex" /> and <paramref name="charCount" /> are not zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> is less than zero.  -or-  <paramref name="startIndex" /> is less than zero.  -or-  <paramref name="startIndex" /> + <paramref name="charCount" /> is greater than the length of <paramref name="value" />.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The string that contains the substring to append.</param>
        <param name="startIndex">The starting position of the substring within <c>value</c>.</param>
        <param name="count">The number of characters in <c>value</c> to append.</param>
        <summary>Appends a copy of a specified substring to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt den angegebenen Bereich von Zeichen in `value` mit der aktuellen Instanz. Wenn `value` ist `null` und `startIndex` und `count` sind beide 0 (null), keine Änderungen vorgenommen werden.  
  
 Die <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> Methode ändert die vorhandene Instanz dieser Klasse ist eine neue Klasseninstanz wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft auf den vorhandenen Verweis aufrufen und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />, and <paramref name="startIndex" /> and <paramref name="count" /> are not zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> less than zero.  -or-  <paramref name="startIndex" /> less than zero.  -or-  <paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of <paramref name="value" />.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a corresponding object argument.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A composite format string.</param>
        <param name="arg0">An object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a single argument.</summary>
        <returns>A reference to this instance with <paramref name="format" /> appended. Each format item in <paramref name="format" /> is replaced by the string representation of <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework, um den Wert eines Objekts in die Textdarstellung umwandeln und Einbetten dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` Parameter besteht aus 0 (null) oder mehrere textausführungen mit NULL oder mehr indizierten Platzhaltern enthalten, so genannten Formatelementen zusammensetzt. Der Index, der die Formatelemente muss 0 sein, zur Anpassung an `arg0`, das einzelne Objekt in der Parameterliste dieser Methode. Der Formatierungsvorgang ersetzt jedes Formatelement durch die Zeichenfolgendarstellung von `arg0`.  
  
 Die Syntax eines Formatelements lautet wie folgt:  
  
 {*Index*[,*Länge*] [:*"FormatString"*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. Wenn es keinen Parameter in gibt der *Index* Position eine <xref:System.FormatException> ausgelöst wird.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Wenn positiv ist, ist der Parameter rechts ausgerichteten; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatierungszeichenfolge, die vom Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierten Formatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` Stellt das Objekt, das formatiert werden. Jedes Formatelement in `format` wird ersetzt durch die Zeichenfolgendarstellung des `arg0`. Wenn das Formatelement enthält `formatString` und `arg0` implementiert die <xref:System.IFormattable> -Schnittstelle ein, klicken Sie dann `arg0.ToString(formatString, null)` definiert die Formatierung. Andernfalls `arg0.ToString()` definiert die Formatierung.  
  
 Wenn die Zeichenfolge zugewiesen `format` ist "Danke für die Spende von {0: ###} lebensmitteldosen für wohltätige." und `arg0` ist eine ganze Zahl mit dem Wert 10 ist, wird der Rückgabewert "Danke für die Spende von 10 lebensmitteldosen für wohltätige."  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">A composite format string.</param>
        <param name="args">An array of objects to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a corresponding argument in a parameter array.</summary>
        <returns>A reference to this instance with <paramref name="format" /> appended. Each format item in <paramref name="format" /> is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework, um den Wert eines Objekts in die Textdarstellung umwandeln und Einbetten dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` -Parameter besteht aus 0 (null) oder mehreren Einheiten Text mit NULL oder mehr indizierten Platzhaltern enthalten, so genannten Formatelementen, die Objekten in der Parameterliste dieser Methode entsprechen. Der Formatierungsvorgang wird jedes Formatelement durch die Zeichenfolgendarstellung des entsprechenden Objekts ersetzt.  
  
 Die Syntax eines Formatelements lautet wie folgt:  
  
 {*Index*[,*Länge*] [:*"FormatString"*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. Wenn es keinen Parameter in gibt der *Index* Position eine <xref:System.FormatException> ausgelöst wird.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Wenn positiv ist, ist der Parameter rechts ausgerichteten; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatierungszeichenfolge, die vom Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierten Formatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `args` Stellt die Objekte, die formatiert werden. Jedes Formatelement in `format` wird ersetzt durch die Zeichenfolgendarstellung des entsprechenden Objekts in `args`. Wenn das Formatelement enthält `formatString` und des entsprechenden Objekts in `args` implementiert die <xref:System.IFormattable> -Schnittstelle ein, klicken Sie dann `args[index].ToString(formatString, provider)` definiert die Formatierung. Andernfalls `args[index].ToString()` definiert die Formatierung.  
  
 Wenn die Zeichenfolge zugewiesen `format` ist "Danke für die Spende von {0: ###} lebensmitteldosen für wohltätige." und `arg0` ist eine ganze Zahl mit dem Wert 10 ist, wird der Rückgabewert "Danke für die Spende von 10 lebensmitteldosen für wohltätige."  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to the length of the <paramref name="args" /> array.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <param name="format">A composite format string.</param>
        <param name="arg0">The object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a single argument using a specified format provider.</summary>
        <returns>A reference to this instance after the append operation has completed. After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> in which any format specification is replaced by the string representation of <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework konvertiert den Wert der `arg0` in die Textdarstellung und Einbetten dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` Parameter besteht aus 0 (null) oder mehrere textausführungen mit NULL oder mehr indizierten Platzhaltern enthalten, so genannten Formatelementen zusammensetzt. Der Index der jedes Formatelement muss 0 (null) sein, da diese Methode mit einem einzelnen Argument eine Argumentliste enthält. Der Formatierungsvorgang ersetzt jedes Formatelement durch die Zeichenfolgendarstellung von `arg0`.  
  
 Die Syntax eines Formatelements lautet wie folgt:  
  
 {*Index*[,*Länge*] [:*"FormatString"*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. In diesem Fall seit der <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> Methode verfügt über ein einzelnes Argument in der Argumentliste, den Wert der *Index* muss immer 0 sein. Wenn es nicht der Fall ist eine <xref:System.FormatException> ausgelöst wird.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Wenn positiv ist, ist der Parameter rechts ausgerichteten; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatierungszeichenfolge, die vom Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierten Formatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Die `provider` Parameter gibt ein <xref:System.IFormatProvider> Implementierung, die Formatierungsinformationen für die Objekte in bereitzustellen, kann `args`. `provider` kann eine der folgenden Formen haben:  
  
-   Ein <xref:System.Globalization.CultureInfo> Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für bereitstellt `arg0` , wenn es sich um einen numerischen Wert handelt.  
  
-   Ein <xref:System.Globalization.DateTimeFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für bereitstellt `arg0` , wenn es sich um einen Wert für Datum und Uhrzeit ist.  
  
-   Eine benutzerdefinierte <xref:System.IFormatProvider> Implementierung, die Formatierungsinformationen für `arg0`. In der Regel implementiert eine solche Implementierung auch die <xref:System.ICustomFormatter> Schnittstelle.  
  
 Wenn die `provider` Parameter ist `null`, Formatierung Informationen werden aus der aktuellen Kultur abgerufen.  
  
 `arg0` Stellt das Objekt, das formatiert werden. Jedes Formatelement in `format` wird ersetzt durch die Zeichenfolgendarstellung des `arg0`. Wenn das Formatelement enthält `formatString` und `arg0` implementiert die <xref:System.IFormattable> -Schnittstelle ein, klicken Sie dann `arg0.ToString(formatString, provider)` definiert die Formatierung. Andernfalls `arg0.ToString()` definiert die Formatierung.  
  
   
  
## Examples  
 Die Folgendes umfasst zwei Aufrufe an die <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> Methode. Beide verwenden die Formatierungskonventionen der Kultur Englisch-Großbritannien (En-GB). Die erste fügt die Zeichenfolgendarstellung einer <xref:System.Decimal> in eine Ergebniszeichenfolge Currency-Wert. Die zweite Fügt eine <xref:System.DateTime> Wert an zwei Stellen in einem Resultset "string", erste einschließlich nur das kurze Datum Zeichenfolge und das zweite, die kurze Uhrzeit-Zeichenfolge.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to one (1).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <param name="format">A composite format string.</param>
        <param name="args">An array of objects to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a corresponding argument in a parameter array using a specified format provider.</summary>
        <returns>A reference to this instance after the append operation has completed. After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> where any format specification is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework, um den Wert eines Objekts in die Textdarstellung umwandeln und Einbetten dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` -Parameter besteht aus 0 (null) oder mehreren Einheiten Text mit NULL oder mehr indizierten Platzhaltern enthalten, so genannten Formatelementen, die Objekten in der Parameterliste dieser Methode entsprechen. Der Formatierungsvorgang wird jedes Formatelement durch die Zeichenfolgendarstellung des entsprechenden Objekts ersetzt.  
  
 Die Syntax eines Formatelements lautet wie folgt:  
  
 {*Index*[,*Länge*] [:*"FormatString"*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. Wenn es keinen Parameter in gibt der *Index* Position eine <xref:System.FormatException> ausgelöst wird.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Wenn positiv ist, ist der Parameter rechts ausgerichteten; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatierungszeichenfolge, die vom Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierten Formatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Die `provider` Parameter gibt ein <xref:System.IFormatProvider> Implementierung, die Formatierungsinformationen für die Objekte in bereitzustellen, kann `args`. `provider` kann eine der folgenden Formen haben:  
  
-   Ein <xref:System.Globalization.CultureInfo> Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für numerische Werte in bietet `args`.  
  
-   Ein <xref:System.Globalization.DateTimeFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für Datums- und Uhrzeitwerte in bietet `args`.  
  
-   Eine benutzerdefinierte <xref:System.IFormatProvider> Implementierung, die Formatierungsinformationen für eine oder mehrere der Objekte in `args`. In der Regel implementiert eine solche Implementierung auch die <xref:System.ICustomFormatter> Schnittstelle. Das zweite Beispiel im nächsten Abschnitt veranschaulicht eine <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> Methodenaufruf mit einem benutzerdefinierten <xref:System.IFormatProvider> Implementierung.  
  
 Wenn die `provider` Parameter ist `null`, Formatanbieterinformationen aus der aktuellen Kultur abgerufen wird.  
  
 `args` Stellt die Objekte, die formatiert werden. Jedes Formatelement in `format` wird ersetzt durch die Zeichenfolgendarstellung des entsprechenden Objekts in `args`. Wenn das Formatelement enthält `formatString` und des entsprechenden Objekts in `args` implementiert die <xref:System.IFormattable> -Schnittstelle ein, klicken Sie dann `args[index].ToString(formatString, provider)` definiert die Formatierung. Andernfalls `args[index].ToString()` definiert die Formatierung.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 Das folgende Beispiel definiert ein benutzerdefiniertes <xref:System.IFormatProvider> -Implementierung mit dem Namen `CustomerFormatter` , die eine Zahl mit einem Bindestrich 10-stellige-Kunde nach der vierten und siebten Ziffer formatiert. Erfolgt eine Übergabe an die <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> Methode, um eine Zeichenfolge zu erstellen, die die formatierte Kundennummer und Customer Name enthält.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to the length of the <paramref name="args" /> array.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A composite format string.</param>
        <param name="arg0">The first object to format.</param>
        <param name="arg1">The second object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of either of two arguments.</summary>
        <returns>A reference to this instance with <paramref name="format" /> appended. Each format item in <paramref name="format" /> is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework, um den Wert eines Objekts in die Textdarstellung umwandeln und Einbetten dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` -Parameter besteht aus 0 (null) oder mehreren Einheiten Text mit NULL oder mehr indizierten Platzhaltern enthalten, so genannten Formatelementen, die entsprechen `arg0` und `arg1`, die zwei Objekte in der Parameterliste dieser Methode. Der Formatierungsvorgang wird jedes Formatelement durch die Zeichenfolgendarstellung des entsprechenden Objekts ersetzt.  
  
 Die Syntax eines Formatelements lautet wie folgt:  
  
 {*Index*[,*Länge*] [:*"FormatString"*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. Wenn es keinen Parameter in gibt der *Index* Position eine <xref:System.FormatException> ausgelöst wird.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Wenn positiv ist, ist der Parameter rechts ausgerichteten; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatierungszeichenfolge, die vom Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierten Formatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` und `arg1` darstellen der Objekte, die formatiert werden. Jedes Formatelement in `format` wird durch die Zeichenfolgendarstellung eines ersetzt `arg0` oder `arg1`. Wenn das Formatelement enthält `formatString` und das entsprechende Objekt implementiert die <xref:System.IFormattable> -Schnittstelle ein, klicken Sie dann `arg` *x* `.ToString(formatString, provider)` wird definiert, in dem die Formatierung aus *x* ist der Index des Arguments. Andernfalls `arg` *x* `.ToString()` definiert die Formatierung.  
  
 Wenn die Zeichenfolge zugewiesen `format` ist "Danke für die Spende von {0: ###} lebensmitteldosen für wohltätige." und `arg0` ist eine ganze Zahl mit dem Wert 10 ist, wird der Rückgabewert "Danke für die Spende von 10 lebensmitteldosen für wohltätige."  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to 2.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <param name="format">A composite format string.</param>
        <param name="arg0">The first object to format.</param>
        <param name="arg1">The second object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of either of two arguments using a specified format provider.</summary>
        <returns>A reference to this instance after the append operation has completed. After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> where any format specification is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework, um den Wert eines Objekts in die Textdarstellung umwandeln und Einbetten dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` -Parameter besteht aus 0 (null) oder mehreren Einheiten Text mit NULL oder mehr indizierten Platzhaltern enthalten, so genannten Formatelementen, die Objekten in der Parameterliste dieser Methode entsprechen. Der Formatierungsvorgang wird jedes Formatelement durch die Zeichenfolgendarstellung des entsprechenden Objekts ersetzt.  
  
 Die Syntax eines Formatelements lautet wie folgt:  
  
 {*Index*[,*Länge*] [:*"FormatString"*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. Wenn es keinen Parameter in gibt der *Index* Position eine <xref:System.FormatException> ausgelöst wird.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Wenn positiv ist, ist der Parameter rechts ausgerichteten; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatierungszeichenfolge, die vom Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierten Formatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Die `provider` Parameter gibt ein <xref:System.IFormatProvider> Implementierung, die Formatierungsinformationen für bereitzustellen, kann `arg0` und `arg1`. `provider` kann eine der folgenden Formen haben:  
  
-   Ein <xref:System.Globalization.CultureInfo> Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für bereitstellt `arg0` oder `arg1` werden numerische Werte.  
  
-   Ein <xref:System.Globalization.DateTimeFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für bereitstellt `arg0` oder `arg1` werden Datums-und Uhrzeitwerte.  
  
-   Eine benutzerdefinierte <xref:System.IFormatProvider> Implementierung, die Formatierungsinformationen für `arg0` und `arg1`. In der Regel implementiert eine solche Implementierung auch die <xref:System.ICustomFormatter> Schnittstelle.  
  
 Wenn die `provider` Parameter ist `null`, Formatanbieterinformationen aus der aktuellen Kultur abgerufen wird.  
  
 `arg0` und `arg1` darstellen der Objekte, die formatiert werden. Jedes Formatelement in `format` wird durch die Zeichenfolgendarstellung des Objekts mit dem entsprechenden Index ersetzt. Wenn das Formatelement enthält `formatString` und das entsprechende Argument implementiert die <xref:System.IFormattable> -Schnittstelle, und klicken Sie dann auf der Funktion des Arguments `ToString(formatString, provider)` Methode definiert, die Formatierung. Andernfalls der Funktion des Arguments `ToString()` Methode definiert, die Formatierung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> anzuzeigenden Zeit und die Temperatur Datenspeichern in eine generische Methode <xref:System.Collections.Generic.Dictionary%602> Objekt. Beachten Sie, dass die Formatzeichenfolge drei Formatelemente, allerdings nur für die stehen zu formatierenden Objekten. Ursache hierfür ist das erste Objekt in der Liste (ein Wert für Datum und Uhrzeit) durch zwei Formatelementen verwendet wird: das erste Format Element zeigt die Zeit, während die zweite zeigt das Datum an.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to 2 (two).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A composite format string.</param>
        <param name="arg0">The first object to format.</param>
        <param name="arg1">The second object to format.</param>
        <param name="arg2">The third object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of either of three arguments.</summary>
        <returns>A reference to this instance with <paramref name="format" /> appended. Each format item in <paramref name="format" /> is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework, um den Wert eines Objekts in die Textdarstellung umwandeln und Einbetten dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` -Parameter besteht aus 0 (null) oder mehreren Einheiten Text mit NULL oder mehr indizierten Platzhaltern enthalten, so genannten Formatelementen, die entsprechen `arg0` über `arg2`, die Objekte in der Parameterliste dieser Methode. Der Formatierungsvorgang wird jedes Formatelement durch die Zeichenfolgendarstellung des entsprechenden Objekts ersetzt.  
  
 Die Syntax eines Formatelements lautet wie folgt:  
  
 {*Index*[,*Länge*] [:*"FormatString"*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. Wenn es keinen Parameter in gibt der *Index* Position eine <xref:System.FormatException> ausgelöst wird.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Wenn positiv ist, ist der Parameter rechts ausgerichteten; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatierungszeichenfolge, die vom Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierten Formatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`, `arg1`, und `arg2` darstellen der Objekte, die formatiert werden. Jedes Formatelement in `format` wird durch die Zeichenfolgendarstellung eines ersetzt `arg0`, `arg1`, oder `arg2`, je nachdem, für den Index des Formatelements. Wenn das Formatelement enthält `formatString` und des entsprechenden Objekts in `args` implementiert die <xref:System.IFormattable> -Schnittstelle ein, klicken Sie dann `arg` *x* `.ToString(formatString, null)` wird definiert, in dem die Formatierung aus * X* ist der Index des Arguments. Andernfalls `arg` *x* `.ToString()` definiert die Formatierung.  
  
 Wenn die Zeichenfolge zugewiesen `format` ist "Danke für die Spende von {0: ###} lebensmitteldosen für wohltätige." und `arg0` ist eine ganze Zahl mit dem Wert 10 ist, wird der Rückgabewert "Danke für die Spende von 10 lebensmitteldosen für wohltätige."  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <param name="format">A composite format string.</param>
        <param name="arg0">The first object to format.</param>
        <param name="arg1">The second object to format.</param>
        <param name="arg2">The third object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of either of three arguments using a specified format provider.</summary>
        <returns>A reference to this instance after the append operation has completed. After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> where any format specification is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework, um den Wert eines Objekts in die Textdarstellung umwandeln und Einbetten dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` -Parameter besteht aus 0 (null) oder mehreren Einheiten Text mit NULL oder mehr indizierten Platzhaltern enthalten, so genannten Formatelementen, die Objekten in der Parameterliste dieser Methode entsprechen. Der Formatierungsvorgang wird jedes Formatelement durch die Zeichenfolgendarstellung des entsprechenden Objekts ersetzt.  
  
 Die Syntax eines Formatelements lautet wie folgt:  
  
 {*Index*[,*Länge*] [:*"FormatString"*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. Wenn es keinen Parameter in gibt der *Index* Position eine <xref:System.FormatException> ausgelöst wird.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Wenn positiv ist, ist der Parameter rechts ausgerichteten; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatierungszeichenfolge, die vom Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierten Formatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Die `provider` Parameter gibt ein <xref:System.IFormatProvider> Implementierung, die Formatierungsinformationen für bereitzustellen, kann `arg0` und `arg1`. `provider` kann eine der folgenden Formen haben:  
  
-   Ein <xref:System.Globalization.CultureInfo> Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für bereitstellt `arg0` oder `arg1` werden numerische Werte.  
  
-   Ein <xref:System.Globalization.DateTimeFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für bereitstellt `arg0`, `arg1`, oder `arg2` werden Datums-und Uhrzeitwerte.  
  
-   Eine benutzerdefinierte <xref:System.IFormatProvider> Implementierung, die Formatierungsinformationen für `arg0`, `arg1`, und `arg2`. In der Regel implementiert eine solche Implementierung auch die <xref:System.ICustomFormatter> Schnittstelle.  
  
 Wenn die `provider` Parameter ist `null`, Formatanbieterinformationen aus der aktuellen Kultur abgerufen wird.  
  
 `arg0`, `arg1`, und `arg2` darstellen der Objekte, die formatiert werden. Jedes Formatelement in `format` wird durch die Zeichenfolgendarstellung des Objekts mit dem entsprechenden Index ersetzt. Wenn das Formatelement enthält `formatString` und das entsprechende Argument implementiert die <xref:System.IFormattable> -Schnittstelle, und klicken Sie dann auf der Funktion des Arguments `ToString(formatString, provider)` Methode definiert, die Formatierung. Andernfalls der Funktion des Arguments `ToString()` Methode definiert, die Formatierung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> Methode, um das Ergebnis ein boolescher Wert veranschaulichen `And` Operation mit ganzzahligen Werten. Beachten Sie, dass die Formatzeichenfolge sechs Formatelemente enthält, aber die Methode verfügt über nur drei Elemente in der Argumentliste, da jedes Element auf zwei unterschiedliche Arten formatiert wird.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to 3 (three).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Appends the default line terminator, or a copy of a specified string and the default line terminator, to the end of this instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appends the default line terminator to the end of the current <see cref="T:System.Text.StringBuilder" /> object.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardzeilenabschlusszeichen ist der aktuelle Wert von der <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendLine%2A> Methode.  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to append.</param>
        <summary>Appends a copy of the specified string followed by the default line terminator to the end of the current <see cref="T:System.Text.StringBuilder" /> object.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardzeilenabschlusszeichen ist der aktuelle Wert von der <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] und [! Include[net_v45](~/Includes/NET-V45-MD.MD)], beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Konstruktor, der Länge und die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Eigenschaft . Dies kann auftreten, insbesondere beim Aufrufen der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, kleine Zeichenfolgen angefügt werden soll.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum number of characters that can be contained in the memory allocated by the current instance.</summary>
        <value>Die Höchstanzahl von Zeichen, die im durch die aktuelle Instanz reservierten Speicher enthalten sein können. Der Wert kann zwischen <see cref="P:System.Text.StringBuilder.Length" /> und <see cref="P:System.Text.StringBuilder.MaxCapacity" /> liegen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> wirkt sich den Zeichenfolgenwert der aktuellen Instanz nicht. <xref:System.Text.StringBuilder.Capacity%2A> kann verringert werden, solange er nicht ist kleiner als <xref:System.Text.StringBuilder.Length%2A>.  
  
 Die <xref:System.Text.StringBuilder> dynamisch belegt mehr Speicherplatz im Bedarfsfall, und erhöht die <xref:System.Text.StringBuilder.Capacity%2A> entsprechend. Aus Gründen der Leistung einer <xref:System.Text.StringBuilder> zuweisen mehr Speicher als erforderlich. Die Größe des Arbeitsspeichers ist implementierungsspezifisch.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than the current length of this instance.  -or-  The value specified for a set operation is greater than the maximum capacity.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The position of the character.</param>
        <summary>Gets or sets the character at the specified character position in this instance.</summary>
        <value>Das Unicode-Zeichen an der Position <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `index` Parameter ist die Position eines Zeichens in die <xref:System.Text.StringBuilder>. Das erste Zeichen in der Zeichenfolge ist bei Index 0. Die Länge einer Zeichenfolge ist die Anzahl der darin enthaltenen Zeichen. Das letzte zugänglich Zeichen von einer <xref:System.Text.StringBuilder> Instanz ist bei Index <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 <xref:System.Text.StringBuilder.Chars%2A> Die Standardeigenschaft eines ist die <xref:System.Text.StringBuilder> Klasse. In c# ist es einen Indexer. Dies bedeutet, dass einzelne Zeichen abgerufen werden können, aus der <xref:System.Text.StringBuilder.Chars%2A> Eigenschaft wie im folgenden Beispiel, das die Anzahl der alphabetischen zählt, Leerzeichen, gezeigt und Interpunktionszeichen in einer Zeichenfolge.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>Leistung und Indizierung zeichenbasierte

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is outside the bounds of this instance while setting a character.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> is outside the bounds of this instance while getting a character.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all characters from the current <see cref="T:System.Text.StringBuilder" /> instance.</summary>
        <returns>An object whose <see cref="P:System.Text.StringBuilder.Length" /> is 0 (zero).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Clear%2A> ist eine bequeme Methode, die Einstellung entspricht der <xref:System.Text.StringBuilder.Length%2A> Eigenschaft der aktuellen Instanz auf 0 (null).  
  
 Aufrufen der <xref:System.Text.StringBuilder.Clear%2A> Methode ändert nicht der aktuellen Instanz <xref:System.Text.StringBuilder.Capacity%2A> oder <xref:System.Text.StringBuilder.MaxCapacity%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert einen <xref:System.Text.StringBuilder> Objekt mit einer Zeichenfolge, die Aufrufe der <xref:System.Text.StringBuilder.Clear%2A> -Methode, und fügt dann eine neue Zeichenfolge an.  
  
 [!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">The starting position in this instance where characters will be copied from. The index is zero-based.</param>
        <param name="destination">The array where characters will be copied.</param>
        <param name="destinationIndex">The starting position in <c>destination</c> where characters will be copied. The index is zero-based.</param>
        <param name="count">The number of characters to be copied.</param>
        <summary>Copies the characters from a specified segment of this instance to a specified segment of a destination <see cref="T:System.Char" /> array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.CopyTo%2A> Methode soll in den seltenen Fällen verwendet werden, wenn Sie aufeinander folgende Abschnitte eines kopieren müssen eine <xref:System.Text.StringBuilder> -Objekts in ein Array. Das Array muss eine feste Größe, eingeteilt, wiederverwendbare und möglicherweise Global zugegriffen werden kann.  
  
 Beispielsweise die Anwendung füllt konnte eine <xref:System.Text.StringBuilder> Objekt, mit einer großen Anzahl von Zeichen der <xref:System.Text.StringBuilder.CopyTo%2A> Methode, um kleine, aufeinander folgende Angaben Kopieren der <xref:System.Text.StringBuilder> -Objekts in ein Array, in denen die einzelnen Teile verarbeitet werden. Wenn alle Daten in der <xref:System.Text.StringBuilder> Objekt wird verarbeitet, die Größe des der <xref:System.Text.StringBuilder> -Objekts auf 0 (null) festgelegt wird und der Zyklus wird wiederholt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.CopyTo%2A> Methode.  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" />, is less than zero.  -or-  <paramref name="sourceIndex" /> is greater than the length of this instance.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceIndex" /> + <paramref name="count" /> is greater than the length of this instance.  -or-  <paramref name="destinationIndex" /> + <paramref name="count" /> is greater than the length of <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">The minimum capacity to ensure.</param>
        <summary>Ensures that the capacity of this instance of <see cref="T:System.Text.StringBuilder" /> is at least the specified value.</summary>
        <returns>The new capacity of this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle Kapazität ist kleiner als das `capacity` Parameter, Speicher für diese Instanz wird neu zugewiesen zum Speichern von mindestens `capacity` -Zeichen; andernfalls wird keine "Erinnerung" geändert.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.EnsureCapacity%2A> Methode.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is less than zero.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">An object to compare with this instance, or <see langword="null" />.</param>
        <summary>Returns a value indicating whether this instance is equal to a specified object.</summary>
        <returns>
          <see langword="true" /> if this instance and <paramref name="sb" /> have equal string, <see cref="P:System.Text.StringBuilder.Capacity" />, and <see cref="P:System.Text.StringBuilder.MaxCapacity" /> values; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Der folgende code verwendet die <xref:System.Text.StringBuilder.Equals%2A> -Methode überprüft, ob zwei <xref:System.Text.StringBuilder> -Objekte gleich sind. Die Methode wird wiederholt aufgerufen, nachdem klein auf jedes Objekt Änderungen werden und die Ergebnisse werden in der Konsole angezeigt.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inserts the string representation of a specified object into this instance at a specified character position.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a Boolean value into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abgerufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v35SP1_long](~/Includes/NET-v35sp1-Long-MD.MD)] und früheren Versionen Aufrufe dieser Methode hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> würde dazu führen, dass das Objekt Gesamtlänge überschreitet <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit dem [! Include[net_v40_long](~/Includes/NET-V40-Long-MD.MD)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified 8-bit unsigned integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abgerufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v35SP1_long](~/Includes/NET-v35sp1-Long-MD.MD)] und früheren Versionen Aufrufe dieser Methode hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> würde dazu führen, dass das Objekt Gesamtlänge überschreitet <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit dem [! Include[net_v40_long](~/Includes/NET-V40-Long-MD.MD)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified Unicode character into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abgerufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The character array to insert.</param>
        <summary>Inserts the string representation of a specified array of Unicode characters into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 Wenn `value` ist `null`, die <xref:System.Text.StringBuilder> wird nicht geändert.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a decimal number into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abgerufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v35SP1_long](~/Includes/NET-v35sp1-Long-MD.MD)] und früheren Versionen Aufrufe dieser Methode hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> würde dazu führen, dass das Objekt Gesamtlänge überschreitet <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit dem [! Include[net_v40_long](~/Includes/NET-V40-Long-MD.MD)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a double-precision floating-point number into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abgerufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v35SP1_long](~/Includes/NET-v35sp1-Long-MD.MD)] und früheren Versionen Aufrufe dieser Methode hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> würde dazu führen, dass das Objekt Gesamtlänge überschreitet <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit dem [! Include[net_v40_long](~/Includes/NET-V40-Long-MD.MD)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified 16-bit signed integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abgerufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v35SP1_long](~/Includes/NET-v35sp1-Long-MD.MD)] und früheren Versionen Aufrufe dieser Methode hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> würde dazu führen, dass das Objekt Gesamtlänge überschreitet <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit dem [! Include[net_v40_long](~/Includes/NET-V40-Long-MD.MD)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified 32-bit signed integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abgerufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v35SP1_long](~/Includes/NET-v35sp1-Long-MD.MD)] und früheren Versionen Aufrufe dieser Methode hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> würde dazu führen, dass das Objekt Gesamtlänge überschreitet <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit dem [! Include[net_v40_long](~/Includes/NET-V40-Long-MD.MD)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a 64-bit signed integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abgerufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v35SP1_long](~/Includes/NET-v35sp1-Long-MD.MD)] und früheren Versionen Aufrufe dieser Methode hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> würde dazu führen, dass das Objekt Gesamtlänge überschreitet <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit dem [! Include[net_v40_long](~/Includes/NET-V40-Long-MD.MD)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The object to insert, or <see langword="null" />.</param>
        <summary>Inserts the string representation of an object into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abgerufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 Wenn `value` ist `null`, der Wert dieser Instanz ist unverändert.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v35SP1_long](~/Includes/NET-v35sp1-Long-MD.MD)] und früheren Versionen Aufrufe dieser Methode hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> würde dazu führen, dass das Objekt Gesamtlänge überschreitet <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit dem [! Include[net_v40_long](~/Includes/NET-V40-Long-MD.MD)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified 8-bit signed integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abgerufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v35SP1_long](~/Includes/NET-v35sp1-Long-MD.MD)] und früheren Versionen Aufrufe dieser Methode hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> würde dazu führen, dass das Objekt Gesamtlänge überschreitet <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit dem [! Include[net_v40_long](~/Includes/NET-V40-Long-MD.MD)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a single-precision floating point number into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abgerufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v35SP1_long](~/Includes/NET-v35sp1-Long-MD.MD)] und früheren Versionen Aufrufe dieser Methode hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> würde dazu führen, dass das Objekt Gesamtlänge überschreitet <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit dem [! Include[net_v40_long](~/Includes/NET-V40-Long-MD.MD)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The string to insert.</param>
        <summary>Inserts a string into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität wird angepasst, nach Bedarf.  
  
 Diese Instanz von <xref:System.Text.StringBuilder> wird nicht geändert werden, wenn `value` ist `null`, oder `value` nicht `null` aber die Länge 0 (null).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the current length of this instance.  -or-  The current length of this <see cref="T:System.Text.StringBuilder" /> object plus the length of <paramref name="value" /> exceeds <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a 16-bit unsigned integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abgerufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v35SP1_long](~/Includes/NET-v35sp1-Long-MD.MD)] und früheren Versionen Aufrufe dieser Methode hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> würde dazu führen, dass das Objekt Gesamtlänge überschreitet <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit dem [! Include[net_v40_long](~/Includes/NET-V40-Long-MD.MD)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a 32-bit unsigned integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abgerufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v35SP1_long](~/Includes/NET-v35sp1-Long-MD.MD)] und früheren Versionen Aufrufe dieser Methode hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> würde dazu führen, dass das Objekt Gesamtlänge überschreitet <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit dem [! Include[net_v40_long](~/Includes/NET-V40-Long-MD.MD)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a 64-bit unsigned integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abgerufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In der [! Include[net_v35SP1_long](~/Includes/NET-v35sp1-Long-MD.MD)] und früheren Versionen Aufrufe dieser Methode hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> würde dazu führen, dass das Objekt Gesamtlänge überschreitet <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit dem [! Include[net_v40_long](~/Includes/NET-V40-Long-MD.MD)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The string to insert.</param>
        <param name="count">The number of times to insert <c>value</c>.</param>
        <summary>Inserts one or more copies of a specified string into this instance at the specified character position.</summary>
        <returns>A reference to this instance after insertion has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
 Dies <xref:System.Text.StringBuilder> Objekt wird nicht geändert werden, wenn `value` ist `null`, `value` nicht `null` aber die Länge 0 (null), oder `count` 0 (null).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the current length of this instance.  -or-  <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.OutOfMemoryException">The current length of this <see cref="T:System.Text.StringBuilder" /> object plus the length of <paramref name="value" /> times <paramref name="count" /> exceeds <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">A character array.</param>
        <param name="startIndex">The starting index within <c>value</c>.</param>
        <param name="charCount">The number of characters to insert.</param>
        <summary>Inserts the string representation of a specified subarray of Unicode characters into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />, and <paramref name="startIndex" /> and <paramref name="charCount" /> are not zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />, <paramref name="startIndex" />, or <paramref name="charCount" /> is less than zero.  -or-  <paramref name="index" /> is greater than the length of this instance.  -or-  <paramref name="startIndex" /> plus <paramref name="charCount" /> is not a position within <paramref name="value" />.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the length of the current <see cref="T:System.Text.StringBuilder" /> object.</summary>
        <value>Die Länge dieser Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Länge einer <xref:System.Text.StringBuilder> Objekt definiert ist, von der Anzahl der <xref:System.Char> Objekte.  
  
 Wie die <xref:System.String.Length%2A?displayProperty=nameWithType> -Eigenschaft, die <xref:System.Text.StringBuilder.Length%2A> Eigenschaft gibt die Länge des aktuellen Zeichenfolgenobjekts an. Im Gegensatz zu den <xref:System.String.Length%2A?displayProperty=nameWithType> -Eigenschaft, die schreibgeschützt ist, die <xref:System.Text.StringBuilder.Length%2A> -Eigenschaft können Sie so ändern Sie die Länge der Zeichenfolge gespeichert, damit die <xref:System.Text.StringBuilder> Objekt.  
  
 Wenn die angegebene Länge kleiner als die aktuelle Länge der aktuellen ist <xref:System.Text.StringBuilder> Objekt wird an die angegebene Länge abgeschnitten. Wenn die angegebene Länge größer als die aktuelle Länge, die das Ende der Zeichenfolgenwert des aktuellen ist <xref:System.Text.StringBuilder> Objekt wird mit dem Unicode-NULL-Zeichen aufgefüllt (U + 0000).  
  
 Wenn die angegebene Länge größer als die aktuelle Kapazität ist <xref:System.Text.StringBuilder.Capacity%2A> erhöht, sodass er größer als oder gleich der angegebenen Länge ist.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Length%2A> Eigenschaft.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than zero or greater than <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum capacity of this instance.</summary>
        <value>Die Höchstanzahl von Zeichen, die diese Instanz enthalten kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die maximale Kapazität für diese Implementierung ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Allerdings wird dieser Wert ist implementierungsspezifisch und in anderen oder höher Implementierungen unterschiedlich sein. Sie können die maximale Kapazität des explizit festlegen einer <xref:System.Text.StringBuilder> Objekt durch Aufrufen der <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> Konstruktor.  
  
 In der[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] und die [!INCLUDE[net_v45](~/includes/net-v45-md.md)], beim Instanziieren der <xref:System.Text.StringBuilder> Objekt durch Aufrufen der <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> -Konstruktor, der Länge und die Kapazität des der <xref:System.Text.StringBuilder> Instanz über den Wert der anwachsen kann seine <xref:System.Text.StringBuilder.MaxCapacity%2A> Eigenschaft. Dies kann auftreten, insbesondere beim Aufrufen der <xref:System.Text.StringBuilder.Append%2A> und <xref:System.Text.StringBuilder.AppendFormat%2A> Methoden, kleine Zeichenfolgen angefügt werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <param name="length">The number of characters to remove.</param>
        <summary>Removes the specified range of characters from this instance.</summary>
        <returns>A reference to this instance after the excise operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle Methode entfernt den angegebenen Bereich von Zeichen aus der aktuellen Instanz. Die Zeichen an (`startIndex` + `length`) verschoben werden, um `startIndex`, und der Zeichenfolgenwert der aktuellen Instanz gekürzt, indem `length`. Die Kapazität der aktuellen Instanz ist nicht betroffen.  
  
> [!NOTE]
>  Die <xref:System.Text.StringBuilder.Remove%2A> Methode ändert den Wert des aktuellen <xref:System.Text.StringBuilder> -Instanz und gibt diese Instanz zurück. Sie erstellen und Zurückgeben einer neuen nicht <xref:System.Text.StringBuilder> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Remove%2A> Methode.  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="startIndex" /> or <paramref name="length" /> is less than zero, or <paramref name="startIndex" /> + <paramref name="length" /> is greater than the length of this instance.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Replaces all occurrences of a specified character or string in this instance with another specified character or string.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">The character to replace.</param>
        <param name="newChar">The character that replaces <c>oldChar</c>.</param>
        <summary>Replaces all occurrences of a specified character in this instance with another specified character.</summary>
        <returns>A reference to this instance with <paramref name="oldChar" /> replaced by <paramref name="newChar" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Vergleich ordinalen, Groß-/Kleinschreibung beachtet, zum Identifizieren der Vorkommen von `oldChar` in der aktuellen Instanz. Die Größe des aktuellen <xref:System.Text.StringBuilder> Instanz nach dem Austausch unverändert ist.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Replace%2A> Methode.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">The string to replace.</param>
        <param name="newValue">The string that replaces <c>oldValue</c>, or <see langword="null" />.</param>
        <summary>Replaces all occurrences of a specified string in this instance with another specified string.</summary>
        <returns>A reference to this instance with all instances of <paramref name="oldValue" /> replaced by <paramref name="newValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Vergleich ordinalen, Groß-/Kleinschreibung beachtet, zum Identifizieren der Vorkommen von `oldValue` in der aktuellen Instanz. Wenn `newValue` ist `null` oder <xref:System.String.Empty?displayProperty=nameWithType>, alle Vorkommen von `oldValue` werden entfernt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Replace%2A> Methode.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The length of <paramref name="oldValue" /> is zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">The character to replace.</param>
        <param name="newChar">The character that replaces <c>oldChar</c>.</param>
        <param name="startIndex">The position in this instance where the substring begins.</param>
        <param name="count">The length of the substring.</param>
        <summary>Replaces, within a substring of this instance, all occurrences of a specified character with another specified character.</summary>
        <returns>A reference to this instance with <paramref name="oldChar" /> replaced by <paramref name="newChar" /> in the range from <paramref name="startIndex" /> to <paramref name="startIndex" /> + <paramref name="count" /> -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Vergleich ordinalen, Groß-/Kleinschreibung beachtet, zum Identifizieren der Vorkommen von `oldChar` in der aktuellen Instanz. Die Größe des aktuellen <xref:System.Text.StringBuilder> Objekt nach dem Austausch unverändert ist.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Replace%2A> Methode.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of the value of this instance.  -or-  <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">The string to replace.</param>
        <param name="newValue">The string that replaces <c>oldValue</c>, or <see langword="null" />.</param>
        <param name="startIndex">The position in this instance where the substring begins.</param>
        <param name="count">The length of the substring.</param>
        <summary>Replaces, within a substring of this instance, all occurrences of a specified string with another specified string.</summary>
        <returns>A reference to this instance with all instances of <paramref name="oldValue" /> replaced by <paramref name="newValue" /> in the range from <paramref name="startIndex" /> to <paramref name="startIndex" /> + <paramref name="count" /> - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Vergleich ordinalen, Groß-/Kleinschreibung beachtet, zum Identifizieren der Vorkommen von `oldValue` in der angegebenen Teilzeichenfolge. Wenn `newValue` ist `null` oder <xref:System.String.Empty?displayProperty=nameWithType>, alle Vorkommen von `oldValue` werden entfernt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Replace%2A> Methode.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The length of <paramref name="oldValue" /> is zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="startIndex" /> plus <paramref name="count" /> indicates a character position not within this instance.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">The object to populate with serialization information.</param>
        <param name="context">The place to store and retrieve serialized data. Reserved for future use.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data necessary to deserialize the current <see cref="T:System.Text.StringBuilder" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `context` Parameter ist für die zukünftige Verwendung reserviert und nicht an diesen Vorgang beteiligt.  
  
 Weitere Informationen finden Sie unter der Methode <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts the value of a <see cref="T:System.Text.StringBuilder" /> to a <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts the value of this instance to a <see cref="T:System.String" />.</summary>
        <returns>A string whose value is the same as this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Text.StringBuilder.ToString%2A> -Methode zum Konvertieren der <xref:System.Text.StringBuilder> -Objekt an eine <xref:System.String> -Objekt, bevor Sie die Zeichenfolge dargestellte übergeben können die <xref:System.Text.StringBuilder> Objekt, das eine Methode mit einer <xref:System.String> Parameter oder in der Benutzeroberfläche anzeigen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Aufrufen der <xref:System.Text.StringBuilder.ToString%2A>-Methode veranschaulicht. In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Text.StringBuilder> Klasse.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">The starting position of the substring in this instance.</param>
        <param name="length">The length of the substring.</param>
        <summary>Converts the value of a substring of this instance to a <see cref="T:System.String" />.</summary>
        <returns>A string whose value is the same as the specified substring of this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Text.StringBuilder.ToString%2A> -Methode zum Konvertieren der <xref:System.Text.StringBuilder> -Objekt an eine <xref:System.String> -Objekt, bevor Sie die Zeichenfolge dargestellte übergeben können die <xref:System.Text.StringBuilder> Objekt, das eine Methode mit einer <xref:System.String> Parameter oder in der Benutzeroberfläche anzeigen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.  -or-  The sum of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the length of the current instance.</exception>
      </Docs>
    </Member>
  </Members>
</Type>