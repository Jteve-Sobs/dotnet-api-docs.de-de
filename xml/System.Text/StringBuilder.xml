<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="05ca9b46e69defdd7a976ba88b93ec0e56f98b14" /><Meta Name="ms.sourcegitcommit" Value="a8ff98b48bda124cfcb2605f5da9b21bc6dcd791" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/14/2020" /><Meta Name="ms.locfileid" Value="77220925" /></Metadata><TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine veränderbare Zeichenfolge dar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 Diese Klasse stellt ein Zeichen folgen ähnliches Objekt dar, dessen Wert eine änderbare Zeichenfolge ist.

 Inhalt dieses Abschnitts:

-   [Die Zeichen folgen-und StringBuilder-Typen](#StringAndSB)

-   [Funktionsweise von StringBuilder](#HowWorks)

-   [Speicher Belegung](#Memory)

-   [Instanziieren eines StringBuilder-Objekts](#Instantiating)

-   [Aufrufen von StringBuilder-Methoden](#Calling)

-   [Ausführen von StringBuilder-Vorgängen](#Operations)

    -   [Iterieren von StringBuilder-Zeichen](#Iterating)

    -   [Hinzufügen von Text zu einem StringBuilder-Objekt](#Adding)

    -   [Löschen von Text aus einem StringBuilder-Objekt](#Deleting)

    -   [Ändern des Texts in einem StringBuilder-Objekt](#Modifying)

-   [Durchsuchen des Texts in einem StringBuilder-Objekt](#Searching)

-   [Umstellen des StringBuilder-Objekts in eine Zeichenfolge](#Converting)

<a name="StringAndSB"></a>
## <a name="the-string-and-stringbuilder-types"></a>Die Zeichen folgen-und StringBuilder-Typen
 Obwohl <xref:System.Text.StringBuilder> und <xref:System.String> beide Zeichen folgen darstellen, werden Sie anders implementiert. <xref:System.String> ist ein unveränderlicher Typ. Das heißt, dass jeder Vorgang, der zum Ändern eines <xref:System.String> Objekts erscheint, tatsächlich eine neue Zeichenfolge erstellt.

 Beispielsweise wird der <xref:System.String.Concat%2A?displayProperty=nameWithType>-Methode im folgenden C# Beispiel aufgerufen, um den Wert einer Zeichen folgen Variablen mit dem Namen `value`zu ändern. Tatsächlich gibt die <xref:System.String.Concat%2A>-Methode ein `value` Objekt zurück, das über einen anderen Wert und eine andere Adresse als das `value`-Objekt verfügt, das an die-Methode übermittelt wurde. Beachten Sie, dass das Beispiel mit der `/unsafe`-Compileroption kompiliert werden muss.

 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]

 Bei Routinen, die eine umfangreiche Zeichen folgen Bearbeitung ausführen (z. b. apps, die eine Zeichenfolge mehrmals in einer Schleife ändern), kann das Ändern einer Zeichenfolge zu einer erheblichen Leistungs Einbuße führen. Die Alternative besteht darin, <xref:System.Text.StringBuilder>zu verwenden, bei dem es sich um eine änderbare Zeichen folgen Klasse handelt. Muability bedeutet, dass nach dem Erstellen einer Instanz der Klasse diese geändert werden kann, indem Zeichen angehängt, entfernt, ersetzt oder eingefügt werden. Ein <xref:System.Text.StringBuilder>-Objekt verwaltet einen Puffer, um Erweiterungen für die Zeichenfolge zu ermöglichen. Neue Daten werden an den Puffer angehängt, wenn Platz verfügbar ist. Andernfalls wird ein neuer, größerer Puffer zugewiesen, Daten aus dem ursprünglichen Puffer werden in den neuen Puffer kopiert, und die neuen Daten werden dann an den neuen Puffer angehängt.

> [!IMPORTANT]
>  Obwohl die <xref:System.Text.StringBuilder>-Klasse im Allgemeinen eine bessere Leistung als die <xref:System.String>-Klasse bietet, sollten Sie <xref:System.String> nicht automatisch durch <xref:System.Text.StringBuilder> ersetzen, wenn Sie Zeichen folgen bearbeiten möchten. Die Leistung hängt von der Größe der Zeichenfolge, der Menge an Arbeitsspeicher, die für die neue Zeichenfolge zugewiesen werden soll, dem System, in dem Ihre APP ausgeführt wird, und dem Typ des Vorgangs ab. Sie sollten darauf vorbereitet sein, Ihre APP zu testen, um zu ermitteln, ob <xref:System.Text.StringBuilder> tatsächlich eine beträchtliche Leistungsverbesserung bietet.

 Verwenden Sie die <xref:System.String>-Klasse unter folgenden Bedingungen:

-   Wenn die Anzahl der Änderungen, die Ihre APP an einer Zeichenfolge vornehmen wird, gering ist. In diesen Fällen bietet <xref:System.Text.StringBuilder> möglicherweise eine vernachlässigende oder keine Leistungsverbesserung gegenüber <xref:System.String>.

-   Bei der Durchführung einer bestimmten Anzahl von Verkettungs Vorgängen, insbesondere bei Zeichenfolgenliteralen. In diesem Fall kann der Compiler die Verkettungs Vorgänge in einem einzelnen Vorgang kombinieren.

-   Wenn Sie umfangreiche Suchvorgänge ausführen müssen, während Sie die Zeichenfolge aufbauen. Die <xref:System.Text.StringBuilder>-Klasse hat keine Suchmethoden wie `IndexOf` oder `StartsWith`. Sie müssen das <xref:System.Text.StringBuilder>-Objekt für diese Vorgänge in eine <xref:System.String> konvertieren, sodass der Leistungsvorteil von der Verwendung von <xref:System.Text.StringBuilder>beeinträchtigt werden kann. Weitere Informationen finden Sie im Abschnitt [Suchen des Texts in einem StringBuilder-Objekt](#Searching) .

 Verwenden Sie die <xref:System.Text.StringBuilder>-Klasse unter folgenden Bedingungen:

-   Wenn Sie davon ausgehen, dass Ihre APP zur Entwurfszeit eine unbekannte Anzahl von Änderungen an einer Zeichenfolge vornimmt (z. b. Wenn Sie eine Schleife verwenden, um eine zufällige Anzahl von Zeichen folgen zu verketten, die Benutzereingaben enthalten).

-   Wenn Sie davon ausgehen, dass Ihre APP eine beträchtliche Anzahl von Änderungen an einer Zeichenfolge vornehmen soll.

<a name="HowWorks"></a>
## <a name="how-stringbuilder-works"></a>Funktionsweise von StringBuilder
 Die <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType>-Eigenschaft gibt die Anzahl der Zeichen an, die das <xref:System.Text.StringBuilder>-Objekt zurzeit enthält. Wenn Sie dem <xref:System.Text.StringBuilder> Objekt Zeichen hinzufügen, vergrößert sich seine Länge, bis es der Größe der <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType>-Eigenschaft entspricht, die die Anzahl der Zeichen definiert, die das Objekt enthalten kann. Wenn die Anzahl der hinzugefügten Zeichen bewirkt, dass die Länge des <xref:System.Text.StringBuilder> Objekts die aktuelle Kapazität überschreitet, wird neuer Speicher zugeordnet, der Wert der <xref:System.Text.StringBuilder.Capacity%2A>-Eigenschaft wird verdoppelt, neue Zeichen werden dem <xref:System.Text.StringBuilder>-Objekt hinzugefügt, und die <xref:System.Text.StringBuilder.Length%2A> Eigenschaft wird angepasst. Zusätzlicher Arbeitsspeicher für das <xref:System.Text.StringBuilder> Objekt wird dynamisch zugewiesen, bis der Wert erreicht wird, der durch die <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType>-Eigenschaft definiert wird. Wenn die maximale Kapazität erreicht ist, kann kein weiterer Arbeitsspeicher für das <xref:System.Text.StringBuilder> Objekt zugeordnet werden. Wenn Sie versuchen, Zeichen hinzuzufügen oder Sie außerhalb der maximalen Kapazität zu erweitern, wird entweder eine <xref:System.ArgumentOutOfRangeException> oder eine <xref:System.OutOfMemoryException> Ausnahme ausgelöst.

 Im folgenden Beispiel wird veranschaulicht, wie ein <xref:System.Text.StringBuilder>-Objekt neuen Arbeitsspeicher zuordnet und seine Kapazität dynamisch vergrößert, wenn die dem-Objekt zugewiesene Zeichenfolge erweitert wird. Der Code erstellt ein <xref:System.Text.StringBuilder> Objekt durch Aufrufen seines Standard Konstruktors (parameterlos). Die Standardkapazität dieses Objekts beträgt 16 Zeichen, und die maximale Kapazität beträgt mehr als 2 Milliarden Zeichen. Die Zeichenfolge "This is a Satz" wird angehängt. führt zu einer neuen Speicher Belegung, da die Zeichen folgen Länge (19 Zeichen) die Standardkapazität des <xref:System.Text.StringBuilder> Objekts überschreitet. Die Kapazität des-Objekts wird auf 32 Zeichen verdoppelt, die neue Zeichenfolge wird hinzugefügt, und die Länge des-Objekts entspricht nun 19 Zeichen. Der Code fügt dann die Zeichenfolge "This is a additional Satz" an. auf den Wert des <xref:System.Text.StringBuilder> Objekts 11 Mal. Wenn der Anfüge Vorgang bewirkt, dass die Länge des <xref:System.Text.StringBuilder> Objekts seine Kapazität überschreitet, wird die vorhandene Kapazität verdoppelt, und der <xref:System.Text.StringBuilder.Append%2A> Vorgang ist erfolgreich.

 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]

<a name="Memory"></a>
## <a name="memory-allocation"></a>Speicherzuweisung
 Die Standardkapazität eines <xref:System.Text.StringBuilder> Objekts beträgt 16 Zeichen, und die maximale Standardkapazität ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Diese Standardwerte werden verwendet, wenn Sie die <xref:System.Text.StringBuilder.%23ctor>-und <xref:System.Text.StringBuilder.%23ctor%28System.String%29>-Konstruktoren aufzurufen.

 Es gibt folgende Möglichkeiten, um die anfängliche Kapazität eines <xref:System.Text.StringBuilder> Objekts explizit zu definieren:

-   Durch Aufrufen eines <xref:System.Text.StringBuilder> Konstruktors, der einen `capacity`-Parameter enthält, wenn Sie das-Objekt erstellen.

-   Durch explizites Zuweisen eines neuen Werts zur <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType>-Eigenschaft, um ein vorhandenes <xref:System.Text.StringBuilder> Objekt zu erweitern. Beachten Sie, dass die-Eigenschaft eine Ausnahme auslöst, wenn die neue Kapazität kleiner ist als die vorhandene Kapazität oder größer als die maximale Kapazität des <xref:System.Text.StringBuilder> Objekts.

-   Durch Aufrufen der <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType>-Methode mit der neuen Kapazität. Die neue Kapazität darf nicht größer sein als die maximale Kapazität des <xref:System.Text.StringBuilder> Objekts. Anders als bei einer Zuweisung zur <xref:System.Text.StringBuilder.Capacity%2A>-Eigenschaft löst <xref:System.Text.StringBuilder.EnsureCapacity%2A> jedoch keine Ausnahme aus, wenn die gewünschte neue Kapazität kleiner ist als die vorhandene Kapazität. in diesem Fall hat der Methodenaufrufe keine Auswirkung.

 Wenn die Länge der Zeichenfolge, die dem <xref:System.Text.StringBuilder> Objekt im konstruktorbefehl zugewiesen ist, entweder die Standardkapazität oder die angegebene Kapazität überschreitet, wird die Eigenschaft <xref:System.Text.StringBuilder.Capacity%2A> auf die Länge der Zeichenfolge festgelegt, die mit dem `value`-Parameter angegeben wird.

 Sie können die maximale Kapazität eines <xref:System.Text.StringBuilder> Objekts explizit definieren, indem Sie den <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>-Konstruktor aufrufen. Sie können die maximale Kapazität nicht ändern, indem Sie der <xref:System.Text.StringBuilder.MaxCapacity%2A>-Eigenschaft einen neuen Wert zuweisen, da sie schreibgeschützt ist.

 Wie im vorherigen Abschnitt gezeigt, wird, wenn die vorhandene Kapazität unzureichend ist, zusätzlicher Arbeitsspeicher zugewiesen, und die Kapazität eines <xref:System.Text.StringBuilder> Objekts verdoppelt sich auf den Wert, der durch die <xref:System.Text.StringBuilder.MaxCapacity%2A>-Eigenschaft definiert wird.

 Im Allgemeinen sind die Standardkapazität und die maximale Kapazität für die meisten apps ausreichend. Sie sollten diese Werte unter folgenden Bedingungen festlegen:

-   , Wenn die endgültige Größe des <xref:System.Text.StringBuilder> Objekts wahrscheinlich übermäßig groß wird, in der Regel über mehrere Megabyte hinaus. In diesem Fall kann es zu Leistungsvorteilen kommen, wenn die anfängliche <xref:System.Text.StringBuilder.Capacity%2A>-Eigenschaft auf einen erheblich hohen Wert festgelegt wird, um zu viele Speicher Belegungen zu vermeiden.

-   Wenn Ihre APP auf einem System mit eingeschränktem Arbeitsspeicher ausgeführt wird. In diesem Fall sollten Sie in Erwägung ziehen, die <xref:System.Text.StringBuilder.MaxCapacity%2A>-Eigenschaft auf weniger als <xref:System.Int32.MaxValue?displayProperty=nameWithType> festzulegen, wenn Ihre APP große Zeichen folgen verarbeitet, die die Ausführung in einer Speicher eingeschränkten Umgebung verursachen können.

<a name="Instantiating"></a>
## <a name="instantiating-a-stringbuilder-object"></a>Instanziieren eines StringBuilder-Objekts
 Instanziieren Sie ein <xref:System.Text.StringBuilder> Objekt, indem Sie einen der sechs überladenen Klassenkonstruktoren aufrufen, die in der folgenden Tabelle aufgeführt sind. Drei der Konstruktoren instanziieren ein <xref:System.Text.StringBuilder> Objekt, dessen Wert eine leere Zeichenfolge ist, aber seine <xref:System.Text.StringBuilder.Capacity%2A>-und <xref:System.Text.StringBuilder.MaxCapacity%2A> Werte unterschiedlich festgelegt sind. Die übrigen drei Konstruktoren definieren ein <xref:System.Text.StringBuilder> Objekt, das über einen bestimmten Zeichen folgen Wert und eine bestimmte Kapazität verfügt. Zwei der drei Konstruktoren verwenden die maximale Standardkapazität von <xref:System.Int32.MaxValue?displayProperty=nameWithType>, während das dritte die maximale Kapazität festlegen kann.

|Konstruktor|Zeichen folgen Wert|Capacity|Maximale Kapazität|
|-----------------|------------------|--------------|----------------------|
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Definiert durch den `capacity`-Parameter|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Definiert durch den `capacity`-Parameter|Definiert durch den `maxCapacity`-Parameter|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Definiert durch den `value`-Parameter|16 oder `value`. <xref:System.String.Length%2A>, je nachdem, welche größer ist|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Definiert durch den `value`-Parameter|Definiert durch den `capacity`-Parameter oder `value`. <xref:System.String.Length%2A>, je nachdem, welcher Wert größer ist.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|wird von `value` definiert <xref:System.String.Substring%2A>(`startIndex`, `length`)|Definiert durch den `capacity`-Parameter oder `value`. <xref:System.String.Length%2A>, je nachdem, welcher Wert größer ist.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|

 Im folgenden Beispiel werden drei dieser Konstruktorüberladungen verwendet, um <xref:System.Text.StringBuilder>-Objekte zu instanziieren.

 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]

<a name="Calling"></a>
## <a name="calling-stringbuilder-methods"></a>Aufrufen von StringBuilder-Methoden
 Die meisten Methoden, die die Zeichenfolge in einer <xref:System.Text.StringBuilder> Instanz ändern, geben einen Verweis auf dieselbe Instanz zurück. Dies ermöglicht es Ihnen, <xref:System.Text.StringBuilder> Methoden auf zwei Arten aufzurufen:

-   Sie können einzelne Methodenaufrufe durchführen und den Rückgabewert ignorieren, wie im folgenden Beispiel gezeigt.

     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]

-   Sie können eine Reihe von Methoden aufrufen in einer einzelnen Anweisung ausführen. Dies kann praktisch sein, wenn Sie eine einzelne Anweisung schreiben möchten, die aufeinander folgende Vorgänge verkettet. Im folgenden Beispiel werden drei Methodenaufrufe aus dem vorherigen Beispiel in eine einzelne Codezeile konsolidiert.

     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]

<a name="Operations"></a>
## <a name="performing-stringbuilder-operations"></a>Ausführen von StringBuilder-Vorgängen
 Sie können die Methoden der <xref:System.Text.StringBuilder>-Klasse verwenden, um Zeichen in einem <xref:System.Text.StringBuilder> Objekt zu durchlaufen, hinzuzufügen, zu löschen oder zu ändern.

<a name="Iterating"></a>
### <a name="iterating-stringbuilder-characters"></a>Iterieren von StringBuilder-Zeichen
 Sie können auf die Zeichen in einem <xref:System.Text.StringBuilder> Objekt zugreifen, indem Sie die <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>-Eigenschaft verwenden. In C#handelt es sich bei <xref:System.Text.StringBuilder.Chars%2A> um einen Indexer. in Visual Basic ist dies die Standard Eigenschaft der <xref:System.Text.StringBuilder>-Klasse. Dies ermöglicht es Ihnen, einzelne Zeichen nur mit Ihrem Index festzulegen oder abzurufen, ohne explizit auf die <xref:System.Text.StringBuilder.Chars%2A> Eigenschaft zu verweisen. Zeichen in einem <xref:System.Text.StringBuilder> Objekt beginnen am Index 0 (null) und werden weiterhin <xref:System.Text.StringBuilder.Length%2A>-1 indiziert.

 Im folgenden Beispiel wird die <xref:System.Text.StringBuilder.Chars%2A>-Eigenschaft veranschaulicht. Er fügt zehn Zufallszahlen an ein <xref:System.Text.StringBuilder> Objekt an und iteriert dann jedes Zeichen. Wenn die Unicode-Kategorie des Zeichens <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>ist, wird die Zahl um 1 verringert (oder die Zahl wird auf 9 geändert, wenn der Wert 0 (null) ist). Im Beispiel wird der Inhalt des <xref:System.Text.StringBuilder> Objekts sowohl vor als auch nach dem Ändern der Werte einzelner Zeichen angezeigt.

 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

<a name="Adding"></a>
### <a name="adding-text-to-a-stringbuilder-object"></a>Hinzufügen von Text zu einem StringBuilder-Objekt
 Die <xref:System.Text.StringBuilder>-Klasse enthält die folgenden Methoden zum Erweitern des Inhalts eines <xref:System.Text.StringBuilder> Objekts:

-   Die <xref:System.Text.StringBuilder.Append%2A>-Methode fügt eine Zeichenfolge, eine Teil Zeichenfolge, ein Zeichen Array, einen Teil eines Zeichen Arrays, ein einzelnes Zeichen, das mehrmals wiederholt wird, oder die Zeichen folgen Darstellung eines primitiven Datentyps an ein <xref:System.Text.StringBuilder> Objekt an.

-   Die <xref:System.Text.StringBuilder.AppendLine%2A>-Methode fügt ein Zeichen für den Zeilen Abschluss oder eine Zeichenfolge zusammen mit einem Zeichen für den Zeilen Abschluss an ein <xref:System.Text.StringBuilder> Objekt an.

-   Die <xref:System.Text.StringBuilder.AppendFormat%2A>-Methode fügt eine [kombinierte Format Zeichenfolge](~/docs/standard/base-types/composite-formatting.md) an ein <xref:System.Text.StringBuilder> Objekt an. Die Zeichen folgen Darstellungen von Objekten, die in der Ergebnis Zeichenfolge enthalten sind, können die Formatierungs Konventionen der aktuellen System Kultur oder der angegebenen Kultur widerspiegeln.

-   Die <xref:System.Text.StringBuilder.Insert%2A>-Methode fügt eine Zeichenfolge, eine Teil Zeichenfolge, mehrere Wiederholungen einer Zeichenfolge, ein Zeichen Array, einen Teil eines Zeichen Arrays oder die Zeichen folgen Darstellung eines primitiven Datentyps an einer angegebenen Position im <xref:System.Text.StringBuilder>-Objekt ein. Die Position wird durch einen NULL basierten Index definiert.

 Im folgenden Beispiel werden die Methoden <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>und <xref:System.Text.StringBuilder.Insert%2A> verwendet, um den Text eines <xref:System.Text.StringBuilder> Objekts zu erweitern.

 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]

<a name="Deleting"></a>
### <a name="deleting-text-from-a-stringbuilder-object"></a>Löschen von Text aus einem StringBuilder-Objekt
 Die <xref:System.Text.StringBuilder>-Klasse enthält Methoden, mit denen die Größe der aktuellen <xref:System.Text.StringBuilder> Instanz reduziert werden kann. Die <xref:System.Text.StringBuilder.Clear%2A>-Methode entfernt alle Zeichen und legt die <xref:System.Text.StringBuilder.Length%2A>-Eigenschaft auf 0 (null) fest. Die <xref:System.Text.StringBuilder.Remove%2A>-Methode löscht eine angegebene Anzahl von Zeichen ab einer bestimmten Indexposition. Außerdem können Sie Zeichen vom Ende eines <xref:System.Text.StringBuilder> Objekts entfernen, indem Sie die <xref:System.Text.StringBuilder.Length%2A>-Eigenschaft auf einen Wert festlegen, der kleiner als die Länge der aktuellen Instanz ist.

 Im folgenden Beispiel wird ein Teil des Texts aus einem <xref:System.Text.StringBuilder>-Objekt entfernt, dessen resultierende Kapazitäts-, maximale Kapazitäts-und Längen Eigenschaftswerte angezeigt, und anschließend wird die <xref:System.Text.StringBuilder.Clear%2A>-Methode aufgerufen, um alle Zeichen aus dem <xref:System.Text.StringBuilder>-Objekt zu entfernen.

 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]

<a name="Modifying"></a>
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Ändern des Texts in einem StringBuilder-Objekt
 Die <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType>-Methode ersetzt alle Vorkommen eines Zeichens oder einer Zeichenfolge im gesamten <xref:System.Text.StringBuilder> Objekt oder in einem bestimmten Zeichenbereich. Im folgenden Beispiel wird die <xref:System.Text.StringBuilder.Replace%2A>-Methode verwendet, um alle Ausrufezeichen (!) durch Fragezeichen (?) im <xref:System.Text.StringBuilder>-Objekt zu ersetzen.

 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]

<a name="Searching"></a>
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Durchsuchen des Texts in einem StringBuilder-Objekt
 Die <xref:System.Text.StringBuilder>-Klasse enthält keine ähnlichen Methoden wie die Methoden <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>und <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, die von der <xref:System.String>-Klasse bereitgestellt werden, sodass Sie das-Objekt nach einem bestimmten Zeichen oder einer Teil Zeichenfolge durchsuchen können. Wenn Sie die Anwesenheits Position oder die Anfangs Zeichenposition einer Teil Zeichenfolge ermitteln, müssen Sie einen <xref:System.String> Wert entweder mithilfe einer Zeichen folgen Suchmethode oder einer Methode für reguläre Ausdrücke durchsuchen. Es gibt vier Möglichkeiten, solche Suchvorgänge zu implementieren, wie in der folgenden Tabelle gezeigt.

|Verfahren|Vorteile|Nachteile|
|---------------|----------|----------|
|Durchsuchen von Zeichen folgen Werten, bevor Sie dem <xref:System.Text.StringBuilder> Objekt hinzugefügt werden.|Nützlich für die Bestimmung, ob eine Teil Zeichenfolge vorhanden ist.|Kann nicht verwendet werden, wenn die Indexposition einer Teil Zeichenfolge wichtig ist.|
|Ruft <xref:System.Text.StringBuilder.ToString%2A> auf und durchsucht das zurückgegebene <xref:System.String> Objekt.|Einfach zu verwenden, wenn Sie den gesamten Text einem <xref:System.Text.StringBuilder> Objekt zuweisen und dann beginnen, ihn zu ändern.|Das wiederholte Abrufen von <xref:System.Text.StringBuilder.ToString%2A> ist mühsam, wenn Sie Änderungen vornehmen müssen, bevor dem <xref:System.Text.StringBuilder> Objekt der gesamte Text hinzugefügt wird.<br /><br /> Wenn Sie Änderungen vornehmen, müssen Sie daran denken, am Ende des <xref:System.Text.StringBuilder> Objekts zu arbeiten.|
|Verwenden Sie die <xref:System.Text.StringBuilder.Chars%2A>-Eigenschaft, um einen Bereich von Zeichen sequenziell zu durchsuchen.|Nützlich, wenn Sie sich mit einzelnen Zeichen oder einer kleinen Teil Zeichenfolge beschäftigen.|Umständlich, wenn die Anzahl der zu suchenden Zeichen groß ist oder die Suchlogik Komplex ist.<br /><br />Führt zu einer sehr schlechten Leistung für Objekte, die durch wiederholte Methodenaufrufe sehr groß geworden sind.  |
|Konvertieren Sie das <xref:System.Text.StringBuilder>-Objekt in ein <xref:System.String> Objekt, und führen Sie Änderungen am <xref:System.String>-Objekt aus.|Nützlich, wenn die Anzahl der Änderungen gering ist.|Negiert den Leistungsvorteil der <xref:System.Text.StringBuilder>-Klasse, wenn die Anzahl der Änderungen groß ist.|

 Betrachten wir diese Verfahren ausführlicher.

-   Wenn das Ziel der Suche ist, zu bestimmen, ob eine bestimmte Teil Zeichenfolge vorhanden ist (d. h., wenn Sie nicht an der Position der Teil Zeichenfolge interessiert sind), können Sie Zeichen folgen durchsuchen, bevor Sie Sie im <xref:System.Text.StringBuilder> Objekt speichern. Im folgenden Beispiel wird eine mögliche Implementierung bereitstellt. Sie definiert eine `StringBuilderFinder` Klasse, deren Konstruktor einen Verweis auf ein <xref:System.Text.StringBuilder> Objekt und die Teil Zeichenfolge, die in der Zeichenfolge gesucht werden soll, übergeben wird. In diesem Fall versucht das Beispiel zu ermitteln, ob sich die aufgezeichneten Temperaturen in Fahrenheit oder Celsius befinden, und fügt den entsprechenden einführenden Text am Anfang des <xref:System.Text.StringBuilder> Objekts hinzu. Ein Zufallszahlengenerator wird zum Auswählen eines Arrays verwendet, das Daten in Grad Celsius oder Grad Fahrenheit enthält.

     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]

-   Ruft die <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>-Methode auf, um das <xref:System.Text.StringBuilder> Objekt in ein <xref:System.String>-Objekt zu konvertieren. Sie können die Zeichenfolge mithilfe von Methoden wie <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> oder <xref:System.String.StartsWith%2A?displayProperty=nameWithType>durchsuchen, oder Sie können reguläre Ausdrücke und die <xref:System.Text.RegularExpressions.Regex>-Klasse verwenden, um nach Mustern zu suchen. Da sowohl <xref:System.Text.StringBuilder>-als auch <xref:System.String>-Objekte UTF-16-Codierung zum Speichern von Zeichen verwenden, sind die Index Positionen von Zeichen, Teil Zeichenfolgen und Übereinstimmungen mit regulären Ausdrücken in beiden Objekten identisch. Dies ermöglicht es Ihnen, <xref:System.Text.StringBuilder> Methoden zu verwenden, um Änderungen an derselben Position vorzunehmen, an der sich dieser Text im <xref:System.String> Objekt befindet.

    > [!NOTE]
    >  Wenn Sie diesen Ansatz anwenden, sollten Sie vom Ende des <xref:System.Text.StringBuilder> Objekts bis zum Anfang arbeiten, damit Sie das <xref:System.Text.StringBuilder> Objekt nicht wiederholt in eine Zeichenfolge konvertieren müssen.

     Dieser Ansatz wird anhand des folgenden Beispiels veranschaulicht. Es speichert vier Vorkommen der einzelnen Buchstaben des englischen Alphabets in einem <xref:System.Text.StringBuilder>-Objekt. Anschließend wird der Text in ein <xref:System.String> Objekt konvertiert und ein regulärer Ausdruck verwendet, um die Anfangsposition jeder vierstelligen Reihenfolge zu identifizieren. Schließlich wird vor jeder vierstelligen Sequenz mit Ausnahme der ersten Sequenz ein Unterstrich hinzugefügt, und das erste Zeichen der Sequenz wird in Großbuchstaben konvertiert.

     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]

-   Verwenden Sie die <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>-Eigenschaft, um einen Bereich von Zeichen sequenziell in einem <xref:System.Text.StringBuilder> Objekt zu durchsuchen. Diese Vorgehensweise ist möglicherweise nicht praktikabel, wenn die Anzahl der zu durchsuchenden Zeichen groß ist oder die Suchlogik besonders komplex ist. Die Auswirkungen auf die Leistung bei sehr großen, <xref:System.Text.StringBuilder> Objekten segmentierten Zeichen folgen basierten Zugriff auf die Leistung finden Sie in der Dokumentation für die <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>-Eigenschaft.

     Das folgende Beispiel ist identisch mit dem vorherigen Beispiel, aber unterscheidet sich von der Implementierung. Er verwendet die <xref:System.Text.StringBuilder.Chars%2A>-Eigenschaft, um zu erkennen, wann ein Zeichen Wert geändert wurde, fügt einen Unterstrich an dieser Position ein und konvertiert das erste Zeichen in der neuen Sequenz in Großbuchstaben.

     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]

-   Speichern Sie den gesamten unveränderten Text im <xref:System.Text.StringBuilder> Objekt, und führen Sie die <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>-Methode aus, um das <xref:System.Text.StringBuilder> Objekt in ein <xref:System.String> Objekt zu konvertieren und die Änderungen am <xref:System.String> Objekt auszuführen. Sie können diesen Ansatz verwenden, wenn Sie nur wenige Änderungen haben. Andernfalls können die Kosten für die Arbeit mit unveränderlichen Zeichen folgen die Leistungsvorteile der Verwendung eines <xref:System.Text.StringBuilder> Objekts widersprechen.

     Das folgende Beispiel ist identisch mit den beiden vorherigen Beispielen, unterscheidet sich jedoch von der Implementierung. Er erstellt ein <xref:System.Text.StringBuilder> Objekt, konvertiert es in ein <xref:System.String> Objekt und verwendet dann einen regulären Ausdruck, um alle verbleibenden Änderungen an der Zeichenfolge auszuführen. Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>-Methode verwendet einen Lambda-Ausdruck, um die Ersetzung bei den einzelnen vergleichen auszuführen.

     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]

<a name="Converting"></a>
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Umstellen des StringBuilder-Objekts in eine Zeichenfolge
 Sie müssen das <xref:System.Text.StringBuilder>-Objekt in ein <xref:System.String>-Objekt konvertieren, bevor Sie die vom <xref:System.Text.StringBuilder>-Objekt dargestellte Zeichenfolge an eine Methode mit einem <xref:System.String>-Parameter übergeben können oder diese auf der Benutzeroberfläche anzeigen. Sie führen diese Konvertierung durch, indem Sie die <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>-Methode aufrufen. Eine Abbildung finden Sie im vorherigen Beispiel, das die <xref:System.Text.StringBuilder.ToString%2A>-Methode aufruft, um ein <xref:System.Text.StringBuilder> Objekt in eine Zeichenfolge zu konvertieren, sodass es an eine Methode für reguläre Ausdrücke übermittelt werden kann.



## Examples
 Im folgenden Beispiel wird gezeigt, wie viele der Methoden aufgerufen werden, die von der <xref:System.Text.StringBuilder>-Klasse definiert werden.

 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]

 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Text.StringBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Text.StringBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der Zeichen folgen Wert dieser Instanz ist auf <xref:System.String.Empty?displayProperty=nameWithType>festgelegt, und die Kapazität wird auf die Implementierungs spezifische Standardkapazität festgelegt.



## Examples
 Im folgenden Beispiel wird veranschaulicht, wie der <xref:System.Text.StringBuilder.%23ctor%2A>-Konstruktor ohne Parameter aufgerufen wird.

 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die empfohlene Anfangsgröße dieser Instanz.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.StringBuilder" />-Klasse unter Verwendung der angegebenen Kapazität.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der `capacity`-Parameter definiert die maximale Anzahl von Zeichen, die im von der aktuellen Instanz zugeordneten Arbeitsspeicher gespeichert werden können. Der Wert wird der <xref:System.Text.StringBuilder.Capacity%2A>-Eigenschaft zugewiesen. Wenn die Anzahl der in der aktuellen Instanz gespeicherten Zeichen diesen `capacity` Wert überschreitet, ordnet das <xref:System.Text.StringBuilder>-Objekt zusätzlichen Speicherplatz zu, um Sie zu speichern.

 Der Zeichen folgen Wert dieser Instanz ist auf <xref:System.String.Empty?displayProperty=nameWithType>festgelegt. Wenn `capacity` NULL ist, wird die Implementierungs spezifische Standardkapazität verwendet.



## Examples
 Im folgenden Beispiel wird veranschaulicht, wie der <xref:System.Text.StringBuilder.%23ctor%2A>-Konstruktor mit einer angegebenen Kapazität aufgerufen wird.

 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als 0 (null).</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, mit der der Wert der Instanz initialisiert wird. Wenn <paramref name="value" /><see langword="null" /> ist, enthält der neue <see cref="T:System.Text.StringBuilder" /> die leere Zeichenfolge (d. h., er enthält <see cref="F:System.String.Empty" />).</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.StringBuilder" />-Klasse unter Verwendung der angegebenen Zeichenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn `value``null` ist, enthält der neue <xref:System.Text.StringBuilder> die leere Zeichenfolge (d. h., er enthält <xref:System.String.Empty>).



## Examples
 Im folgenden Beispiel wird veranschaulicht, wie der <xref:System.Text.StringBuilder.%23ctor%2A>-Konstruktor mit der angegebenen Zeichenfolge aufgerufen wird.

 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die empfohlene Anfangsgröße des <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">Die Höchstanzahl von Zeichen, die die aktuelle Zeichenfolge enthalten kann.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.StringBuilder" />-Klasse, die bei einer angegebenen Kapazität beginnt, die bis auf ein angegebenes Maximum erhöht werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der `capacity`-Parameter definiert die maximale Anzahl von Zeichen, die im von der aktuellen Instanz zugeordneten Arbeitsspeicher gespeichert werden können. Der Wert wird der <xref:System.Text.StringBuilder.Capacity%2A>-Eigenschaft zugewiesen. Wenn die Anzahl der in der aktuellen Instanz gespeicherten Zeichen diesen `capacity` Wert überschreitet, ordnet das <xref:System.Text.StringBuilder>-Objekt zusätzlichen Speicherplatz zu, um Sie zu speichern.

 Wenn `capacity` NULL ist, wird die Implementierungs spezifische Standardkapazität verwendet.

 Die `maxCapacity`-Eigenschaft definiert die maximale Anzahl von Zeichen, die die aktuelle Instanz enthalten kann. Der Wert wird der <xref:System.Text.StringBuilder.MaxCapacity%2A>-Eigenschaft zugewiesen. Wenn die Anzahl der in der aktuellen Instanz gespeicherten Zeichen diesen `maxCapacity` Wert überschreitet, weist das <xref:System.Text.StringBuilder> Objekt keinen zusätzlichen Arbeitsspeicher zu, sondern löst stattdessen eine Ausnahme aus.



## Examples
 Im folgenden Beispiel wird veranschaulicht, wie der <xref:System.Text.StringBuilder.%23ctor%2A>-Konstruktor mit einer angegebenen Kapazität und maximaler Kapazität aufgerufen wird.

 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxCapacity" /> ist kleiner als 1, <paramref name="capacity" /> ist kleiner als 0 (null), oder <paramref name="capacity" /> ist größer als <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, mit der der Wert der Instanz initialisiert wird. Wenn <paramref name="value" /><see langword="null" /> ist, enthält der neue <see cref="T:System.Text.StringBuilder" /> die leere Zeichenfolge (d. h., er enthält <see cref="F:System.String.Empty" />).</param>
        <param name="capacity">Die empfohlene Anfangsgröße des <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.StringBuilder" />-Klasse unter Verwendung der angegebenen Zeichenfolge und der angegebenen Kapazität.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der `capacity`-Parameter definiert die maximale Anzahl von Zeichen, die im von der aktuellen Instanz zugeordneten Arbeitsspeicher gespeichert werden können. Der Wert wird der <xref:System.Text.StringBuilder.Capacity%2A>-Eigenschaft zugewiesen. Wenn die Anzahl der in der aktuellen Instanz gespeicherten Zeichen diesen `capacity` Wert überschreitet, ordnet das <xref:System.Text.StringBuilder>-Objekt zusätzlichen Speicherplatz zu, um Sie zu speichern.

 Wenn `capacity` NULL ist, wird die Implementierungs spezifische Standardkapazität verwendet.



## Examples
 Im folgenden Beispiel wird veranschaulicht, wie der <xref:System.Text.StringBuilder.%23ctor%2A>-Konstruktor mit einer Anfangs Zeichenfolge und einer angegebenen Kapazität aufgerufen wird.

 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als 0 (null).</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die die Teilzeichenfolge enthält, mit der der Wert dieser Instanz initialisiert wird. Wenn <paramref name="value" /><see langword="null" /> ist, enthält der neue <see cref="T:System.Text.StringBuilder" /> die leere Zeichenfolge (d. h., er enthält <see cref="F:System.String.Empty" />).</param>
        <param name="startIndex">Die Position in <paramref name="value" />, an der die Teilzeichenfolge beginnt.</param>
        <param name="length">Die Anzahl der Zeichen in der Teilzeichenfolge.</param>
        <param name="capacity">Die empfohlene Anfangsgröße des <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.StringBuilder" />-Klasse unter Verwendung der angegebenen Teilzeichenfolge und der angegebenen Kapazität.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der `capacity`-Parameter definiert die maximale Anzahl von Zeichen, die im von der aktuellen Instanz zugeordneten Arbeitsspeicher gespeichert werden können. Der Wert wird der <xref:System.Text.StringBuilder.Capacity%2A>-Eigenschaft zugewiesen. Wenn die Anzahl der in der aktuellen Instanz gespeicherten Zeichen diesen `capacity` Wert überschreitet, ordnet das <xref:System.Text.StringBuilder>-Objekt zusätzlichen Speicherplatz zu, um Sie zu speichern.

 Wenn `capacity` NULL ist, wird die Implementierungs spezifische Standardkapazität verwendet.



## Examples
 Im folgenden Beispiel wird veranschaulicht, wie der <xref:System.Text.StringBuilder.%23ctor%2A>-Konstruktor mit der angegebenen Zeichenfolge aufgerufen wird.

 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als 0 (null).

Oder

 <paramref name="startIndex" /> plus <paramref name="length" /> ist keine Position in <paramref name="value" />.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Objekts an diese Instanz an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende boolesche Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen booleschen Werts an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.Boolean%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]

 Die <xref:System.Text.StringBuilder.Append%28System.Boolean%29>-Methode ruft die <xref:System.Boolean.ToString?displayProperty=nameWithType>-Methode auf, um die Zeichen folgen Darstellung von `value`zu erhalten. Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 8-Bit-Ganzzahl ohne Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.Byte%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]

 Die <xref:System.Text.StringBuilder.Append%28System.Byte%29>-Methode ruft die <xref:System.Byte.ToString%28System.IFormatProvider%29>-Methode auf, um die Zeichen folgen Darstellung der `value` für die aktuelle Kultur zu erhalten. Um die Formatierung von `value`zu steuern, müssen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A>-Methode aufzurufen.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Die anzufügende UTF-16-codierte Codeeinheit.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen <see cref="T:System.Char" />-Objekts an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.Char%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Das anzufügende Array von Zeichen.</param>
        <summary>Fügt die Zeichenfolgendarstellung der Unicode-Zeichen in einem angegebenen Array an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode fügt alle Zeichen im angegebenen Array an die aktuelle Instanz in derselben Reihenfolge an, in der Sie in `value`angezeigt werden. Wenn `value` `null`ist, werden keine Änderungen vorgenommen.

 Die <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen Dezimalzahl an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.Decimal%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]

 Die <xref:System.Text.StringBuilder.Append%28System.Decimal%29>-Methode ruft die <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>-Methode auf, um die Zeichen folgen Darstellung der `value` für die aktuelle Kultur zu erhalten. Um die Formatierung von `value`zu steuern, müssen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A>-Methode aufzurufen.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen Gleitkommazahl mit doppelter Genauigkeit an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.Double%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]

 Die <xref:System.Text.StringBuilder.Append%28System.Double%29>-Methode ruft die <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>-Methode auf, um die Zeichen folgen Darstellung der `value` für die aktuelle Kultur zu erhalten. Um die Formatierung von `value`zu steuern, müssen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A>-Methode aufzurufen.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 16-Bit-Ganzzahl mit Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.Int16%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]

 Die <xref:System.Text.StringBuilder.Append%28System.Int16%29>-Methode ruft die <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>-Methode auf, um die Zeichen folgen Darstellung der `value` für die aktuelle Kultur zu erhalten. Um die Formatierung von `value`zu steuern, müssen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A>-Methode aufzurufen.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 32-Bit-Ganzzahl mit Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.Int32%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]

 Die <xref:System.Text.StringBuilder.Append%28System.Int32%29>-Methode ruft die <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>-Methode auf, um die Zeichen folgen Darstellung der `value` für die aktuelle Kultur zu erhalten. Um die Formatierung von `value`zu steuern, müssen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A>-Methode aufzurufen.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 64-Bit-Ganzzahl mit Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.Int64%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]

 Die <xref:System.Text.StringBuilder.Append%28System.Int64%29>-Methode ruft die <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> auf, um die Zeichen folgen Darstellung der `value` für die aktuelle Kultur zu erhalten. Um die Formatierung von `value`zu steuern, müssen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A>-Methode aufzurufen.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das anzufügende Objekt.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Objekts an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.Object%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht. Er definiert eine `Dog` Klasse, erstellt ein `Dog` Objekt und führt drei Aufrufe an die <xref:System.Text.StringBuilder.Append%2A>-Methode aus, um eine Zeichenfolge zu erstellen, die den Namen und die Rasse des Hundes enthält.

 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]

 Die <xref:System.Text.StringBuilder.Append%28System.Object%29>-Methode ruft die <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode auf, um die Zeichen folgen Darstellung von `value`zu erhalten. Wenn `value` `null`ist, werden keine Änderungen am <xref:System.Text.StringBuilder> Objekt vorgenommen.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlyMemory`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlyMemory(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlyMemory&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlyMemory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende schreibgeschützte Zeichenspeicherbereich.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines festgelegten schreibgeschützten Zeichenspeicherbereichs an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">Die anzufügende schreibgeschützte Zeichenspanne.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer festgelegten schreibgeschützten Zeichenspanne an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 8-Bit-Ganzzahl mit Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.SByte%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]

 Die <xref:System.Text.StringBuilder.Append%28System.SByte%29>-Methode ruft die <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>-Methode auf, um die Zeichen folgen Darstellung der `value` für die aktuelle Kultur zu erhalten. Um die Formatierung von `value`zu steuern, müssen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A>-Methode aufzurufen.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen Gleitkommazahl mit einfacher Genauigkeit an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.Single%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]

 Die <xref:System.Text.StringBuilder.Append%28System.Single%29>-Methode ruft die <xref:System.Single.ToString%2A?displayProperty=nameWithType>-Methode auf, um die Zeichen folgen Darstellung der `value` für die aktuelle Kultur zu erhalten. Um die Formatierung von `value`zu steuern, müssen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A>-Methode aufzurufen.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die anzufügende Zeichenfolge.</param>
        <summary>Fügt eine Kopie der angegebenen Zeichenfolge an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.String%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]

 Wenn `value` `null`ist, werden keine Änderungen vorgenommen.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Zeichenfolgengenerator.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Zeichenfolgengenerators an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 16-Bit-Ganzzahl ohne Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.UInt16%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]

 Die <xref:System.Text.StringBuilder.Append%28System.UInt16%29>-Methode ruft die <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>-Methode auf, um die Zeichen folgen Darstellung von `value`zu erhalten. Um die Formatierung von `value`zu steuern, müssen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A>-Methode aufzurufen.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 32-Bit-Ganzzahl ohne Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.UInt32%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]

 Der <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Ruft die <xref:System.UInt32.ToString%2A?displayProperty=nameWithType>-Methode auf, um die Zeichen folgen Darstellung der `value` für die aktuelle Kultur zu erhalten. Um die Formatierung von `value`zu steuern, müssen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A>-Methode aufzurufen.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 64-Bit-Ganzzahl ohne Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.UInt64%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]

 Die <xref:System.Text.StringBuilder.Append%28System.UInt64%29>-Methode ruft die <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>-Methode auf, um die Zeichen folgen Darstellung der `value` für die aktuelle Kultur zu erhalten. Um die Formatierung von `value`zu steuern, müssen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A>-Methode aufzurufen.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Das anzufügende Zeichen.</param>
        <param name="repeatCount">Die Anzahl der Anfügewiederholungen für <paramref name="value" />.</param>
        <summary>Fügt eine angegebene Anzahl von Kopien der Zeichenfolgendarstellung eines Unicode-Zeichens an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount" /> ist kleiner als 0 (null).

Oder

Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <exception cref="T:System.OutOfMemoryException">Nicht genügend Arbeitsspeicher.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein Array von Zeichen.</param>
        <param name="valueCount">Die Anzahl der Zeichen im Array.</param>
        <summary>Fügt ein Array aus Unicode-Zeichen ab einer angegebenen Adresse an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode fügt `valueCount` Zeichen, beginnend bei der Adresse `value`, an die aktuelle Instanz an.

 Die <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="valueCount" /> ist kleiner als 0 (null).

Oder

Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> ist ein NULL-Zeiger</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeichenarray.</param>
        <param name="startIndex">Die Anfangsposition in <paramref name="value" />.</param>
        <param name="charCount">Die Anzahl der anzufügenden Zeichen.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Unterarrays von Unicode-Zeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode fügt den angegebenen Zeichenbereich in `value` an die aktuelle Instanz an. Wenn `value` `null` und `startIndex` und `count` beide NULL sind, werden keine Änderungen vorgenommen.

 Die <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />, und <paramref name="startIndex" /> und <paramref name="charCount" /> sind nicht 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> ist kleiner als 0 (null).

Oder

 <paramref name="startIndex" /> ist kleiner als 0 (null).

Oder

 <paramref name="startIndex" /> + <paramref name="charCount" /> ist größer als die Länge von <paramref name="value" />.

Oder

Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die die anzufügende Teilzeichenfolge enthält.</param>
        <param name="startIndex">Die Anfangsposition der Teilzeichenfolge innerhalb des <paramref name="value" />-Parameters.</param>
        <param name="count">Die Anzahl der anzufügenden Zeichen in <paramref name="value" />.</param>
        <summary>Fügt eine Kopie einer angegebenen Teilzeichenfolge an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode fügt den angegebenen Zeichenbereich in `value` an die aktuelle Instanz an. Wenn `value` `null` und `startIndex` und `count` beide NULL sind, werden keine Änderungen vorgenommen.

 Die <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29>-Methode ändert die vorhandene Instanz dieser Klasse. Es wird keine neue Klasseninstanz zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft für den vorhandenen Verweis aufzurufen, und Sie müssen den Rückgabewert nicht einem <xref:System.Text.StringBuilder> Objekt zuweisen, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />, und <paramref name="startIndex" /> und <paramref name="count" /> sind nicht 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist kleiner als 0 (null).

Oder

 <paramref name="startIndex" /> ist kleiner als 0 (null).

Oder

 <paramref name="startIndex" /> + <paramref name="count" /> ist größer als die Länge von <paramref name="value" />.

Oder

Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">Der Zeichenfolgengenerator, der die anzufügende Teilzeichenfolge enthält.</param>
        <param name="startIndex">Die Anfangsposition der Teilzeichenfolge innerhalb des <paramref name="value" />-Parameters.</param>
        <param name="count">Die Anzahl der anzufügenden Zeichen in <paramref name="value" />.</param>
        <summary>Fügt eine Kopie einer Teilzeichenfolge im festgelegten Zeichenfolgengenerator an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung eines entsprechenden Objektarguments ersetzt.</summary>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg0">Ein zu formatierendes Objekt.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung eines einzelnen Arguments ersetzt.</summary>
        <returns>Ein Verweis auf diese Instanz mit angefügtem <paramref name="format" />. Die einzelnen Elemente in <paramref name="format" /> werden jeweils durch eine Zeichenfolgendarstellung von <paramref name="arg0" /> ersetzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in das aktuelle <xref:System.Text.StringBuilder> Objekt einzubetten.

 Der `format`-Parameter besteht aus null oder mehr Text Läufen, die mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, vermischt werden. Der Index der Format Elemente muss 0 (null) sein, damit er `arg0`entspricht, dem einzelnen Objekt in der Parameterliste dieser Methode. Der Formatierungsprozess ersetzt jedes Format Element durch die Zeichen folgen Darstellung der `arg0`.

 Die Syntax eines Format Elements lautet wie folgt:

 {*Index*[,*length*] [:*FormatString*]}

 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.

|Element|BESCHREIBUNG|
|-------------|-----------------|
|*Index*|Die null basierte Position in der Parameterliste des-Objekts, das formatiert werden soll. Wenn das durch den *Index* angegebene Objekt `null`ist, wird das Format Element durch <xref:System.String.Empty?displayProperty=nameWithType>ersetzt. Wenn an der *Index* Position kein Parameter vorhanden ist, wird ein <xref:System.FormatException> ausgelöst.|
|,*length*|Die Mindestanzahl von Zeichen in der Zeichen folgen Darstellung des-Parameters. Wenn dies positiv ist, wird der-Parameter rechtsbündig ausgerichtet. Wenn der Wert negativ ist, wird er linksbündig ausgerichtet.|
|:*Format Zeichenfolge*|Eine standardmäßige oder benutzerdefinierte Format Zeichenfolge, die vom-Parameter unterstützt wird.|

> [!NOTE]
>  Informationen zu den standardmäßigen und benutzerdefinierten Format Zeichenfolgen, die mit Datums-und Uhrzeitwerten verwendet werden, finden Sie unter Standardformat Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md) Informationen zu den standardmäßigen [und benutzerdefinierten](~/docs/standard/base-types/custom-numeric-format-strings.md)Formatierungs Zeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [standardmäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und Informationen zu den Standardformat Zeichenfolgen für-Enumerationen finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).

 `arg0` das das zu formatierende Objekt darstellt. Jedes Format Element in `format` wird durch die Zeichen folgen Darstellung `arg0`ersetzt. Wenn das Format Element `formatString` enthält und `arg0` die <xref:System.IFormattable>-Schnittstelle implementiert, definiert `arg0.ToString(formatString, null)` die Formatierung. Andernfalls definiert `arg0.ToString()` die Formatierung.

 Wenn die Zeichenfolge, die `format` zugewiesen ist, "vielen Dank für Ihre Spende an {0: # # # #} Lebensmitteldosen an unsere gemeinnützige Organisation." und `arg0` eine ganze Zahl mit dem Wert 10 ist, lautet der Rückgabewert "Danke für die Spende von 10 Nahrungsmitteln an unsere gemeinnützige Organisation".



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.

Oder

Der Index eines Formatelements ist kleiner als 0 (null) oder größer gleich 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="args">Ein Array zu formatierender Objekte.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung eines entsprechenden Arguments in einem Parameterarray ersetzt.</summary>
        <returns>Ein Verweis auf diese Instanz mit angefügtem <paramref name="format" />. Jedes Formatelement in <paramref name="format" /> wird durch die Zeichenfolgendarstellung des entsprechenden Objektarguments ersetzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in das aktuelle <xref:System.Text.StringBuilder> Objekt einzubetten.

 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die Objekten in der Parameterliste dieser Methode entsprechen. Der Formatierungsprozess ersetzt jedes Format Element durch die Zeichen folgen Darstellung des entsprechenden Objekts.

 Die Syntax eines Format Elements lautet wie folgt:

 {*Index*[,*length*] [:*FormatString*]}

 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.

|Element|BESCHREIBUNG|
|-------------|-----------------|
|*Index*|Die null basierte Position in der Parameterliste des-Objekts, das formatiert werden soll. Wenn das durch den *Index* angegebene Objekt `null`ist, wird das Format Element durch <xref:System.String.Empty?displayProperty=nameWithType>ersetzt. Wenn an der *Index* Position kein Parameter vorhanden ist, wird ein <xref:System.FormatException> ausgelöst.|
|,*length*|Die Mindestanzahl von Zeichen in der Zeichen folgen Darstellung des-Parameters. Wenn dies positiv ist, wird der-Parameter rechtsbündig ausgerichtet. Wenn der Wert negativ ist, wird er linksbündig ausgerichtet.|
|:*Format Zeichenfolge*|Eine standardmäßige oder benutzerdefinierte Format Zeichenfolge, die vom-Parameter unterstützt wird.|

> [!NOTE]
>  Informationen zu den standardmäßigen und benutzerdefinierten Format Zeichenfolgen, die mit Datums-und Uhrzeitwerten verwendet werden, finden Sie unter Standardformat Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md) Informationen zu den standardmäßigen [und benutzerdefinierten](~/docs/standard/base-types/custom-numeric-format-strings.md)Formatierungs Zeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [standardmäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und Informationen zu den Standardformat Zeichenfolgen für-Enumerationen finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).

 `args` die die zu formatierenden Objekte darstellt. Jedes Format Element in `format` wird durch die Zeichen folgen Darstellung des entsprechenden Objekts in `args`ersetzt. Wenn das Format Element `formatString` enthält und das entsprechende Objekt in `args` die <xref:System.IFormattable>-Schnittstelle implementiert, definiert `args[index].ToString(formatString, provider)` die Formatierung. Andernfalls definiert `args[index].ToString()` die Formatierung.

 Wenn die Zeichenfolge, die `format` zugewiesen ist, "vielen Dank für Ihre Spende an {0: # # # #} Lebensmitteldosen an unsere gemeinnützige Organisation." und `arg0` eine ganze Zahl mit dem Wert 10 ist, lautet der Rückgabewert "Danke für die Spende von 10 Nahrungsmitteln an unsere gemeinnützige Organisation".



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> oder <paramref name="args" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.

Oder

Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich der Länge des <paramref name="args" />-Arrays.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg0">Das zu formatierende Objekt.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung eines einzigen Arguments mit einem angegebenen Formatanbieter ersetzt.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde. Nach dem Anfügevorgang enthält diese Instanz alle Daten, die auch vor dem Vorgang vorhanden waren. Ihnen folgt eine Kopie von <paramref name="format" />, wobei die Formatangabe durch die Zeichenfolgendarstellung von <paramref name="arg0" /> ersetzt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) des .NET Framework, um den Wert von `arg0` in seine Textdarstellung zu konvertieren und diese Darstellung in das aktuelle <xref:System.Text.StringBuilder> Objekt einzubetten.

 Der `format`-Parameter besteht aus null oder mehr Text Läufen, die mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, vermischt werden. Der Index jedes Format Elements muss NULL (0) sein, da diese Methode eine Argumentliste mit einem einzelnen Argument enthält. Der Formatierungsprozess ersetzt jedes Format Element durch die Zeichen folgen Darstellung der `arg0`.

 Die Syntax eines Format Elements lautet wie folgt:

 {*Index*[,*length*] [:*FormatString*]}

 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.

|Element|BESCHREIBUNG|
|-------------|-----------------|
|*Index*|Die null basierte Position in der Parameterliste des-Objekts, das formatiert werden soll. Wenn das durch den *Index* angegebene Objekt `null`ist, wird das Format Element durch <xref:System.String.Empty?displayProperty=nameWithType>ersetzt. Da in diesem Fall die <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29>-Methode ein einzelnes Argument in der Argumentliste aufweist, muss der Wert des *Indexes* immer 0 sein. Wenn dies nicht der Fall ist, wird ein <xref:System.FormatException> ausgelöst.|
|,*length*|Die Mindestanzahl von Zeichen in der Zeichen folgen Darstellung des-Parameters. Wenn dies positiv ist, wird der-Parameter rechtsbündig ausgerichtet. Wenn der Wert negativ ist, wird er linksbündig ausgerichtet.|
|:*Format Zeichenfolge*|Eine standardmäßige oder benutzerdefinierte Format Zeichenfolge, die vom-Parameter unterstützt wird.|

> [!NOTE]
>  Informationen zu den standardmäßigen und benutzerdefinierten Format Zeichenfolgen, die mit Datums-und Uhrzeitwerten verwendet werden, finden Sie unter Standardformat Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md) Informationen zu den standardmäßigen [und benutzerdefinierten](~/docs/standard/base-types/custom-numeric-format-strings.md)Formatierungs Zeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [standardmäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und Informationen zu den Standardformat Zeichenfolgen für-Enumerationen finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).

 Der `provider`-Parameter gibt eine <xref:System.IFormatProvider> Implementierung an, die Formatierungsinformationen für die Objekte in `args`bereitstellen kann. `provider` kann eine der folgenden Formen haben:

-   Ein <xref:System.Globalization.CultureInfo>-Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.

-   Ein <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Formatierungsinformationen für `arg0` bereitstellt, wenn es sich um einen numerischen Wert handelt.

-   Ein <xref:System.Globalization.DateTimeFormatInfo> Objekt, das kulturspezifische Formatierungsinformationen für `arg0` bereitstellt, wenn es sich um einen Datums-und Uhrzeitwert handelt.

-   Eine benutzerdefinierte <xref:System.IFormatProvider>-Implementierung, die Formatierungsinformationen für `arg0`bereitstellt. In der Regel implementiert eine solche Implementierung auch die <xref:System.ICustomFormatter>-Schnittstelle.

 Wenn der `provider`-Parameter `null`ist, werden Formatierungsinformationen aus der aktuellen Kultur abgerufen.

 `arg0` das das zu formatierende Objekt darstellt. Jedes Format Element in `format` wird durch die Zeichen folgen Darstellung `arg0`ersetzt. Wenn das Format Element `formatString` enthält und `arg0` die <xref:System.IFormattable>-Schnittstelle implementiert, definiert `arg0.ToString(formatString, provider)` die Formatierung. Andernfalls definiert `arg0.ToString()` die Formatierung.



## Examples
 Folgendes umfasst zwei Aufrufe der <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29>-Methode. Beide verwenden die Formatierungs Konventionen der Kultur Englisch-Großbritannien (en-GB). Der erste fügt die Zeichen folgen Darstellung einer <xref:System.Decimal> Wert Währung in eine Ergebnis Zeichenfolge ein. Die zweite fügt einen <xref:System.DateTime> Wert an zwei Stellen in einer Ergebnis Zeichenfolge ein, wobei der erste nur die kurze Datums Zeichenfolge und die zweite die kurze Zeit Zeichenfolge enthält.

 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.

Oder

Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Gewusst wie: Definieren und Verwenden von benutzerdefinierten numerischen Formatanbietern</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="args">Ein Array zu formatierender Objekte.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird von der Zeichenfolgendarstellung eines entsprechenden Arguments in einem Parameterarray ersetzt, das einen angegebenen Formatanbieter verwendet.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde. Nach dem Anfügevorgang enthält diese Instanz alle Daten, die auch vor dem Vorgang vorhanden waren. Ihnen folgt eine Kopie von <paramref name="format" />, wobei die Formatangabe durch die Zeichenfolgendarstellung des entsprechenden Objektarguments ersetzt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in das aktuelle <xref:System.Text.StringBuilder> Objekt einzubetten.

 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die Objekten in der Parameterliste dieser Methode entsprechen. Der Formatierungsprozess ersetzt jedes Format Element durch die Zeichen folgen Darstellung des entsprechenden Objekts.

 Die Syntax eines Format Elements lautet wie folgt:

 {*Index*[,*length*] [:*FormatString*]}

 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.

|Element|BESCHREIBUNG|
|-------------|-----------------|
|*Index*|Die null basierte Position in der Parameterliste des-Objekts, das formatiert werden soll. Wenn das durch den *Index* angegebene Objekt `null`ist, wird das Format Element durch <xref:System.String.Empty?displayProperty=nameWithType>ersetzt. Wenn an der *Index* Position kein Parameter vorhanden ist, wird ein <xref:System.FormatException> ausgelöst.|
|,*length*|Die Mindestanzahl von Zeichen in der Zeichen folgen Darstellung des-Parameters. Wenn dies positiv ist, wird der-Parameter rechtsbündig ausgerichtet. Wenn der Wert negativ ist, wird er linksbündig ausgerichtet.|
|:*Format Zeichenfolge*|Eine standardmäßige oder benutzerdefinierte Format Zeichenfolge, die vom-Parameter unterstützt wird.|

> [!NOTE]
>  Informationen zu den standardmäßigen und benutzerdefinierten Format Zeichenfolgen, die mit Datums-und Uhrzeitwerten verwendet werden, finden Sie unter Standardformat Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md) Informationen zu den standardmäßigen [und benutzerdefinierten](~/docs/standard/base-types/custom-numeric-format-strings.md)Formatierungs Zeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [standardmäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und Informationen zu den Standardformat Zeichenfolgen für-Enumerationen finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).

 Der `provider`-Parameter gibt eine <xref:System.IFormatProvider> Implementierung an, die Formatierungsinformationen für die Objekte in `args`bereitstellen kann. `provider` kann eine der folgenden Formen haben:

-   Ein <xref:System.Globalization.CultureInfo>-Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.

-   Ein <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Formatierungsinformationen für numerische Werte in `args`bereitstellt.

-   Ein <xref:System.Globalization.DateTimeFormatInfo> Objekt, das kulturspezifische Formatierungsinformationen für Datums-und Uhrzeitwerte in `args`bereitstellt.

-   Eine benutzerdefinierte <xref:System.IFormatProvider> Implementierung, die Formatierungsinformationen für eines oder mehrere der Objekte in `args`bereitstellt. In der Regel implementiert eine solche Implementierung auch die <xref:System.ICustomFormatter>-Schnittstelle. Das zweite Beispiel im nächsten Abschnitt veranschaulicht einen <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> Methoden Aufrufes mit einer benutzerdefinierten <xref:System.IFormatProvider> Implementierung.

 Wenn der `provider`-Parameter `null`ist, werden Format Anbieter Informationen aus der aktuellen Kultur abgerufen.

 `args` die die zu formatierenden Objekte darstellt. Jedes Format Element in `format` wird durch die Zeichen folgen Darstellung des entsprechenden Objekts in `args`ersetzt. Wenn das Format Element `formatString` enthält und das entsprechende Objekt in `args` die <xref:System.IFormattable>-Schnittstelle implementiert, definiert `args[index].ToString(formatString, provider)` die Formatierung. Andernfalls definiert `args[index].ToString()` die Formatierung.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 Im folgenden Beispiel wird eine benutzerdefinierte <xref:System.IFormatProvider> Implementierung mit dem Namen `CustomerFormatter` definiert, die eine 10-stellige Kundennummer mit Bindestrichen nach den vierten und siebten Ziffern formatiert. Sie wird an die <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>-Methode übermittelt, um eine Zeichenfolge zu erstellen, die die formatierte Kundennummer und den Kundennamen enthält.

 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.

Oder

Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich der Länge des <paramref name="args" />-Arrays.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Gewusst wie: Definieren und Verwenden von benutzerdefinierten numerischen Formatanbietern</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung für eines von zwei Argumenten ersetzt.</summary>
        <returns>Ein Verweis auf diese Instanz mit angefügtem <paramref name="format" />. Jedes Formatelement in <paramref name="format" /> wird durch die Zeichenfolgendarstellung des entsprechenden Objektarguments ersetzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in das aktuelle <xref:System.Text.StringBuilder> Objekt einzubetten.

 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die `arg0` und `arg1`entsprechen, den beiden Objekten in der Parameterliste dieser Methode. Der Formatierungsprozess ersetzt jedes Format Element durch die Zeichen folgen Darstellung des entsprechenden Objekts.

 Die Syntax eines Format Elements lautet wie folgt:

 {*Index*[,*length*] [:*FormatString*]}

 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.

|Element|BESCHREIBUNG|
|-------------|-----------------|
|*Index*|Die null basierte Position in der Parameterliste des-Objekts, das formatiert werden soll. Wenn das durch den *Index* angegebene Objekt `null`ist, wird das Format Element durch <xref:System.String.Empty?displayProperty=nameWithType>ersetzt. Wenn an der *Index* Position kein Parameter vorhanden ist, wird ein <xref:System.FormatException> ausgelöst.|
|,*length*|Die Mindestanzahl von Zeichen in der Zeichen folgen Darstellung des-Parameters. Wenn dies positiv ist, wird der-Parameter rechtsbündig ausgerichtet. Wenn der Wert negativ ist, wird er linksbündig ausgerichtet.|
|:*Format Zeichenfolge*|Eine standardmäßige oder benutzerdefinierte Format Zeichenfolge, die vom-Parameter unterstützt wird.|

> [!NOTE]
>  Informationen zu den standardmäßigen und benutzerdefinierten Format Zeichenfolgen, die mit Datums-und Uhrzeitwerten verwendet werden, finden Sie unter Standardformat Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md) Informationen zu den standardmäßigen [und benutzerdefinierten](~/docs/standard/base-types/custom-numeric-format-strings.md)Formatierungs Zeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [standardmäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und Informationen zu den Standardformat Zeichenfolgen für-Enumerationen finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).

 `arg0` und `arg1` die zu formatierenden Objekte darstellen. Jedes Format Element in `format` wird durch die Zeichen folgen Darstellung von `arg0` oder `arg1`ersetzt. Wenn das Format Element `formatString` enthält und das entsprechende Objekt die <xref:System.IFormattable> Schnittstelle implementiert, definiert `arg`*x* -`.ToString(formatString, provider)` die Formatierung, wobei *x* für den Index des Arguments steht. Andernfalls definiert `arg`*x* -`.ToString()` die Formatierung.

 Wenn die Zeichenfolge, die `format` zugewiesen ist, "vielen Dank für Ihre Spende an {0: # # # #} Lebensmitteldosen an unsere gemeinnützige Organisation." und `arg0` eine ganze Zahl mit dem Wert 10 ist, lautet der Rückgabewert "Danke für die Spende von 10 Nahrungsmitteln an unsere gemeinnützige Organisation".



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.

Oder

Der Index eines Formatelements ist kleiner als 0 (null) oder größer gleich 2.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung eines der zwei Argumente mit einem angegebenen Formatanbieter ersetzt.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde. Nach dem Anfügevorgang enthält diese Instanz alle Daten, die auch vor dem Vorgang vorhanden waren. Ihnen folgt eine Kopie von <paramref name="format" />, wobei die Formatangabe durch die Zeichenfolgendarstellung des entsprechenden Objektarguments ersetzt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in das aktuelle <xref:System.Text.StringBuilder> Objekt einzubetten.

 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die Objekten in der Parameterliste dieser Methode entsprechen. Der Formatierungsprozess ersetzt jedes Format Element durch die Zeichen folgen Darstellung des entsprechenden Objekts.

 Die Syntax eines Format Elements lautet wie folgt:

 {*Index*[,*length*] [:*FormatString*]}

 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.

|Element|BESCHREIBUNG|
|-------------|-----------------|
|*Index*|Die null basierte Position in der Parameterliste des-Objekts, das formatiert werden soll. Wenn das durch den *Index* angegebene Objekt `null`ist, wird das Format Element durch <xref:System.String.Empty?displayProperty=nameWithType>ersetzt. Wenn an der *Index* Position kein Parameter vorhanden ist, wird ein <xref:System.FormatException> ausgelöst.|
|,*length*|Die Mindestanzahl von Zeichen in der Zeichen folgen Darstellung des-Parameters. Wenn dies positiv ist, wird der-Parameter rechtsbündig ausgerichtet. Wenn der Wert negativ ist, wird er linksbündig ausgerichtet.|
|:*Format Zeichenfolge*|Eine standardmäßige oder benutzerdefinierte Format Zeichenfolge, die vom-Parameter unterstützt wird.|

> [!NOTE]
>  Informationen zu den standardmäßigen und benutzerdefinierten Format Zeichenfolgen, die mit Datums-und Uhrzeitwerten verwendet werden, finden Sie unter Standardformat Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md) Informationen zu den standardmäßigen [und benutzerdefinierten](~/docs/standard/base-types/custom-numeric-format-strings.md)Formatierungs Zeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [standardmäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und Informationen zu den Standardformat Zeichenfolgen für-Enumerationen finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).

 Der `provider`-Parameter gibt eine <xref:System.IFormatProvider> Implementierung an, die Formatierungsinformationen für `arg0` und `arg1`bereitstellen kann. `provider` kann eine der folgenden Formen haben:

-   Ein <xref:System.Globalization.CultureInfo>-Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.

-   Ein <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Formatierungsinformationen für `arg0` oder `arg1` bereitstellt, wenn es sich um numerische Werte handelt.

-   Ein <xref:System.Globalization.DateTimeFormatInfo> Objekt, das kulturspezifische Formatierungsinformationen für `arg0` oder `arg1` bereitstellt, wenn diese Datums-und Uhrzeitwerte sind.

-   Eine benutzerdefinierte <xref:System.IFormatProvider>-Implementierung, die Formatierungsinformationen für `arg0` und `arg1`bereitstellt. In der Regel implementiert eine solche Implementierung auch die <xref:System.ICustomFormatter>-Schnittstelle.

 Wenn der `provider`-Parameter `null`ist, werden Format Anbieter Informationen aus der aktuellen Kultur abgerufen.

 `arg0` und `arg1` die zu formatierenden Objekte darstellen. Jedes Format Element in `format` wird durch die Zeichen folgen Darstellung des Objekts ersetzt, das über den entsprechenden Index verfügt. Wenn das Format Element `formatString` enthält und das entsprechende Argument die <xref:System.IFormattable> Schnittstelle implementiert, definiert die `ToString(formatString, provider)`-Methode des Arguments die Formatierung. Andernfalls definiert die `ToString()`-Methode des Arguments die Formatierung.



## Examples
 Im folgenden Beispiel wird die <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29>-Methode verwendet, um in einem generischen <xref:System.Collections.Generic.Dictionary%602>-Objekt gespeicherte Zeit-und Temperaturdaten anzuzeigen. Beachten Sie, dass die Format Zeichenfolge drei Format Elemente enthält, obwohl nur zu formatierende Objekte vorhanden sind. Dies liegt daran, dass das erste Objekt in der Liste (ein Datums-und Uhrzeitwert) von zwei Format Elementen verwendet wird: das erste Format Element zeigt die Uhrzeit an, während die zweite das Datum anzeigt.

 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.

Oder

Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich 2.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage"><para>IIn .net Core und in den .NET Framework 4,0 und höheren Versionen, wenn Sie das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft überschreiten. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Gewusst wie: Definieren und Verwenden von benutzerdefinierten numerischen Formatanbietern</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <param name="arg2">Das dritte zu formatierende Objekt.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung für eines von drei Argumenten ersetzt.</summary>
        <returns>Ein Verweis auf diese Instanz mit angefügtem <paramref name="format" />. Jedes Formatelement in <paramref name="format" /> wird durch die Zeichenfolgendarstellung des entsprechenden Objektarguments ersetzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in das aktuelle <xref:System.Text.StringBuilder> Objekt einzubetten.

 Der `format`-Parameter besteht aus null oder mehr Text Ausführungen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die `arg0` durch `arg2`entsprechen, den Objekten in der Parameterliste dieser Methode. Der Formatierungsprozess ersetzt jedes Format Element durch die Zeichen folgen Darstellung des entsprechenden Objekts.

 Die Syntax eines Format Elements lautet wie folgt:

 {*Index*[,*length*] [:*FormatString*]}

 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.

|Element|BESCHREIBUNG|
|-------------|-----------------|
|*Index*|Die null basierte Position in der Parameterliste des-Objekts, das formatiert werden soll. Wenn das durch den *Index* angegebene Objekt `null`ist, wird das Format Element durch <xref:System.String.Empty?displayProperty=nameWithType>ersetzt. Wenn an der *Index* Position kein Parameter vorhanden ist, wird ein <xref:System.FormatException> ausgelöst.|
|,*length*|Die Mindestanzahl von Zeichen in der Zeichen folgen Darstellung des-Parameters. Wenn dies positiv ist, wird der-Parameter rechtsbündig ausgerichtet. Wenn der Wert negativ ist, wird er linksbündig ausgerichtet.|
|:*Format Zeichenfolge*|Eine standardmäßige oder benutzerdefinierte Format Zeichenfolge, die vom-Parameter unterstützt wird.|

> [!NOTE]
>  Informationen zu den standardmäßigen und benutzerdefinierten Format Zeichenfolgen, die mit Datums-und Uhrzeitwerten verwendet werden, finden Sie unter Standardformat Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md) Informationen zu den standardmäßigen [und benutzerdefinierten](~/docs/standard/base-types/custom-numeric-format-strings.md)Formatierungs Zeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [standardmäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und Informationen zu den Standardformat Zeichenfolgen für-Enumerationen finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).

 `arg0`, `arg1`und `arg2` stellen die zu formatierenden Objekte dar. Jedes Format Element in `format` wird abhängig vom Index des Format Elements durch die Zeichen folgen Darstellung von `arg0`, `arg1`oder `arg2`ersetzt. Wenn das Format Element `formatString` enthält und das entsprechende Objekt in `args` die <xref:System.IFormattable>-Schnittstelle implementiert, definiert `arg`*x* -`.ToString(formatString, null)` die Formatierung, wobei *x* für den Index des Arguments steht. Andernfalls definiert `arg`*x* -`.ToString()` die Formatierung.

 Wenn die Zeichenfolge, die `format` zugewiesen ist, "vielen Dank für Ihre Spende an {0: # # # #} Lebensmitteldosen an unsere gemeinnützige Organisation." und `arg0` eine ganze Zahl mit dem Wert 10 ist, lautet der Rückgabewert "Danke für die Spende von 10 Nahrungsmitteln an unsere gemeinnützige Organisation".



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.

Oder

Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <param name="arg2">Das dritte zu formatierende Objekt.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung eines der drei Argumente mit einem angegebenen Formatanbieter ersetzt.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde. Nach dem Anfügevorgang enthält diese Instanz alle Daten, die auch vor dem Vorgang vorhanden waren. Ihnen folgt eine Kopie von <paramref name="format" />, wobei die Formatangabe durch die Zeichenfolgendarstellung des entsprechenden Objektarguments ersetzt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in das aktuelle <xref:System.Text.StringBuilder> Objekt einzubetten.

 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die Objekten in der Parameterliste dieser Methode entsprechen. Der Formatierungsprozess ersetzt jedes Format Element durch die Zeichen folgen Darstellung des entsprechenden Objekts.

 Die Syntax eines Format Elements lautet wie folgt:

 {*Index*[,*length*] [:*FormatString*]}

 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.

|Element|BESCHREIBUNG|
|-------------|-----------------|
|*Index*|Die null basierte Position in der Parameterliste des-Objekts, das formatiert werden soll. Wenn das durch den *Index* angegebene Objekt `null`ist, wird das Format Element durch <xref:System.String.Empty?displayProperty=nameWithType>ersetzt. Wenn an der *Index* Position kein Parameter vorhanden ist, wird ein <xref:System.FormatException> ausgelöst.|
|,*length*|Die Mindestanzahl von Zeichen in der Zeichen folgen Darstellung des-Parameters. Wenn dies positiv ist, wird der-Parameter rechtsbündig ausgerichtet. Wenn der Wert negativ ist, wird er linksbündig ausgerichtet.|
|:*Format Zeichenfolge*|Eine standardmäßige oder benutzerdefinierte Format Zeichenfolge, die vom-Parameter unterstützt wird.|

> [!NOTE]
>  Informationen zu den standardmäßigen und benutzerdefinierten Format Zeichenfolgen, die mit Datums-und Uhrzeitwerten verwendet werden, finden Sie unter Standardformat Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md) Informationen zu den standardmäßigen [und benutzerdefinierten](~/docs/standard/base-types/custom-numeric-format-strings.md)Formatierungs Zeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [standardmäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und Informationen zu den Standardformat Zeichenfolgen für-Enumerationen finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).

 Der `provider`-Parameter gibt eine <xref:System.IFormatProvider> Implementierung an, die Formatierungsinformationen für `arg0` und `arg1`bereitstellen kann. `provider` kann eine der folgenden Formen haben:

-   Ein <xref:System.Globalization.CultureInfo>-Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.

-   Ein <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Formatierungsinformationen für `arg0` oder `arg1` bereitstellt, wenn es sich um numerische Werte handelt.

-   Ein <xref:System.Globalization.DateTimeFormatInfo> Objekt, das kulturspezifische Formatierungsinformationen für `arg0`, `arg1`oder `arg2` bereitstellt, wenn diese Datums-und Uhrzeitwerte sind.

-   Eine benutzerdefinierte <xref:System.IFormatProvider> Implementierung, die Formatierungsinformationen für `arg0`, `arg1`und `arg2`bereitstellt. In der Regel implementiert eine solche Implementierung auch die <xref:System.ICustomFormatter>-Schnittstelle.

 Wenn der `provider`-Parameter `null`ist, werden Format Anbieter Informationen aus der aktuellen Kultur abgerufen.

 `arg0`, `arg1`und `arg2` stellen die zu formatierenden Objekte dar. Jedes Format Element in `format` wird durch die Zeichen folgen Darstellung des Objekts ersetzt, das über den entsprechenden Index verfügt. Wenn das Format Element `formatString` enthält und das entsprechende Argument die <xref:System.IFormattable> Schnittstelle implementiert, definiert die `ToString(formatString, provider)`-Methode des Arguments die Formatierung. Andernfalls definiert die `ToString()`-Methode des Arguments die Formatierung.



## Examples
 Im folgenden Beispiel wird die <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>-Methode verwendet, um das Ergebnis eines booleschen `And` Vorgangs mit ganzzahligen Werten zu veranschaulichen. Beachten Sie, dass die Format Zeichenfolge sechs Format Elemente enthält, die-Methode jedoch nur drei Elemente in der Argumentliste aufweist, da jedes Element auf zwei verschiedene Arten formatiert ist.

 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.

Oder

Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich 3 (drei).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Gewusst wie: Definieren und Verwenden von benutzerdefinierten numerischen Formatanbietern</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Das als Trennlinie zu verwendende Zeichen. <paramref name="separator" /> ist in den verknüpften Zeichenfolgen nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</param>
        <param name="values">Ein Array, das die zu verkettenden Zeichenfolgen enthält, die an die aktuelle Instanz des Zeichenfolgen-Generators angefügt werden sollen.</param>
        <summary>Verkettet die Zeichenfolgendarstellungen der Elemente im bereitgestellten Array von Objekten, wobei das angegebene als Trennzeichen zu verwendende Zeichen zwischen den einzelnen Elementen verwendet wird, und fügt dann das Ergebnis an die aktuelle Instanz des Zeichenfolgen-Generators an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Das als Trennlinie zu verwendende Zeichen. <paramref name="separator" /> ist in den verknüpften Zeichenfolgen nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</param>
        <param name="values">Ein Array, das die zu verkettenden Zeichenfolgen enthält, die an die aktuelle Instanz des Zeichenfolgen-Generators angefügt werden sollen.</param>
        <summary>Verkettet die Zeichenfolgen des bereitgestellten Arrays, wobei das angegebene als Trennzeichen zu verwendende Zeichen zwischen den einzelnen Zeichenfolgen verwendet wird, und fügt dann das Ergebnis an die aktuelle Instanz des Zeichenfolgen-Generators an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <paramref name="separator" /> ist in den verknüpften Zeichenfolgen nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</param>
        <param name="values">Ein Array, das die zu verkettenden Zeichenfolgen enthält, die an die aktuelle Instanz des Zeichenfolgen-Generators angefügt werden sollen.</param>
        <summary>Verkettet die Zeichenfolgendarstellungen der Elemente im bereitgestellten Array von Objekten, wobei das angegebene Trennzeichen zwischen den einzelnen Elementen verwendet wird, und fügt dann das Ergebnis an die aktuelle Instanz des Zeichenfolgen-Generators an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <paramref name="separator" /> ist in den verknüpften Zeichenfolgen nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</param>
        <param name="values">Ein Array, das die zu verkettenden Zeichenfolgen enthält, die an die aktuelle Instanz des Zeichenfolgen-Generators angefügt werden sollen.</param>
        <summary>Verkettet die Zeichenfolgen des bereitgestellten Arrays, wobei das angegebene Trennzeichen zwischen den einzelnen Zeichenfolgen verwendet wird, und fügt dann das Ergebnis an die aktuelle Instanz des Zeichenfolgen-Generators an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Member von <paramref name="values" />.</typeparam>
        <param name="separator">Das als Trennlinie zu verwendende Zeichen. <paramref name="separator" /> ist in den verketteten und angefügten Zeichenfolgen nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</param>
        <param name="values">Eine Sammlung, die die zu verkettenden Objekte enthält, die an die aktuelle Instanz des Zeichenfolgen-Generators angefügt werden sollen.</param>
        <summary>Verkettet die Elemente einer Sammlung und fügt diese an, wobei das angegebene als Trennzeichen zu verwendende Zeichen zwischen den einzelnen Elementen verwendet wird.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Member von <paramref name="values" />.</typeparam>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <paramref name="separator" /> ist in den verketteten und angefügten Zeichenfolgen nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</param>
        <param name="values">Eine Sammlung, die die zu verkettenden Objekte enthält, die an die aktuelle Instanz des Zeichenfolgen-Generators angefügt werden sollen.</param>
        <summary>Verkettet die Elemente einer Sammlung und fügt diese an, wobei das Trennzeichen zwischen den einzelnen Elementen verwendet wird.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt das Standardzeilenabschlusszeichen oder eine Kopie der angegebenen Zeichenfolge und das Standardzeilenabschlusszeichen am Ende dieser Instanz an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fügt das Standardzeilenabschlusszeichen am Ende des aktuellen <see cref="T:System.Text.StringBuilder" />-Objekts an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das standardmäßige Zeilen Abschluss Zeichen ist der aktuelle Wert der <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>-Eigenschaft.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendLine%2A> Methode.

 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Die anzufügende Zeichenfolge.</param>
        <summary>Fügt eine Kopie der angegebenen Zeichenfolge gefolgt vom Standardzeilenabschlusszeichen am Ende des aktuellen <see cref="T:System.Text.StringBuilder" />-Objekts an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das standardmäßige Zeilen Abschluss Zeichen ist der aktuelle Wert der <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>-Eigenschaft.

 Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <see cref="T:System.Text.StringBuilder" /> Objekt durch Aufrufen des <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der <see cref="P:System.Text.StringBuilder.MaxCapacity" />-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> zum Anfügen kleiner Zeichen folgen aufzurufen.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höchstanzahl von Zeichen ab, die im durch die aktuelle Instanz reservierten Speicher enthalten sein können, oder legt diese fest.</summary>
        <value>Die Höchstanzahl von Zeichen, die im durch die aktuelle Instanz reservierten Speicher enthalten sein können. Der Wert kann zwischen <see cref="P:System.Text.StringBuilder.Length" /> und <see cref="P:System.Text.StringBuilder.MaxCapacity" /> liegen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Capacity%2A> wirkt sich nicht auf den Zeichen folgen Wert der aktuellen Instanz aus. <xref:System.Text.StringBuilder.Capacity%2A> können verringert werden, solange Sie nicht kleiner als <xref:System.Text.StringBuilder.Length%2A>ist.

 Der <xref:System.Text.StringBuilder> weist bei Bedarf dynamisch mehr Speicherplatz zu und erhöht <xref:System.Text.StringBuilder.Capacity%2A> entsprechend. Aus Leistungsgründen kann eine <xref:System.Text.StringBuilder> mehr Arbeitsspeicher zuweisen als benötigt. Die zugeordnete Menge an Arbeitsspeicher ist Implementierungs spezifisch.



## Examples
 Im folgenden Beispiel wird die <xref:System.Text.StringBuilder.Capacity%2A>-Eigenschaft veranschaulicht.

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen SET-Vorgang angegebene Wert ist kleiner als die aktuelle Länge dieser Instanz.

 Oder

 Der für einen SET-Vorgang angegebene Wert ist größer als die maximale Kapazität.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Die Position des Zeichens.</param>
        <summary>Ruft das Zeichen an der angegebenen Zeichenposition in dieser Instanz ab oder legt dieses fest.</summary>
        <value>Das Unicode-Zeichen an der Position <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der `index`-Parameter ist die Position eines Zeichens innerhalb der <xref:System.Text.StringBuilder>. Das erste Zeichen in der Zeichenfolge ist am Index 0. Die Länge einer Zeichenfolge entspricht der Anzahl der enthaltenen Zeichen. Das letzte zugreif bare Zeichen einer <xref:System.Text.StringBuilder> Instanz ist am Index <xref:System.Text.StringBuilder.Length%2A>-1.

 <xref:System.Text.StringBuilder.Chars%2A> ist die Standard Eigenschaft der <xref:System.Text.StringBuilder>-Klasse. In C#handelt es sich um einen Indexer. Dies bedeutet, dass einzelne Zeichen aus der <xref:System.Text.StringBuilder.Chars%2A>-Eigenschaft abgerufen werden können, wie im folgenden Beispiel gezeigt, das die Anzahl der alphabetischen Zeichen, Leerzeichen und Interpunktions Zeichen in einer Zeichenfolge zählt.

 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]

### <a name="performance-and-character-based-indexing"></a>Leistung und zeichenbasierte Indizierung

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt beim Festlegen eines Zeichens außerhalb des Bereichs dieser Instanz.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> liegt beim Abrufen eines Zeichens außerhalb des Bereichs dieser Instanz.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Zeichen aus der aktuellen <see cref="T:System.Text.StringBuilder" />-Instanz.</summary>
        <returns>Ein Objekt, dessen <see cref="P:System.Text.StringBuilder.Length" /> 0 (null) ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.Text.StringBuilder.Clear%2A> ist eine bequeme Methode, die dem Festlegen der <xref:System.Text.StringBuilder.Length%2A>-Eigenschaft der aktuellen Instanz auf 0 (null) entspricht.

## Examples

Im folgenden Beispiel wird ein <xref:System.Text.StringBuilder>-Objekt mit einer Zeichenfolge instanziiert, die <xref:System.Text.StringBuilder.Clear%2A>-Methode aufgerufen und dann eine neue Zeichenfolge angefügt.

[!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
[!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Die Anfangsposition in dieser Instanz, ab der Zeichen kopiert werden. Der Index ist nullbasiert.</param>
        <param name="destination">Die schreibbare Spanne, in die Zeichen kopiert werden.</param>
        <param name="count">Die Anzahl der zu kopierenden Zeichen.</param>
        <summary>Kopiert die Zeichen aus einem angegebenen Segment dieser Instanz in eine Ziel-<see cref="T:System.Char" />-Spanne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.CopyTo%2A>-Methode soll in seltenen Situationen verwendet werden, in denen Sie aufeinander folgende Abschnitte eines <xref:System.Text.StringBuilder> Objekts in eine Spanne kopieren müssen.

 Die Anwendung kann z. b. ein <xref:System.Text.StringBuilder> Objekt mit einer großen Anzahl von Zeichen auffüllen und dann die <xref:System.Text.StringBuilder.CopyTo%2A>-Methode verwenden, um kleine, aufeinander folgende Teile des <xref:System.Text.StringBuilder> Objekts in eine Spanne zu kopieren, in der die Teile verarbeitet werden. Wenn alle Daten im <xref:System.Text.StringBuilder> Objekt verarbeitet werden, wird die Größe des <xref:System.Text.StringBuilder> Objekts auf 0 (null) festgelegt, und der Cycle wird wiederholt.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.Char[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Die Anfangsposition in dieser Instanz, ab der Zeichen kopiert werden. Der Index ist nullbasiert.</param>
        <param name="destination">Das Array, in das Zeichen kopiert werden.</param>
        <param name="destinationIndex">Die Anfangsposition in <paramref name="destination" />, an die Zeichen kopiert werden. Der Index ist nullbasiert.</param>
        <param name="count">Die Anzahl der zu kopierenden Zeichen.</param>
        <summary>Kopiert die Zeichen aus einem angegebenen Segment dieser Instanz in ein angegebenes Segment eines Ziel-<see cref="T:System.Char" />-Arrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.StringBuilder.CopyTo%2A>-Methode soll in seltenen Situationen verwendet werden, in denen Sie aufeinander folgende Abschnitte eines <xref:System.Text.StringBuilder> Objekts effizient in ein Array kopieren müssen. Das Array muss eine festgelegte Größe, eine vorab Zuordnung, eine wiederverwendbare und möglicherweise Global zugänglich sein.

 Die Anwendung kann z. b. ein <xref:System.Text.StringBuilder> Objekt mit einer großen Anzahl von Zeichen auffüllen und dann die <xref:System.Text.StringBuilder.CopyTo%2A>-Methode verwenden, um kleine, aufeinander folgende Teile des <xref:System.Text.StringBuilder> Objekts in ein Array zu kopieren, in dem die Teile verarbeitet werden. Wenn alle Daten im <xref:System.Text.StringBuilder> Objekt verarbeitet werden, wird die Größe des <xref:System.Text.StringBuilder> Objekts auf 0 (null) festgelegt, und der Cycle wird wiederholt.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.CopyTo%2A> Methode.

 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />, <paramref name="destinationIndex" /> oder <paramref name="count" /> ist kleiner als 0 (null).

Oder

 <paramref name="sourceIndex" /> ist größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> + <paramref name="count" /> ist größer als die Länge dieser Instanz.

Oder

 <paramref name="destinationIndex" /> + <paramref name="count" /> ist größer als die Länge von <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die Mindestkapazität, die gewährleistet sein muss.</param>
        <summary>Stellt sicher, dass die Kapazität dieser Instanz von <see cref="T:System.Text.StringBuilder" /> mindestens gleich dem angegebenen Wert ist.</summary>
        <returns>Die neue Kapazität dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn die aktuelle Kapazität kleiner als der `capacity`-Parameter ist, wird der Arbeitsspeicher für diese Instanz neu zugeordnet, um mindestens `capacity` Anzahl von Zeichen zu enthalten. Andernfalls wird kein Arbeitsspeicher geändert.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.EnsureCapacity%2A> Methode.

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als 0 (null).

Oder

Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="span">Die Zeichenspanne, die mit der aktuellen Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die Zeichen in dieser Instanz den Zeichen in einer angegebenen schreibgeschützten Zeichenspanne entsprechen.</summary>
        <returns><see langword="true" />, wenn die Zeichen in dieser Instanz und in <paramref name="span" /> identisch sind; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die `Equals`-Methode führt einen Ordinalvergleich durch, um zu bestimmen, ob die Zeichen in der aktuellen Instanz und `span` gleich sind.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">Ein Objekt, das mit dieser Instanz verglichen werden soll, oder <see langword="null" />.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz mit einem angegebenen Objekt übereinstimmt.</summary>
        <returns><see langword="true" />, wenn diese Instanz und <paramref name="sb" /> die gleichen Zeichenfolgenwerte sowie die gleichen Werte für <see cref="P:System.Text.StringBuilder.Capacity" /> und <see cref="P:System.Text.StringBuilder.MaxCapacity" /> enthalten, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

**.NET Framework und .net Core 2,2 und frühere Versionen:** Die aktuelle Instanz und `sb` sind gleich, wenn Sie über die gleichen Werte für Zeichen folgen, <xref:System.Text.StringBuilder.Capacity>und <xref:System.Text.StringBuilder.MaxCapacity> verfügen. Die `Equals`-Methode verwendet einen Ordinalvergleich, um zu bestimmen, ob die Zeichen folgen gleich sind.

**.Net Core 3,0 und höhere Versionen:** Die aktuelle Instanz und die `sb` sind gleich, wenn die Zeichen folgen, die beiden <xref:System.Text.StringBuilder> Objekten zugewiesen sind, identisch sind.  Zum Bestimmen der Gleichheit verwendet die `Equals` Methode einen Ordinalvergleich. Die Eigenschaften Werte <xref:System.Text.StringBuilder.Capacity> und <xref:System.Text.StringBuilder.MaxCapacity> werden im Vergleich nicht verwendet.

## Examples
 Im folgenden Code wird die <xref:System.Text.StringBuilder.Equals%2A>-Methode verwendet, um zu überprüfen, ob zwei <xref:System.Text.StringBuilder>-Objekte gleich sind. Die-Methode wird wiederholt aufgerufen, nachdem an jedem Objekt kleine Änderungen vorgenommen wurden, und die Ergebnisse werden in der Konsole angezeigt.

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChunks">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder.ChunkEnumerator GetChunks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringBuilder/ChunkEnumerator GetChunks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.GetChunks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChunks () As StringBuilder.ChunkEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder::ChunkEnumerator GetChunks();" />
      <MemberSignature Language="F#" Value="member this.GetChunks : unit -&gt; System.Text.StringBuilder.ChunkEnumerator" Usage="stringBuilder.GetChunks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder+ChunkEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Objekt zurück, das zum Durchlaufen der Blöcke von Zeichen verwendet werden kann, die in einer <see langword="ReadOnlyMemory&lt;Char&gt;" />-Methode dargestellt werden, die aus dieser <see cref="T:System.Text.StringBuilder" />-Instanz erstellt wurde.</summary>
        <returns>Ein Enumerator für die Blöcke in <see langword="ReadOnlyMemory&lt;Char&gt;" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Sie können die Blöcke im Speicherbereich mit Code wie dem folgenden iterieren:

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
    foreach(char ch in chunk.Span)
        { /* operations on ch */ }
```

Der Zweck dieser Methode besteht darin, die Daten eines *Konstanten* <xref:System.Text.StringBuilder>effizient zu extrahieren. Wenn die <xref:System.Text.StringBuilder> geändert wird, während die Block Enumeration unvollständig ist, ist das Ergebnis nicht definiert. <xref:System.Text.StringBuilder> ist ebenfalls nicht Thread sicher, sodass der Betrieb mit gleichzeitigen Threads unzulässig ist.

Es ist nicht garantiert, dass die zurückgegebenen <xref:System.ReadOnlyMemory%601> Blöcke unverändert bleiben, wenn die <xref:System.Text.StringBuilder> geändert wird, sodass Sie Sie nicht für die spätere Verwendung Zwischenspeichern.

Wenn Sie einen <xref:System.ReadOnlySpan%601> aus einem <xref:System.ReadOnlyMemory%601> erstellen (wie die <xref:System.ReadOnlyMemory%601.Span?displayProperty=nameWithType>-Methode im vorherigen Beispiel ist), ist es aufwändig. Erstellen Sie daher eine lokale Variable für die Spanne, wenn Sie Sie in einer `for` Anweisung in einer verwenden müssen. Beispiel:

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
{
    var span = chunk.Span;
    for(int i = 0; i < span.Length; i++)
    {
        /* operations on span[i] */
    }
}
```

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Objekts an einer angegebenen Zeichenposition in diese Instanz ein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines booleschen Werts an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichen folgen Darstellung `value`zu erhalten. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen haben Aufrufe dieser Methode eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst, wenn durch das Einfügen <paramref name="value" /> die Gesamtlänge des Objekts <see cref="P:System.Text.StringBuilder.MaxCapacity" />überschreiten würde. Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]löst die-Methode eine <see cref="T:System.OutOfMemoryException" />aus.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 8-Bit-Ganzzahl ohne Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichen folgen Darstellung `value`zu erhalten. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen haben Aufrufe dieser Methode eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst, wenn durch das Einfügen <paramref name="value" /> die Gesamtlänge des Objekts <see cref="P:System.Text.StringBuilder.MaxCapacity" />überschreiten würde. Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]löst die-Methode eine <see cref="T:System.OutOfMemoryException" />aus.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Unicode-Zeichens an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichen folgen Darstellung `value`zu erhalten. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.

Oder

Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Das einzufügende Zeichenarray.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Arrays von Unicode-Zeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 Wenn `value` `null`ist, wird die <xref:System.Text.StringBuilder> nicht geändert.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.

Oder

Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer Dezimalzahl an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichen folgen Darstellung `value`zu erhalten. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen haben Aufrufe dieser Methode eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst, wenn durch das Einfügen <paramref name="value" /> die Gesamtlänge des Objekts <see cref="P:System.Text.StringBuilder.MaxCapacity" />überschreiten würde. Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]löst die-Methode eine <see cref="T:System.OutOfMemoryException" />aus.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer Gleitkommazahl mit doppelter Genauigkeit an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichen folgen Darstellung `value`zu erhalten. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen haben Aufrufe dieser Methode eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst, wenn durch das Einfügen <paramref name="value" /> die Gesamtlänge des Objekts <see cref="P:System.Text.StringBuilder.MaxCapacity" />überschreiten würde. Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]löst die-Methode eine <see cref="T:System.OutOfMemoryException" />aus.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 16-Bit-Ganzzahl mit Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichen folgen Darstellung `value`zu erhalten. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen haben Aufrufe dieser Methode eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst, wenn durch das Einfügen <paramref name="value" /> die Gesamtlänge des Objekts <see cref="P:System.Text.StringBuilder.MaxCapacity" />überschreiten würde. Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]löst die-Methode eine <see cref="T:System.OutOfMemoryException" />aus.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 32-Bit-Ganzzahl mit Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichen folgen Darstellung `value`zu erhalten. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen haben Aufrufe dieser Methode eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst, wenn durch das Einfügen <paramref name="value" /> die Gesamtlänge des Objekts <see cref="P:System.Text.StringBuilder.MaxCapacity" />überschreiten würde. Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]löst die-Methode eine <see cref="T:System.OutOfMemoryException" />aus.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer 64-Bit-Ganzzahl mit Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichen folgen Darstellung `value`zu erhalten. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen haben Aufrufe dieser Methode eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst, wenn durch das Einfügen <paramref name="value" /> die Gesamtlänge des Objekts <see cref="P:System.Text.StringBuilder.MaxCapacity" />überschreiten würde. Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]löst die-Methode eine <see cref="T:System.OutOfMemoryException" />aus.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Das einzufügende Objekt oder <see langword="null" />.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines Objekts an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichen folgen Darstellung `value`zu erhalten. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 Wenn `value` `null`ist, wird der Wert dieser Instanz unverändert.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen haben Aufrufe dieser Methode eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst, wenn durch das Einfügen <paramref name="value" /> die Gesamtlänge des Objekts <see cref="P:System.Text.StringBuilder.MaxCapacity" />überschreiten würde. Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]löst die-Methode eine <see cref="T:System.OutOfMemoryException" />aus.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Die einzufügende Zeichenspanne.</param>
        <summary>Fügt die Sequenz von Zeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die vorhandenen Zeichen werden verschoben, um Platz für die Zeichenfolge in der `value` zu schaffen, um Sie einzufügen. Die Kapazität wird nach Bedarf angepasst.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 8-Bit-Ganzzahl mit Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichen folgen Darstellung `value`zu erhalten. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen haben Aufrufe dieser Methode eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst, wenn durch das Einfügen <paramref name="value" /> die Gesamtlänge des Objekts <see cref="P:System.Text.StringBuilder.MaxCapacity" />überschreiten würde. Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]löst die-Methode eine <see cref="T:System.OutOfMemoryException" />aus.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer Gleitkommazahl mit einfacher Genauigkeit an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichen folgen Darstellung `value`zu erhalten. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen haben Aufrufe dieser Methode eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst, wenn durch das Einfügen <paramref name="value" /> die Gesamtlänge des Objekts <see cref="P:System.Text.StringBuilder.MaxCapacity" />überschreiten würde. Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]löst die-Methode eine <see cref="T:System.OutOfMemoryException" />aus.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Die einzufügende Zeichenfolge.</param>
        <summary>Fügt eine Zeichenfolge an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität wird nach Bedarf angepasst.

 Diese Instanz von <xref:System.Text.StringBuilder> wird nicht geändert, wenn `value` `null`ist, oder `value` nicht `null`, aber die Länge ist 0 (null).



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die aktuelle Länge dieser Instanz.

Oder

Die aktuelle Länge dieses <see cref="T:System.Text.StringBuilder" />-Objekts plus die Länge von <paramref name="value" /> überschreiten <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer 16-Bit-Ganzzahl ohne Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichen folgen Darstellung `value`zu erhalten. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen haben Aufrufe dieser Methode eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst, wenn durch das Einfügen <paramref name="value" /> die Gesamtlänge des Objekts <see cref="P:System.Text.StringBuilder.MaxCapacity" />überschreiten würde. Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]löst die-Methode eine <see cref="T:System.OutOfMemoryException" />aus.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer 32-Bit-Ganzzahl ohne Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichen folgen Darstellung `value`zu erhalten. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen haben Aufrufe dieser Methode eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst, wenn durch das Einfügen <paramref name="value" /> die Gesamtlänge des Objekts <see cref="P:System.Text.StringBuilder.MaxCapacity" />überschreiten würde. Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]löst die-Methode eine <see cref="T:System.OutOfMemoryException" />aus.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer 64-Bit-Ganzzahl ohne Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichen folgen Darstellung `value`zu erhalten. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen haben Aufrufe dieser Methode eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst, wenn durch das Einfügen <paramref name="value" /> die Gesamtlänge des Objekts <see cref="P:System.Text.StringBuilder.MaxCapacity" />überschreiten würde. Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]löst die-Methode eine <see cref="T:System.OutOfMemoryException" />aus.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Die einzufügende Zeichenfolge.</param>
        <param name="count">Die Anzahl der Einfügewiederholungen für <paramref name="value" />.</param>
        <summary>Fügt eine oder mehrere Kopien einer angegebenen Zeichenfolge an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.

 Dieses <xref:System.Text.StringBuilder> Objekt wird nicht geändert, wenn `value` `null`ist, `value` nicht `null`, aber seine Länge 0 (null) ist, oder `count` gleich 0 (null) ist.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer als die aktuelle Länge dieser Instanz.

Oder

 <paramref name="count" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.OutOfMemoryException">Die aktuelle Länge dieses <see cref="T:System.Text.StringBuilder" />-Objekts plus die Länge von <paramref name="value" /> multipliziert mit <paramref name="count" /> überschreitet <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Ein Zeichenarray.</param>
        <param name="startIndex">Der Startindex in <paramref name="value" />.</param>
        <param name="charCount">Die Anzahl der einzufügenden Zeichen.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Unterarrays von Unicode-Zeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird nach Bedarf angepasst.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />, und <paramref name="startIndex" /> und <paramref name="charCount" /> sind nicht 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />, <paramref name="startIndex" /> oder <paramref name="charCount" /> ist kleiner als 0 (null).

Oder

 <paramref name="index" /> ist größer als die Länge dieser Instanz.

Oder

 <paramref name="startIndex" /> plus <paramref name="charCount" /> ist keine Position in <paramref name="value" />.

Oder

Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge des aktuellen <see cref="T:System.Text.StringBuilder" />-Objekts ab oder legt diese fest.</summary>
        <value>Die Länge dieser Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die Länge eines <xref:System.Text.StringBuilder> Objekts wird durch die Anzahl von <xref:System.Char> Objekten definiert.

 Wie die <xref:System.String.Length%2A?displayProperty=nameWithType>-Eigenschaft gibt die <xref:System.Text.StringBuilder.Length%2A>-Eigenschaft die Länge des aktuellen Zeichen folgen Objekts an. Anders als bei der <xref:System.String.Length%2A?displayProperty=nameWithType>-Eigenschaft, die schreibgeschützt ist, können Sie mit der <xref:System.Text.StringBuilder.Length%2A>-Eigenschaft die Länge der Zeichenfolge ändern, die in das <xref:System.Text.StringBuilder>-Objekt gespeichert wird.

 Wenn die angegebene Länge kleiner als die aktuelle Länge ist, wird das aktuelle <xref:System.Text.StringBuilder> Objekt auf die angegebene Länge gekürzt. Wenn die angegebene Länge größer als die aktuelle Länge ist, wird das Ende des Zeichen folgen Werts des aktuellen <xref:System.Text.StringBuilder> Objekts mit dem Unicode-Zeichen NULL (U + 0000) aufgefüllt.

 Wenn die angegebene Länge größer als die aktuelle Kapazität ist, <xref:System.Text.StringBuilder.Capacity%2A> vergrößert, sodass Sie größer oder gleich der angegebenen Länge ist.



## Examples
 Im folgenden Beispiel wird die <xref:System.Text.StringBuilder.Length%2A>-Eigenschaft veranschaulicht.

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen Set-Vorgang angegebene Wert ist kleiner als 0 (null) oder größer als <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Kapazität dieser Instanz ab.</summary>
        <value>Die Höchstanzahl von Zeichen, die diese Instanz enthalten kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die maximale Kapazität für diese Implementierung ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Dieser Wert ist jedoch Implementierungs spezifisch und unterscheidet sich möglicherweise in anderen Implementierungen von oder höher. Sie können die maximale Kapazität eines <xref:System.Text.StringBuilder> Objekts explizit festlegen, indem Sie den <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>-Konstruktor aufrufen.

Wenn Sie in .net Core und in den .NET Framework 4,0 und höheren Versionen das <xref:System.Text.StringBuilder> Objekt durch Aufrufen des <xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)>-Konstruktors instanziieren, können sowohl die Länge als auch die Kapazität der <xref:System.Text.StringBuilder> Instanz über den Wert der <xref:System.Text.StringBuilder.MaxCapacity>-Eigenschaft hinaus zunehmen. Dies kann besonders dann vorkommen, wenn Sie die Methoden <xref:System.Text.StringBuilder.Append(System.String)> und <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> zum Anfügen kleiner Zeichen folgen aufzurufen.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Position in dieser Instanz, an der das Entfernen beginnt.</param>
        <param name="length">Die Anzahl der zu entfernenden Zeichen.</param>
        <summary>Entfernt den angegebenen Bereich von Zeichen aus dieser Instanz.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Ausschneidevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die aktuelle Methode entfernt den angegebenen Zeichenbereich aus der aktuellen Instanz. Die Zeichen an (`startIndex` + `length`) werden in `startIndex`verschoben, und der Zeichen folgen Wert der aktuellen Instanz wird durch `length`verkürzt. Die Kapazität der aktuellen Instanz ist nicht betroffen.

> [!NOTE]
>  Die <xref:System.Text.StringBuilder.Remove%2A>-Methode ändert den Wert der aktuellen <xref:System.Text.StringBuilder> Instanz und gibt diese Instanz zurück. Es wird kein neues <xref:System.Text.StringBuilder> Objekt erstellt und zurückgegeben.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Remove%2A> Methode.

 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wenn <paramref name="startIndex" /> oder <paramref name="length" /> kleiner als 0 (null) ist oder <paramref name="startIndex" /> + <paramref name="length" /> größer als die Länge dieser Instanz sind.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ersetzt alle Vorkommen eines angegebenen Zeichens bzw. einer angegebenen Zeichenfolge in dieser Instanz durch ein anderes Zeichen bzw. eine andere Zeichenfolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Das zu ersetzende Zeichen.</param>
        <param name="newChar">Das Zeichen, das <paramref name="oldChar" /> ersetzt.</param>
        <summary>Ersetzt in dieser Instanz alle Vorkommen eines angegebenen Zeichens durch ein anderes angegebenes Zeichen.</summary>
        <returns>Ein Verweis auf diese Instanz, bei der <paramref name="oldChar" /> durch <paramref name="newChar" /> ersetzt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode führt einen Vergleich unter Berücksichtigung der Groß-/Kleinschreibung durch, um die Vorkommen von `oldChar` in der aktuellen Instanz zu identifizieren. Die Größe der aktuellen <xref:System.Text.StringBuilder> Instanz bleibt nach der Ersetzung unverändert.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Replace%2A> Methode.

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Die zu ersetzende Zeichenfolge.</param>
        <param name="newValue">Die Zeichenfolge, die <paramref name="oldValue" /> ersetzt, oder <see langword="null" />.</param>
        <summary>Ersetzt in dieser Instanz alle Vorkommen einer angegebenen Zeichenfolge durch eine andere angegebene Zeichenfolge.</summary>
        <returns>Ein Verweis auf diese Instanz, bei der alle Vorkommen von <paramref name="oldValue" /> durch <paramref name="newValue" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode führt einen Vergleich unter Berücksichtigung der Groß-/Kleinschreibung durch, um die Vorkommen von `oldValue` in der aktuellen Instanz zu identifizieren. Wenn `newValue` `null` oder <xref:System.String.Empty?displayProperty=nameWithType>ist, werden alle Vorkommen von `oldValue` entfernt.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Replace%2A> Methode.

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="oldValue" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">Das zu ersetzende Zeichen.</param>
        <param name="newChar">Das Zeichen, das <paramref name="oldChar" /> ersetzt.</param>
        <param name="startIndex">Die Position in dieser Instanz, an der die Teilzeichenfolge beginnt.</param>
        <param name="count">Die Länge der Teilzeichenfolge.</param>
        <summary>Ersetzt alle Vorkommen eines angegebenen Zeichens in einer Teilzeichenfolge dieser Instanz durch ein anderes angegebenes Zeichen.</summary>
        <returns>Ein Verweis auf diese Instanz, bei der <paramref name="oldChar" /> im Bereich von <paramref name="newChar" /> bis <paramref name="startIndex" /><paramref name="startIndex" /> +  -1 durch <paramref name="count" /> ersetzt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode führt einen Vergleich unter Berücksichtigung der Groß-/Kleinschreibung durch, um die Vorkommen von `oldChar` in der aktuellen Instanz zu identifizieren. Die Größe des aktuellen <xref:System.Text.StringBuilder> Objekts bleibt nach der Ersetzung unverändert.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Replace%2A> Methode.

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> + <paramref name="count" /> ist größer als die Länge des Werts dieser Instanz.

Oder

 <paramref name="startIndex" /> oder <paramref name="count" /> ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">Die zu ersetzende Zeichenfolge.</param>
        <param name="newValue">Die Zeichenfolge, die <paramref name="oldValue" /> ersetzt, oder <see langword="null" />.</param>
        <param name="startIndex">Die Position in dieser Instanz, an der die Teilzeichenfolge beginnt.</param>
        <param name="count">Die Länge der Teilzeichenfolge.</param>
        <summary>Ersetzt alle Vorkommen einer angegebenen Zeichenfolge in einer Teilzeichenfolge dieser Instanz durch eine andere angegebene Zeichenfolge.</summary>
        <returns>Ein Verweis auf diese Instanz, bei der alle Instanzen von <paramref name="oldValue" /> im Bereich von <paramref name="newValue" /> bis <paramref name="startIndex" /><paramref name="startIndex" /> +  - 1 durch <paramref name="count" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode führt einen Vergleich unter Berücksichtigung der Groß-/Kleinschreibung durch, um Vorkommen von `oldValue` in der angegebenen Teil Zeichenfolge zu identifizieren. Wenn `newValue` `null` oder <xref:System.String.Empty?displayProperty=nameWithType>ist, werden alle Vorkommen von `oldValue` entfernt.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Replace%2A> Methode.

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="oldValue" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> oder <paramref name="count" /> ist kleiner als 0.

Oder

 <paramref name="startIndex" /> plus <paramref name="count" /> gibt eine Zeichenposition außerhalb dieser Instanz an.

Oder

Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="info">Das Objekt, das mit Serialisierungsinformationen aufgefüllt werden soll.</param>
        <param name="context">Der Ort zum Speichern und Abrufen von serialisierten Daten. Für die zukünftige Verwendung reserviert.</param>
        <summary>Füllt ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den Daten, die erforderlich sind, um das aktuelle <see cref="T:System.Text.StringBuilder" />-Objekt zu deserialisieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der `context`-Parameter ist für die zukünftige Verwendung reserviert und ist an diesem Vorgang nicht beteiligt.

 Weitere Informationen finden Sie unter der Methode <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType>.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert einer angegebenen <see cref="T:System.Text.StringBuilder" />-Klasse in eine <see cref="T:System.String" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in einen <see cref="T:System.String" />.</summary>
        <returns>Eine Zeichenfolge, deren Wert mit dieser Instanz übereinstimmt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Sie müssen die <xref:System.Text.StringBuilder.ToString%2A>-Methode aufrufen, um das <xref:System.Text.StringBuilder> Objekt in ein <xref:System.String>-Objekt zu konvertieren, bevor Sie die durch das <xref:System.Text.StringBuilder> Objekt dargestellte Zeichenfolge an eine Methode übergeben können, die einen <xref:System.String>-Parameter hat, oder Sie in der Benutzeroberfläche anzeigen.



## Examples
 Im folgenden Beispiel wird das Aufrufen der <xref:System.Text.StringBuilder.ToString%2A>-Methode veranschaulicht. Dieses Beispiel ist Teil eines größeren Beispiels, das für die <xref:System.Text.StringBuilder>-Klasse bereitgestellt wird.

 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die Anfangsposition der Teilzeichenfolge innerhalb dieser Instanz.</param>
        <param name="length">Die Länge der Teilzeichenfolge.</param>
        <summary>Konvertiert den Wert einer Teilzeichenfolge dieser Instanz in eine <see cref="T:System.String" />.</summary>
        <returns>Eine Zeichenfolge, deren Wert der angegebenen Teilzeichenfolge dieser Instanz entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Sie müssen die <xref:System.Text.StringBuilder.ToString%2A>-Methode aufrufen, um das <xref:System.Text.StringBuilder> Objekt in ein <xref:System.String>-Objekt zu konvertieren, bevor Sie die durch das <xref:System.Text.StringBuilder> Objekt dargestellte Zeichenfolge an eine Methode übergeben können, die einen <xref:System.String>-Parameter hat, oder Sie in der Benutzeroberfläche anzeigen.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.

Oder

Die Summe aus <paramref name="startIndex" /> und <paramref name="length" /> übersteigt die Länge der aktuellen Instanz.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
