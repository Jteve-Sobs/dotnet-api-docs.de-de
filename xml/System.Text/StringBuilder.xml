<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3809815cf1f1c75d067b9b02c2369b20eeaf52f0" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48742799" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine veränderbare Zeichenfolge dar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse stellt einen Zeichenfolge-ähnliches Objekt, dessen Wert eine veränderbare Sequenz von Zeichen dar.  
  
 In diesem Abschnitt  
  
-   [Die Zeichenfolge und StringBuilder-Typen](#StringAndSB)  
  
-   [Funktionsweise von "StringBuilder"](#HowWorks)  
  
-   [Speicherbelegung](#Memory)  
  
-   [Instanziieren eines StringBuilder-Objekts](#Instantiating)  
  
-   [Aufrufen von "StringBuilder"-Methoden](#Calling)  
  
-   [Ausführen von "StringBuilder"-Vorgängen](#Operations)  
  
    -   [Durchlaufen von "StringBuilder"-Zeichen](#Iterating)  
  
    -   [Hinzufügen von Text in ein StringBuilder-Objekt](#Adding)  
  
    -   [Löschen von Text aus einer StringBuilder-Objekts](#Deleting)  
  
    -   [Ändern den Text in ein StringBuilder-Objekt](#Modifying)  
  
-   [Suchen den Text in ein StringBuilder-Objekt](#Searching)  
  
-   [StringBuilder-Objekts konvertieren in eine Zeichenfolge](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>Die Zeichenfolge und StringBuilder-Typen  
 Obwohl <xref:System.Text.StringBuilder> und <xref:System.String> beide Sequenzen darstellen von Zeichen, sie unterschiedlich implementiert sind. <xref:System.String> ist ein unveränderlicher Typ an. D. h. jeder Vorgang, der angezeigt wird, so ändern Sie eine <xref:System.String> Objekt tatsächlich eine neue Zeichenfolge erstellt.  
  
 Z. B. der Aufruf der <xref:System.String.Concat%2A?displayProperty=nameWithType> -Methode in der folgenden C#-Beispiel wird angezeigt, zum Ändern des Werts, der eine String-Variable, die mit dem Namen `value`. In der Tat die <xref:System.String.Concat%2A> Methode gibt eine `value` Objekt mit einem anderen Wert und einer Adresse aus der `value` -Objekt, das an die Methode übergeben wurde. Beachten Sie, dass das Beispiel kompiliert werden muss, mit der `/unsafe` -Compileroption.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 Für die Routinen, die umfangreiche zeichenfolgenbearbeitung (z. B. apps, die eine Zeichenfolge mehrere Male in einer Schleife ändern) ausführen, kann wiederholt Ändern einer Zeichenfolge beträchtliche Leistungseinbußen genauer. Die Alternative ist die Verwendung <xref:System.Text.StringBuilder>, der eine veränderbare Zeichenfolge-Klasse ist. Veränderlichkeit bedeutet, dass eine Instanz der Klasse erstellt wurde, geändert werden können durch Anfügen, entfernen, ersetzen oder Einfügen von Zeichen. Ein <xref:System.Text.StringBuilder> -Objekt verwaltet einen Puffer zur Aufnahme von Erweiterungen in der Zeichenfolge. Neue Daten werden in den Puffer angefügt, wenn Platz verfügbar ist; andernfalls ein neuen Puffer zugeordnet ist, Daten aus dem ursprünglichen Puffer in den neuen Puffer kopiert und die neuen Daten dann in den neuen Puffer angehängt ist.  
  
> [!IMPORTANT]
>  Obwohl die <xref:System.Text.StringBuilder> -Klasse bietet im Allgemeinen eine bessere Leistung als die <xref:System.String> -Klasse, Sie nicht automatisch als Ersatz für <xref:System.String> mit <xref:System.Text.StringBuilder> jedes Mal, wenn Zeichenfolgen bearbeitet werden sollen. Leistung hängt von der Größe der Zeichenfolge, die Menge an Arbeitsspeicher, die für die neue Zeichenfolge, das System, in dem Ihre app ausgeführt wird, und der Typ des Vorgangs zugeordnet werden. Sie sollten darauf vorbereitet sein, testen Sie Ihre app aus, um zu bestimmen, ob <xref:System.Text.StringBuilder> bietet eine deutliche leistungsverbesserung.  
  
 Erwägen Sie die Verwendung der <xref:System.String> Klasse, die unter diesen Bedingungen:  
  
-   Wenn die Anzahl der Änderungen, die Ihre app in eine Zeichenfolge machen klein ist. In diesen Fällen <xref:System.Text.StringBuilder> möglicherweise geringfügig Angebot oder keine leistungsverbesserung gegenüber <xref:System.String>.  
  
-   Wenn Sie eine feste Anzahl von Verkettungsvorgänge, insbesondere bei Zeichenfolgenliteralen ausführen. In diesem Fall kann der Compiler die Verkettungsvorgänge in einem Vorgang kombiniert werden.  
  
-   Wenn Sie umfangreiche Suchoperationen auszuführen, während Sie Ihre Zeichenfolge erstellen müssen. Die <xref:System.Text.StringBuilder> Klasse fehlt Suchmethoden wie z. B. `IndexOf` oder `StartsWith`. Müssen Sie zum Konvertieren der <xref:System.Text.StringBuilder> -Objekt an eine <xref:System.String> für diese Vorgänge, wodurch sich der Leistungsvorteil von der Verwendung zunichte <xref:System.Text.StringBuilder>. Weitere Informationen finden Sie unter den [Durchsuchen den Text eines StringBuilder-Objekts](#Searching) Abschnitt.  
  
 Erwägen Sie die Verwendung der <xref:System.Text.StringBuilder> Klasse, die unter diesen Bedingungen:  
  
-   Wenn Sie erwarten, dass Ihre app eine unbekannte Anzahl von Änderungen an einer Zeichenfolge vornehmen, zur Entwurfszeit (z. B., wenn Sie mithilfe eine Schleife um eine zufällige Zahl von Zeichenfolgen zu verketten, die eine Benutzereingabe enthalten).  
  
-   Wenn Sie Ihre app eine erhebliche Anzahl von Änderungen an einer Zeichenfolge vornehmen erwarten.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>Funktionsweise von "StringBuilder"  
 Die <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> Eigenschaft gibt die Anzahl von Zeichen an der <xref:System.Text.StringBuilder> Objekt derzeit enthält. Wenn Sie Zeichen hinzufügen der <xref:System.Text.StringBuilder> Objekt, seine Länge erhöht, bis es die Größe der gleich der <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> Eigenschaft, die die Anzahl der Zeichen definiert, die das Objekt enthalten kann. Wenn die Anzahl der hinzugefügten Zeichen bewirkt, die Länge des dass der <xref:System.Text.StringBuilder> Objekt überschreitet die aktuelle Kapazität, die neue Arbeitsspeicher zugewiesen wurde, ist den Wert des der <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft verdoppelt, neue Zeichen hinzugefügt werden die <xref:System.Text.StringBuilder> -Objekt und seine <xref:System.Text.StringBuilder.Length%2A>Eigenschaft angepasst wird. Zusätzlicher Arbeitsspeicher für die <xref:System.Text.StringBuilder> Objekt wird dynamisch zugeordnet, bis sie den Wert erreicht die <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> Eigenschaft. Wenn die maximale Kapazität erreicht ist, kann keine weiteren Arbeitsspeicher belegt werden, für die <xref:System.Text.StringBuilder> -Objekt, und versuchen, zu Zeichen hinzufügen oder erweitern ihn über seine maximale Kapazität, die ausgelöst werden, entweder eine <xref:System.ArgumentOutOfRangeException> oder <xref:System.OutOfMemoryException> Ausnahme.  
  
 Im folgende Beispiel wird veranschaulicht, wie eine <xref:System.Text.StringBuilder> Objekt weist neuen Speicher und seine Kapazität dynamisch erhöht, wenn die Zeichenfolge, die dem Objekt zugewiesenen erweitert wird. Der Code erstellt eine <xref:System.Text.StringBuilder> -Objekt durch Aufrufen von seinem (parameterlosen) Standardkonstruktor. Die Standardkapazität dieses Objekt ist 16 Zeichen ein, und die maximale Kapazität ist mehr als 2 Milliarden-Zeichen. Anfügen der Zeichenfolge "Dies ist ein Satz an." führt eine neue speicherbelegung, da die Länge der Zeichenfolge (19 Zeichen) über die Standardkapazität überschreitet die <xref:System.Text.StringBuilder> Objekt. Die Kapazität des Objekts verdoppelt, bis 32 Zeichen, die neue Zeichenfolge hinzugefügt wird und die Länge des Objekts entspricht nun 19 Zeichen. Der Code fügt dann die Zeichenfolge "This is einen zusätzlichen Satz an." auf den Wert des der <xref:System.Text.StringBuilder> 11 Mal Objekt. Jedes Mal, wenn der Vorgang wird die Länge des der <xref:System.Text.StringBuilder> Objekt, das die die vorhandene Kapazität übersteigt, verdoppelt und die <xref:System.Text.StringBuilder.Append%2A> Vorgang erfolgreich ausgeführt wird.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>Speicherbelegung  
 Die Standardkapazität ein <xref:System.Text.StringBuilder> Objekt ist 16 Zeichen ein, und die standardmäßige maximale Kapazität ist <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Diese Standardwerte werden verwendet, wenn Sie beim Aufrufen der <xref:System.Text.StringBuilder.%23ctor> und <xref:System.Text.StringBuilder.%23ctor%28System.String%29> Konstruktoren.  
  
 Sie können explizit die Anfangskapazität der definieren eine <xref:System.Text.StringBuilder> Objekt auf folgende Weise:  
  
-   Durch das Aufrufen einer von der <xref:System.Text.StringBuilder> Konstruktoren, die enthält eine `capacity` Parameter an, wenn Sie das Objekt zu erstellen.  
  
-   Durch Zuweisen von explizit einen neuen Wert der <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> zu einer vorhandenen erweiternde Eigenschaft <xref:System.Text.StringBuilder> Objekt. Beachten Sie, dass die Eigenschaft eine Ausnahme auslöst, wenn die neue Kapazität kleiner als die vorhandene Kapazität oder größer als die <xref:System.Text.StringBuilder> maximale Kapazität des Objekts.  
  
-   Durch Aufrufen der <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> Methode mit der neuen Kapazität. Die neue Kapazität muss nicht größer sein als die <xref:System.Text.StringBuilder> maximale Kapazität des Objekts. Anders als bei einer Zuweisung an die <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft <xref:System.Text.StringBuilder.EnsureCapacity%2A> löst keine Ausnahme aus, wenn die gewünschte neue Kapazität kleiner als die vorhandene Kapazität ist; in diesem Fall der Methodenaufruf hat keine Auswirkungen.  
  
 Wenn die Länge der Zeichenfolge zugewiesen der <xref:System.Text.StringBuilder> Objekt im Konstruktoraufruf überschreitet, entweder die festgelegte Standardkapazität oder die angegebene Kapazität, die <xref:System.Text.StringBuilder.Capacity%2A> -Eigenschaftensatz auf die Länge der Zeichenfolge angegeben, mit der `value` Parameter.  
  
 Sie können explizit definieren, die maximale Kapazität einer <xref:System.Text.StringBuilder> -Objekt durch Aufrufen der <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> Konstruktor. Sie können nicht die maximale Kapazität ändern, indem Sie einen neuen Wert zuweisen der <xref:System.Text.StringBuilder.MaxCapacity%2A> -Eigenschaft, da es schreibgeschützt ist.  
  
 Wie im vorherigen Abschnitt wird gezeigt, wenn die vorhandene Kapazität nicht ausreichend, zusätzlichen Arbeitsspeicher ist reserviert und die Kapazität der ein <xref:System.Text.StringBuilder> Objekt Double-Werte bis zu dem Wert von definiert die <xref:System.Text.StringBuilder.MaxCapacity%2A> Eigenschaft.  
  
 Im Allgemeinen sind die Standardkapazität und die maximale Kapazität für die meisten Anwendungen ausreichend. Sie sollten das Festlegen dieser Werte in den folgenden Situationen:  
  
-   Wenn die letztlich die Größe des der <xref:System.Text.StringBuilder> Objekt wird wahrscheinlich äußerst, in der Regel über mehrere Megabyte groß. In diesem Fall gibt es möglicherweise einige Leistungsvorteile bieten Festlegen der anfänglichen <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft mit einem äußerst hohem Wert, der die zu viele Arbeitsspeicher neuzuordnungen überflüssig.  
  
-   Wenn Ihre app auf einem System mit eingeschränktem Arbeitsspeicher ausgeführt wird. Sie möchten in diesem Fall erwägen Sie, ob die <xref:System.Text.StringBuilder.MaxCapacity%2A> Eigenschaft, um weniger als <xref:System.Int32.MaxValue?displayProperty=nameWithType> , wenn Ihre app lange Zeichenfolgen behandelt, die sie zum Ausführen in einer Umgebung mit eingeschränktem Arbeitsspeicher führen kann.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>Instanziieren eines StringBuilder-Objekts  
 Instanziieren Sie ein <xref:System.Text.StringBuilder> Objekt durch Aufrufen einer ihrer sechs Konstruktoren von überladene Klasse, die in der folgenden Tabelle aufgeführt sind. Drei Konstruktoren Instanziieren einer <xref:System.Text.StringBuilder> Objekt, dessen Wert eine leere Zeichenfolge festgelegt, aber die <xref:System.Text.StringBuilder.Capacity%2A> und <xref:System.Text.StringBuilder.MaxCapacity%2A> Werte unterschiedlich. Die verbleibenden drei Konstruktoren definieren eine <xref:System.Text.StringBuilder> -Objekt, das einen bestimmten Zeichenfolgenwert und Kapazität verfügt. Zwei der drei Konstruktoren verwenden Sie die standardmäßige maximale Kapazität von <xref:System.Int32.MaxValue?displayProperty=nameWithType>, während die dritte, die Sie die maximale Kapazität festlegen kann.  
  
|Konstruktor|Zeichenfolgenwert|Kapazität|Maximale Kapazität|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Definiert die `capacity` Parameter|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Definiert die `capacity` Parameter|Definiert die `maxCapacity` Parameter|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Definiert die `value` Parameter|16 oder `value`. <xref:System.String.Length%2A>, welcher Wert größer ist.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Definiert die `value` Parameter|Definiert die `capacity` Parameter oder `value`. <xref:System.String.Length%2A>, welcher Wert größer ist.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Definiert von `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Definiert die `capacity` Parameter oder `value`. <xref:System.String.Length%2A>, welcher Wert größer ist.|Definiert die `maxCapacity` Parameter|  
  
 Das folgende Beispiel verwendet drei der folgenden Konstruktorüberladungen instanziieren <xref:System.Text.StringBuilder> Objekte.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>Aufrufen von "StringBuilder"-Methoden  
 Die meisten der Methoden, ändern die Zeichenfolge in, eine <xref:System.Text.StringBuilder> Instanz einen Verweis auf die gleiche Instanz zurückgeben. Dadurch können Sie zum Aufrufen <xref:System.Text.StringBuilder> Methoden gibt es zwei Möglichkeiten:  
  
-   Sie können einzelne Methodenaufrufe und den Rückgabewert zu ignorieren, wie im folgenden Beispiel wird der Fall ist.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   Sie können eine Reihe von Methodenaufrufen in einer einzelnen Anweisung vornehmen. Dies kann praktisch sein, wenn eine einzelne Anweisung geschrieben, die aufeinander folgende Operationen verkettet werden soll. Im folgende Beispiel werden drei Methodenaufrufe aus dem vorherigen Beispiel in einer einzelnen Zeile des Codes konsolidiert.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>Ausführen von "StringBuilder"-Vorgängen  
 Können Sie die Methoden der <xref:System.Text.StringBuilder> -Klasse durchlaufen, hinzufügen, löschen oder Ändern von Zeichen in einer <xref:System.Text.StringBuilder> Objekt.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>Durchlaufen von "StringBuilder"-Zeichen  
 Sie erreichen die Zeichen in einer <xref:System.Text.StringBuilder> -Objekt unter Verwendung der <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> Eigenschaft. In c# <xref:System.Text.StringBuilder.Chars%2A> ist ein Indexer; in Visual Basic ist es die Standardeigenschaft der <xref:System.Text.StringBuilder> Klasse. Dadurch können Sie festlegen oder Abrufen der einzelne Zeichen mithilfe ihres Indexes nur ohne ausdrücklichen Verweis auf die <xref:System.Text.StringBuilder.Chars%2A> Eigenschaft. Zeichen in einem <xref:System.Text.StringBuilder> Objekt bei Index 0 (null) beginnen und index weiterhin <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Chars%2A> Eigenschaft. Es fügt zehn Zufallszahlen, um eine <xref:System.Text.StringBuilder> Objekt aus, und anschließend wird jedes Zeichen. Wenn Unicode-Kategorie des Zeichens ist <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, es verringert die Anzahl von 1 (oder die Anzahl und 9 geändert wird, wenn der Wert 0 ist). Das Beispiel zeigt den Inhalt der <xref:System.Text.StringBuilder> Objekt sowohl vor und nach dem die Werte der einzelnen Zeichen ist auf diesem geändert wurden.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>Hinzufügen von Text in ein StringBuilder-Objekt  
 Die <xref:System.Text.StringBuilder> Klasse enthält die folgenden Methoden für die Erweiterung den Inhalt einer <xref:System.Text.StringBuilder> Objekt:  
  
-   Die <xref:System.Text.StringBuilder.Append%2A> Methode fügt eine Zeichenfolge, eine untergeordnete Zeichenfolge, ein Array von Zeichen, die einen Teil eines Arrays von Zeichen, ein einzelnes Zeichen mehrmals wiederholt, oder geben Sie die Zeichenfolgendarstellung eines primitiven Datentyps zu einem <xref:System.Text.StringBuilder> Objekt.  
  
-   Die <xref:System.Text.StringBuilder.AppendLine%2A> Methode fügt ein Zeilenabschlusszeichen oder eine Zeichenfolge zusammen mit einem Zeilenabschlusszeichen an eine <xref:System.Text.StringBuilder> Objekt.  
  
-   Die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode fügt eine auf einem <xref:System.Text.StringBuilder> Objekt. Die Zeichenfolgendarstellung von Objekten, die in der Ergebniszeichenfolge enthalten, können die Formatierungskonventionen der aktuellen Systemkultur oder einer angegebenen Kultur widerspiegeln.  
  
-   Die <xref:System.Text.StringBuilder.Insert%2A> -Methode fügt eine Zeichenfolge, die eine untergeordnete Zeichenfolge, die mehrere Wiederholungen einer Zeichenfolge, ein Array von Zeichen, die einen Teil eines Arrays von Zeichen oder die Zeichenfolgendarstellung eines primitiven Datentyps Geben Sie an einer angegebenen Position in der <xref:System.Text.StringBuilder> Objekt. Die Position wird durch einen nullbasierten Index definiert.  
  
 Im folgenden Beispiel wird die <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, und <xref:System.Text.StringBuilder.Insert%2A> Methoden zum Erweitern des Texts einer <xref:System.Text.StringBuilder> Objekt.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>Löschen von Text aus einer StringBuilder-Objekts  
 Die <xref:System.Text.StringBuilder> Klasse enthält Methoden, die die Größe des aktuellen reduzieren können <xref:System.Text.StringBuilder> Instanz. Die <xref:System.Text.StringBuilder.Clear%2A> -Methode entfernt alle Zeichen und legt die <xref:System.Text.StringBuilder.Length%2A> Eigenschaft 0 (null). Die <xref:System.Text.StringBuilder.Remove%2A> -Methode löscht eine angegebene Anzahl von Zeichen ab einer bestimmten Indexposition. Darüber hinaus können Sie Zeichen entfernen, am Ende einer <xref:System.Text.StringBuilder> Objekt durch Festlegen der <xref:System.Text.StringBuilder.Length%2A> Eigenschaft mit einem Wert, der kleiner als die Länge der aktuellen Instanz ist.  
  
 Im folgenden Beispiel wird ein Teil des Texts aus einem <xref:System.Text.StringBuilder> Objekt zeigt die resultierende Kapazität, maximale Kapazität und Länge Eigenschaftswerte und ruft dann die <xref:System.Text.StringBuilder.Clear%2A> Methode so entfernen Sie alle Zeichen aus der <xref:System.Text.StringBuilder> Objekt.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Ändern den Text in ein StringBuilder-Objekt  
 Die <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> Methode ersetzt alle Vorkommen eines Zeichens oder einer Zeichenfolge in der gesamten <xref:System.Text.StringBuilder> Objekt oder in einem Bereich von bestimmten Zeichen. Im folgenden Beispiel wird die <xref:System.Text.StringBuilder.Replace%2A> Methode, um alle Ausrufezeichen (!) durch das Fragezeichen (?) im Ersetzen der <xref:System.Text.StringBuilder> Objekt.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Suchen den Text in ein StringBuilder-Objekt  
 Die <xref:System.Text.StringBuilder> Klasse enthält keine ähnlichen Methoden der <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, und <xref:System.String.StartsWith%2A?displayProperty=nameWithType> von bereitgestellten Methoden die <xref:System.String> -Klasse, die Sie das Objekt für ein bestimmtes Zeichen oder eine Teilzeichenfolge durchsuchen können. Ermitteln des Vorhandenseins oder Zeichen, die Anfangsposition einer Teilzeichenfolge erfordert, dass Sie suchen eine <xref:System.String> Wert, indem Sie entweder eine Suchmethode Zeichenfolge oder eine Methode des regulären Ausdrucks. Es gibt vier Möglichkeiten, diese suchen, wie die folgende Tabelle zeigt zu implementieren.  
  
|Verfahren|Experten|Nachteile|  
|---------------|----------|----------|  
|Suchen Sie vor dem Hinzufügen der Benutzer zur Zeichenfolgenwerte der <xref:System.Text.StringBuilder> Objekt.|Nützlich, um zu bestimmen, ob eine Teilzeichenfolge vorhanden ist.|Kann nicht verwendet werden, wenn der Index einer Teilzeichenfolge wichtig ist.|  
|Rufen Sie <xref:System.Text.StringBuilder.ToString%2A> , und suchen Sie das zurückgegebene <xref:System.String> Objekt.|Einfach zu verwenden, wenn Sie den gesamten Text zum Zuweisen einer <xref:System.Text.StringBuilder> Objekt aus, und dann beginnen, ihn zu ändern.|Mühsam, wiederholt aufrufen <xref:System.Text.StringBuilder.ToString%2A> Wenn Sie Änderungen vornehmen müssen, bevor alle Text hinzugefügt wird die <xref:System.Text.StringBuilder> Objekt.<br /><br /> Denken Sie daran arbeiten am Ende der <xref:System.Text.StringBuilder> Text des Objekts, wenn Sie Änderungen vornehmen.|  
|Verwenden der <xref:System.Text.StringBuilder.Chars%2A> Eigenschaft um einen Bereich von Zeichen nacheinander zu suchen.|Nützlich, wenn Sie einzelne Zeichen oder eine kleine untergeordnete Zeichenfolge kümmern.|Umständlich, wenn die Anzahl der zu suchenden Zeichen groß ist oder wenn die Suchlogik komplex ist.<br /><br />Die Ergebnisse sehr schlechte Leistung für Objekte, die durch wiederholte Methodenaufrufe sehr groß geworden sind.  |  
|Konvertieren der <xref:System.Text.StringBuilder> -Objekt an eine <xref:System.String> Objekt aus, und führen Sie die Änderungen auf die <xref:System.String> Objekt.|Nützlich, wenn die Anzahl der Änderungen klein ist.|Den Leistungsvorteil negiert die <xref:System.Text.StringBuilder> Klasse, wenn die Anzahl der Änderungen groß ist.|  
  
 Wir sehen uns diese Techniken ausführlicher.  
  
-   Wenn das Ziel für die Suche ist, um zu bestimmen, ob eine bestimmte Teilzeichenfolge vorhanden ist (d. h., wenn Sie an der Position der Teilzeichenfolge nicht), können Sie Zeichenfolgen suchen, vor der Speicherung in der <xref:System.Text.StringBuilder> Objekt. Im folgenden Beispiel wird eine mögliche Implementierung. Definiert eine `StringBuilderFinder` Klasse übergeben wird, dessen Konstruktor wird einen Verweis auf eine <xref:System.Text.StringBuilder> -Objekt und die Teilzeichenfolge in der Zeichenfolge gesucht. In diesem Fall das Beispiel versucht, zu bestimmen, ob das aufgezeichnete Temperaturen in Fahrenheit oder Celsius sind, und fügt den entsprechenden einführenden Text am Anfang der <xref:System.Text.StringBuilder> Objekt. Eine Zufallszahlen-Generators wird verwendet, um ein Array auszuwählen, die Daten in Grad Celsius oder Grad Fahrenheit Betrug enthält.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   Rufen Sie die <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> Methode zum Konvertieren der <xref:System.Text.StringBuilder> -Objekt an eine <xref:System.String> Objekt. Sie können die Zeichenfolge suchen, indem Sie mit Methoden wie <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> oder <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, oder Sie können reguläre Ausdrücke und die <xref:System.Text.RegularExpressions.Regex> Klasse, um nach Mustern zu suchen. Da beide <xref:System.Text.StringBuilder> und <xref:System.String> Objekte verwenden die UTF-16-Codierung zum Speichern von Zeichen, die Indexpositionen der Zeichen, Teilzeichenfolgen, und die Übereinstimmungen mit regulären Ausdrücken werden in beide Objekte gleich. Dies ermöglicht Ihnen die Verwendung <xref:System.Text.StringBuilder> Methoden zu Änderungen an der gleichen Position, an dem dieser Text, in gefunden wird, der <xref:System.String> Objekt.  
  
    > [!NOTE]
    >  Wenn Sie diesen Ansatz verfolgen, sollten Sie arbeiten, am Ende der <xref:System.Text.StringBuilder> Objekt, dessen ab, damit Sie nicht wiederholt konvertieren die <xref:System.Text.StringBuilder> -Objekt in eine Zeichenfolge.  
  
     Dieser Ansatz wird anhand des folgenden Beispiels veranschaulicht. Sie speichert jeden Buchstaben des englischen Alphabets in vier Vorkommen einer <xref:System.Text.StringBuilder> Objekt. Anschließend konvertiert den Text, der eine <xref:System.String> -Objekt und verwendet einen regulären Ausdruck identifiziert die Anfangsposition der jeder vier Zeichen bestehenden Sequenz. Abschließend fügt einen Unterstrich vor jeder Sequenz vier Zeichen mit Ausnahme der ersten Sequenz und das erste Zeichen der Sequenz, die in Großbuchstaben konvertiert.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   Verwenden der <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> Eigenschaft sequenziell suchen Sie einen Bereich von Zeichen in einem <xref:System.Text.StringBuilder> Objekt. Dieser Ansatz darf nicht praktikabel sein, die Anzahl von Zeichen an, die durchsucht werden bei großen oder Suchlogik besonders komplex ist. Für die Auswirkungen auf die Leistung von Zeichen für Zeichen indexbasierten Zugriff für sehr große, chunked <xref:System.Text.StringBuilder> Objekten finden Sie in der Dokumentation für die <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> Eigenschaft. 
  
     Im folgende Beispiel wird dieselbe Funktion wie im vorherigen Beispiel, aber nach unterschiedlich implementiert. Er verwendet den <xref:System.Text.StringBuilder.Chars%2A> Eigenschaft erkennen, wenn der Wert eines Zeichens geändert hat, einen Unterstrich an dieser Position eingefügt, und das erste Zeichen in der neuen Sequenz in Großbuchstaben konvertiert.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   Store den nicht geänderten Text in die <xref:System.Text.StringBuilder> Objekt, rufen Sie die <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> Methode zum Konvertieren der <xref:System.Text.StringBuilder> -Objekt an eine <xref:System.String> Objekt aus, und führen Sie die Änderungen auf die <xref:System.String> Objekt. Sie können diesen Ansatz verwenden, wenn Sie nur wenige Änderungen haben; Andernfalls kann die Kosten für das Arbeiten mit unveränderlichen Zeichenfolgen die Leistungsvorteile des Einsatzes von Negieren einer <xref:System.Text.StringBuilder> Objekt.  
  
     Im folgenden Beispiel wird dieselbe Funktion wie die beiden vorangehenden Beispielen jedoch unterscheidet sich in der Implementierung. Erstellt eine <xref:System.Text.StringBuilder> -Objekt, konvertiert sie in einem <xref:System.String> -Objekt, und klicken Sie dann mithilfe eines regulären Ausdrucks die Zeichenfolge alle verbleibende Änderungen ausführen. Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Methode verwendet einen Lambda-Ausdruck für den Ersetzungsvorgang für jede Übereinstimmung.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>StringBuilder-Objekts konvertieren in eine Zeichenfolge  
 Sie müssen das <xref:System.Text.StringBuilder>-Objekt in ein <xref:System.String>-Objekt konvertieren, bevor Sie die vom <xref:System.Text.StringBuilder>-Objekt dargestellte Zeichenfolge an eine Methode mit einem <xref:System.String>-Parameter übergeben können oder diese auf der Benutzeroberfläche anzeigen. Sie führen diese Konvertierung durch Aufrufen der <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> Methode. Eine Abbildung finden Sie im vorherige Beispiel, das Aufrufe der <xref:System.Text.StringBuilder.ToString%2A> Methode zum Konvertieren einer <xref:System.Text.StringBuilder> Objekts in eine Zeichenfolge, sodass er an eine Methode des regulären Ausdrucks übergeben werden kann.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie viele der definierten Methoden aufrufen, die <xref:System.Text.StringBuilder> Klasse.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
    </block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.StringBuilder" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.StringBuilder" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zeichenfolgenwert dieser Instanz wird festgelegt, um <xref:System.String.Empty?displayProperty=nameWithType>, und die Kapazität auf die implementierungsspezifischen Standardkapazität festgelegt ist.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Aufrufen der <xref:System.Text.StringBuilder.%23ctor%2A> Konstruktor ohne Parameter.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die empfohlene Anfangsgröße dieser Instanz.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.StringBuilder" />-Klasse unter Verwendung der angegebenen Kapazität.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `capacity` Parameter definiert die maximale Anzahl von Zeichen, die im von der aktuellen Instanz reservierten Speicher gespeichert werden können. Der Wert zugewiesen wird die <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft. Dies überschreitet die Anzahl der Zeichen in der aktuellen Instanz gespeichert werden `capacity` Wert, der <xref:System.Text.StringBuilder> Objekt weist den zusätzlichen Arbeitsspeicher, um sie zu speichern.  
  
 Der Zeichenfolgenwert dieser Instanz wird festgelegt, um <xref:System.String.Empty?displayProperty=nameWithType>. Wenn `capacity` ist 0 (null), die implementierungsspezifische Standardkapazität verwendet wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Aufrufen der <xref:System.Text.StringBuilder.%23ctor%2A> Konstruktor mit einer angegebenen Kapazität.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> ist kleiner als Null.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, mit der der Wert der Instanz initialisiert wird. Wenn <c>value</c><see langword="null" /> ist, enthält der neue <see cref="T:System.Text.StringBuilder" /> die leere Zeichenfolge (d. h., er enthält <see cref="F:System.String.Empty" />).</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.StringBuilder" />-Klasse unter Verwendung der angegebenen Zeichenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `value` `null` ist, enthält der neue <xref:System.Text.StringBuilder> die leere Zeichenfolge (d. h., er enthält <xref:System.String.Empty>).  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Aufrufen der <xref:System.Text.StringBuilder.%23ctor%2A> Konstruktor mit der angegebenen Zeichenfolge.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die empfohlene Anfangsgröße des <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">Die Höchstanzahl von Zeichen, die die aktuelle Zeichenfolge enthalten kann.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.StringBuilder" />-Klasse, die bei einer angegebenen Kapazität beginnt, die bis auf ein angegebenes Maximum erhöht werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `capacity` Parameter definiert die maximale Anzahl von Zeichen, die im von der aktuellen Instanz reservierten Speicher gespeichert werden können. Der Wert zugewiesen wird die <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft. Dies überschreitet die Anzahl der Zeichen in der aktuellen Instanz gespeichert werden `capacity` Wert, der <xref:System.Text.StringBuilder> Objekt weist den zusätzlichen Arbeitsspeicher, um sie zu speichern.  
  
 Wenn `capacity` ist 0 (null), die implementierungsspezifische Standardkapazität verwendet wird.  
  
 Die `maxCapacity` Eigenschaft definiert die maximale Anzahl von Zeichen, die die aktuelle Instanz enthalten kann. Der Wert zugewiesen wird die <xref:System.Text.StringBuilder.MaxCapacity%2A> Eigenschaft. Dies überschreitet die Anzahl der Zeichen in der aktuellen Instanz zu speichernde `maxCapacity` Wert, der <xref:System.Text.StringBuilder> Objekt ist kein zusätzlichen Arbeitsspeicher belegt werden, aber stattdessen löst eine Ausnahme aus.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Aufrufen der <xref:System.Text.StringBuilder.%23ctor%2A> Konstruktor mit einer angegebenen Kapazität und die maximale Kapazität.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxCapacity" /> ist kleiner als 1, <paramref name="capacity" /> ist kleiner als 0 (null), oder <paramref name="capacity" /> ist größer als <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, mit der der Wert der Instanz initialisiert wird. Wenn <c>value</c><see langword="null" /> ist, enthält der neue <see cref="T:System.Text.StringBuilder" /> die leere Zeichenfolge (d. h., er enthält <see cref="F:System.String.Empty" />).</param>
        <param name="capacity">Die empfohlene Anfangsgröße des <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.StringBuilder" />-Klasse unter Verwendung der angegebenen Zeichenfolge und der angegebenen Kapazität.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `capacity` Parameter definiert die maximale Anzahl von Zeichen, die im von der aktuellen Instanz reservierten Speicher gespeichert werden können. Der Wert zugewiesen wird die <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft. Dies überschreitet die Anzahl der Zeichen in der aktuellen Instanz gespeichert werden `capacity` Wert, der <xref:System.Text.StringBuilder> Objekt weist den zusätzlichen Arbeitsspeicher, um sie zu speichern.  
  
 Wenn `capacity` ist 0 (null), die implementierungsspezifische Standardkapazität verwendet wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Aufrufen der <xref:System.Text.StringBuilder.%23ctor%2A> Konstruktor mit einer ursprünglichen Zeichenfolge und einer angegebenen Kapazität.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> ist kleiner als Null.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die die Teilzeichenfolge enthält, mit der der Wert dieser Instanz initialisiert wird. Wenn <c>value</c><see langword="null" /> ist, enthält der neue <see cref="T:System.Text.StringBuilder" /> die leere Zeichenfolge (d. h., er enthält <see cref="F:System.String.Empty" />).</param>
        <param name="startIndex">Die Position in <c>value</c>, an der die Teilzeichenfolge beginnt.</param>
        <param name="length">Die Anzahl der Zeichen in der Teilzeichenfolge.</param>
        <param name="capacity">Die empfohlene Anfangsgröße des <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.StringBuilder" />-Klasse unter Verwendung der angegebenen Teilzeichenfolge und der angegebenen Kapazität.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `capacity` Parameter definiert die maximale Anzahl von Zeichen, die im von der aktuellen Instanz reservierten Speicher gespeichert werden können. Der Wert zugewiesen wird die <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft. Dies überschreitet die Anzahl der Zeichen in der aktuellen Instanz gespeichert werden `capacity` Wert, der <xref:System.Text.StringBuilder> Objekt weist den zusätzlichen Arbeitsspeicher, um sie zu speichern.  
  
 Wenn `capacity` ist 0 (null), die implementierungsspezifische Standardkapazität verwendet wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Aufrufen der <xref:System.Text.StringBuilder.%23ctor%2A> Konstruktor mit der angegebenen Zeichenfolge.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> ist kleiner als Null.  
  
- oder -  
 Die Summe von <paramref name="startIndex" /> und <paramref name="length" /> ist keine Position, die in <paramref name="value" /> liegt.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Objekts an diese Instanz an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende boolesche Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen booleschen Werts an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Methodenaufrufe der <xref:System.Boolean.ToString?displayProperty=nameWithType> die Zeichenfolgendarstellung der abzurufenden Methode `value`. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 8-Bit-Ganzzahl ohne Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Byte%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Byte%29> Methodenaufrufe der <xref:System.Byte.ToString%28System.IFormatProvider%29> die Zeichenfolgendarstellung der abzurufenden Methode `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Die anzufügende UTF-16-codierte Codeeinheit.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen <see cref="T:System.Char" />-Objekts an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Char%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Das anzufügende Array von Zeichen.</param>
        <summary>Fügt die Zeichenfolgendarstellung der Unicode-Zeichen in einem angegebenen Array an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt alle Zeichen im angegebenen Array mit der aktuellen Instanz in der gleichen Reihenfolge wie im `value`. Wenn `value` ist `null`, werden keine Änderungen vorgenommen.  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen Dezimalzahl an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Methodenaufrufe der <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> die Zeichenfolgendarstellung der abzurufenden Methode `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen Gleitkommazahl mit doppelter Genauigkeit an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Double%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Double%29> Methodenaufrufe der <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> die Zeichenfolgendarstellung der abzurufenden Methode `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 16-Bit-Ganzzahl mit Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Int16%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Int16%29> Methodenaufrufe der <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> die Zeichenfolgendarstellung der abzurufenden Methode `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 32-Bit-Ganzzahl mit Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Int32%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Int32%29> Methodenaufrufe der <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> die Zeichenfolgendarstellung der abzurufenden Methode `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 64-Bit-Ganzzahl mit Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Int64%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Int64%29> Methodenaufrufe der <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> die Zeichenfolgendarstellung des abzurufenden `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das anzufügende Objekt.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Objekts an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Object%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht. Definiert eine `Dog` Klasse ist, erstellt eine `Dog` -Objekt, und drei Aufrufe der <xref:System.Text.StringBuilder.Append%2A> Methode, um eine Zeichenfolge zu erstellen, die Namen und die Art der Dog enthält.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Object%29> Methodenaufrufe der <xref:System.Object.ToString%2A?displayProperty=nameWithType> die Zeichenfolgendarstellung der abzurufenden Methode `value`. Wenn `value` ist `null`, werden keine Änderungen vorgenommen, um die <xref:System.Text.StringBuilder> Objekt.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 8-Bit-Ganzzahl mit Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.SByte%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.SByte%29> Methodenaufrufe der <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> die Zeichenfolgendarstellung der abzurufenden Methode `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen Gleitkommazahl mit einfacher Genauigkeit an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Single%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Single%29> Methodenaufrufe der <xref:System.Single.ToString%2A?displayProperty=nameWithType> die Zeichenfolgendarstellung der abzurufenden Methode `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die anzufügende Zeichenfolge.</param>
        <summary>Fügt eine Kopie der angegebenen Zeichenfolge an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.String%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Wenn `value` ist `null`, werden keine Änderungen vorgenommen.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 16-Bit-Ganzzahl ohne Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Methodenaufrufe der <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> die Zeichenfolgendarstellung der abzurufenden Methode `value`. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 32-Bit-Ganzzahl ohne Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Aufrufe der <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> die Zeichenfolgendarstellung der abzurufenden Methode `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 64-Bit-Ganzzahl ohne Vorzeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 Die <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Methodenaufrufe der <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> die Zeichenfolgendarstellung der abzurufenden Methode `value` für die aktuelle Kultur. Zum Steuern der Formatierung der `value`, rufen Sie die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Das anzufügende Zeichen.</param>
        <param name="repeatCount">Die Anzahl der Anfügewiederholungen für <c>value</c>.</param>
        <summary>Fügt eine angegebene Anzahl von Kopien der Zeichenfolgendarstellung eines Unicode-Zeichens an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="repeatCount" /> ist kleiner als Null.  
  
- oder -  
Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <exception cref="T:System.OutOfMemoryException">Nicht genügend Arbeitsspeicher.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein Array von Zeichen.</param>
        <param name="valueCount">Die Anzahl der Zeichen im Array.</param>
        <summary>Fügt ein Array aus Unicode-Zeichen ab einer angegebenen Adresse an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt `valueCount` Zeichen ab Adresse `value` mit der aktuellen Instanz.  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> Objekt.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="valueCount" /> ist kleiner als Null.  
  
- oder -  
Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> ist ein NULL-Zeiger</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeichenarray.</param>
        <param name="startIndex">Die Anfangsposition in <c>value</c>.</param>
        <param name="charCount">Die Anzahl der anzufügenden Zeichen.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Unterarrays von Unicode-Zeichen an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt den angegebenen Bereich von Zeichen in `value` mit der aktuellen Instanz. Wenn `value` ist `null` und `startIndex` und `count` sind beide 0 (null), keine Änderungen vorgenommen werden.  
  
 Die <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />, und <paramref name="startIndex" /> und <paramref name="charCount" /> sind nicht 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> ist kleiner als Null.  
  
- oder -  
 <paramref name="startIndex" /> ist kleiner als Null.  
  
- oder -  
 <paramref name="startIndex" /> + <paramref name="charCount" /> ist größer als die Länge von <paramref name="value" />.  
  
- oder -  
Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die die anzufügende Teilzeichenfolge enthält.</param>
        <param name="startIndex">Die Anfangsposition der Teilzeichenfolge innerhalb von <c>value</c>.</param>
        <param name="count">Die Anzahl der anzufügenden Zeichen in <c>value</c>.</param>
        <summary>Fügt eine Kopie einer angegebenen Teilzeichenfolge an diese Instanz an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt den angegebenen Bereich von Zeichen in `value` mit der aktuellen Instanz. Wenn `value` ist `null` und `startIndex` und `count` sind beide 0 (null), keine Änderungen vorgenommen werden.  
  
 Die <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> Methode ändert die vorhandene Instanz dieser Klasse, eine neue Instanz der Klasse wird nicht zurückgegeben. Aus diesem Grund können Sie eine Methode oder Eigenschaft aufrufen, auf den vorhandenen Verweis, und Sie müssen keine weisen Sie den Rückgabewert in einer <xref:System.Text.StringBuilder> -Objekts, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />, und <paramref name="startIndex" /> und <paramref name="count" /> sind nicht 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist kleiner als 0 (null).  
  
- oder -  
 <paramref name="startIndex" /> ist kleiner als 0 (null).  
  
- oder -  
 <paramref name="startIndex" /> + <paramref name="count" /> ist größer als die Länge von <paramref name="value" />.  
  
- oder -  
Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung eines entsprechenden Objektarguments ersetzt.</summary>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatzeichenfolge.</param>
        <param name="arg0">Ein zu formatierendes Objekt.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung eines einzelnen Arguments ersetzt.</summary>
        <returns>Ein Verweis auf diese Instanz mit angefügtem <paramref name="format" />. Die einzelnen Elemente in <paramref name="format" /> werden jeweils durch eine Zeichenfolgendarstellung von <paramref name="arg0" /> ersetzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework konvertiert den Wert eines Objekts in die binäre Darstellung und das Einbetten von dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` -Parameter besteht aus 0 (null) oder mehreren Einheiten Text mit keinem oder mehreren indizierten Platzhaltern enthalten, den so genannten Formatelementen. Der Index, der die Formatelemente muss 0 sein, entsprechen `arg0`, das einzelne Objekt in der Liste der Parameter dieser Methode. Die Formatierung zu ersetzt jedes Formatelement durch die Zeichenfolgendarstellung des `arg0`.  
  
 Die Syntax eines Formatelements ist wie folgt aus:  
  
 {*Index*[,*Länge*] [:*FormatString*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. Wenn es keinen Parameter in gibt der *Index* Position eine <xref:System.FormatException> ausgelöst.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Bei einem positiven Wert ist, ist der Parameter rechts ausgerichtete; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatzeichenfolge, die durch den Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatzeichenfolgen für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßige und benutzerdefinierte Formatzeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` Stellt das Objekt, das formatiert werden. Jedes Formatelement in `format` wird durch die Zeichenfolgendarstellung von ersetzt `arg0`. Wenn das Formatelement enthält `formatString` und `arg0` implementiert die <xref:System.IFormattable> Schnittstelle ist, klicken Sie dann `arg0.ToString(formatString, null)` definiert die Formatierung. Andernfalls `arg0.ToString()` definiert die Formatierung.  
  
 Wenn die Zeichenfolge zugewiesen `format` ist "Danke für die Spende von {0: ###} lebensmitteldosen für wohltätige Zwecke." und `arg0` ist eine ganze Zahl mit dem Wert 10 ist, wird der Rückgabewert "Vielen Dank für die Spende von 10 lebensmitteldosen für wohltätige Zwecke".  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist kleiner als 0 (null) oder größer gleich 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatzeichenfolge.</param>
        <param name="args">Ein Array zu formatierender Objekte.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung eines entsprechenden Arguments in einem Parameterarray ersetzt.</summary>
        <returns>Ein Verweis auf diese Instanz mit angefügtem <paramref name="format" />. Jedes Formatelement in <paramref name="format" /> wird durch die Zeichenfolgendarstellung des entsprechenden Objektarguments ersetzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework konvertiert den Wert eines Objekts in die binäre Darstellung und das Einbetten von dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` -Parameter besteht aus 0 (null) oder weitere Ausführungen von Text und optional ein mit NULL oder mehr indizierten Platzhaltern enthalten, den so genannten Formatelementen, die auf Objekte in der Liste der Parameter dieser Methode entsprechen. Die Formatierung zu ersetzt jedes Formatelement durch die Zeichenfolgendarstellung des entsprechenden Objekts.  
  
 Die Syntax eines Formatelements ist wie folgt aus:  
  
 {*Index*[,*Länge*] [:*FormatString*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. Wenn es keinen Parameter in gibt der *Index* Position eine <xref:System.FormatException> ausgelöst.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Bei einem positiven Wert ist, ist der Parameter rechts ausgerichtete; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatzeichenfolge, die durch den Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatzeichenfolgen für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßige und benutzerdefinierte Formatzeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `args` Stellt den zu formatierenden Objekte dar. Jedes Formatelement in `format` wird ersetzt durch die Zeichenfolgendarstellung des entsprechenden Objekts in `args`. Wenn das Formatelement enthält `formatString` und das entsprechende Objekt in `args` implementiert die <xref:System.IFormattable> Schnittstelle ist, klicken Sie dann `args[index].ToString(formatString, provider)` definiert die Formatierung. Andernfalls `args[index].ToString()` definiert die Formatierung.  
  
 Wenn die Zeichenfolge zugewiesen `format` ist "Danke für die Spende von {0: ###} lebensmitteldosen für wohltätige Zwecke." und `arg0` ist eine ganze Zahl mit dem Wert 10 ist, wird der Rückgabewert "Vielen Dank für die Spende von 10 lebensmitteldosen für wohltätige Zwecke".  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> oder <paramref name="args" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich der Länge des <paramref name="args" />-Arrays.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine kombinierte Formatzeichenfolge.</param>
        <param name="arg0">Das zu formatierende Objekt.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung eines einzigen Arguments mit einem angegebenen Formatanbieter ersetzt.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde. Nach dem Anfügevorgang enthält diese Instanz alle Daten, die auch vor dem Vorgang vorhanden waren. Ihnen folgt eine Kopie von <paramref name="format" />, wobei die Formatangabe durch die Zeichenfolgendarstellung von <paramref name="arg0" /> ersetzt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework konvertiert den Wert der `arg0` in die Textdarstellung und Einbetten von dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` -Parameter besteht aus 0 (null) oder mehreren Einheiten Text mit keinem oder mehreren indizierten Platzhaltern enthalten, den so genannten Formatelementen. Der Index der einzelnen Elemente muss 0 (null) sein, da diese Methode eine Argumentliste mit einem einzelnen Argument enthält. Die Formatierung zu ersetzt jedes Formatelement durch die Zeichenfolgendarstellung des `arg0`.  
  
 Die Syntax eines Formatelements ist wie folgt aus:  
  
 {*Index*[,*Länge*] [:*FormatString*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. In diesem Fall seit der <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> Methode hat ein einzelnes Argument in der Argumentliste den Wert der *Index* muss immer 0 sein. Ist dies nicht der Fall, ein <xref:System.FormatException> ausgelöst.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Bei einem positiven Wert ist, ist der Parameter rechts ausgerichtete; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatzeichenfolge, die durch den Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatzeichenfolgen für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßige und benutzerdefinierte Formatzeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Die `provider` Parameter gibt ein <xref:System.IFormatProvider> -Implementierung, die Formatierungsinformationen für die Objekte in bereitzustellen, kann `args`. `provider` kann eine der folgenden Formen haben:  
  
-   Ein <xref:System.Globalization.CultureInfo> -Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für bereitstellt `arg0` , wenn es sich um einen numerischen Wert handelt.  
  
-   Ein <xref:System.Globalization.DateTimeFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für bereitstellt `arg0` ist dies ein Datum und Uhrzeit-Wert.  
  
-   Eine benutzerdefinierte <xref:System.IFormatProvider> -Implementierung, die Formatierungsinformationen für `arg0`. In der Regel implementiert eine solche Implementierung auch die <xref:System.ICustomFormatter> Schnittstelle.  
  
 Wenn die `provider` Parameter `null`, Formatierung erhalten Sie Informationen aus der aktuellen Kultur.  
  
 `arg0` Stellt das Objekt, das formatiert werden. Jedes Formatelement in `format` wird durch die Zeichenfolgendarstellung von ersetzt `arg0`. Wenn das Formatelement enthält `formatString` und `arg0` implementiert die <xref:System.IFormattable> Schnittstelle ist, klicken Sie dann `arg0.ToString(formatString, provider)` definiert die Formatierung. Andernfalls `arg0.ToString()` definiert die Formatierung.  
  
   
  
## Examples  
 Im folgenden finden Sie zwei Aufrufe der <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> Methode. Beide verwenden die Formatierungskonventionen der Kultur Englisch-Großbritannien (En-GB). Die erste fügt die angegebene Zeichenfolgendarstellung einer <xref:System.Decimal> Währung in eine Ergebniszeichenfolge Wert. Der zweite Fügt eine <xref:System.DateTime> Wert an zwei Stellen in einem Resultset eine Zeichenfolge, die erste einschließlich nur das kurze Datum, Zeichenfolge und das zweite die kurze Zeit-Zeichenfolge.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Gewusst wie: Definieren und Verwenden von benutzerdefinierten numerischen Formatanbietern</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine kombinierte Formatzeichenfolge.</param>
        <param name="args">Ein Array zu formatierender Objekte.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird von der Zeichenfolgendarstellung eines entsprechenden Arguments in einem Parameterarray ersetzt, das einen angegebenen Formatanbieter verwendet.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde. Nach dem Anfügevorgang enthält diese Instanz alle Daten, die auch vor dem Vorgang vorhanden waren. Ihnen folgt eine Kopie von <paramref name="format" />, wobei die Formatangabe durch die Zeichenfolgendarstellung des entsprechenden Objektarguments ersetzt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework konvertiert den Wert eines Objekts in die binäre Darstellung und das Einbetten von dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` -Parameter besteht aus 0 (null) oder weitere Ausführungen von Text und optional ein mit NULL oder mehr indizierten Platzhaltern enthalten, den so genannten Formatelementen, die auf Objekte in der Liste der Parameter dieser Methode entsprechen. Die Formatierung zu ersetzt jedes Formatelement durch die Zeichenfolgendarstellung des entsprechenden Objekts.  
  
 Die Syntax eines Formatelements ist wie folgt aus:  
  
 {*Index*[,*Länge*] [:*FormatString*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. Wenn es keinen Parameter in gibt der *Index* Position eine <xref:System.FormatException> ausgelöst.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Bei einem positiven Wert ist, ist der Parameter rechts ausgerichtete; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatzeichenfolge, die durch den Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatzeichenfolgen für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßige und benutzerdefinierte Formatzeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Die `provider` Parameter gibt ein <xref:System.IFormatProvider> -Implementierung, die Formatierungsinformationen für die Objekte in bereitzustellen, kann `args`. `provider` kann eine der folgenden Formen haben:  
  
-   Ein <xref:System.Globalization.CultureInfo> -Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für numerische Werte in bietet `args`.  
  
-   Ein <xref:System.Globalization.DateTimeFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für Datums- und Uhrzeitwerte in bietet `args`.  
  
-   Eine benutzerdefinierte <xref:System.IFormatProvider> -Implementierung, die Formatierungsinformationen für eine oder mehrere der Objekte im `args`. In der Regel implementiert eine solche Implementierung auch die <xref:System.ICustomFormatter> Schnittstelle. Das zweite Beispiel im nächsten Abschnitt zeigt eine <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> Aufruf der Methode mit einem benutzerdefinierten <xref:System.IFormatProvider> Implementierung.  
  
 Wenn die `provider` Parameter `null`, Anbieter von Formatinformationen aus der aktuellen Kultur abgerufen wird.  
  
 `args` Stellt den zu formatierenden Objekte dar. Jedes Formatelement in `format` wird ersetzt durch die Zeichenfolgendarstellung des entsprechenden Objekts in `args`. Wenn das Formatelement enthält `formatString` und das entsprechende Objekt in `args` implementiert die <xref:System.IFormattable> Schnittstelle ist, klicken Sie dann `args[index].ToString(formatString, provider)` definiert die Formatierung. Andernfalls `args[index].ToString()` definiert die Formatierung.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 Das folgende Beispiel definiert ein benutzerdefiniertes <xref:System.IFormatProvider> Implementierung, die mit dem Namen `CustomerFormatter` ab, die Kunden 10-stellige Zahl mit Bindestrichen nach den vierten und sieben Ziffern formatiert. Er wird zum Übergeben der <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> Methode, um eine Zeichenfolge zu erstellen, die den formatierten Kundennummer und den Kundennamen enthält.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich der Länge des <paramref name="args" />-Arrays.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Gewusst wie: Definieren und Verwenden von benutzerdefinierten numerischen Formatanbietern</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatzeichenfolge.</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung für eines von zwei Argumenten ersetzt.</summary>
        <returns>Ein Verweis auf diese Instanz mit angefügtem <paramref name="format" />. Jedes Formatelement in <paramref name="format" /> wird durch die Zeichenfolgendarstellung des entsprechenden Objektarguments ersetzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework konvertiert den Wert eines Objekts in die binäre Darstellung und das Einbetten von dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` -Parameter besteht aus 0 (null) oder weitere Ausführungen von Text und optional ein mit NULL oder mehr indizierten Platzhaltern enthalten, den so genannten Formatelementen, die entsprechen `arg0` und `arg1`, die zwei Objekte in der Liste der Parameter dieser Methode. Die Formatierung zu ersetzt jedes Formatelement durch die Zeichenfolgendarstellung des entsprechenden Objekts.  
  
 Die Syntax eines Formatelements ist wie folgt aus:  
  
 {*Index*[,*Länge*] [:*FormatString*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. Wenn es keinen Parameter in gibt der *Index* Position eine <xref:System.FormatException> ausgelöst.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Bei einem positiven Wert ist, ist der Parameter rechts ausgerichtete; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatzeichenfolge, die durch den Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatzeichenfolgen für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßige und benutzerdefinierte Formatzeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` und `arg1` den zu formatierenden Objekte darstellen. Jedes Formatelement in `format` wird durch die Zeichenfolgendarstellung eines ersetzt `arg0` oder `arg1`. Wenn das Formatelement enthält `formatString` und das entsprechende Objekt implementiert die <xref:System.IFormattable> Schnittstelle ist, klicken Sie dann `arg` *x* `.ToString(formatString, provider)` , in denen die Formatierung, definiert *x* ist der Index des Arguments. Andernfalls `arg` *x* `.ToString()` definiert die Formatierung.  
  
 Wenn die Zeichenfolge zugewiesen `format` ist "Danke für die Spende von {0: ###} lebensmitteldosen für wohltätige Zwecke." und `arg0` ist eine ganze Zahl mit dem Wert 10 ist, wird der Rückgabewert "Vielen Dank für die Spende von 10 lebensmitteldosen für wohltätige Zwecke".  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist kleiner als 0 (null) oder größer gleich 2.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine kombinierte Formatzeichenfolge.</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung eines der zwei Argumente mit einem angegebenen Formatanbieter ersetzt.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde. Nach dem Anfügevorgang enthält diese Instanz alle Daten, die auch vor dem Vorgang vorhanden waren. Ihnen folgt eine Kopie von <paramref name="format" />, wobei die Formatangabe durch die Zeichenfolgendarstellung des entsprechenden Objektarguments ersetzt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework konvertiert den Wert eines Objekts in die binäre Darstellung und das Einbetten von dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` -Parameter besteht aus 0 (null) oder weitere Ausführungen von Text und optional ein mit NULL oder mehr indizierten Platzhaltern enthalten, den so genannten Formatelementen, die auf Objekte in der Liste der Parameter dieser Methode entsprechen. Die Formatierung zu ersetzt jedes Formatelement durch die Zeichenfolgendarstellung des entsprechenden Objekts.  
  
 Die Syntax eines Formatelements ist wie folgt aus:  
  
 {*Index*[,*Länge*] [:*FormatString*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. Wenn es keinen Parameter in gibt der *Index* Position eine <xref:System.FormatException> ausgelöst.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Bei einem positiven Wert ist, ist der Parameter rechts ausgerichtete; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatzeichenfolge, die durch den Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatzeichenfolgen für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßige und benutzerdefinierte Formatzeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Die `provider` Parameter gibt ein <xref:System.IFormatProvider> -Implementierung, die Formatierungsinformationen für bereitzustellen, kann `arg0` und `arg1`. `provider` kann eine der folgenden Formen haben:  
  
-   Ein <xref:System.Globalization.CultureInfo> -Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für bereitstellt `arg0` oder `arg1` , wenn sie numerische Werte sind.  
  
-   Ein <xref:System.Globalization.DateTimeFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für bereitstellt `arg0` oder `arg1` , wenn sie die Datums-und Uhrzeitwerte sind.  
  
-   Eine benutzerdefinierte <xref:System.IFormatProvider> -Implementierung, die Formatierungsinformationen für `arg0` und `arg1`. In der Regel implementiert eine solche Implementierung auch die <xref:System.ICustomFormatter> Schnittstelle.  
  
 Wenn die `provider` Parameter `null`, Anbieter von Formatinformationen aus der aktuellen Kultur abgerufen wird.  
  
 `arg0` und `arg1` den zu formatierenden Objekte darstellen. Jedes Formatelement in `format` wird durch die Zeichenfolgendarstellung des Objekts mit dem entsprechenden Index ersetzt. Wenn das Formatelement enthält `formatString` und das entsprechende Argument implementiert die <xref:System.IFormattable> -Schnittstelle, und klicken Sie dann auf des Arguments des `ToString(formatString, provider)` Methode definiert, die Formatierung. Andernfalls des Arguments `ToString()` Methode definiert, die Formatierung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> anzuzeigenden Zeit und Temperatur-Daten in einer generischen Methode <xref:System.Collections.Generic.Dictionary%602> Objekt. Beachten Sie, dass die Zeichenfolge drei Formatelemente, allerdings nur für den stehen zu formatierenden Objekten. Dies ist, weil das erste Objekt in der Liste (ein Wert für Datum und Uhrzeit) von zwei Formatelemente verwendet werden: die erste Format-Element angezeigt, die Zeit, und die zweite zeigt das Datum an.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich 2.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und in der .NET Framework 4.0 und höher, beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Gewusst wie: Definieren und Verwenden von benutzerdefinierten numerischen Formatanbietern</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatzeichenfolge.</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <param name="arg2">Das dritte zu formatierende Objekt.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung für eines von drei Argumenten ersetzt.</summary>
        <returns>Ein Verweis auf diese Instanz mit angefügtem <paramref name="format" />. Jedes Formatelement in <paramref name="format" /> wird durch die Zeichenfolgendarstellung des entsprechenden Objektarguments ersetzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework konvertiert den Wert eines Objekts in die binäre Darstellung und das Einbetten von dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` -Parameter besteht aus 0 (null) oder weitere Ausführungen von Text und optional ein mit NULL oder mehr indizierten Platzhaltern enthalten, den so genannten Formatelementen, die entsprechen `arg0` über `arg2`, die Objekte in der Liste der Parameter dieser Methode. Die Formatierung zu ersetzt jedes Formatelement durch die Zeichenfolgendarstellung des entsprechenden Objekts.  
  
 Die Syntax eines Formatelements ist wie folgt aus:  
  
 {*Index*[,*Länge*] [:*FormatString*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. Wenn es keinen Parameter in gibt der *Index* Position eine <xref:System.FormatException> ausgelöst.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Bei einem positiven Wert ist, ist der Parameter rechts ausgerichtete; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatzeichenfolge, die durch den Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatzeichenfolgen für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßige und benutzerdefinierte Formatzeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`, `arg1`, und `arg2` den zu formatierenden Objekte darstellen. Jedes Formatelement in `format` wird durch die Zeichenfolgendarstellung eines ersetzt `arg0`, `arg1`, oder `arg2`, je nachdem, für den Index des Formatelements. Wenn das Formatelement enthält `formatString` und das entsprechende Objekt in `args` implementiert die <xref:System.IFormattable> Schnittstelle ist, klicken Sie dann `arg` *x* `.ToString(formatString, null)` wird definiert, in dem die Formatierung aus * X* ist der Index des Arguments. Andernfalls `arg` *x* `.ToString()` definiert die Formatierung.  
  
 Wenn die Zeichenfolge zugewiesen `format` ist "Danke für die Spende von {0: ###} lebensmitteldosen für wohltätige Zwecke." und `arg0` ist eine ganze Zahl mit dem Wert 10 ist, wird der Rückgabewert "Vielen Dank für die Spende von 10 lebensmitteldosen für wohltätige Zwecke".  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendFormat%2A> Methode.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine kombinierte Formatzeichenfolge.</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <param name="arg2">Das dritte zu formatierende Objekt.</param>
        <summary>Fügt die Zeichenfolge, die durch Verarbeitung einer kombinierten Formatzeichenfolge mit 0 (null) oder mehr Formatelementen zurückgegeben wurde, an diese Instanz an. Jedes Formatelement wird durch die Zeichenfolgendarstellung eines der drei Argumente mit einem angegebenen Formatanbieter ersetzt.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde. Nach dem Anfügevorgang enthält diese Instanz alle Daten, die auch vor dem Vorgang vorhanden waren. Ihnen folgt eine Kopie von <paramref name="format" />, wobei die Formatangabe durch die Zeichenfolgendarstellung des entsprechenden Objektarguments ersetzt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) von .NET Framework konvertiert den Wert eines Objekts in die binäre Darstellung und das Einbetten von dieser Darstellung in der aktuellen <xref:System.Text.StringBuilder> Objekt.  
  
 Die `format` -Parameter besteht aus 0 (null) oder weitere Ausführungen von Text und optional ein mit NULL oder mehr indizierten Platzhaltern enthalten, den so genannten Formatelementen, die auf Objekte in der Liste der Parameter dieser Methode entsprechen. Die Formatierung zu ersetzt jedes Formatelement durch die Zeichenfolgendarstellung des entsprechenden Objekts.  
  
 Die Syntax eines Formatelements ist wie folgt aus:  
  
 {*Index*[,*Länge*] [:*FormatString*]}  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*index*|Die nullbasierte Position in der Parameterliste des Objekts, das formatiert werden. Wenn das Objekt vom angegebenen *Index* ist `null`, das Formatelement wird durch ersetzt <xref:System.String.Empty?displayProperty=nameWithType>. Wenn es keinen Parameter in gibt der *Index* Position eine <xref:System.FormatException> ausgelöst.|  
|,*Länge*|Die minimale Anzahl von Zeichen in eine Zeichenfolgendarstellung des Parameters. Bei einem positiven Wert ist, ist der Parameter rechts ausgerichtete; Wenn Sie negativ ist, ist es linksbündig ausgerichtet.|  
|:*formatString*|Eine standardmäßige oder benutzerdefinierte Formatzeichenfolge, die durch den Parameter unterstützt wird.|  
  
> [!NOTE]
>  Die standardmäßigen und benutzerdefinierten Formatzeichenfolgen mit Datums-und Uhrzeitwerte verwendet werden, finden Sie unter [Standardformatzeichenfolgen für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Die standardmäßige und benutzerdefinierte Formatzeichenfolgen, die mit numerischen Werten verwendet werden, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Standardformatzeichenfolgen für Enumerationen verwendet, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Die `provider` Parameter gibt ein <xref:System.IFormatProvider> -Implementierung, die Formatierungsinformationen für bereitzustellen, kann `arg0` und `arg1`. `provider` kann eine der folgenden Formen haben:  
  
-   Ein <xref:System.Globalization.CultureInfo> -Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für bereitstellt `arg0` oder `arg1` , wenn sie numerische Werte sind.  
  
-   Ein <xref:System.Globalization.DateTimeFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen für bereitstellt `arg0`, `arg1`, oder `arg2` , wenn sie die Datums-und Uhrzeitwerte sind.  
  
-   Eine benutzerdefinierte <xref:System.IFormatProvider> -Implementierung, die Formatierungsinformationen für `arg0`, `arg1`, und `arg2`. In der Regel implementiert eine solche Implementierung auch die <xref:System.ICustomFormatter> Schnittstelle.  
  
 Wenn die `provider` Parameter `null`, Anbieter von Formatinformationen aus der aktuellen Kultur abgerufen wird.  
  
 `arg0`, `arg1`, und `arg2` den zu formatierenden Objekte darstellen. Jedes Formatelement in `format` wird durch die Zeichenfolgendarstellung des Objekts mit dem entsprechenden Index ersetzt. Wenn das Formatelement enthält `formatString` und das entsprechende Argument implementiert die <xref:System.IFormattable> -Schnittstelle, und klicken Sie dann auf des Arguments des `ToString(formatString, provider)` Methode definiert, die Formatierung. Andernfalls des Arguments `ToString()` Methode definiert, die Formatierung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> Methode veranschaulicht das Ergebnis ein boolescher Wert `And` Operation mit ganzzahligen Werten. Beachten Sie, dass die Formatzeichenfolge sechs Formatelemente enthält, aber die Methode nur drei Elemente in der Liste der Argumente hat, da jedes Element auf zwei verschiedene Arten formatiert ist.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich 3 (drei).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der erweiterten Zeichenfolge würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschreiten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Gewusst wie: Definieren und Verwenden von benutzerdefinierten numerischen Formatanbietern</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt das Standardzeilenabschlusszeichen oder eine Kopie der angegebenen Zeichenfolge und das Standardzeilenabschlusszeichen am Ende dieser Instanz an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fügt das Standardzeilenabschlusszeichen am Ende des aktuellen <see cref="T:System.Text.StringBuilder" />-Objekts an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardzeilenabschluss ist der aktuelle Wert von der <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.AppendLine%2A> Methode.  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die anzufügende Zeichenfolge.</param>
        <summary>Fügt eine Kopie der angegebenen Zeichenfolge gefolgt vom Standardzeilenabschlusszeichen am Ende des aktuellen <see cref="T:System.Text.StringBuilder" />-Objekts an.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardzeilenabschluss ist der aktuelle Wert von der <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <see cref="T:System.Text.StringBuilder" /> -Objekt durch Aufrufen der <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> sowohl die Länge und die Kapazität der Konstruktor der <see cref="T:System.Text.StringBuilder" /> Instanz über den Wert der anwachsen kann seine <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <see cref="M:System.Text.StringBuilder.Append(System.String)" /> und <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> Methoden, um kurze Zeichenfolgen anfügen.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höchstanzahl von Zeichen ab, die im durch die aktuelle Instanz reservierten Speicher enthalten sein können, oder legt diese fest.</summary>
        <value>Die Höchstanzahl von Zeichen, die im durch die aktuelle Instanz reservierten Speicher enthalten sein können. Der Wert kann zwischen <see cref="P:System.Text.StringBuilder.Length" /> und <see cref="P:System.Text.StringBuilder.MaxCapacity" /> liegen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> Der Zeichenfolgenwert der aktuellen Instanz ist keine Auswirkungen auf. <xref:System.Text.StringBuilder.Capacity%2A> verringert werden kann, solange er nicht ist kleiner als <xref:System.Text.StringBuilder.Length%2A>.  
  
 Die <xref:System.Text.StringBuilder> dynamisch belegt mehr Platz im Bedarfsfall, und erhöht <xref:System.Text.StringBuilder.Capacity%2A> entsprechend. Aus Leistungsgründen einen <xref:System.Text.StringBuilder> möglicherweise mehr Speicher als erforderlich zuzuordnen. Die Menge des belegten Arbeitsspeichers ist implementierungsspezifisch.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Text.StringBuilder.Capacity%2A> Eigenschaft.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen SET-Vorgang angegebene Wert ist kleiner als die aktuelle Länge dieser Instanz.  
  
- oder -  
Der für einen SET-Vorgang angegebene Wert ist größer als die maximale Kapazität.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Die Position des Zeichens.</param>
        <summary>Ruft das Zeichen an der angegebenen Zeichenposition in dieser Instanz ab oder legt dieses fest.</summary>
        <value>Das Unicode-Zeichen an der Position <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `index` -Parameter stellt die Position eines Zeichens in der <xref:System.Text.StringBuilder>. Das erste Zeichen in der Zeichenfolge ist bei Index 0. Die Länge einer Zeichenfolge ist die Anzahl der darin enthaltenen Zeichen. Das letzte zugänglich Zeichen eine <xref:System.Text.StringBuilder> Instanz ist am Index <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 <xref:System.Text.StringBuilder.Chars%2A> ist die Standardeigenschaft der <xref:System.Text.StringBuilder> Klasse. In c# ist es ein Indexer. Dies bedeutet, dass einzelne Zeichen abgerufen werden können, aus der <xref:System.Text.StringBuilder.Chars%2A> -Eigenschaft wie im folgenden Beispiel, das die Anzahl der alphabetischen zählt, dargestellt, Leerzeichen, und Satzzeichen in einer Zeichenfolge.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>Leistung und die zeichenbasierte Indizierung

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> liegt beim Festlegen eines Zeichens außerhalb des Bereichs dieser Instanz.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> liegt beim Abrufen eines Zeichens außerhalb des Bereichs dieser Instanz.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Zeichen aus der aktuellen <see cref="T:System.Text.StringBuilder" />-Instanz.</summary>
        <returns>Ein Objekt, dessen <see cref="P:System.Text.StringBuilder.Length" /> 0 (null) ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Clear%2A> ist eine bequeme Methode, die entsprechend der Einstellung der <xref:System.Text.StringBuilder.Length%2A> Eigenschaft der aktuellen Instanz mit 0 (null).  
  
 Aufrufen der <xref:System.Text.StringBuilder.Clear%2A> Methode ändert nicht der aktuellen Instanz <xref:System.Text.StringBuilder.Capacity%2A> oder <xref:System.Text.StringBuilder.MaxCapacity%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Text.StringBuilder> Objekt mit einer Zeichenfolge, die Aufrufe der <xref:System.Text.StringBuilder.Clear%2A> -Methode, und anschließend eine neue Zeichenfolge angefügt.  
  
 [!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Die Anfangsposition in dieser Instanz, ab der Zeichen kopiert werden. Der Index ist nullbasiert.</param>
        <param name="destination">Das Array, in das Zeichen kopiert werden.</param>
        <param name="destinationIndex">Die Anfangsposition in <c>destination</c>, an die Zeichen kopiert werden. Der Index ist nullbasiert.</param>
        <param name="count">Die Anzahl der zu kopierenden Zeichen.</param>
        <summary>Kopiert die Zeichen aus einem angegebenen Segment dieser Instanz in ein angegebenes Segment eines Ziel-<see cref="T:System.Char" />-Arrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.StringBuilder.CopyTo%2A> Methode richtet sich an, in dem seltenen Fall verwendet werden, wenn Sie aufeinander folgende Abschnitte eines kopieren müssen eine <xref:System.Text.StringBuilder> Objekt in ein Array. Das Array muss eine feste Größe, vorab festgelegten, wiederverwendbare und ggf. Global zugegriffen werden kann.  
  
 Beispielsweise Ihre Anwendung füllt konnte eine <xref:System.Text.StringBuilder> Objekt, mit einer großen Anzahl von Zeichen der <xref:System.Text.StringBuilder.CopyTo%2A> Methode zum Kopieren von kleinen, aufeinander folgende Teile der <xref:System.Text.StringBuilder> Objekt in ein Array, in dem die Komponenten verarbeitet werden. Wenn alle Daten in der <xref:System.Text.StringBuilder> Objekt verarbeitet wird, die Größe des der <xref:System.Text.StringBuilder> Objekt auf 0 (null) festgelegt ist und die wird wiederholt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.CopyTo%2A> Methode.  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
- oder -  
 <paramref name="sourceIndex" /> ist größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceIndex" /> + <paramref name="count" /> ist größer als die Länge dieser Instanz.  
  
- oder -  
 <paramref name="destinationIndex" /> + <paramref name="count" /> ist größer als die Länge von <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die Mindestkapazität, die gewährleistet sein muss.</param>
        <summary>Stellt sicher, dass die Kapazität dieser Instanz von <see cref="T:System.Text.StringBuilder" /> mindestens gleich dem angegebenen Wert ist.</summary>
        <returns>Die neue Kapazität dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle Kapazität ist kleiner als der `capacity` Parameter, Speicher für diese Instanz wird neu zugewiesen zum Speichern von mindestens `capacity` Anzahl von Zeichen; andernfalls wird kein Speicher geändert hat.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.EnsureCapacity%2A> Methode.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> ist kleiner als Null.  
  
- oder -  
Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">Ein Objekt, das mit dieser Instanz verglichen werden soll, oder <see langword="null" />.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen Objekt ist.</summary>
        <returns>
          <see langword="true" />, wenn diese Instanz und <paramref name="sb" /> die gleichen Zeichenfolgenwerte sowie die gleichen Werte für <see cref="P:System.Text.StringBuilder.Capacity" /> und <see cref="P:System.Text.StringBuilder.MaxCapacity" /> enthalten, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Der folgende code verwendet die <xref:System.Text.StringBuilder.Equals%2A> -Methode überprüft, ob zwei <xref:System.Text.StringBuilder> Objekte gleich sind. Die Methode wird wiederholt aufgerufen, wenn kleinere Änderungen auf jedes Objekt erfolgen und die Ergebnisse werden in der Konsole angezeigt.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Objekts an einer angegebenen Zeichenposition in diese Instanz ein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines booleschen Werts an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abrufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen, die Aufrufe dieser Methode ausgelöst hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> des Objekts Gesamtlänge überschreiten würde <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 8-Bit-Ganzzahl ohne Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abrufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen, die Aufrufe dieser Methode ausgelöst hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> des Objekts Gesamtlänge überschreiten würde <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Unicode-Zeichens an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abrufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.  
  
- oder -  
Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Das einzufügende Zeichenarray.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Arrays von Unicode-Zeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 Wenn `value` ist `null`, <xref:System.Text.StringBuilder> wird nicht geändert.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.  
  
- oder -  
Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer Dezimalzahl an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abrufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen, die Aufrufe dieser Methode ausgelöst hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> des Objekts Gesamtlänge überschreiten würde <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer Gleitkommazahl mit doppelter Genauigkeit an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abrufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen, die Aufrufe dieser Methode ausgelöst hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> des Objekts Gesamtlänge überschreiten würde <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 16-Bit-Ganzzahl mit Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abrufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen, die Aufrufe dieser Methode ausgelöst hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> des Objekts Gesamtlänge überschreiten würde <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 32-Bit-Ganzzahl mit Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abrufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen, die Aufrufe dieser Methode ausgelöst hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> des Objekts Gesamtlänge überschreiten würde <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer 64-Bit-Ganzzahl mit Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abrufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen, die Aufrufe dieser Methode ausgelöst hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> des Objekts Gesamtlänge überschreiten würde <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Das einzufügende Objekt oder <see langword="null" />.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines Objekts an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abrufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 Wenn `value` ist `null`, der Wert dieser Instanz bleibt unverändert.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen, die Aufrufe dieser Methode ausgelöst hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> des Objekts Gesamtlänge überschreiten würde <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer angegebenen 8-Bit-Ganzzahl mit Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abrufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen, die Aufrufe dieser Methode ausgelöst hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> des Objekts Gesamtlänge überschreiten würde <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer Gleitkommazahl mit einfacher Genauigkeit an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abrufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen, die Aufrufe dieser Methode ausgelöst hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> des Objekts Gesamtlänge überschreiten würde <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Die einzufügende Zeichenfolge.</param>
        <summary>Fügt eine Zeichenfolge an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität wird angepasst, je nach Bedarf.  
  
 Diese Instanz von <xref:System.Text.StringBuilder> wird nicht geändert werden, wenn `value` ist `null`, oder `value` nicht `null` jedoch seine Länge ist 0 (null).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.  
  
- oder -  
Die Summe der aktuellen Länge dieses <see cref="T:System.Text.StringBuilder" />-Objekts und der Länge von <paramref name="value" /> ist größer als <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer 16-Bit-Ganzzahl ohne Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abrufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen, die Aufrufe dieser Methode ausgelöst hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> des Objekts Gesamtlänge überschreiten würde <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer 32-Bit-Ganzzahl ohne Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abrufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen, die Aufrufe dieser Methode ausgelöst hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> des Objekts Gesamtlänge überschreiten würde <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Der einzufügende Wert.</param>
        <summary>Fügt die Zeichenfolgendarstellung einer 64-Bit-Ganzzahl ohne Vorzeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> wird verwendet, um eine Zeichenfolgendarstellung abrufen `value`. Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <exception cref="T:System.OutOfMemoryException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <block subset="none" type="usage">
          <para>In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] und früheren Versionen, die Aufrufe dieser Methode ausgelöst hat eine <see cref="T:System.ArgumentOutOfRangeException" /> beim Einfügen von <paramref name="value" /> des Objekts Gesamtlänge überschreiten würde <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], löst die Methode eine <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Die einzufügende Zeichenfolge.</param>
        <param name="count">Die Anzahl der Einfügewiederholungen für <c>value</c>.</param>
        <summary>Fügt eine oder mehrere Kopien einer angegebenen Zeichenfolge an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
 Dies <xref:System.Text.StringBuilder> Objekt wird nicht geändert werden, wenn `value` ist `null`, `value` nicht `null` jedoch seine Länge ist 0 (null), oder `count` ist 0 (null).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.  
  
- oder -  
 <paramref name="count" /> ist kleiner als Null.</exception>
        <exception cref="T:System.OutOfMemoryException">Die Summe der aktuellen Länge dieses <see cref="T:System.Text.StringBuilder" />-Objekts und der Länge von <paramref name="value" /> multipliziert mit <paramref name="count" /> ist größer als <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Die Position in dieser Instanz, an der die Einfügung beginnt.</param>
        <param name="value">Ein Zeichenarray.</param>
        <param name="startIndex">Der Startindex in <c>value</c>.</param>
        <param name="charCount">Die Anzahl der einzufügenden Zeichen.</param>
        <summary>Fügt die Zeichenfolgendarstellung eines angegebenen Unterarrays von Unicode-Zeichen an der angegebenen Zeichenposition in diese Instanz ein.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vorhandene Zeichen werden verschoben, um Platz für den neuen Text zu schaffen. Die Kapazität dieser Instanz wird angepasst, je nach Bedarf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Insert%2A> Methode.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />, und <paramref name="startIndex" /> und <paramref name="charCount" /> sind nicht 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />, <paramref name="startIndex" /> oder <paramref name="charCount" /> ist kleiner als 0 (null).  
  
- oder -  
 <paramref name="index" /> ist größer als die Länge dieser Instanz.  
  
- oder -  
 Die Summe von <paramref name="startIndex" /> und <paramref name="charCount" /> ist keine Position, die in <paramref name="value" /> liegt.  
  
- oder -  
Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge des aktuellen <see cref="T:System.Text.StringBuilder" />-Objekts ab oder legt diese fest.</summary>
        <value>Die Länge dieser Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Länge einer <xref:System.Text.StringBuilder> Objekt wird definiert, von der Anzahl der <xref:System.Char> Objekte.  
  
 Wie die <xref:System.String.Length%2A?displayProperty=nameWithType> -Eigenschaft, die <xref:System.Text.StringBuilder.Length%2A> Eigenschaft gibt die Länge der im aktuellen Zeichenfolgenobjekt. Im Gegensatz zu den <xref:System.String.Length%2A?displayProperty=nameWithType> -Eigenschaft, die schreibgeschützt ist, die <xref:System.Text.StringBuilder.Length%2A> Eigenschaft können Sie so ändern Sie die Länge der Zeichenfolge gespeichert, um die <xref:System.Text.StringBuilder> Objekt.  
  
 Wenn die angegebene Länge kleiner als die aktuelle Länge der aktuellen ist <xref:System.Text.StringBuilder> Objekt wird auf die angegebene Länge abgeschnitten. Wenn die angegebene Länge größer als die aktuelle Länge, die das Ende des Werts des aktuellen ist <xref:System.Text.StringBuilder> Objekt wird aufgefüllt, mit der Unicode-Zeichen NULL (U + 0000).  
  
 Wenn die angegebene Länge größer als die aktuelle Kapazität wird <xref:System.Text.StringBuilder.Capacity%2A> erhöht, sodass er größer als oder gleich der angegebenen Länge ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Text.StringBuilder.Length%2A> Eigenschaft.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen set-Vorgang angegebene Wert ist kleiner als 0 (null) oder größer als <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Kapazität dieser Instanz ab.</summary>
        <value>Die Höchstanzahl von Zeichen, die diese Instanz enthalten kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die maximale Kapazität für diese Implementierung <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Allerdings wird dieser Wert ist implementierungsspezifisch und kann sich in der Implementierung abhängig sein. Sie können explizit festlegen, die maximale Kapazität einer <xref:System.Text.StringBuilder> -Objekt durch Aufrufen der <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> Konstruktor.  
  
In .NET Core und die .NET Framework 4.0 und höhere Versionen, die beim Instanziieren der <xref:System.Text.StringBuilder> -Objekt durch Aufrufen der <xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)> sowohl die Länge und die Kapazität der Konstruktor der <xref:System.Text.StringBuilder> Instanz über den Wert der anwachsen kann seine <xref:System.Text.StringBuilder.MaxCapacity> Diese Eigenschaft. Dies kann auftreten, insbesondere beim Aufruf der <xref:System.Text.StringBuilder.Append(System.String)> und <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> Methoden, um kurze Zeichenfolgen anfügen.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <param name="length">Die Anzahl der zu entfernenden Zeichen.</param>
        <summary>Entfernt den angegebenen Bereich von Zeichen aus dieser Instanz.</summary>
        <returns>Ein Verweis auf diese Instanz, nachdem der Ausschneidevorgang abgeschlossen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle Methode entfernt den angegebenen Bereich von Zeichen aus der aktuellen Instanz. Die Zeichen bei (`startIndex` + `length`) werden in verschoben `startIndex`, und der Zeichenfolgenwert der aktuellen Instanz gekürzt wird, werden `length`. Die Kapazität der aktuellen Instanz ist nicht betroffen.  
  
> [!NOTE]
>  Die <xref:System.Text.StringBuilder.Remove%2A> Methode ändert den Wert des aktuellen <xref:System.Text.StringBuilder> -Instanz und gibt diese Instanz zurück. Es nicht zu erstellen und Zurückgeben einer neuen <xref:System.Text.StringBuilder> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Remove%2A> Methode.  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wenn <paramref name="startIndex" /> oder <paramref name="length" /> kleiner als 0 (null) ist oder <paramref name="startIndex" /> + <paramref name="length" /> größer als die Länge dieser Instanz sind.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ersetzt alle Vorkommen eines angegebenen Zeichens bzw. einer angegebenen Zeichenfolge in dieser Instanz durch ein anderes Zeichen bzw. eine andere Zeichenfolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Das zu ersetzende Zeichen.</param>
        <param name="newChar">Das Zeichen, das <c>oldChar</c> ersetzt.</param>
        <summary>Ersetzt in dieser Instanz alle Vorkommen eines angegebenen Zeichens durch ein anderes angegebenes Zeichen.</summary>
        <returns>Ein Verweis auf diese Instanz, bei der <paramref name="oldChar" /> durch <paramref name="newChar" /> ersetzt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Vergleich ordinalen, Groß-/Kleinschreibung beachtet, zum Identifizieren der Vorkommen des `oldChar` in der aktuellen Instanz. Die Größe des aktuellen <xref:System.Text.StringBuilder> Instanz wird nach einem Austausch nicht geändert.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Replace%2A> Methode.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Die zu ersetzende Zeichenfolge.</param>
        <param name="newValue">Die Zeichenfolge, die <c>oldValue</c> ersetzt, oder <see langword="null" />.</param>
        <summary>Ersetzt in dieser Instanz alle Vorkommen einer angegebenen Zeichenfolge durch eine andere angegebene Zeichenfolge.</summary>
        <returns>Ein Verweis auf diese Instanz, bei der alle Vorkommen von <paramref name="oldValue" /> durch <paramref name="newValue" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Vergleich ordinalen, Groß-/Kleinschreibung beachtet, zum Identifizieren der Vorkommen des `oldValue` in der aktuellen Instanz. Wenn `newValue` ist `null` oder <xref:System.String.Empty?displayProperty=nameWithType>, alle Vorkommen von `oldValue` werden entfernt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Replace%2A> Methode.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="oldValue" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">Das zu ersetzende Zeichen.</param>
        <param name="newChar">Das Zeichen, das <c>oldChar</c> ersetzt.</param>
        <param name="startIndex">Die Position in dieser Instanz, an der die Teilzeichenfolge beginnt.</param>
        <param name="count">Die Länge der Teilzeichenfolge.</param>
        <summary>Ersetzt alle Vorkommen eines angegebenen Zeichens in einer Teilzeichenfolge dieser Instanz durch ein anderes angegebenes Zeichen.</summary>
        <returns>Ein Verweis auf diese Instanz, bei der <paramref name="oldChar" /> im Bereich von <paramref name="startIndex" /> bis <paramref name="startIndex" /> + <paramref name="count" /> -1 durch <paramref name="newChar" /> ersetzt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Vergleich ordinalen, Groß-/Kleinschreibung beachtet, zum Identifizieren der Vorkommen des `oldChar` in der aktuellen Instanz. Die Größe des aktuellen <xref:System.Text.StringBuilder> Objekt ist nach einem Austausch unverändert.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Replace%2A> Methode.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> + <paramref name="count" /> ist größer als die Länge des Werts dieser Instanz.  
  
- oder -  
 <paramref name="startIndex" /> oder <paramref name="count" /> ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">Die zu ersetzende Zeichenfolge.</param>
        <param name="newValue">Die Zeichenfolge, die <c>oldValue</c> ersetzt, oder <see langword="null" />.</param>
        <param name="startIndex">Die Position in dieser Instanz, an der die Teilzeichenfolge beginnt.</param>
        <param name="count">Die Länge der Teilzeichenfolge.</param>
        <summary>Ersetzt alle Vorkommen einer angegebenen Zeichenfolge in einer Teilzeichenfolge dieser Instanz durch eine andere angegebene Zeichenfolge.</summary>
        <returns>Ein Verweis auf diese Instanz, bei der alle Instanzen von <paramref name="oldValue" /> im Bereich von <paramref name="startIndex" /> bis <paramref name="startIndex" /> + <paramref name="count" /> - 1 durch <paramref name="newValue" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Vergleich ordinalen, Groß-/Kleinschreibung beachtet, zum Identifizieren der Vorkommen des `oldValue` in der angegebenen Teilzeichenfolge. Wenn `newValue` ist `null` oder <xref:System.String.Empty?displayProperty=nameWithType>, alle Vorkommen von `oldValue` werden entfernt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.StringBuilder.Replace%2A> Methode.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="oldValue" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> oder <paramref name="count" /> ist kleiner als 0.  
  
- oder -  
 Die Summe von <paramref name="startIndex" /> und <paramref name="count" /> bezeichnet eine Zeichenposition außerhalb dieser Instanz.  
  
- oder -  
Bei Erhöhung des Werts dieser Instanz würde <see cref="P:System.Text.StringBuilder.MaxCapacity" /> überschritten.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Das Objekt, das mit Serialisierungsinformationen aufgefüllt werden soll.</param>
        <param name="context">Der Ort zum Speichern und Abrufen von serialisierten Daten. Für zukünftige Verwendung reserviert.</param>
        <summary>Füllt ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den Daten, die erforderlich sind, um das aktuelle <see cref="T:System.Text.StringBuilder" />-Objekt zu deserialisieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `context` -Parameter ist für die zukünftige Verwendung reserviert und nicht an diesen Vorgang beteiligt.  
  
 Weitere Informationen finden Sie unter der Methode <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert einer angegebenen <see cref="T:System.Text.StringBuilder" />-Klasse in eine <see cref="T:System.String" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in einen <see cref="T:System.String" />.</summary>
        <returns>Eine Zeichenfolge, deren Wert mit dieser Instanz übereinstimmt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Text.StringBuilder.ToString%2A> Methode zum Konvertieren der <xref:System.Text.StringBuilder> -Objekt eine <xref:System.String> -Objekt, bevor Sie die Zeichenfolge, die durch dargestellt übergeben können die <xref:System.Text.StringBuilder> Objekt, das eine Methode mit einer <xref:System.String> Parameter oder zum Anzeigen der Benutzeroberfläche.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Aufrufen der <xref:System.Text.StringBuilder.ToString%2A>-Methode veranschaulicht. In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Text.StringBuilder> Klasse.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die Anfangsposition der Teilzeichenfolge innerhalb dieser Instanz.</param>
        <param name="length">Die Länge der Teilzeichenfolge.</param>
        <summary>Konvertiert den Wert einer Teilzeichenfolge dieser Instanz in eine <see cref="T:System.String" />.</summary>
        <returns>Eine Zeichenfolge, deren Wert der angegebenen Teilzeichenfolge dieser Instanz entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Text.StringBuilder.ToString%2A> Methode zum Konvertieren der <xref:System.Text.StringBuilder> -Objekt eine <xref:System.String> -Objekt, bevor Sie die Zeichenfolge, die durch dargestellt übergeben können die <xref:System.Text.StringBuilder> Objekt, das eine Methode mit einer <xref:System.String> Parameter oder zum Anzeigen der Benutzeroberfläche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.  
  
- oder -  
Die Summe aus <paramref name="startIndex" /> und <paramref name="length" /> ist größer als die Länge der aktuellen Instanz.</exception>
      </Docs>
    </Member>
  </Members>
</Type>