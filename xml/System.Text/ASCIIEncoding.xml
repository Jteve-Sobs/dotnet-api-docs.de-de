<Type Name="ASCIIEncoding" FullName="System.Text.ASCIIEncoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ab5211a8f9320a934d74d9b3f821ee108ec6cb24" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531154" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ASCIIEncoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ASCIIEncoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.ASCIIEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class ASCIIEncoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class ASCIIEncoding : System::Text::Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine ASCII-Zeichencodierung von Unicode-Zeichen dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Kodieren werden Unicode-Zeichen in eine Bytefolge transformiert. Beim Decodieren wird transformiert eine codierte Bytefolge in einen Satz von Unicode-Zeichen.  
  
 <xref:System.Text.ASCIIEncoding> die Windows-Codepage 20127 entspricht. Da ASCII eine 7-Bit-Codierung ist, sind ASCII-Zeichen von U + 0000 bis U + 007F auf die ersten 128 Unicode-Zeichen beschränkt. Bei Verwendung von Standard-Encoder zurückgegebenes der <xref:System.Text.Encoding.ASCII%2A?displayProperty=nameWithType> Eigenschaft oder die <xref:System.Text.ASCIIEncoding.%23ctor%2A> Zeichen außerhalb dieses Bereichs-Konstruktor mit einem Fragezeichen (?) ersetzt werden, bevor der Codierungsvorgang ausgeführt wird.  Da die <xref:System.Text.ASCIIEncoding> Klasse unterstützt nur einen eingeschränkten Zeichensatz, der <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, und <xref:System.Text.UTF32Encoding> Klassen sind besser für globalisierten Anwendungen geeignet. Die folgenden Aspekte können Sie entscheiden, ob Sie verwenden <xref:System.Text.ASCIIEncoding>:  
  
-   Einige Protokolle erfordern ASCII- oder eine Teilmenge von ASCII. In diesen Fällen ASCII ist die Codierung geeignet.  
  
-   Wenn eine 8-Bit-Codierung erwartet wird, nicht-ASCII-wahrscheinlich die richtige Wahl. Stattdessen Sie verwenden Sie UTF8 anstelle von ASCII. Klicken Sie für die Zeichen U + 0000 bis U + 007F die Ergebnisse sind identisch, aber alle Unicode-Zeichen sind darstellbaren in UTF-8, wodurch Datenverlust vermieden wird.  
  
> [!CAUTION]
>  <xref:System.Text.ASCIIEncoding> bietet keine Fehler erkannt. Aus Gründen der Sicherheit sollten Sie verwenden <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, oder <xref:System.Text.UTF32Encoding> und fehlererkennung zu aktivieren.  
  
 Die <xref:System.Text.ASCIIEncoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.ASCIIEncoding.GetBytes%2A> -Methode führt die eigentliche Codierung.  
  
 Entsprechend der <xref:System.Text.ASCIIEncoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und <xref:System.Text.ASCIIEncoding.GetChars%2A> und <xref:System.Text.ASCIIEncoding.GetString%2A> Methoden führen die tatsächliche Decodierung aus.  
  
 Beachten Sie, dass die Standardeinstellung <xref:System.Text.ASCIIEncoding> Konstruktor selbst möglicherweise nicht das entsprechende Verhalten für Ihre Anwendung. Sie sollten erwägen Sie, ob die <xref:System.Text.Encoding.EncoderFallback%2A> oder <xref:System.Text.Encoding.DecoderFallback%2A> Eigenschaft <xref:System.Text.EncoderExceptionFallback> oder <xref:System.Text.DecoderExceptionFallback> um Sequenzen mit dem 8. Bitsatz zu verhindern. Benutzerdefiniertes Verhalten möglicherweise auch für diese Fälle geeignet sein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Unicode-Zeichen in ASCII codiert wird. Beachten Sie den Verlust von Daten, die tritt auf, wenn Ihre Anwendung verwendet <xref:System.Text.ASCIIEncoding> zum Codieren von Unicode-Zeichen außerhalb des ASCII-Bereichs.  
  
 [!code-cpp[System.Text.ASCIIEncoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.ASCIIEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.ASCIIEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.ASCIIEncoding Example/VB/snippet.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoder" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ASCIIEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ASCIIEncoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.ASCIIEncoding" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Die <xref:System.Text.ASCIIEncoding> Klasse bietet keine Fehler erkannt. Aus Gründen der Sicherheit sollten Sie verwenden die <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, oder <xref:System.Text.UTF32Encoding> Klasse, und Aktivieren der fehlererkennung.  
  
 Falls gewünscht ASCII-Codierung verwenden, möglicherweise dieser Konstruktor keine entsprechende fallbackverhaltens für Ihre Anwendung bereit. Er verwendet die <xref:System.Text.EncoderReplacementFallback> und <xref:System.Text.DecoderReplacementFallback> Klassen, die jedes Zeichen außerhalb des Bereichs U + 0000 bis U + 007F durch ein Fragezeichen (?) ersetzt. Rufen Sie stattdessen die <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> oder <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> Methode und übergeben Sie ihn <xref:System.Text.EncoderExceptionFallback> und <xref:System.Text.DecoderExceptionFallback> Objekte Ausnahmefallback verwendet.  
  
> [!NOTE]
>  <xref:System.Text.ASCIIEncoding> nur die Unicode-Zeichenwerte zwischen U + 0000 und U + 007F unterstützt. Aus diesem Grund <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, und <xref:System.Text.UTF32Encoding> für globalisierten Anwendungen besser geeignet sind.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <xref:System.Text.ASCIIEncoding> -Instanz und der Anzeigename der Codierung.  
  
 [!code-cpp[System.Text.ASCIIEncoding.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.ASCIIEncoding.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.ASCIIEncoding.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen erzeugt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="chars">Die <see cref="T:System.String" />-Klasse mit den zu codierenden Zeichen.</param>
        <summary>Berechnet die Anzahl der Bytes, die durch das Codieren der Zeichen in der angegebenen <see cref="T:System.String" />-Klasse erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.ASCIIEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes verwendet die Anwendung <xref:System.Text.ASCIIEncoding.GetByteCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A>. Die <xref:System.Text.ASCIIEncoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.ASCIIEncoding.GetByteCount%2A> Methode zum Zurückgeben der Anzahl von Bytes, die zum Codieren einer Zeichenfolge mit erforderlichen <xref:System.Text.ASCIIEncoding>.  
  
 [!code-cpp[System.Text.ASCIIEncoding.GetByteCount2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetByteCount2 Example/CPP/getbytecount-string.cpp#1)]
 [!code-csharp[System.Text.ASCIIEncoding.GetByteCount2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetByteCount2 Example/CS/getbytecount-string.cs#1)]
 [!code-vb[System.Text.ASCIIEncoding.GetByteCount2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetByteCount2 Example/VB/getbytecount-string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.ASCIIEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Ein Zeiger auf das erste zu codierende Zeichen.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen ab dem angegebenen Zeichenzeiger erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.ASCIIEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes verwendet die Anwendung <xref:System.Text.ASCIIEncoding.GetByteCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A>. Die <xref:System.Text.ASCIIEncoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.ASCIIEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist kleiner als Null.  
  
 - oder -   
  
 Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.ASCIIEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="index">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen aus dem angegebenen Zeichenarray erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.ASCIIEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes verwendet die Anwendung <xref:System.Text.ASCIIEncoding.GetByteCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A>. Die <xref:System.Text.ASCIIEncoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.ASCIIEncoding.GetByteCount%2A> Methode zum Zurückgeben der Anzahl von Bytes erforderlich, um ein Array von Unicode-Zeichen mit codieren <xref:System.Text.ASCIIEncoding>.  
  
 [!code-cpp[System.Text.ASCIIEncoding.GetByteCount1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetByteCount1 Example/CPP/getbytecount-char[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.ASCIIEncoding.GetByteCount1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetByteCount1 Example/CS/getbytecount-char[]-int32-int32.cs#1)]
 [!code-vb[System.Text.ASCIIEncoding.GetByteCount1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetByteCount1 Example/VB/getbytecount-char[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.  
  
 - oder -   
  
 Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.ASCIIEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codiert Zeichen in eine Bytefolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Ein Zeiger auf das erste zu codierende Zeichen.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <param name="byteCount">Die maximale Anzahl der zu schreibenden Bytes.</param>
        <summary>Codiert Zeichen beginnend am angegebenen Zeichenzeiger in eine Bytefolge, die beginnend am angegebenen Bytezeiger gespeichert wird.</summary>
        <returns>Die durch <paramref name="bytes" /> angegebene tatsächliche Anzahl von Bytes, die am Speicherort geschrieben wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.ASCIIEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes verwendet die Anwendung <xref:System.Text.ASCIIEncoding.GetByteCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A>. Die <xref:System.Text.ASCIIEncoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesene Daten können nur in sequenzielle Blöcke verfügbar sein. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.ASCIIEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.ASCIIEncoding.GetEncoder%2A> Methode bzw.  
  
 <xref:System.Text.ASCIIEncoding> bietet keine Fehler erkannt. Alle Unicode-Zeichen, die größer als U + 007F übersetzt eine ASCII-Fragezeichen ("?").  
  
> [!CAUTION]
>  Aus Gründen der Sicherheit wird empfohlen, Ihre Anwendung mit <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, oder <xref:System.Text.UTF32Encoding> und fehlererkennung zu aktivieren.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.ASCIIEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> oder <paramref name="byteCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> ist niedriger als die sich ergebende Anzahl von Bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.ASCIIEncoding.GetEncoder" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="charIndex">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</param>
        <param name="byteIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <summary>Codiert Zeichen aus dem angegebenen Zeichenarray in das angegebene Bytearray.</summary>
        <returns>Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.ASCIIEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes verwendet die Anwendung <xref:System.Text.ASCIIEncoding.GetByteCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A>. Die <xref:System.Text.ASCIIEncoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesene Daten können nur in sequenzielle Blöcke verfügbar sein. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.ASCIIEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.ASCIIEncoding.GetEncoder%2A> Methode bzw.  
  
 <xref:System.Text.ASCIIEncoding> bietet keine Fehler erkannt. Alle Unicode-Zeichen, die größer als U + 007F codiert als ASCII-Fragezeichen ("?").  
  
> [!CAUTION]
>  Aus Gründen der Sicherheit wird empfohlen, Ihre Anwendung mit <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, oder <xref:System.Text.UTF32Encoding> und fehlererkennung zu aktivieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.ASCIIEncoding.GetBytes%2A> Methode, um einen Bereich von Zeichen aus einer Zeichenfolge zu codieren, und Speichern der codierten Zeichen in einem Bereich von Elementen in ein Bytearray.  
  
 [!code-cpp[System.Text.ASCIIEncoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetBytes1 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.ASCIIEncoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetBytes1 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.ASCIIEncoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetBytes1 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.  
  
 - oder -   
  
 <paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.ASCIIEncoding.GetEncoder" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Die <see cref="T:System.String" />-Klasse mit den zu codierenden Zeichen.</param>
        <param name="charIndex">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</param>
        <param name="byteIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <summary>Codiert Zeichen aus der angegebenen <see cref="T:System.String" />-Klasse in das angegebene Bytearray.</summary>
        <returns>Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.ASCIIEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes verwendet die Anwendung <xref:System.Text.ASCIIEncoding.GetByteCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A>. Die <xref:System.Text.ASCIIEncoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesene Daten können nur in sequenzielle Blöcke verfügbar sein. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.ASCIIEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.ASCIIEncoding.GetEncoder%2A> Methode bzw.  
  
 <xref:System.Text.ASCIIEncoding> bietet keine Fehler erkannt. Alle Unicode-Zeichen, die größer als U + 007F codiert als ASCII-Fragezeichen ("?").  
  
> [!CAUTION]
>  Aus Gründen der Sicherheit wird empfohlen, Ihre Anwendung mit <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, oder <xref:System.Text.UTF32Encoding> und fehlererkennung zu aktivieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.ASCIIEncoding.GetBytes%2A> Methode, um einen Bereich von Elementen aus einem Array von Unicode-Zeichen zu codieren, und speichern die codierten Bytes in einem Bereich von Elementen in einem Bytearray.  
  
 [!code-cpp[System.Text.ASCIIEncoding.GetBytes2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetBytes2/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.ASCIIEncoding.GetBytes2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetBytes2/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.ASCIIEncoding.GetBytes2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetBytes2/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.  
  
 - oder -   
  
 <paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.ASCIIEncoding.GetEncoder" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge erzeugt werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf das erste zu decodierende Byte.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge ab dem angegebenen Bytezeiger erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.ASCIIEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen, die Anwendung verwendet <xref:System.Text.ASCIIEncoding.GetCharCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A>. Die <xref:System.Text.ASCIIEncoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.ASCIIEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist kleiner als Null.  
  
 - oder -   
  
 Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="Overload:System.Text.ASCIIEncoding.GetChars" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge aus dem angegebenen Bytearray erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.ASCIIEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen, die Anwendung verwendet <xref:System.Text.ASCIIEncoding.GetCharCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A>. Die <xref:System.Text.ASCIIEncoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.ASCIIEncoding.GetCharCount%2A> Methode, um die Anzahl von Zeichen zurückzugeben, die beim Decodieren Sie einen Bereich von Elementen in einem Bytearray erzeugt.  
  
 [!code-cpp[System.Text.ASCIIEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.ASCIIEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.ASCIIEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.  
  
 - oder -   
  
 Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="Overload:System.Text.ASCIIEncoding.GetChars" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodiert eine Bytefolge in Zeichen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf das erste zu decodierende Byte.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <param name="charCount">Die maximale Anzahl der zu schreibenden Zeichen.</param>
        <summary>Decodiert eine Bytefolge beginnend am angegebenen Bytezeiger in Zeichen, die beginnend am angegebenen Zeichenzeiger gespeichert werden.</summary>
        <returns>Die durch <paramref name="chars" /> angegebene tatsächliche Anzahl der Zeichen, die am Speicherort geschrieben wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.ASCIIEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen, die Anwendung verwendet <xref:System.Text.ASCIIEncoding.GetCharCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A>. Die <xref:System.Text.ASCIIEncoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesene Daten können nur in sequenzielle Blöcke verfügbar sein. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.ASCIIEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.ASCIIEncoding.GetEncoder%2A> Methode bzw.  
  
 <xref:System.Text.ASCIIEncoding> bietet keine Fehler erkannt. Jedes Byte, die größer als 0x7F hexadezimale ist decodiert als Unicode-Fragezeichen ("?").  
  
> [!CAUTION]
>  Aus Gründen der Sicherheit wird empfohlen, Ihre Anwendung mit <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, oder <xref:System.Text.UTF32Encoding> und fehlererkennung zu aktivieren.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.ASCIIEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> oder <paramref name="charCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> ist niedriger als die sich ergebende Anzahl von Zeichen.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.ASCIIEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetDecoder" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="byteIndex">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Das Zeichenarray, das die sich ergebenden Zeichen enthalten soll.</param>
        <param name="charIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <summary>Decodiert eine Bytefolge aus dem angegebenen Bytearray in das angegebene Zeichenarray.</summary>
        <returns>Die tatsächliche Anzahl der Zeichen, die in <paramref name="chars" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.ASCIIEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen, die Anwendung verwendet <xref:System.Text.ASCIIEncoding.GetCharCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A>. Die <xref:System.Text.ASCIIEncoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesene Daten können nur in sequenzielle Blöcke verfügbar sein. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.ASCIIEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.ASCIIEncoding.GetEncoder%2A> Methode bzw.  
  
 <xref:System.Text.ASCIIEncoding> bietet keine Fehler erkannt. Jedes Byte, die größer als 0x7F hexadezimale ist decodiert als Unicode-Fragezeichen ("?").  
  
> [!CAUTION]
>  Aus Gründen der Sicherheit wird empfohlen, Ihre Anwendung mit <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, oder <xref:System.Text.UTF32Encoding> und fehlererkennung zu aktivieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie auf einen Bereich von Elementen aus einem Bytearray zu decodieren und speichert das Ergebnis in einen Satz von Elementen in ein Array von Unicode-Zeichen.  
  
 [!code-cpp[System.Text.ASCIIEncoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.ASCIIEncoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.ASCIIEncoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />, <paramref name="byteCount" /> oder <paramref name="charIndex" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="byteindex" /> und <paramref name="byteCount" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.  
  
 - oder -   
  
 <paramref name="charIndex" /> ist kein gültiger Index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> hat von <paramref name="charIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Zeichen aufzunehmen.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.ASCIIEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetDecoder" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Decoder ab, der eine ASCII-codierte Bytefolge in eine Unicode-Zeichenfolge konvertiert.</summary>
        <returns>Ein <see cref="T:System.Text.Decoder" />, der eine ASCII-codierte Bytefolge in eine Unicode-Zeichenfolge konvertiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> konvertiert sequenzielle Blöcke von Bytes in sequenzielle Blöcke von Zeichen ähnlich wie die <xref:System.Text.ASCIIEncoding.GetChars%2A> Methode dieser Klasse. Allerdings eine <xref:System.Text.Decoder> verwaltet Zustandsinformationen zwischen aufrufen, damit Bytesequenzen, die Blöcke umfassen, ordnungsgemäß decodiert werden können. Die <xref:System.Text.Decoder> behält nachfolgende Bytes am Ende der Datenblöcke und die nachfolgenden Bytes im nächste Decodierungsvorgang verwendet. Aus diesem Grund <xref:System.Text.ASCIIEncoding.GetDecoder%2A> und <xref:System.Text.ASCIIEncoding.GetEncoder%2A> eignen sich für die netzwerkübertragung und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Encoder ab, der eine Unicode-Zeichenfolge in eine ASCII-codierte Bytefolge konvertiert.</summary>
        <returns>Ein <see cref="T:System.Text.Encoder" />, der eine Unicode-Zeichenfolge in eine ASCII-codierte Bytefolge konvertiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> konvertiert sequenzielle Blöcke von Zeichen in sequenzielle Blöcke von Bytes auf ähnliche Weise die <xref:System.Text.ASCIIEncoding.GetBytes%2A> Methode dieser Klasse. Allerdings ein <xref:System.Text.Encoder> verwaltet Zustandsinformationen zwischen aufrufen, damit Zeichensequenzen, die Blöcke umfassen, korrekt codiert werden können. Die <xref:System.Text.Encoder> auch beibehalten, nachfolgende Zeichen am Ende der Datenblöcke und das nachfolgenden Zeichen in der nächsten Codierungsvorgang verwendet. Z. B. ein Datenblock möglicherweise eine hohe Ersatzzeichen ohne Entsprechung enden, und die übereinstimmende niedrige Ersatzzeichen ist möglicherweise in den nächsten Datenblock. Aus diesem Grund <xref:System.Text.ASCIIEncoding.GetDecoder%2A> und <xref:System.Text.ASCIIEncoding.GetEncoder%2A> eignen sich für die netzwerkübertragung und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet die maximale Anzahl der Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt wird.</summary>
        <returns>Die maximale Anzahl an Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.ASCIIEncoding.GetByteCount%2A> Methode berechnet die genaue Arraygröße, die <xref:System.Text.ASCIIEncoding.GetBytes%2A> Methode zum Speichern von der resultierenden Bytes, wohingegen die <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A> Methode berechnet die maximale Arraygröße. Die <xref:System.Text.ASCIIEncoding.GetByteCount%2A> Methode in der Regel weniger Speicher belegt, aber die <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A> ein Worst-Case Zahl ist, einschließlich ungünstigsten Fall für das derzeit ausgewählte <xref:System.Text.EncoderFallback>.  Bei Auswahl von Ersatzfallback mit einer potenziell großen Zeichenfolge <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A> große Werte zurückgeben können.  
  
 Die <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A> Methode berücksichtigt potenziell übrig gebliebene Surrogate aus einer vorherigen Codierungsvorgang. Daher, wenn die <xref:System.Text.ASCIIEncoding> -Objekt verwendet die standardmäßige Ersatzfallback oder wenn ein benutzerdefiniertes Ersatzfallback mit einem einzelnen möglichen Fallbackzeichen definiert wurde, gibt die Methode `charCount` + 1. Wenn die <xref:System.Text.ASCIIEncoding> Objekt verwendet einen Ersatzfallback mit mehreren möglichen Fallbackzeichen, der Methodenrückgabe *n* * (`charCount` + 1), wobei *n* ist die maximale Anzahl von Fallback Zeichen.  
  
 <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A> hat keinen Bezug zu <xref:System.Text.ASCIIEncoding.GetChars%2A>. Wenn Ihre Anwendung eine ähnliche Funktion für die Verwendung mit benötigt <xref:System.Text.ASCIIEncoding.GetChars%2A>, sollte <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` ist nicht unbedingt der gleiche Wert wie `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A> Methode zum Berechnen von Bytes erforderlich, um eine angegebene Anzahl von Zeichen zu codieren.  
  
 [!code-cpp[System.Text.ASCIIEncoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.ASCIIEncoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.ASCIIEncoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> ist kleiner als Null.  
  
 - oder -   
  
 Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <altmember cref="M:System.Text.ASCIIEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet die maximale Anzahl der Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</summary>
        <returns>Die maximale Anzahl von Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.ASCIIEncoding.GetCharCount%2A> Methode berechnet die genaue Arraygröße, die <xref:System.Text.ASCIIEncoding.GetChars%2A> Methode zum Speichern der resultierenden Zeichen, die während der <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A> Methode berechnet die maximale Arraygröße. Die <xref:System.Text.ASCIIEncoding.GetCharCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A> Ruft die Anzahl Worst-Case, einschließlich ungünstigsten Fall für das derzeit ausgewählte ab <xref:System.Text.DecoderFallback>. Wenn ein Decoderfallback vorhanden ist, hat, die fallback maximal *n*, <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A> -Methode zurückkehrt *n* * `byteCount`.  
  
 <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A> hat keinen Bezug zu <xref:System.Text.ASCIIEncoding.GetBytes%2A>. Wenn Ihre Anwendung eine ähnliche Funktion für die Verwendung mit benötigt <xref:System.Text.ASCIIEncoding.GetBytes%2A>, sollte <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` ist nicht unbedingt der gleiche Wert wie `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A> Methode, um die maximale Anzahl von Zeichen, die eine angegebene Anzahl von Bytes zu decodieren zu berechnen.  
  
 [!code-cpp[System.Text.ASCIIEncoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.ASCIIEncoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.ASCIIEncoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> ist kleiner als Null.  
  
 - oder -   
  
 Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <altmember cref="M:System.Text.ASCIIEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int byteIndex, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 byteIndex, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.ASCIIEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), byteIndex As Integer, byteCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="byteIndex">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Decodiert einen Bytebereich aus einem Bytearray in eine Zeichenfolge.</summary>
        <returns>Eine <see cref="T:System.String" />-Klasse, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Daten konvertiert werden, z. B. aus einem Stream gelesene Daten können nur in sequenzielle Blöcke verfügbar sein. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.ASCIIEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.ASCIIEncoding.GetEncoder%2A> Methode bzw.  
  
 <xref:System.Text.ASCIIEncoding> bietet keine Fehler erkannt. Jedes Byte, die größer als 0x7F hexadezimale ist decodiert als Unicode-Fragezeichen ("?").  
  
> [!CAUTION]
>  Aus Gründen der Sicherheit sollten Sie verwenden die <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, oder <xref:System.Text.UTF32Encoding> Klassen ab, und Aktivieren der Erkennung anstelle der <xref:System.Text.ASCIIEncoding> Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.ASCIIEncoding.GetString%2A> Methode konvertiert ein Bytearray in eine <xref:System.String>.  
  
 [!code-cpp[System.Text.ASCIIEncoding.GetString1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetString1 Example/CPP/getstring-byte[].cpp#1)]
 [!code-csharp[System.Text.ASCIIEncoding.GetString1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetString1 Example/CS/getstring-byte[].cs#1)]
 [!code-vb[System.Text.ASCIIEncoding.GetString1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.ASCIIEncoding.GetString1 Example/VB/getstring-byte[].vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.ASCIIEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetDecoder" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public override bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.ASCIIEncoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für die aktuelle Codierung Einzelbytecodepunkte verwendet werden.</summary>
        <value>Diese Eigenschaft ist immer <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt die <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> Eigenschaft zur Bestimmung der Größe eines Bytearrays für die Codierung von Vorgängen und die Größe eines Arrays von Zeichen für Codierungsvorgänge (z. B. so, dass die Größe des Bytearrays <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> * die Anzahl der Zeichen sein codiert), rufen Sie die <xref:System.Text.ASCIIEncoding.GetByteCount%2A> oder <xref:System.Text.ASCIIEncoding.GetMaxByteCount%2A> Methode zum Verschlüsseln von Vorgängen und die <xref:System.Text.ASCIIEncoding.GetCharCount%2A> oder <xref:System.Text.ASCIIEncoding.GetMaxCharCount%2A> Methode bei Decodierungsvorgängen. Diese Methoden nimmt die <xref:System.Text.ASCIIEncoding> objektspezifischen Ersatz Fallbackstrategie berücksichtigt beim Berechnen der erforderlichen Arraygröße.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.ASCIIEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.ASCIIEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>