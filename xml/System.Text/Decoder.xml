<Type Name="Decoder" FullName="System.Text.Decoder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="af988a5d852dff603b2e4e888be96288515f405e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531024" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Decoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Decoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Decoder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Decoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Decoder abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Konvertiert eine Bytefolge in einen codierten Zeichensatz.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Abrufen einer Instanz einer Implementierung von der <xref:System.Text.Decoder> -Klasse, die Anwendung sollte verwenden die <xref:System.Text.Encoding.GetDecoder%2A> Methode eine <xref:System.Text.Encoding> Implementierung.  
  
 Die <xref:System.Text.Decoder.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Decoder.GetChars%2A> Methode führt die tatsächlichen Decodierung aus. Es sind mehrere Versionen der beiden Methoden zur Verfügung, in der <xref:System.Text.Decoder> Klasse. Weitere Informationen finden Sie unter <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>. Ein <xref:System.Text.Decoder> -Objekt verwaltet Zustandsinformationen zwischen aufeinander folgenden Aufrufen `GetChars` oder <xref:System.Text.Decoder.Convert%2A> Methoden, damit Bytesequenzen, die Blöcke umfassen, ordnungsgemäß decodiert werden können. Die <xref:System.Text.Decoder> behält nachfolgende Bytes am Ende der Datenblöcke und die nachfolgenden Bytes im nächste Decodierungsvorgang verwendet. Aus diesem Grund <xref:System.Text.Encoding.GetDecoder%2A> und <xref:System.Text.Encoding.GetEncoder%2A> sind für die Übertragung und Datei Netzwerkvorgänge hilfreich, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.  
  
> [!NOTE]
>  Wenn die Anwendung einen Strom von Daten abgeschlossen ist, sollten stellen Sie sicher, dass die Zustandsinformationen, durch Festlegen geleert wird der `flush` Parameter `true` im Aufruf geeigneten Methode. Wenn eine Ausnahme auftritt oder wenn die Anwendung Streams wechselt, sollten Sie aufrufen <xref:System.Text.Decoder.Reset%2A> So löschen Sie den internen Status der `Decoder` Objekt.  
  
## <a name="version-considerations"></a>Version-Überlegungen  
 Ein <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt serialisiert werden kann, während eine Konvertierungsoperation. Der Status des Objekts wird beibehalten, wenn es in der gleichen Version von .NET Framework deserialisiert wird, aber verloren gehen, wenn es in einer anderen Version deserialisiert wird.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von einem <xref:System.Text.Decoder> , zwei unterschiedliche Bytearrays in ein Zeichenarray zu konvertieren. Keines der Zeichen Bytes umfasst die Arrays. Dies ist ähnlich einer <xref:System.IO.StreamReader> Objekt verweist, das intern beim Lesen eines Streams.  
  
 [!code-cpp[Classic Decoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Decoder Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Decoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Decoder Example/CS/source.cs#1)]
 [!code-vb[Classic Decoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Decoder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Wenn Ihre Anwendung von dieser Klasse erbt, müssen sie alle Member überschreiben.</para>
    </block>
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Decoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Decoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Decoder" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um eine Instanz einer Implementierung dieser Klasse zu erhalten, sollte die Anwendung verwenden die <xref:System.Text.Encoding.GetDecoder%2A> Methode von einer <xref:System.Text.Encoding> Implementierung.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht zwei Techniken zum Initialisieren einer neuen <xref:System.Text.Decoder> Instanz.  
  
 [!code-cpp[System.Text.Decoder.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.Decoder.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.Decoder.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert eine codierte Bytefolge in eine Zeichenfolge oder ein Zeichenarray.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char), flush As Boolean, ByRef bytesUsed As Integer, ByRef charsUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <param name="bytesUsed">To be added.</param>
        <param name="charsUsed">To be added.</param>
        <param name="completed">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (byte* bytes, int byteCount, char* chars, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(System::Byte* bytes, int byteCount, char* chars, int charCount, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">Die Adresse eines Puffers, der die zu konvertierenden Bytefolgen enthält.</param>
        <param name="byteCount">Die Anzahl der zu konvertierenden Bytes in <c>bytes</c>.</param>
        <param name="chars">Die Adresse eines Puffers zum Speichern der konvertierten Zeichen.</param>
        <param name="charCount">Die maximale Anzahl von Zeichen in <c>chars</c>, die bei der Konvertierung verwendet wird.</param>
        <param name="flush">
          <see langword="true" />, um anzugeben, dass keine weiteren Daten konvertiert werden; andernfalls <see langword="false" />.</param>
        <param name="bytesUsed">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die von der Konvertierung erzeugt wurden. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <param name="charsUsed">In der Rückgabe dieser Methode ist die Anzahl der Zeichen aus <c>chars</c> enthalten, die bei der Konvertierung verwendet wurden. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <param name="completed">In der Rückgabe dieser Methode ist <see langword="true" /> enthalten, wenn alle von <c>byteCount</c> angegebenen Zeichen konvertiert wurden; andernfalls <see langword="false" />. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Konvertiert einen Puffer codierter Bytes in UTF-16-codierte Zeichen und speichert das Ergebnis in einem anderen Puffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass die <xref:System.Text.Decoder> -Objekt speichert den Zustand zwischen Aufrufen von <xref:System.Text.Decoder.Convert%2A>. Wenn die Anwendung einen Strom von Daten abgeschlossen ist, legen sie die `flush` Parameter `true` um sicherzustellen, dass die Zustandsinformationen geleert wird. Mit dieser Einstellung wird vom Decoder ungültige Bytes am Ende des Datenblocks ignoriert und löscht den internen Puffer. Alle verbleibenden verarbeiteten Daten, die Teil einer logischen Einheit, z. B. das hohe Ersatzzeichen eines Ersatzzeichenpaars werden gemäß der aktuellen fallbackeinstellungen konvertiert.  
  
 Die `Convert` -Methode entwickelt, um in einer Schleife verwendet werden, um zu eine beliebige Anzahl von Eingaben zu decodierende z. B. aus einer Datei oder einem Stream gelesenen Daten. Sie speichert die Ausgabe der Decodierungsvorgang in einen Puffer mit fester Größe. <xref:System.Text.Decoder.GetChars%2A> löst eine Ausnahme aus, wenn die Ausgabepuffer nicht groß genug ist, aber <xref:System.Text.Decoder.Convert%2A> wird so viel Speicherplatz wie möglich zu füllen und die gelesenen Bytes und geschriebenen Zeichen zurück. Siehe auch die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Thema weitere Kommentare.  
  
 Die `completed` Output-Parameter gibt an, ob alle Daten im Eingabepuffer konvertiert und im Ausgabepuffer gespeichert wurden. Dieser Parameter auf festgelegt ist `false` Wenn die Anzahl der Bytes, wird angegeben die `byteCount` Parameter kann nicht konvertiert werden, ohne dass die Anzahl der Zeichen, die gemäß der `charCount` Parameter. In diesem Fall sollte die Anwendung verwenden Sie den Inhalt des Ausgabepuffers oder geben Sie einen neuen Ausgabepuffer Inkrement der `bytes` Parameter, um die Anzahl der Bytes, die gemäß der `bytesUsed` Parameter, rufen Sie anschließend die `Convert` -Methode erneut auf die verbleibenden Eingabe zu verarbeiten.  
  
 Die `completed` Parameter kann auch festgelegt werden, um `false`, obwohl die `bytesUsed` und `byteCount` Parameter gleich sind. Diese Situation tritt auf, wenn es weiterhin Daten in der <xref:System.Text.Decoder> -Objekt, das nicht im gespeichert wurden die `bytes` Puffer.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.Decoder.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> oder <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> oder <paramref name="byteCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">Der Ausgabepuffer ist zu klein, um die konvertierte Eingabe zu enthalten. Der Ausgabepuffer muss mindestens so groß sein, wie durch die <see cref="Overload:System.Text.Decoder.GetCharCount" />-Methode angegeben.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Decoder.Fallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex, int32 charCount, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer, charCount As Integer, flush As Boolean, ByRef bytesUsed As Integer, ByRef charsUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein zu konvertierendes Bytearray</param>
        <param name="byteIndex">Das erste zu konvertierende Element von <c>bytes</c>.</param>
        <param name="byteCount">Die Anzahl zu konvertierende Elemente von <c>bytes</c>.</param>
        <param name="chars">Ein Array zum Speichern der konvertierten Zeichen</param>
        <param name="charIndex">Das erste Element von <c>chars</c>, in dem Daten gespeichert werden.</param>
        <param name="charCount">Die maximale Anzahl der in der Konversion zu verwendenden Elemente von <c>chars</c>.</param>
        <param name="flush">
          <see langword="true" />, um anzugeben, dass keine weiteren Daten konvertiert werden; andernfalls <see langword="false" />.</param>
        <param name="bytesUsed">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die bei der Konvertierung verwendet wurden. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <param name="charsUsed">In der Rückgabe dieser Methode ist die Anzahl der Zeichen aus <c>chars</c> enthalten, die von der Konvertierung erstellt wurden. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <param name="completed">In der Rückgabe dieser Methode ist <see langword="true" /> enthalten, wenn alle von <c>byteCount</c> angegebenen Zeichen konvertiert wurden; andernfalls <see langword="false" />. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Konvertiert ein Array codierter Bytes in UTF-16-codierte Zeichen und speichert das Ergebnis in einem Zeichenarray.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass die <xref:System.Text.Decoder> -Objekt speichert den Zustand zwischen Aufrufen von <xref:System.Text.Decoder.Convert%2A>. Wenn die Anwendung einen Strom von Daten abgeschlossen ist, legen sie die `flush` Parameter `true` um sicherzustellen, dass die Zustandsinformationen geleert wird. Mit dieser Einstellung wird vom Decoder ungültige Bytes am Ende des Datenblocks ignoriert und löscht den internen Puffer. Alle verbleibenden verarbeiteten Daten, die Teil einer logischen Einheit, z. B. das hohe Ersatzzeichen eines Ersatzzeichenpaars werden gemäß der aktuellen fallbackeinstellungen konvertiert.  
  
 Die `Convert` -Methode entwickelt, um in einer Schleife verwendet werden, um zu eine beliebige Anzahl von Eingaben zu decodierende z. B. aus einer Datei oder einem Stream gelesenen Daten. Sie speichert die Ausgabe der Decodierungsvorgang in einen Puffer mit fester Größe. <xref:System.Text.Decoder.GetChars%2A> löst eine Ausnahme aus, wenn die Ausgabepuffer nicht groß genug ist, aber <xref:System.Text.Decoder.Convert%2A> wird so viel Speicherplatz wie möglich zu füllen und die gelesenen Bytes und geschriebenen Zeichen zurück. Siehe auch die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Thema weitere Kommentare.  
  
 Die `completed` Output-Parameter gibt an, ob alle Daten im Eingabepuffer konvertiert und im Ausgabepuffer gespeichert wurden. Dieser Parameter auf festgelegt ist `false` Wenn die Anzahl der Bytes, wird angegeben die `byteCount` Parameter kann nicht konvertiert werden, ohne dass die Anzahl der Zeichen, die gemäß der `charCount` Parameter. In diesem Fall sollte die Anwendung verwenden Sie den Inhalt des Ausgabepuffers oder geben Sie einen neuen Ausgabepuffer Inkrement der `bytes` Parameter, um die Anzahl der Bytes, die gemäß der `bytesUsed` Parameter, rufen Sie anschließend die `Convert` -Methode erneut auf die verbleibenden Eingabe zu verarbeiten.  
  
 Die `completed` Parameter kann auch festgelegt werden, um `false`, obwohl die `bytesUsed` und `byteCount` Parameter gleich sind. Diese Situation tritt auf, wenn es weiterhin Daten in der <xref:System.Text.Decoder> -Objekt, das nicht im gespeichert wurden die `bytes` Puffer.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Text.Encoder.Convert%2A> Methode, um eine Datei mit UTF-16-Zeichen in UTF-8 konvertieren. Es verwendet dann die <xref:System.Text.Decoder.Convert%2A> Methode zum Konvertieren der UTF-8-Zeichen zurück in UTF-16-Zeichen.  
  
 [!code-csharp[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/cs/edCvt.cs#1)]
 [!code-vb[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/vb/edCvt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> oder <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" />, <paramref name="byteIndex" /> oder <paramref name="byteCount" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 Die Länge von<paramref name="chars" /> - <paramref name="charIndex" /> ist kleiner als <paramref name="charCount" />.  
  
 - oder -   
  
 Die Länge von<paramref name="bytes" /> - <paramref name="byteIndex" /> ist kleiner als <paramref name="byteCount" />.</exception>
        <exception cref="T:System.ArgumentException">Der Ausgabepuffer ist zu klein, um die konvertierte Eingabe zu enthalten. Der Ausgabepuffer muss mindestens so groß sein, wie durch die <see cref="Overload:System.Text.Decoder.GetCharCount" />-Methode angegeben.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Decoder.Fallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback Fallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback Fallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Decoder.Fallback" />
      <MemberSignature Language="VB.NET" Value="Public Property Fallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ Fallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Text.DecoderFallback" />-Objekt für das aktuelle <see cref="T:System.Text.Decoder" />-Objekt ab oder legt es fest.</summary>
        <value>Ein <see cref="T:System.Text.DecoderFallback" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.DecoderFallback> -Objekt stellt einen Fehlerhandler, der aufgerufen wird, wenn eine codierte Bytefolge in Zeichen konvertiert werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert in einem set-Vorgang ist <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentException">Ein neuer Wert kann in einem set-Vorgang nicht zugewiesen werden, da das aktuelle <see cref="T:System.Text.DecoderFallbackBuffer" />-Objekt Daten enthält, die noch nicht decodiert wurden.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.FallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="FallbackBuffer">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallbackBuffer FallbackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallbackBuffer FallbackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Text.Decoder.FallbackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FallbackBuffer As DecoderFallbackBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallbackBuffer ^ FallbackBuffer { System::Text::DecoderFallbackBuffer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallbackBuffer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Text.DecoderFallbackBuffer" />-Objekt ab, das dem aktuellen <see cref="T:System.Text.Decoder" />-Objekt zugeordnet ist.</summary>
        <value>Ein <see cref="T:System.Text.DecoderFallbackBuffer" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.DecoderFallbackBuffer> Objekt darstellt, vom verwendeten Daten der <xref:System.Text.DecoderFallback> Objekt. Die <xref:System.Text.DecoderFallback> -Objekt stellt einen Fehlerhandler, der aufgerufen wird, wenn eine codierte Bytefolge in Zeichen konvertiert werden kann.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.Fallback" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge erzeugt werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.ReadOnlySpan{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf das erste zu decodierende Byte.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="flush">
          <see langword="true" />, um das Löschen des internen Status des Encoders nach der Berechnung zu simulieren, andernfalls <see langword="false" />.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge ab dem angegebenen Bytezeiger erzeugt werden. Ein Parameter gibt an, ob der interne Zustand des Decoders nach der Kalkulation gelöscht werden soll.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytesequenz erzeugt werden, und jeglicher Bytes im internen Puffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wirkt sich nicht auf den Zustand des Decoders aus.  
  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Decoder.GetChars%2A> erfordert zum Speichern der resultierenden Zeichen, die Anwendung die zu verwendende <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Wenn `GetChars` aufgerufen wird und `flush` festgelegt `false`, Decoders nachfolgende Bytes am Ende der Datenblöcke in einem internen Puffer gespeichert und verwendet diese im nächsten Decodierungsvorgang. Die Anwendung sollte Aufrufen `GetCharCount` auf einen Block von Daten unmittelbar vor dem Aufruf `GetChars` auf den gleichen Block, damit nachfolgende Bytes aus dem vorherigen Block in die Berechnung eingeschlossen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" /> (<see langword="Nothing" /> in Visual Basic .NET).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Decoder.Fallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge aus dem angegebenen Bytearray erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytesequenz erzeugt werden, und jeglicher Bytes im internen Puffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wirkt sich nicht auf den Zustand des Decoders aus.  
  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Decoder.GetChars%2A> erfordert zum Speichern der resultierenden Zeichen, die Anwendung die zu verwendende <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Wenn `GetChars` aufgerufen wird und `flush` festgelegt `false`, Decoders nachfolgende Bytes am Ende der Datenblöcke in einem internen Puffer gespeichert und verwendet diese im nächsten Decodierungsvorgang. Die Anwendung sollte Aufrufen `GetCharCount` auf einen Block von Daten unmittelbar vor dem Aufruf `GetChars` auf den gleichen Block, damit nachfolgende Bytes aus dem vorherigen Block in die Berechnung eingeschlossen werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Text.Decoder.GetCharCount%2A> Methode, um die erforderliche Anzahl von Zeichen decodiert den angegebenen Bereich von Bytes im Array zu berechnen.  
  
 [!code-cpp[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Decoder.Fallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes, int index, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte(), index As Integer, count As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="flush">
          <see langword="true" />, um das Löschen des internen Status des Encoders nach der Berechnung zu simulieren, andernfalls <see langword="false" />.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge aus dem angegebenen Bytearray erzeugt werden. Ein Parameter gibt an, ob der interne Zustand des Decoders nach der Kalkulation gelöscht werden soll.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytesequenz erzeugt werden, und jeglicher Bytes im internen Puffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wirkt sich nicht auf den Zustand des Decoders aus.  
  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Decoder.GetChars%2A> erfordert zum Speichern der resultierenden Zeichen, die Anwendung die zu verwendende <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Wenn `GetChars` aufgerufen wird und `flush` festgelegt `false`, Decoders nachfolgende Bytes am Ende der Datenblöcke in einem internen Puffer gespeichert und verwendet diese im nächsten Decodierungsvorgang. Die Anwendung sollte Aufrufen `GetCharCount` auf einen Block von Daten unmittelbar vor dem Aufruf `GetChars` auf den gleichen Block, damit nachfolgende Bytes aus dem vorherigen Block in die Berechnung eingeschlossen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Decoder.Fallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge in Zeichen decodiert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf das erste zu decodierende Byte.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <param name="charCount">Die maximale Anzahl der zu schreibenden Zeichen.</param>
        <param name="flush">
          <see langword="true" /> löscht nach der Konvertierung den internen Zustand des Decoders, andernfalls <see langword="false" />.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge beginnend am angegebenen Bytezeiger einschließlich aller Bytes im internen Puffer in Zeichen decodiert, die ab Beginn des angegebenen Zeichenzeigers gespeichert werden. Ein Parameter gibt an, ob der interne Zustand des Decoders nach der Konvertierung zu löschen ist.</summary>
        <returns>Die tatsächliche Anzahl der Zeichen, die an der durch den <paramref name="chars" />-Parameter angegebenen Position geschrieben wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass die <xref:System.Text.Decoder> -Objekt speichert den Zustand zwischen Aufrufen von <xref:System.Text.Decoder.GetChars%2A>. Wenn die Anwendung einen Strom von Daten abgeschlossen ist, legen sie die `flush` Parameter `true` um sicherzustellen, dass die Zustandsinformationen geleert wird. Mit dieser Einstellung wird vom Decoder ungültige Bytes am Ende des Datenblocks ignoriert und löscht den internen Puffer.  
  
 Zum Berechnen der genauen Puffergröße `GetChars` erfordert zum Speichern der resultierenden Zeichen, die Anwendung die zu verwendende <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Wenn `GetChars` aufgerufen wird und `flush` festgelegt `false`, Decoders nachfolgende Bytes am Ende der Datenblöcke in einem internen Puffer gespeichert und verwendet diese im nächsten Decodierungsvorgang. Die Anwendung sollte Aufrufen `GetCharCount` auf einen Block von Daten unmittelbar vor dem Aufruf `GetChars` auf den gleichen Block, damit nachfolgende Bytes aus dem vorherigen Block in die Berechnung eingeschlossen werden.  
  
 Wenn Ihre Anwendung ist viele Segmente eines Eingabedatenstroms konvertieren, können Sie verwenden die <xref:System.Text.Decoder.Convert%2A> Methode. <xref:System.Text.Decoder.GetChars%2A> löst eine Ausnahme aus, wenn die Ausgabepuffer nicht groß genug ist, aber <xref:System.Text.Decoder.Convert%2A> wird so viel Speicherplatz wie möglich zu füllen und die gelesenen Bytes und geschriebenen Zeichen zurück. Siehe auch die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Thema weitere Kommentare.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).  
  
 - oder -   
  
 <paramref name="chars" /> ist <see langword="null" />(<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> oder <paramref name="charCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> ist niedriger als die sich ergebende Anzahl von Zeichen.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Decoder.Fallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="byteIndex">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Das Zeichenarray, das die sich ergebenden Zeichen enthalten soll.</param>
        <param name="charIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge aus dem angegebenen Bytearray einschließlich aller Bytes im internen Puffer in das angegebene Zeichenarray decodiert.</summary>
        <returns>Die tatsächliche Anzahl der Zeichen, die in <paramref name="chars" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass die <xref:System.Text.Decoder> -Objekt speichert den Zustand zwischen Aufrufen von <xref:System.Text.Decoder.GetChars%2A>. Wenn die Anwendung einen Strom von Daten abgeschlossen ist, legen sie die `flush` Parameter `true` um sicherzustellen, dass die Zustandsinformationen geleert wird. Mit dieser Einstellung wird vom Decoder ungültige Bytes am Ende des Datenblocks ignoriert und löscht den internen Puffer.  
  
 Zum Berechnen der genauen Arraygröße `GetChars` erfordert zum Speichern der resultierenden Zeichen, die Anwendung die zu verwendende <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Wenn `GetChars` aufgerufen wird und `flush` festgelegt `false`, Decoders nachfolgende Bytes am Ende der Datenblöcke in einem internen Puffer gespeichert und verwendet diese im nächsten Decodierungsvorgang. Die Anwendung sollte Aufrufen `GetCharCount` auf einen Block von Daten unmittelbar vor dem Aufruf `GetChars` auf den gleichen Block, damit nachfolgende Bytes aus dem vorherigen Block in die Berechnung eingeschlossen werden.  
  
 Wenn Ihre Anwendung ist viele Segmente eines Eingabedatenstroms konvertieren, können Sie verwenden die <xref:System.Text.Decoder.Convert%2A> Methode. <xref:System.Text.Decoder.GetChars%2A> löst eine Ausnahme aus, wenn die Ausgabepuffer nicht groß genug ist, aber <xref:System.Text.Decoder.Convert%2A> wird so viel Speicherplatz wie möglich zu füllen und die gelesenen Bytes und geschriebenen Zeichen zurück. Siehe auch die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Thema weitere Kommentare.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie auf einen Bereich von Elementen aus einem Bytearray zu decodieren und in ein Array von Unicode-Zeichen zu speichern. Die <xref:System.Text.Decoder.GetCharCount%2A> Methode wird verwendet, um die Anzahl der Zeichen, die zum Speichern der decodierten Elemente im Array zu berechnen `bytes`. Die <xref:System.Text.Decoder.GetChars%2A> Methode decodiert die angegebenen Elemente im Bytearray und speichert sie in das neue Array von Zeichen.  
  
 [!code-cpp[System.Text.Decoder.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.Decoder.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.Decoder.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).  
  
 - oder -   
  
 <paramref name="chars" /> ist <see langword="null" />(<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />, <paramref name="byteCount" /> oder <paramref name="charIndex" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="byteindex" /> und <paramref name="byteCount" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.  
  
 - oder -   
  
 <paramref name="charIndex" /> ist kein gültiger Index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> hat von <paramref name="charIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Zeichen aufzunehmen.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Decoder.Fallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="byteIndex">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Das Zeichenarray, das die sich ergebenden Zeichen enthalten soll.</param>
        <param name="charIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <param name="flush">
          <see langword="true" /> löscht nach der Konvertierung den internen Zustand des Decoders, andernfalls <see langword="false" />.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge aus dem angegebenen Bytearray einschließlich aller Bytes im internen Puffer in das angegebene Zeichenarray decodiert. Ein Parameter gibt an, ob der interne Zustand des Decoders nach der Konvertierung zu löschen ist.</summary>
        <returns>Die tatsächliche Anzahl der Zeichen, die in den <paramref name="chars" />-Parameter geschrieben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass die <xref:System.Text.Decoder> -Objekt speichert den Zustand zwischen Aufrufen von <xref:System.Text.Decoder.GetChars%2A>. Wenn die Anwendung einen Strom von Daten abgeschlossen ist, legen sie die `flush` Parameter `true` um sicherzustellen, dass die Zustandsinformationen geleert wird. Mit dieser Einstellung wird vom Decoder ungültige Bytes am Ende des Datenblocks ignoriert und löscht den internen Puffer.  
  
 Zum Berechnen der genauen Arraygröße `GetChars` erfordert zum Speichern der resultierenden Zeichen, die Anwendung die zu verwendende <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Wenn `GetChars` aufgerufen wird und `flush` festgelegt `false`, Decoders nachfolgende Bytes am Ende der Datenblöcke in einem internen Puffer gespeichert und verwendet diese im nächsten Decodierungsvorgang. Die Anwendung sollte Aufrufen `GetCharCount` auf einen Block von Daten unmittelbar vor dem Aufruf `GetChars` auf den gleichen Block, damit nachfolgende Bytes aus dem vorherigen Block in die Berechnung eingeschlossen werden.  
  
 Wenn Ihre Anwendung ist viele Segmente eines Eingabedatenstroms konvertieren, können Sie verwenden die <xref:System.Text.Decoder.Convert%2A> Methode. <xref:System.Text.Decoder.GetChars%2A> löst eine Ausnahme aus, wenn die Ausgabepuffer nicht groß genug ist, aber <xref:System.Text.Decoder.Convert%2A> wird so viel Speicherplatz wie möglich zu füllen und die gelesenen Bytes und geschriebenen Zeichen zurück. Siehe auch die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Thema weitere Kommentare.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).  
  
 - oder -   
  
 <paramref name="chars" /> ist <see langword="null" />(<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />, <paramref name="byteCount" /> oder <paramref name="charIndex" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="byteindex" /> und <paramref name="byteCount" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.  
  
 - oder -   
  
 <paramref name="charIndex" /> ist kein gültiger Index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> hat von <paramref name="charIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Zeichen aufzunehmen.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - und -  
  
 Für <see cref="P:System.Text.Decoder.Fallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird der Decoder in den Anfangszustand zurückversetzt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode löscht den internen Zustand des der <xref:System.Text.Decoder> Objekt. Die Methode löscht alle Zustandsinformationen, die in einem vorherigen Aufruf von aufgezeichneten <xref:System.Text.Decoder.GetChars%2A> oder <xref:System.Text.Decoder.Convert%2A>, einschließlich nachfolgende Bytes am Ende des vorherigen Datenblocks.  
  
 Rufen Sie Ihre Anwendung sollte die <xref:System.Text.Decoder.Reset%2A> Methode, wenn es derselbe Decoder verwendet werden, selbst wenn eine Ausnahme ausgelöst wird, indem Sie möchte <xref:System.Text.Decoder.GetChars%2A>, <xref:System.Text.Decoder.Convert%2A>, oder <xref:System.Text.Decoder.GetCharCount%2A>, oder wenn der Decoder Streams schaltet an und beginnt, einen anderen Stream zu decodieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>