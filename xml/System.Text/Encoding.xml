<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2f031561ce5fc2208a221fc7cdca2e0869901103" /><Meta Name="ms.sourcegitcommit" Value="385ff23cc00fe9aa1c93460c62603b45c2041d0b" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/22/2019" /><Meta Name="ms.locfileid" Value="74388049" /></Metadata><TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Zeichencodierung dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 Beim Kodieren werden Unicode-Zeichen in eine Bytefolge transformiert. Im Gegensatz dazu ist das Decodieren der Prozess der Transformation einer Sequenz codierter Bytes in eine Gruppe von Unicode-Zeichen. Informationen zu den Unicode-Transformations Formaten (UTFs) und anderen Codierungen, die von <xref:System.Text.Encoding>unterstützt werden, finden Sie unter [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md).

 Beachten Sie, dass <xref:System.Text.Encoding> für die Verwendung von Unicode-Zeichen anstelle von willkürlichen Binärdaten (z. b. Byte Arrays) vorgesehen ist. Wenn Sie beliebige Binärdaten in Text codieren müssen, sollten Sie ein Protokoll wie z. b. UUEncode verwenden, das von Methoden wie z. b. <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>implementiert wird.

 .Net bietet die folgenden Implementierungen der <xref:System.Text.Encoding>-Klasse, um aktuelle Unicode-Codierungen und andere Codierungen zu unterstützen:

-   <xref:System.Text.ASCIIEncoding> Unicode-Zeichen als einzelne 7-Bit-ASCII-Zeichen codiert. Diese Codierung unterstützt nur Zeichen Werte zwischen U + 0000 und u + 007F. Codepage 20127. Auch über die <xref:System.Text.Encoding.ASCII%2A>-Eigenschaft verfügbar.

-   <xref:System.Text.UTF7Encoding> Unicode-Zeichen mithilfe der UTF-7-Codierung codiert. Diese Codierung unterstützt alle Unicode-Zeichen Werte. Codepage 65000. Auch über die <xref:System.Text.Encoding.UTF7%2A>-Eigenschaft verfügbar.

-   <xref:System.Text.UTF8Encoding> Unicode-Zeichen mithilfe der UTF-8-Codierung codiert. Diese Codierung unterstützt alle Unicode-Zeichen Werte. Codepage 65001. Auch über die <xref:System.Text.Encoding.UTF8%2A>-Eigenschaft verfügbar.

-   <xref:System.Text.UnicodeEncoding> Unicode-Zeichen mithilfe der UTF-16-Codierung codiert. Sowohl Little-Endian-als auch Big-Endian-Byte Bestellungen werden unterstützt. Auch über die <xref:System.Text.Encoding.Unicode%2A>-Eigenschaft und die <xref:System.Text.Encoding.BigEndianUnicode%2A>-Eigenschaft verfügbar.

-   <xref:System.Text.UTF32Encoding> codiert Unicode-Zeichen mithilfe der UTF-32-Codierung. Es werden sowohl kleine Endian-(Codepage 12000) als auch Big Endian-Byte Bestellungen (Codepage 12001) unterstützt. Auch über die <xref:System.Text.Encoding.UTF32%2A>-Eigenschaft verfügbar.

 Die <xref:System.Text.Encoding>-Klasse ist hauptsächlich für die Konvertierung zwischen verschiedenen Codierungen und Unicode vorgesehen. Häufig ist eine der abgeleiteten Unicode-Klassen die richtige Wahl für Ihre APP.

 Verwenden Sie die <xref:System.Text.Encoding.GetEncoding%2A>-Methode, um andere Codierungen abzurufen, und rufen Sie die <xref:System.Text.Encoding.GetEncodings%2A>-Methode auf, um eine Liste aller Codierungen abzurufen.

 In der folgenden Tabelle sind die Codierungen aufgelistet, die von .NET Framework und .net Core unterstützt werden. Sie listet die Code Page Nummer jeder Codierung und die Werte der <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>-und <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> Eigenschaften der Codierung auf. Ein Häkchen in den Spalten **.NET Framework Support** und **.net Core-Unterstützung** gibt an, dass die Codepage unabhängig von der zugrunde liegenden Plattform nativ von der .NET-Implementierung unterstützt wird. Für .NET Framework hängt die Verfügbarkeit anderer Codierungen, die in der Tabelle aufgelistet sind, vom Betriebssystem ab. Für .net Core sind andere Codierungen verfügbar, indem die <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType>-Klasse oder die Ableitung von der <xref:System.Text.EncodingProvider?displayProperty=nameWithType>-Klasse verwendet wird.

> [!NOTE]
> Codepages, deren <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>-Eigenschaft einem internationalen Standard entspricht, entsprechen nicht notwendigerweise vollständig dem Standard.

|Codepage|name|Angezeigter Name|.NET Framework Unterstützung| .NET Core-Unterstützung |
|---------|----|------------|----------------------|-------------------|
|37|IBM037|IBM EBCDIC (USA-Kanada)|||
|437|IBM437|OEM-USA|||
|500|IBM500|IBM EBCDIC (International)|||
|708|ASMO-708|Arabisch (ASMO 708)|||
|720|DOS-720|Arabisch (DOS)|||
|737|ibm737|Griechisch (DOS)|||
|775|ibm775|Baltisch (DOS)|||
|850|ibm850|Westeuropäisch (DOS)|||
|852|ibm852|Mitteleuropäisch (DOS)|||
|855|IBM855|OEM-Kyrillisch|||
|857|ibm857|Türkisch (DOS)|||
|858|IBM00858|OEM-mehrsprachige lateinische I|||
|860|IBM860|Portugiesisch (DOS)|||
|861|ibm861|Isländisch (DOS)|||
|862|DOS-862|Hebräisch (DOS)|||
|863|IBM863|Französisch (Kanada)|||
|864|IBM864|Arabisch (864)|||
|865|IBM865|Nordisch (DOS)|||
|866|cp866|Kyrillisch (DOS)|||
|869|ibm869|Griechisch, modern (DOS)|||
|870|IBM870|IBM EBCDIC (mehrsprachige lateinische-2)|||
|874|windows-874|Thailändisch (Windows)|||
|875|cp875|IBM EBCDIC (griechisch modern)|||
|932|shift_jis|Japanisch (Shift-JIS)|||
|936|gb2312|Chinesisch vereinfacht (GB2312)|✓||
|949|ks_c_5601-1987|Koreanisch|||
|950|Big5|Chinesisch traditionell (Big5)|||
|1026|IBM1026|IBM EBCDIC (Türkisch (lateinisch-5)|||
|1047|IBM01047|IBM Latin-1|||
|1140|IBM01140|IBM EBCDIC (USA-Kanada-Euro)|||
|1141|IBM01141|IBM EBCDIC (Deutschland-Euro)|||
|1142|IBM01142|IBM EBCDIC (Dänemark-Norwegen-Euro)|||
|1143|IBM01143|IBM EBCDIC (Finnland-Schweden-Euro)|||
|1144|IBM01144|IBM EBCDIC (Italien-Euro)|||
|1145|IBM01145|IBM EBCDIC (Spanien-Euro)|||
|1146|IBM01146|IBM EBCDIC (UK-Euro)|||
|1147|IBM01147|IBM EBCDIC (Frankreich-Euro)|||
|1148|IBM01148|IBM EBCDIC (International-Euro)|||
|1149|IBM01149|IBM EBCDIC (Isländisch-Euro)|||
|1200|UTF-16|Unicode|✓|✓|
|1201|unicodeFFFE|Unicode (Big-tedian)|✓|✓|
|1250|windows-1250|Mitteleuropäisch (Windows)|||
|1251|windows-1251|Kyrillisch (Windows)|||
|1252|Windows-1252|Westeuropäisch (Windows)|✓||
|1253|windows-1253|Griechisch (Windows)|||
|1254|windows-1254|Türkisch (Windows)|||
|1255|windows-1255|Hebräisch (Windows)|||
|1256|windows-1256|Arabisch (Windows)|||
|1257|windows-1257|Baltisch (Windows)|||
|1258|windows-1258|Vietnamesisch (Windows)|||
|1361|Johab|Koreanisch (Johab)|||
|10000|Macintosh|Westeuropäisch (Mac)|||
|10001|x-Mac-Japanisch|Japanisch (Mac)|||
|10002|x-mac-chinesetrad|Chinesisch (traditionell) (Mac)|||
|10003|x-Mac-Koreanisch|Koreanisch (Mac)|✓||
|10004|x-Mac-Arabisch|Arabisch (Mac)|||
|10005|x-Mac-Hebräisch|Hebräisch (Mac)|||
|10006|x-Mac-Griechisch|Griechisch (Mac)|||
|10007|x-Mac-Kyrillisch|Kyrillisch (Mac)|||
|10008|x-Mac-chinesesimp|Chinesisch vereinfacht (Mac)|✓||
|10010|x-Mac-Rumänisch|Rumänisch (Mac)|||
|10017|x-Mac-Ukrainisch|Ukrainisch (Mac)|||
|10021|x-Mac-Thai|Thailändisch (Mac)|||
|10029|x-Mac-CE|Mitteleuropäisch (Mac)|||
|10079|x-Mac-Isländisch|Isländisch (Mac)|||
|10081|x-Mac-Türkisch|Türkisch (Mac)|||
|10082|x-Mac-Kroatisch|Kroatisch (Mac)|||
|12000|UTF-32|Unicode (UTF-32)|✓|✓|
|12001|UTF-32be|Unicode (UTF-32 Big-d)|✓|✓|
|20000|x-Chinesisch-CNS|Chinesisch (traditionell) (CNS)|||
|20001|x-cp20001|TCA-Taiwan|||
|20002|x-Chinesisch-eTEN|Chinesisch (traditionell) (eTEN)|||
|20003|x-cp20003|IBM5550 Taiwan|||
|20004|x-cp20004|Teletext-Taiwan|||
|20005|x-cp20005|Wang Taiwan|||
|20105|x-IA5|Westeuropäisch (IA5)|||
|20106|x-IA5-German|Deutsch (IA5)|||
|20107|x-IA5-Schwedisch|Schwedisch (IA5)|||
|20108|x-IA5-Norwegisch|Norwegisch (IA5)|||
|20127|us-ascii|US-ASCII|✓|✓|
|20261|x-cp20261|T. 61|||
|20269|x-cp20269|ISO-6937|||
|20273|IBM273|IBM EBCDIC (Deutschland)|||
|20277|IBM277|IBM EBCDIC (Dänemark-Norwegen)|||
|20278|IBM278|IBM EBCDIC (Finnland-Schweden)|||
|20280|IBM280|IBM EBCDIC (Italien)|||
|20284|IBM284|IBM EBCDIC (Spanien)|||
|20285|IBM285|IBM EBCDIC (Vereinigtes Königreich)|||
|20290|IBM290|IBM EBCDIC (Japanisch Katakana)|||
|20297|IBM297|IBM EBCDIC (Frankreich)|||
|20420|IBM420|IBM EBCDIC (Arabisch)|||
|20423|IBM423|IBM EBCDIC (Griechisch)|||
|20424|IBM424|IBM EBCDIC (Hebräisch)|||
|20833|x-EBCDIC-koreanextended|IBM EBCDIC (Koreanisch erweitert)|||
|20838|IBM-Thai|IBM EBCDIC (Thailändisch)|||
|20866|koi8-r|Kyrillisch (KOI8-R)|||
|20871|IBM871|IBM EBCDIC (Isländisch)|||
|20880|IBM880|IBM EBCDIC (Kyrillisch Russisch)|||
|20905|IBM905|IBM EBCDIC (Türkisch)|||
|20924|IBM00924|IBM Latin-1|||
|20932|EUC-JP|Japanisch (JIS 0208-1990 und 0212-1990)|||
|20936|x-cp20936|Chinesisch vereinfacht (GB2312-80)|✓||
|20949|x-cp20949|Koreanisch Wansung|✓||
|21025|cp1025|IBM EBCDIC (Kyrillisch Serbisch-Bulgarisch)|||
|21866|KOI8-u|Kyrillisch (KOI8-U)|||
|28591|iso-8859-1|Westeuropäisch (ISO)|✓|✓|
|28592|iso-8859-2|Mitteleuropäisch (ISO)|||
|28593|iso-8859-3|Lateinisch 3 (ISO)|||
|28594|iso-8859-4|Baltisch (ISO)|||
|28595|iso-8859-5|Kyrillisch (ISO)|||
|28596|iso-8859-6|Arabisch (ISO)|||
|28597|iso-8859-7|Griechisch (ISO)|||
|28598|iso-8859-8|Hebräisch (ISO-Visual)|✓||
|28599|iso-8859-9|Türkisch (ISO)|||
|28603|iso-8859-13|Estonian (ISO)|||
|28605|iso-8859-15|Lateinisch 9 (ISO)|||
|29001|x-Europa|'|||
|38598|iso-8859-8-i|Hebräisch (ISO-logisch)|✓||
|50220|ISO-2022-JP|Japanisch (JIS)|✓||
|50221|csISO2022JP|Japanisch (JIS-1-Byte-Kana zulassen)|✓||
|50222|ISO-2022-JP|Japanisch (JIS-1 Byte Kana-so/SI)|✓||
|50225|ISO-2022-KR|Koreanisch (ISO)|✓||
|50227|x-cp50227|Chinesisch vereinfacht (ISO-2022)|✓||
|51932|EUC-JP|Japanisch (EUC)|✓||
|51936|EUC-CN|Chinesisch (vereinfacht) (EUC)|✓||
|51949|EUC-KR|Koreanisch (EUC)|✓||
|52936|hz-gb-2312|Chinesisch (vereinfacht) (Hz)|✓||
|54936|GB18030|Chinesisch vereinfacht (GB18030)|✓||
|57002|x-ISCII-de|ISCII-Geräte Abteilung|✓||
|57003|x-ISCII-be|ISCII Bengalisch|✓||
|57004|x-iscii-ta|ISCII Tamil|✓||
|57005|x-ISCII-te|ISCII Telugu|✓||
|57006|x-ISCII-as|ISCII-Assamese|✓||
|57007|x-ISCII-or|ISCII Oriya|✓||
|57008|x-ISCII-Ka|ISCII Kannada|✓||
|57009|x-ISCII-MA|ISCII Malayalam|✓||
|57010|x-iscii-gu|ISCII Gujarati|✓||
|57011|x-iscii-pa|ISCII Punjabi|✓||
|65000|UTF-7|Unicode (UTF-7)|✓|✓|
|65001|utf-8|Unicode (UTF-8)|✓|✓|

 Im folgenden Beispiel werden die Methoden <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> und <xref:System.Text.Encoding.GetEncoding%28System.String%29> aufgerufen, um die Windows-Codepage-Codierung (Windows) zu erhalten. Er vergleicht die <xref:System.Text.Encoding> von den Methoden Aufrufen zurückgegebenen Objekte, um anzuzeigen, dass Sie gleich sind. Anschließend zeigt Maps den Unicode-Codepunkt und den entsprechenden Codepage-Wert für jedes Zeichen im griechischen Alphabet an.

 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]

 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die vom bereitgestellten <xref:System.Text.Encoder> verwenden <xref:System.Text.Encoding.GetDecoder%2A> Methode bzw. die <xref:System.Text.Encoding.GetEncoder%2A> Methode einer abgeleiteten Klasse.

 Der UTF-16-und der UTF-32-Encoder können die Big-Endian-Byte Reihenfolge (signifikanteste Byte zuerst) oder die kleine Endian-Byte Reihenfolge (das am wenigsten signifikante Byte zuerst) verwenden. Beispielsweise wird der lateinische Großbuchstabe A (U + 0041) wie folgt serialisiert (in Hexadezimal):

-   UTF-16 Big-Endian-Byte Reihenfolge: 00 41

-   UTF-16 Little-Endian-Byte Reihenfolge: 41 00

-   UTF-32 Big Endian-Byte Reihenfolge: 00 00 00 41

-   UTF-32 Little-Endian-Byte Reihenfolge: 41 00 00 00

 Es ist in der Regel effizienter, Unicode-Zeichen mithilfe der systemeigenen Byte Reihenfolge zu speichern. Beispielsweise ist es besser, die Little-Endian-Byte Reihenfolge auf kleinen Endian-Plattformen wie z. b. Intel-Computern zu verwenden.

 Die <xref:System.Text.Encoding.GetPreamble%2A>-Methode ruft ein Bytearray ab, das die Byte Reihenfolge-Marke (BOM) enthält. Wenn dieses Bytearray einem codierten Stream vorangestellt wird, hilft es dem Decoder, das verwendete Codierungsformat zu identifizieren.

 Weitere Informationen zur Byte Reihenfolge und zur Byte Reihenfolge-Markierung finden Sie im Unicode-Standard auf der [Unicode-Homepage](https://go.microsoft.com/fwlink/?LinkId=37123).

 Beachten Sie, dass die Codierungs Klassen Fehler zulassen:

-   Wechseln Sie im Hintergrund zu einem "?"-Zeichen.

-   Verwenden Sie ein Zeichen mit der optimalen Anpassung.

-   Wechseln Sie zu einem anwendungsspezifischen Verhalten, indem Sie die Klassen <xref:System.Text.EncoderFallback> und <xref:System.Text.DecoderFallback> mit dem Unicode-Ersatz Zeichen "U + FFFD" verwenden.

 Sie sollten für jeden Datenstrom Fehler eine Ausnahme auslösen. Eine APP verwendet entweder das Flag "throwOnError", falls zutreffend, oder verwendet die Klassen "<xref:System.Text.EncoderExceptionFallback>" und "<xref:System.Text.DecoderExceptionFallback>". Der Fall Back am besten geeignet ist oft nicht empfehlenswert, da dies zu Datenverlusten oder Verwirrung führen kann und langsamer als einfache Zeichen Ersetzungen ist. Bei ANSI-Codierungen ist das beste Verhalten der Standardeinstellung.



## Examples
 Im folgenden Beispiel wird eine Zeichenfolge von einer Codierung in eine andere konvertiert.

> [!NOTE]
>  Das Byte []-Array ist der einzige Typ in diesem Beispiel, der die codierten Daten enthält. Die .NET-Typen "char" und "String" sind selbst Unicode, sodass der <xref:System.Text.Encoding.GetChars%2A>-Rückruf die Daten zurück in Unicode decodiert.

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Abgeleitete Klassen überschreiben diesen Konstruktor.

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">Der Codepagebezeichner der bevorzugten Codierung.

 - oder -

 0, um die Standardcodierung zu verwenden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse, die der angegebenen Codepage entspricht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Abgeleitete Klassen überschreiben diesen Konstruktor.

 Aufrufe dieses Konstruktors aus einer abgeleiteten Klasse erstellen ein <xref:System.Text.Encoding> Objekt, das einen Fall Back mit dem besten Wert für Codierungs-und Decodierungs Vorgänge verwendet. Die Eigenschaften "<xref:System.Text.Encoding.DecoderFallback%2A>" und "<xref:System.Text.Encoding.EncoderFallback%2A>" sind schreibgeschützt und können nicht geändert werden. Um die Fall Back Strategie für eine Klasse zu steuern, die von <xref:System.Text.Encoding>abgeleitet ist, müssen Sie den <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>-Konstruktor aufzurufen.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codePage" /> ist kleiner als Null.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">Der Bezeichner der Codierungs-Codepage.</param>
        <param name="encoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn ein Zeichen nicht mit der aktuellen Codierung codiert werden kann.</param>
        <param name="decoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn eine Bytefolge nicht mit der aktuellen Codierung decodiert werden kann.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse, die der angegebenen Codepage entspricht, mit den angegebenen Fallbackstrategien für Codierer und Decodierer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Dieser Konstruktor ist `protected`. abgeleitete Klassen überschreiben Sie.

 Dieser Konstruktor wird von einer abgeleiteten Klasse aufgerufen, um die Fall Back Codierungs-und Decodierungs Strategien zu steuern. Mit den <xref:System.Text.Encoding> Klassenkonstruktoren werden schreibgeschützte Codierungs Objekte erstellt, die die Festlegung des Encoders oder Decoderfallbacks nach der Erstellung des Objekts nicht zulassen.

 Wenn entweder `encoderFallback` oder `decoderFallback` den Wert NULL hat, wird der Fall Back mit der besten Anpassung als entsprechende Fall Back Strategie verwendet.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codePage" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für den ASCII-Zeichensatz (7-Bit) ab.</summary>
        <value>Eine Codierung für den ASCII-Zeichensatz (7 Bits).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASCII-Zeichen sind auf die niedrigsten 128 Unicode-Zeichen (von U + 0000 bis U + 007F) beschränkt.

 Wenn Sie die ASCII-Codierung für Ihre App auswählen, sollten Sie Folgendes beachten:

-   Die ASCII-Codierung ist in der Regel für Protokolle geeignet, für die ASCII erforderlich ist.

-   Wenn Sie eine 8-Bit-Codierung benötigen (was manchmal fälschlicherweise als "ASCII" bezeichnet wird), wird die UTF-8-Codierung über die ASCII-Codierung empfohlen. Für die Zeichen 0-7f sind die Ergebnisse identisch, aber die Verwendung von UTF-8 vermeidet den Datenverlust, indem die Darstellung aller Unicode-Zeichen, die darstellbar sind, zugelassen wird. Beachten Sie, dass die ASCII-Codierung eine 8-Bit-Mehrdeutigkeit aufweist, die böswillige Verwendungsmöglichkeiten zulässt, aber die UTF-8-Codierung entfernt Mehrdeutigkeiten über das 8. Bit.

-   Vor der .NET Framework Version 2,0 ermöglichte das .NET Framework Spoofing, indem das 8. Bit ignoriert wurde. Beginnend mit dem .NET Framework 2,0 werden nicht-ASCII-Code Punkte während der Decodierung zurückgegriffen.

 Das <xref:System.Text.ASCIIEncoding> Objekt, das von dieser Eigenschaft zurückgegeben wird, verfügt möglicherweise nicht über das entsprechende Verhalten für Ihre APP. Er verwendet einen Ersatz Fall Back, um jede Zeichenfolge zu ersetzen, die nicht codiert werden kann, und jedes Byte, das nicht mit einem Fragezeichen ("?") decodiert werden kann. Stattdessen können Sie die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>-Methode aufzurufen, um ein <xref:System.Text.ASCIIEncoding> Objekt zu instanziieren, dessen Fall Back entweder eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>ist, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]



## Examples
 Im folgenden Beispiel werden die Auswirkungen der ASCII-Codierung auf Zeichen, die sich außerhalb des ASCII-Bereichs befinden, veranschaulicht.

 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-16-Format mit Big-Endian-Bytereihenfolge ab.</summary>
        <value>Ein Codierungsobjekt für das UTF-16-Format, das die Big-Endian-Bytereihenfolge verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das <xref:System.Text.UnicodeEncoding> Objekt, das von dieser Eigenschaft zurückgegeben wird, verfügt möglicherweise nicht über das entsprechende Verhalten für Ihre APP. Er verwendet einen Ersatz Fall Back, um jede Zeichenfolge zu ersetzen, die nicht codiert werden kann, und jedes Byte, das nicht mit einem Fragezeichen ("?") decodiert werden kann. Stattdessen können Sie den <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>-Konstruktor aufzurufen, um ein Big-Endian-<xref:System.Text.UnicodeEncoding> Objekt zu instanziieren, dessen Fall Back entweder eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>ist, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]

 Das zurückgegebene <xref:System.Text.UnicodeEncoding>-Objekt verfügt über die Eigenschaften <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>und <xref:System.Text.Encoding.WebName%2A>, die den Namen "unicodeFFFE" ergeben. Obwohl die UTF-16 Big Endian-Byte Reihenfolge Markierung das hexadezimale FEFF ist, wurde der Name "unicodeFFFE" ausgewählt, da die Byte Reihenfolge-Markierung auf kleinen Endian-Windows-Computern als hexadezimale FFFE angezeigt wird.



## Examples
 Im folgenden Beispiel wird eine Textdatei mit einer UTF-16-Codierung mithilfe der Big-Endian-Byte Reihenfolge gelesen.

 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]

 Im folgenden Beispiel wird die Anzahl der Bytes bestimmt, die zum Codieren eines Zeichen Arrays erforderlich sind, die Zeichen codiert und die resultierenden Bytes angezeigt werden.

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Name für die aktuelle Codierung abgerufen, die mit den Body-Tags des E-Mail-Agenten verwendet werden kann.</summary>
        <value>Ein Name der aktuellen <see cref="T:System.Text.Encoding" />-Klasse, die mit den Body-Tags des E-Mail-Agenten verwendet werden kann.

- oder -

Eine leere Zeichenfolge (""), wenn das aktuelle <see cref="T:System.Text.Encoding" /> nicht verwendet werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn Sie eine Codierung für einen Textkörper Namen benötigen, sollten Sie <xref:System.Text.Encoding.GetEncoding%2A> mit der <xref:System.Text.Encoding.BodyName%2A>-Eigenschaft abrufen. Häufig wird von der-Methode eine andere Codierung von der im-Befehl bereitgestellten Test Codierung abgerufen. Im Allgemeinen müssen nur e-Mail-Anwendungen eine solche Codierung abrufen. die meisten anderen Anwendungen, die eine Codierung beschreiben müssen, sollten ihre <xref:System.Text.Encoding.WebName%2A>verwenden.

 In einigen Fällen entspricht der Wert der <xref:System.Text.Encoding.BodyName%2A>-Eigenschaft dem internationalen Standard, der diese Codierung definiert. Dies bedeutet nicht, dass die Implementierung vollständig mit diesem Standard übereinstimmt.



## Examples
 Im folgenden Beispiel werden die anderen Namen für die einzelnen Codierungen abgerufen und die Codierungen mit einem oder mehreren Namen angezeigt, die sich von <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>unterscheiden. Es wird <xref:System.Text.Encoding.EncodingName%2A> angezeigt, aber nicht mit diesem verglichen.

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt beim Überschreiben in einer abgeleiteten Klasse eine flache Kopie des aktuellen <see cref="T:System.Text.Encoding" />-Objekts.</summary>
        <returns>Eine Kopie des aktuellen <see cref="T:System.Text.Encoding" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der Klon ist beschreibbar, auch wenn das ursprüngliche <xref:System.Text.Encoding>-Objekt schreibgeschützt ist. Daher können die Eigenschaften des geklonten geändert werden.

 Eine flache Kopie eines-Objekts ist nur eine Kopie des-Objekts. Wenn das Objekt Verweise auf andere Objekte enthält, erstellt die flache Kopie keine Kopien der referenzierten Objekte. Stattdessen verweist es auf die ursprünglichen Objekte. Im Gegensatz dazu erstellt eine tiefe Kopie eines Objekts eine Kopie des Objekts und eine Kopie aller Elemente, die direkt oder indirekt von diesem Objekt referenziert werden.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Codepagebezeichner der aktuellen <see cref="T:System.Text.Encoding" />-Klasse beim Überschreiben in einer abgeleiteten Klasse ab.</summary>
        <value>Der Codepagebezeichner der aktuellen <see cref="T:System.Text.Encoding" />-Klasse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel werden die anderen Namen für die einzelnen Codierungen abgerufen und die Codierungen mit einem oder mehreren Namen angezeigt, die sich von <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>unterscheiden. Es wird <xref:System.Text.Encoding.EncodingName%2A> angezeigt, aber nicht mit diesem verglichen.

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert ein Bytearray aus einer Codierung in eine andere.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Das Codierungsformat von <paramref name="bytes" />.</param>
        <param name="dstEncoding">Das Zielcodierungsformat.</param>
        <param name="bytes">Die zu konvertierenden Bytes.</param>
        <summary>Konvertiert ein vollständiges Bytearray aus einer Codierung in eine andere.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Byte" />, das die Ergebnisse der Konvertierung in <paramref name="bytes" /> von <paramref name="srcEncoding" /> in <paramref name="dstEncoding" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel wird eine Unicode-codierte Zeichenfolge in eine ASCII-codierte Zeichenfolge konvertiert. Da das von der <xref:System.Text.Encoding.ASCII%2A>-Eigenschaft zurückgegebene ASCII-Codierungs Objekt den Ersatz Fall Back verwendet und das Pi-Zeichen nicht Teil des ASCII-Zeichensatzes ist, wird das Pi-Zeichen durch ein Fragezeichen ersetzt, wie die Ausgabe des Beispiels zeigt.

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" /> ist <see langword="null" />.

- oder -

 <paramref name="dstEncoding" /> ist <see langword="null" />.

- oder -

 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 **srcEncoding.** Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 **dstEncoding.** Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Die Codierung des Quellarrays, <paramref name="bytes" />.</param>
        <param name="dstEncoding">Die Codierung des Ausgabearrays.</param>
        <param name="bytes">Das zu konvertierende Bytearray.</param>
        <param name="index">Der Index des ersten zu konvertierenden Elements von <paramref name="bytes" />.</param>
        <param name="count">Die Anzahl der zu konvertierenden Bytes.</param>
        <summary>Konvertiert einen Bereich von Bytes in einem Bytearray aus einer Codierung in eine andere.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Byte" />, das das Ergebnis der Konvertierung eines Bereichs von Bytes in <paramref name="bytes" /> von <paramref name="srcEncoding" /> in <paramref name="dstEncoding" /> enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" /> ist <see langword="null" />.

- oder -

 <paramref name="dstEncoding" /> ist <see langword="null" />.

- oder -

 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich im Bytearray an.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 **srcEncoding.** Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 **dstEncoding.** Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DecoderFallback As DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Text.DecoderFallback" />-Objekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt ab.</summary>
        <value>Das Decoderfallbackobjekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das <xref:System.Text.DecoderFallback>-Objekt stellt einen Fehlerhandler dar, der aufgerufen wird, wenn eine codierte Byte Sequenz nicht in ein Zeichen decodiert werden kann. Jeder der folgenden Handlertypen wird unterstützt:

-   Ein Fall Back-Handler mit der besten Anpassung, der Bytes ersetzt, die nicht mit einem geeigneten Ersatz Zeichen decodiert werden können.

-   Ein Ersatz Fall Back Handler, der Bytes ersetzt, die nicht durch ein beliebiges Ersatz Zeichen decodiert werden können. .NET enthält einen Ersatz Fall Back Handler, <xref:System.Text.DecoderFallback>. dieser ersetzt standardmäßig bytes, die nicht decodiert werden können, durch ein Fragezeichen ("?").

-   Ein Ausnahmefall Back Handler, der eine Ausnahme auslöst, wenn Bytes nicht decodiert werden können. .NET enthält einen Ausnahmefall Back Handler, <xref:System.Text.DecoderExceptionFallback>, der eine <xref:System.Text.DecoderFallbackException> auslöst, wenn Bytes nicht decodiert werden können.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert in einem set-Vorgang ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Wert kann in einem set-Vorgang nicht zugewiesen werden, da das aktuelle <see cref="T:System.Text.Encoding" />-Objekt schreibgeschützt ist.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardcodierung für diese .NET-Implementierung ab.</summary>
        <value>Die Standard Codierung für diese .NET-Implementierung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!WARNING]
>  Verschiedene Computer können unterschiedliche Codierungen als Standard verwenden, und die Standard Codierung kann sich auf einem einzelnen Computer ändern. Wenn Sie die <xref:System.Text.Encoding.Default%2A> Codierung zum Codieren und Decodieren von Daten verwenden, die zwischen Computern gestreamt werden, oder die zu unterschiedlichen Zeitpunkten auf demselben Computer abgerufen werden, werden diese Daten möglicherweise falsch übersetzt. Außerdem verwendet die von der <xref:System.Text.Encoding.Default%2A>-Eigenschaft zurückgegebene Codierung den Fall Back mit der besten Zeichenzahl, um Zeichen, die von der Codepage unterstützt werden, nicht unterstützte Zeichen zuzuordnen. Aus diesen Gründen wird die Verwendung der Standard Codierung nicht empfohlen. Um sicherzustellen, dass codierte Bytes ordnungsgemäß decodiert werden, sollten Sie eine Unicode-Codierung verwenden, wie z. b. <xref:System.Text.UTF8Encoding> oder <xref:System.Text.UnicodeEncoding>. Sie können auch ein Protokoll auf höherer Ebene verwenden, um sicherzustellen, dass das gleiche Format zum Codieren und decodieren verwendet wird.

### <a name="the-default-property-in-the-net-framework"></a>Die Standard Eigenschaft im .NET Framework

In der .NET Framework auf dem Windows-Desktop Ruft die <xref:System.Text.Encoding.Default%2A>-Eigenschaft immer die aktive Codepage des Systems ab und erstellt ein <xref:System.Text.Encoding>-Objekt, das Ihr entspricht. Die aktive Codepage ist möglicherweise eine ANSI-Codepage, die den ASCII-Zeichensatz samt zusätzlichen Zeichen enthält, die von der Codepage abweichen. Da alle <xref:System.Text.Encoding.Default%2A> Codierungen, die auf ANSI-Codepages basieren, Daten verloren gehen, sollten Sie stattdessen die <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> Codierung verwenden. UTF-8 ist im Bereich von u + 00 bis u + 7F häufig identisch, kann jedoch ohne Verlust Zeichen außerhalb des ASCII-Bereichs codieren.

## <a name="the-default-property-on-net-core"></a>Die Standard Eigenschaft in .net Core

In .net Core gibt die <xref:System.Text.Encoding.Default%2A>-Eigenschaft immer den <xref:System.Text.UTF8Encoding>zurück. UTF-8 wird unter allen Betriebssystemen (Windows, Linux und Max OS X) unterstützt, auf denen .net Core-Anwendungen ausgeführt werden.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EncoderFallback As EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Text.EncoderFallback" />-Objekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt ab.</summary>
        <value>Das Encoderfallbackobjekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das <xref:System.Text.EncoderFallback>-Objekt stellt einen Fehlerhandler dar, der aufgerufen wird, wenn ein Zeichen nicht in eine codierte Byte Sequenz konvertiert werden kann. Jeder der folgenden Handlertypen wird unterstützt:

-   Ein Fall Back-Handler mit der besten Anpassung, der Zeichen ersetzt, die nicht mit einem geeigneten Ersatz Zeichen codiert werden können.

-   Ein Ersatz Fall Back Handler, durch den Zeichen ersetzt werden, die nicht mit einem beliebigen Ersatz Zeichen codiert werden können. .NET enthält einen Ersatz Fall Back Handler, <xref:System.Text.EncoderFallback>. dieser ersetzt standardmäßig Zeichen, die nicht mit einem Fragezeichen ("?") codiert werden können.

-   Ein Ausnahmefall Back Handler, der eine Ausnahme auslöst, wenn Zeichen nicht codiert werden können. .NET enthält einen Ausnahmefall Back Handler, <xref:System.Text.EncoderExceptionFallback>, der eine <xref:System.Text.EncoderFallbackException> auslöst, wenn Zeichen nicht decodiert werden können.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert in einem set-Vorgang ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Wert kann in einem set-Vorgang nicht zugewiesen werden, da das aktuelle <see cref="T:System.Text.Encoding" />-Objekt schreibgeschützt ist.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird die Klartextbeschreibung der aktuellen Codierung abgerufen.</summary>
        <value>Die Klartextbeschreibung der aktuellen <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.Encoding.EncodingName%2A>-Eigenschaft ist für die Anzeige bestimmt. Um einen Namen zu suchen, der an die <xref:System.Text.Encoding.GetEncoding%2A>-Methode übermittelt werden kann, verwenden Sie die <xref:System.Text.Encoding.WebName%2A>-Eigenschaft.



## Examples
 Im folgenden Beispiel werden die anderen Namen für die einzelnen Codierungen abgerufen und die Codierungen mit einem oder mehreren Namen angezeigt, die sich von <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>unterscheiden. Es wird <xref:System.Text.Encoding.EncodingName%2A> angezeigt, aber nicht mit diesem verglichen.

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das <see cref="T:System.Object" />, das mit der aktuellen Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob das angegebene <see cref="T:System.Object" /> und die aktuelle Instanz gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="value" /> eine Instanz von <see cref="T:System.Text.Encoding" /> und gleich der aktuellen Instanz ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Zwei Instanzen von <xref:System.Text.Encoding> werden als gleich betrachtet, wenn Sie derselben Codepage entsprechen und ihre `EncoderFallback` und `DecoderFallback` Objekte gleich sind. Insbesondere abgeleitete Codepages verfügen jeweils über eine Codepage von 0, und ihre Fallbacks werden normalerweise `null` (`Nothing` in Visual Basic .net). Folglich werden alle einander als gleich betrachtet. Eine Folge besteht darin, dass bei der Verwendung <xref:System.Text.Encoding.Equals%2A> zum Auffüllen einer Hash Tabelle alle abgeleiteten Codierungen gleich sind und in denselben Hash Tabellen Slot fallen.



## Examples
 Im folgenden Beispiel werden zwei Instanzen derselben Codierung abgerufen (eine nach Codepage und eine andere nach Namen) und ihre Gleichheit überprüft.

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Bytes, die beim Codieren der Zeichen erzeugt werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray mit den zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Bytes, die beim Codieren aller Zeichen im angegebenen Zeichenarray erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die durch Codieren aller Zeichen im angegebenen Zeichenarray erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, können Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen. Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus. Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.

-   Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Versionen der <xref:System.Text.Encoding.GetBytes%2A>-Methode verwenden.

-   Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollten Sie den Ausgabepuffer wieder verwenden. In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.

-   Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.



## Examples
 Im folgenden Beispiel wird die Anzahl der Bytes bestimmt, die zum Codieren eines Zeichen Arrays erforderlich sind, die Zeichen codiert und die resultierenden Bytes angezeigt werden.

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">Die zu codierende Zeichenspanne.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Byte, die beim Codieren der Zeichen in der angegebenen Zeichenspanne erzeugt werden.</summary>
        <returns>Die Anzahl von Bytes, die beim Codieren des angegebenen Zeichenbereichs erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue spannen Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, können Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen. Um die maximale spannen Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen. Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus. Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.

-   Wenn Ihre APP die Eingabe von Eingabezeichen verarbeitet, wird die Span-Version von <xref:System.Text.Encoding.GetBytes%2A> empfohlen.

-   Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabe spannen Puffer zu klein ist. Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge mit den zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Bytes, die beim Codieren der Zeichen in der angegebenen Zeichenfolge erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, können Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen. Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus. Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.

-   Wenn Ihre APP Zeichen folgen Eingaben behandelt, wird die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A> empfohlen.

-   Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.

-   Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.



## Examples
 Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, die Zeichen codiert und die resultierenden Bytes anzeigt.

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">Ein Zeiger auf das erste zu codierende Zeichen.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Bytes, die beim Codieren der Zeichen ab dem Zeichenzeiger erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes erfordert, sollten Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen. Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 Die <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>-Methode führt die eigentliche Codierung aus. Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.

-   Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version der <xref:System.Text.Encoding.GetBytes%2A>-Methode verwenden.

-   Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%2A> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.

-   Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="index">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Bytes, die beim Codieren der Zeichen aus dem angegebenen Zeichenarray erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, können Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen. Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus. Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.

-   Wenn Ihre APP Zeichen folgen Eingaben behandelt, wird die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A> empfohlen.

-   Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.

-   Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.



## Examples
 Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um drei Zeichen aus einem Zeichen Array zu codieren, die Zeichen zu codieren und die resultierenden Bytes anzeigen.

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.

- oder -

 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge mit den zu codierenden Zeichen.</param>
        <param name="index">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Bytes, die beim Codieren der Zeichen aus der angegebenen Zeichenfolge erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der Zeichenfolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, können Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen. Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus. Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.

-   Wenn Ihre APP Zeichen folgen Eingaben behandelt, wird die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A> empfohlen.

-   Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.

-   Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.


## Examples
 Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um drei Zeichen aus einem Zeichen Array zu codieren, die Zeichen zu codieren und die resultierenden Bytes anzeigen.

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>

      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen in eine Bytefolge codiert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray mit den zu codierenden Zeichen.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden alle Zeichen im angegebenen Zeichenarray in eine Bytefolge codiert.</summary>
        <returns>Ein Bytearray mit den Ergebnissen der Codierung der angegebenen Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die vom bereitgestellten <xref:System.Text.Encoder> verwenden <xref:System.Text.Encoding.GetDecoder%2A> Methode bzw. die <xref:System.Text.Encoding.GetEncoder%2A> Methode einer abgeleiteten Klasse.

 Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus. Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird. (Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden. Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann. <xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)

-   Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version der <xref:System.Text.Encoding.GetBytes%2A>-Methode abrufen.

-   Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.

-   Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.



## Examples
 Im folgenden Beispiel wird die Anzahl der Bytes bestimmt, die zum Codieren eines Zeichen Arrays erforderlich sind, die Zeichen codiert und die resultierenden Bytes angezeigt werden.

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge mit den zu codierenden Zeichen.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden alle Zeichen in der angegebenen Zeichenfolge in eine Bytefolge codiert.</summary>
        <returns>Ein Bytearray mit den Ergebnissen der Codierung der angegebenen Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die vom bereitgestellten <xref:System.Text.Encoder> verwenden <xref:System.Text.Encoding.GetDecoder%2A> Methode bzw. die <xref:System.Text.Encoding.GetEncoder%2A> Methode einer abgeleiteten Klasse.

 Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird. (Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden. Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann. <xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)

-   Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A>verwenden.

-   Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.

-   Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.



## Examples
 Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, die Zeichen codiert und die resultierenden Bytes anzeigt.

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">Die Spanne mit den zu codierenden Zeichen.</param>
        <param name="bytes">Die Bytespanne, die die codierten Bytes enthalten soll.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden Zeichen aus der angegebenen schreibgeschützten Spanne in eine Bytespanne codiert.</summary>
        <returns>Die Anzahl der codierten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die vom bereitgestellten <xref:System.Text.Encoder> verwenden <xref:System.Text.Encoding.GetDecoder%2A> Methode bzw. die <xref:System.Text.Encoding.GetEncoder%2A> Methode einer abgeleiteten Klasse.

 Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird. (Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden. Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann. <xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)

-   Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A>verwenden.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.

-   Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.

 ]]></format>
        </remarks>

      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="index">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen im angegebenen Zeichenarray in eine Bytefolge codiert.</summary>
        <returns>Ein Bytearray mit den Ergebnissen der Codierung der angegebenen Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die vom bereitgestellten <xref:System.Text.Encoder> verwenden <xref:System.Text.Encoding.GetDecoder%2A> Methode bzw. die <xref:System.Text.Encoding.GetEncoder%2A> Methode einer abgeleiteten Klasse.

 Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird. (Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden. Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann. <xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)

-   Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A>verwenden.

-   Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.

-   Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.



## Examples
 Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um drei Zeichen aus einem Zeichen Array zu codieren, die Zeichen zu codieren und die resultierenden Bytes anzeigen.

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.

- oder -

 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge mit den zu codierenden Zeichen.</param>
        <param name="index">Der Index in der Zeichenfolge, von dem die Codierung gestartet werden soll.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen, die von <paramref name="count" /> in der angegebenen Zeichenfolge festgelegt werden, in ein Bytearray codiert, angefangen bei dem angegeben <paramref name="index" />-Element.</summary>
        <returns>Ein Bytearray mit den Ergebnissen der Codierung der angegebenen Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die vom bereitgestellten <xref:System.Text.Encoder> verwenden <xref:System.Text.Encoding.GetDecoder%2A> Methode bzw. die <xref:System.Text.Encoding.GetEncoder%2A> Methode einer abgeleiteten Klasse.

 Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird. (Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden. Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann. <xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)

-   Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A>verwenden.

-   Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.

-   Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.


## Examples
 Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, die Zeichen codiert und die resultierenden Bytes anzeigt.

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">Ein Zeiger auf das erste zu codierende Zeichen.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <param name="byteCount">Die maximale Anzahl der zu schreibenden Bytes.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen beginnend am angegebenen Zeichenzeiger in eine Bytefolge codiert, die ab Beginn des angegebenen Bytezeigers gespeichert wird.</summary>
        <returns>Die tatsächliche Anzahl an Bytes, die an der durch den <paramref name="bytes" />-Parameter angegebenen Position geschrieben wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes erfordert, müssen Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen. Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> Objekt von der bereitgestellten <xref:System.Text.Encoding.GetDecoder%2A> oder <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.

 Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus. Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird. (Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden. Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann. <xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)

-   Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A>verwenden.

-   Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.

-   Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" />.

- oder -

 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> oder <paramref name="byteCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="byteCount" /> ist niedriger als die sich ergebende Anzahl von Bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="charIndex">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</param>
        <param name="byteIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen aus dem angegebenen Zeichenarray in das angegebene Bytearray codiert.</summary>
        <returns>Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, sollten Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen. Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die vom bereitgestellten <xref:System.Text.Encoder> verwenden <xref:System.Text.Encoding.GetDecoder%2A> Methode bzw. die <xref:System.Text.Encoding.GetEncoder%2A> Methode einer abgeleiteten Klasse.

 Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird. (Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden. Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann. <xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)

-   Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A>verwenden.

-   Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.

-   Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.



## Examples
 Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um drei Zeichen aus einem Zeichen Array zu codieren, die Zeichen zu codieren und die resultierenden Bytes anzeigen.

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" />.

- oder -

 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />, <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).

- oder -

 <paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" />an.

- oder -

 <paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge mit den zu codierenden Zeichen.</param>
        <param name="charIndex">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</param>
        <param name="byteIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen aus der angegebenen Zeichenfolge in das angegebene Bytearray codiert.</summary>
        <returns>Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, sollten Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen. Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die vom bereitgestellten <xref:System.Text.Encoder> verwenden <xref:System.Text.Encoding.GetDecoder%2A> Methode bzw. die <xref:System.Text.Encoding.GetEncoder%2A> Methode einer abgeleiteten Klasse.

 Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird. (Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden. Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann. <xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)

-   Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A>verwenden.

-   Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.

-   Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.



## Examples
 Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, die Zeichen codiert und die resultierenden Bytes anzeigt.

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.

- oder -

 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />, <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).

- oder -

 <paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" />an.

- oder -

 <paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge erzeugt werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren aller Bytes in dem angegebenen Bytearray erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> zum Speichern der resultierenden Zeichen benötigt, sollten Sie die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>-Methode verwenden. Verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29>-Methode, um die maximale Array Größe zu berechnen. Die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 Die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29>-Methode führt die eigentliche Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie den Status zwischen den Aufrufen wahrscheinlich beibehalten.

-   Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, sollten Sie die <xref:System.Text.Encoding.GetString%2A>-Methode verwenden. Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.

-   Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.

-   Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.



## Examples
 Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann in ein Zeichen Array decodiert.

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">Eine zu decodierende schreibgeschützte Bytespanne.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren der bereitgestellten schreibgeschützten Bytespanne erzeugt werden.</summary>
        <returns>Die Anzahl von Zeichen, die beim Decodieren der Bytespanne erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen erfordert, sollten Sie die <xref:System.Text.Encoding.GetCharCount%2A>-Methode verwenden. Verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode, um die maximale Array Größe zu berechnen. Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie den Status zwischen den Aufrufen wahrscheinlich beibehalten.

-   Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, empfiehlt es sich, die <xref:System.Text.Encoding.GetString%2A>-Methode zu verwenden. Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.

-   Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.

 ]]></format>
        </remarks>

      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf das erste zu decodierende Byte.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge ab dem angegebenen Bytezeiger erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen erfordert, sollten Sie die <xref:System.Text.Encoding.GetCharCount%2A>-Methode verwenden. Verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode, um die maximale Array Größe zu berechnen. Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie den Status zwischen den Aufrufen wahrscheinlich beibehalten.

-   Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, empfiehlt es sich, die <xref:System.Text.Encoding.GetString%2A>-Methode zu verwenden. Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.

-   Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.

-   Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge aus dem angegebenen Bytearray erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, sollten Sie die <xref:System.Text.Encoding.GetCharCount%2A>-Methode verwenden. Verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode, um die maximale Array Größe zu berechnen. Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie den Status zwischen den Aufrufen wahrscheinlich beibehalten.

-   Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, empfiehlt es sich, die <xref:System.Text.Encoding.GetString%2A>-Methode zu verwenden. Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.

-   Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.

-   Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.



## Examples
 Im folgenden Beispiel wird eine Zeichenfolge von einer Codierung in eine andere konvertiert.

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann ein Bereich von Bytes in ein Zeichen Array decodiert.

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.

- oder -

 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge in Zeichen decodiert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden alle Bytes im angegebenen Bytearray in Zeichen decodiert.</summary>
        <returns>Ein Zeichenarray, das die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> ruft Zeichen aus einer Eingabe Byte Sequenz ab. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, da <xref:System.Text.Encoding> diskrete Konvertierungen erwartet, während <xref:System.Text.Decoder> für mehrere Durchgänge in einem einzelnen Eingabestream konzipiert ist.

 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die vom bereitgestellten <xref:System.Text.Encoder> verwenden <xref:System.Text.Encoding.GetDecoder%2A> Methode bzw. die <xref:System.Text.Encoding.GetEncoder%2A> Methode einer abgeleiteten Klasse.

 **Hinweis** Diese Methode ist für die Verwendung von Unicode-Zeichen vorgesehen, nicht für beliebige Binärdaten, wie z. b. Byte Arrays. Wenn Sie beliebige Binärdaten in Text codieren müssen, sollten Sie ein Protokoll wie z. b. UUEncode verwenden, das von Methoden wie z. b. <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>implementiert wird.

 Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie den Status zwischen Aufrufen wahrscheinlich beibehalten, da Byte Sequenzen bei der Verarbeitung in Batches unterbrochen werden können. (Beispielsweise kann ein Teil einer ISO-2022-Verschiebungs Sequenz einen <xref:System.Text.Encoding.GetChars%2A> Aufrufe beenden und zu Beginn des nächsten <xref:System.Text.Encoding.GetChars%2A>-Aufrufes fortsetzen. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft den Fall Back für diese unvollständigen Sequenzen auf, aber <xref:System.Text.Decoder> speichert diese Sequenzen für den nächsten-Befehl.)

-   Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, empfiehlt es sich, die <xref:System.Text.Encoding.GetString%2A>-Methode zu verwenden. Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.

-   Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.

-   Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.



## Examples
 Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann in ein Zeichen Array decodiert.

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">Eine schreibgeschützte Spanne, die die zu decodierende Bytefolge enthält.</param>
        <param name="chars">Die Zeichenspanne, die die decodierten Bytes empfängt.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden alle Bytes in der angegebenen schreibgeschützten Bytespanne in eine Zeichenspanne decodiert.</summary>
        <returns>Die Anzahl der decodierten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> ruft Zeichen aus einer Eingabe Byte Spanne ab. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, da <xref:System.Text.Encoding> diskrete Konvertierungen erwartet, während <xref:System.Text.Decoder> für mehrere Durchgänge in einem einzelnen Eingabestream konzipiert ist.

 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die vom bereitgestellten <xref:System.Text.Encoder> verwenden <xref:System.Text.Encoding.GetDecoder%2A> Methode bzw. die <xref:System.Text.Encoding.GetEncoder%2A> Methode einer abgeleiteten Klasse.

 Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie den Status zwischen Aufrufen wahrscheinlich beibehalten, da Byte Sequenzen bei der Verarbeitung in Batches unterbrochen werden können. (Beispielsweise kann ein Teil einer ISO-2022-Verschiebungs Sequenz einen <xref:System.Text.Encoding.GetChars%2A> Aufrufe beenden und zu Beginn des nächsten <xref:System.Text.Encoding.GetChars%2A>-Aufrufes fortsetzen. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft den Fall Back für diese unvollständigen Sequenzen auf, aber <xref:System.Text.Decoder> speichert diese Sequenzen für den nächsten-Befehl.)

-   Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, empfiehlt es sich, die <xref:System.Text.Encoding.GetString%2A>-Methode zu verwenden. Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.

-   Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.

-   Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge aus dem angegebenen Bytearray in Zeichen decodiert.</summary>
        <returns>Ein Zeichenarray, das die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> ruft Zeichen aus einer Eingabe Byte Sequenz ab. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, da <xref:System.Text.Encoding> diskrete Konvertierungen erwartet, während <xref:System.Text.Decoder> für mehrere Durchgänge in einem einzelnen Eingabestream konzipiert ist.

 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die vom bereitgestellten <xref:System.Text.Encoder> verwenden <xref:System.Text.Encoding.GetDecoder%2A> Methode bzw. die <xref:System.Text.Encoding.GetEncoder%2A> Methode einer abgeleiteten Klasse.

 **Hinweis** Diese Methode ist für die Verwendung von Unicode-Zeichen vorgesehen, nicht für beliebige Binärdaten, wie z. b. Byte Arrays. Wenn Sie beliebige Binärdaten in Text codieren müssen, sollten Sie ein Protokoll wie z. b. UUEncode verwenden, das von Methoden wie z. b. <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>implementiert wird.

 Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie den Status zwischen Aufrufen wahrscheinlich beibehalten, da Byte Sequenzen bei der Verarbeitung in Batches unterbrochen werden können. (Beispielsweise kann ein Teil einer ISO-2022-Verschiebungs Sequenz einen <xref:System.Text.Encoding.GetChars%2A> Aufrufe beenden und zu Beginn des nächsten <xref:System.Text.Encoding.GetChars%2A>-Aufrufes fortsetzen. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft den Fall Back für diese unvollständigen Sequenzen auf, aber <xref:System.Text.Decoder> speichert diese Sequenzen für den nächsten-Befehl.)

-   Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, empfiehlt es sich, die <xref:System.Text.Encoding.GetString%2A>-Methode zu verwenden. Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.

-   Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.

-   Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.



## Examples
 Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann ein Bereich von Bytes in ein Zeichen Array decodiert.

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.

- oder -

 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf das erste zu decodierende Byte.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <param name="charCount">Die maximale Anzahl der zu schreibenden Zeichen.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge beginnend am angegebenen Bytezeiger in Zeichen decodiert, die ab Beginn des angegebenen Zeichenzeigers gespeichert werden.</summary>
        <returns>Die tatsächliche Anzahl der Zeichen, die an der durch den <paramref name="chars" />-Parameter angegebenen Position geschrieben wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen erfordert, sollten Sie die <xref:System.Text.Encoding.GetCharCount%2A>-Methode verwenden. Verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode, um die maximale Array Größe zu berechnen. Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> ruft Zeichen aus einer Eingabe Byte Sequenz ab. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, da <xref:System.Text.Encoding> diskrete Konvertierungen erwartet, während <xref:System.Text.Decoder> für mehrere Durchgänge in einem einzelnen Eingabestream konzipiert ist.

 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> Objekt von der bereitgestellten <xref:System.Text.Encoding.GetDecoder%2A> oder <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.

 **Hinweis** Diese Methode ist für die Verwendung von Unicode-Zeichen vorgesehen, nicht für beliebige Binärdaten, wie z. b. Byte Arrays. Wenn Sie beliebige Binärdaten in Text codieren müssen, sollten Sie ein Protokoll wie z. b. UUEncode verwenden, das von Methoden wie z. b. <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>implementiert wird.

 Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie den Status zwischen Aufrufen wahrscheinlich beibehalten, da Byte Sequenzen bei der Verarbeitung in Batches unterbrochen werden können. (Beispielsweise kann ein Teil einer ISO-2022-Verschiebungs Sequenz einen <xref:System.Text.Encoding.GetChars%2A> Aufrufe beenden und zu Beginn des nächsten <xref:System.Text.Encoding.GetChars%2A>-Aufrufes fortsetzen. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft den Fall Back für diese unvollständigen Sequenzen auf, aber <xref:System.Text.Decoder> speichert diese Sequenzen für den nächsten-Befehl.)

-   Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, wird die <xref:System.Text.Encoding.GetString%2A>-Methode empfohlen. Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.

-   Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.

-   Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />.

- oder -

 <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> oder <paramref name="charCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="charCount" /> ist niedriger als die sich ergebende Anzahl von Zeichen.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="byteIndex">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Das Zeichenarray, das die sich ergebenden Zeichen enthalten soll.</param>
        <param name="charIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge aus dem angegebenen Bytearray in das angegebene Zeichenarray decodiert.</summary>
        <returns>Die tatsächliche Anzahl der Zeichen, die in <paramref name="chars" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, sollten Sie die <xref:System.Text.Encoding.GetCharCount%2A>-Methode verwenden. Verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode, um die maximale Array Größe zu berechnen. Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 2a? displayproperty = namewithtype > Ruft Zeichen aus einer Eingabe Byte Sequenz ab. [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 2a? displayproperty = namewithtype > ist anders als <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, weil <xref:System.Text.Encoding> diskrete Konvertierungen erwartet, während <xref:System.Text.Decoder> für mehrere Durchgänge in einem einzelnen Eingabestream konzipiert ist.

 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die vom bereitgestellten <xref:System.Text.Encoder> verwenden <xref:System.Text.Encoding.GetDecoder%2A> Methode bzw. die <xref:System.Text.Encoding.GetEncoder%2A> Methode einer abgeleiteten Klasse.

 **Hinweis** Diese Methode ist für die Verwendung von Unicode-Zeichen vorgesehen, nicht für beliebige Binärdaten, wie z. b. Byte Arrays. Wenn Sie beliebige Binärdaten in Text codieren müssen, sollten Sie ein Protokoll wie z. b. UUEncode verwenden, das von Methoden wie z. b. <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>implementiert wird.

 Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.

 Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt. Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:

-   Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten. In diesem Fall müssen Sie den Status zwischen Aufrufen wahrscheinlich beibehalten, da Byte Sequenzen bei der Verarbeitung in Batches unterbrochen werden können. (Beispielsweise kann ein Teil einer ISO-2022-Verschiebungs Sequenz einen [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 2a > aufrufen und fortsetzen zu Beginn des nächsten [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 2a-> Aufrufens. [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 2a? displayproperty = namewithtype > Ruft den Fall Back für diese unvollständigen Sequenzen auf, aber <xref:System.Text.Decoder> speichert diese Sequenzen für den nächsten-Befehl.)

-   Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, wird die <xref:System.Text.Encoding.GetString%2A>-Methode empfohlen. Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.

-   Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer. Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.

-   Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden. In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.

-   Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.



## Examples
 Im folgenden Beispiel wird eine Zeichenfolge von einer Codierung in eine andere konvertiert.

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann ein Bereich von Bytes in ein Zeichen Array decodiert.

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />.

- oder -

 <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" />, <paramref name="byteCount" /> oder <paramref name="charIndex" /> ist kleiner als 0 (null).

- oder -

 <paramref name="byteindex" /> und <paramref name="byteCount" /> geben keinen gültigen Bereich in <paramref name="bytes" />an.

- oder -

 <paramref name="charIndex" /> ist kein gültiger Index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="chars" /> hat von <paramref name="charIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Zeichen aufzunehmen.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Decoder abgerufen, der eine codierte Bytefolge in Zeichen konvertiert.</summary>
        <returns>Eine <see cref="T:System.Text.Decoder" />-Klasse, die eine codierte Bytefolge in eine Folge von Zeichen codiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode konvertiert sequenzielle Blöcke von Bytes in sequenzielle Zeichenblöcke, ähnlich wie bei der <xref:System.Text.Encoding.GetChars%2A>-Methode dieser Klasse. Ein <xref:System.Text.Decoder> behält jedoch Zustandsinformationen zwischen Aufrufen bei, damit Byte Sequenzen, die Blöcke spannen, ordnungsgemäß decodiert werden. Der <xref:System.Text.Decoder> behält auch nachfolgende Bytes am Ende der Datenblöcke bei und verwendet die nachfolgenden Bytes im nächsten Decodierungs Vorgang. Aus diesem Grund sind <xref:System.Text.Encoding.GetDecoder%2A> und <xref:System.Text.Encoding.GetEncoder%2A> für Netzwerkübertragungs-und Datei Vorgänge nützlich, da diese Vorgänge häufig Datenblöcke anstelle eines gesamten Datenstroms behandeln.

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die Standard Implementierung gibt einen <see cref="T:System.Text.Decoder" /> zurück, der die Methoden <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> und <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> der aktuellen <see cref="T:System.Text.Encoding" />aufruft. Sie müssen diese Methode überschreiben, um eine <see cref="T:System.Text.Decoder" /> zurückzugeben, die ihren Zustand zwischen Aufrufen beibehält.</para></block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Encoder abgerufen, der eine Folge von Unicode-Zeichen in eine codierte Bytefolge konvertiert.</summary>
        <returns>Ein <see cref="T:System.Text.Encoder" />, der eine Folge von Unicode-Zeichen in eine codierte Bytefolge konvertiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode konvertiert sequenzielle Blöcke von Zeichen in sequenzielle Block von Bytes, ähnlich wie bei der <xref:System.Text.Encoding.GetBytes%2A>-Methode dieser Klasse. Eine <xref:System.Text.Encoder> behält jedoch Zustandsinformationen zwischen Aufrufen bei, sodass Sie Zeichen folgen, die Blöcke spannen, ordnungsgemäß codiert. Der <xref:System.Text.Encoder> behält auch nachfolgende Zeichen am Ende der Datenblöcke bei und verwendet die nachfolgenden Zeichen im nächsten Codierungs Vorgang. Beispielsweise kann ein Datenblock mit einem nicht übereinstimmenden hohen Ersatz Zeichen enden, und das entsprechende niedrige Ersatz Zeichen kann sich im nächsten Datenblock befinden. Aus diesem Grund sind <xref:System.Text.Encoding.GetDecoder%2A> und <xref:System.Text.Encoding.GetEncoder%2A> für Netzwerkübertragungs-und Datei Vorgänge nützlich, da diese Vorgänge häufig Datenblöcke anstelle eines gesamten Datenstroms behandeln.

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die Standard Implementierung gibt einen <see cref="T:System.Text.Encoder" /> zurück, der die Methoden <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> und <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> der aktuellen <see cref="T:System.Text.Encoding" />aufruft. Sie müssen diese Methode überschreiben, um eine <see cref="T:System.Text.Encoder" /> zurückzugeben, die ihren Zustand zwischen Aufrufen beibehält.</para></block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Codierung für die angegebene Codepage zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">Der Codepagebezeichner der bevorzugten Codierung. Mögliche Werte sind in der Codepage-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.

- oder -

0 (null), um die Standardcodierung zu verwenden.</param>
        <summary>Gibt die dem angegebenen Codepagebezeichner zugeordnete Codierung zurück.</summary>
        <returns>Die Codierung, die der angegebenen Codepage zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der Fall Back Handler hängt vom Codierungstyp `codepage`ab. Wenn `codepage` eine Codepage oder eine Doppelbyte-Zeichensatz Codierung (DBCS) ist, wird ein Fall Back-Handler mit dem besten Zeichen verwendet. Andernfalls wird ein Ersatz Fall Back Handler verwendet. Diese Fall Back Handler sind für Ihre APP möglicherweise nicht geeignet. Um den Fall Back Handler anzugeben, der von der durch `codepage`angegebenen Codierung verwendet wird, können Sie die <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>-Überladung aufrufen.

 In der .NET Framework basiert die <xref:System.Text.Encoding.GetEncoding%2A>-Methode auf der zugrunde liegenden Plattform, um die meisten Codepages zu unterstützen. Allerdings unterstützt die .NET Framework nativ einige Codierungen. Eine Liste der Codepages finden Sie im Thema <xref:System.Text.Encoding>-Klasse. In .net Core gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode die Codierungen zurück, die von .net Core unterstützt werden. Bei beiden .net-Implementierungen können Sie die <xref:System.Text.Encoding.GetEncodings%2A>-Methode zum Abrufen eines Arrays von <xref:System.Text.EncodingInfo> Objekten, das Informationen zu allen verfügbaren Codierungen enthält, abrufen.

 Zusätzlich zu den Codierungen, die in .net Core nativ verfügbar sind oder auf einer bestimmten Platt Form Version der .NET Framework intrinsisch unterstützt werden, gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode alle zusätzlichen Codierungen zurück, die durch das Registrieren eines-<xref:System.Text.EncodingProvider> verfügbar gemacht werden. Objekt. Wenn dieselbe Codierung von mehreren <xref:System.Text.EncodingProvider> Objekten registriert wurde, gibt diese Methode die zuletzt registrierte zurück.

Sie können auch den Wert 0 für das `codepage` Argument angeben. Das genaue Verhalten hängt davon ab, ob Codierungen verfügbar gemacht wurden, indem ein <xref:System.Text.EncodingProvider> Objekt registriert wird:

- Wenn mindestens ein Codierungs Anbieter registriert wurde, wird die Codierung des letzten registrierten Anbieters zurückgegeben, der eine Codierung zurückgegeben hat, wenn der <xref:System.Text.Encoding.GetEncoding%2A> Methode ein `codepage` Argument 0 (null) überlassen wird.

- Wenn auf dem .NET Framework kein Codierungs Anbieter registriert wurde und die <xref:System.Text.CodePagesEncodingProvider> der registrierte Codierungs Anbieter ist, oder wenn kein registrierter Codierungs Anbieter einen `codepage` Wert von 0 verarbeitet, wird die aktive Codepage des Betriebssystems zurückgegeben. Um die aktive Codepage auf Windows-Systemen zu ermitteln, müssen Sie die Windows [GetACP-](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Funktion aus dem .NET Framework auf dem Windows-Desktop aufrufen.

- Wenn in .net Core kein Codierungs Anbieter registriert wurde oder wenn kein registrierter Codierungs Anbieter einen `codepage` Wert von 0 verarbeitet, wird der <xref:System.Text.UTF8Encoding>zurückgegeben.

> [!NOTE]
>  Einige nicht unterstützte Codepages bewirken, dass eine <xref:System.ArgumentException> ausgelöst wird, während andere zu einer <xref:System.NotSupportedException>führen. Der Code muss daher alle Ausnahmen abfangen, die im Abschnitt "Ausnahmen" angegeben sind.

> [!NOTE]
>  Die ANSI-Codepages können sich auf verschiedenen Computern unterscheiden und können auf einem einzelnen Computer geändert werden, was zu Daten Beschädigungen führt. Aus diesem Grund wird, wenn die aktive Codepage eine ANSI-Codepage ist, das Codieren und Decodieren von Daten mithilfe der Standard Codepage, die von `Encoding.GetEncoding(0)` zurückgegeben wird, nicht empfohlen. Um möglichst konsistente Ergebnisse zu erzielen, sollten Sie eine Unicode-Codierung, z. b. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage verwenden.

 <xref:System.Text.Encoding.GetEncoding%2A> gibt eine zwischengespeicherte-Instanz mit Standardeinstellungen zurück. Verwenden Sie die Konstruktoren abgeleiteter Klassen, um eine Instanz mit unterschiedlichen Einstellungen zu erhalten. Beispielsweise stellt die <xref:System.Text.UTF32Encoding>-Klasse einen Konstruktor bereit, mit dem Sie die Fehlererkennung aktivieren können.



## Examples
 Im folgenden Beispiel werden zwei Instanzen derselben Codierung abgerufen (eine nach Codepage und eine andere nach Namen) und ihre Gleichheit überprüft.

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codepage" /> ist kleiner als 0 (null) oder größer als 65535.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" /> wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" /> wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Codepagename der bevorzugten Codierung. Jeder von der <see cref="P:System.Text.Encoding.WebName" />-Eigenschaft zurückgegebene Wert ist gültig. Mögliche Werte sind in der Name-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.</param>
        <summary>Gibt die dem angegebenen Codepagenamen zugeordnete Codierung zurück.</summary>
        <returns>Die der angegebenen Codepage zugeordnete Codierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der Fall Back Handler hängt vom Codierungstyp `name`ab. Wenn `name` eine Codepage oder eine Doppelbyte-Zeichensatz Codierung (DBCS) ist, wird ein Fall Back-Handler mit dem besten Zeichen verwendet. Andernfalls wird ein Ersatz Fall Back Handler verwendet. Diese Fall Back Handler sind für Ihre APP möglicherweise nicht geeignet. Um den Fall Back Handler anzugeben, der von der durch `name`angegebenen Codierung verwendet wird, können Sie die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>-Überladung aufrufen.

In der .NET Framework basiert die <xref:System.Text.Encoding.GetEncoding%2A>-Methode auf der zugrunde liegenden Plattform, um die meisten Codepages zu unterstützen. Allerdings unterstützt die .NET Framework nativ einige Codierungen. Eine Liste der Codepages finden Sie im Thema <xref:System.Text.Encoding>-Klasse. In .net Core gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode die Codierungen zurück, die von .net Core unterstützt werden. Bei beiden .net-Implementierungen können Sie die <xref:System.Text.Encoding.GetEncodings%2A>-Methode zum Abrufen eines Arrays von <xref:System.Text.EncodingInfo> Objekten, das Informationen zu allen verfügbaren Codierungen enthält, abrufen.

 Zusätzlich zu den Codierungen, die in .net Core nativ verfügbar sind oder auf einer bestimmten Platt Form Version der .NET Framework intrinsisch unterstützt werden, gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode alle zusätzlichen Codierungen zurück, die durch das Registrieren eines-<xref:System.Text.EncodingProvider> verfügbar gemacht werden. Objekt. Wenn dieselbe Codierung von mehreren <xref:System.Text.EncodingProvider> Objekten registriert wurde, gibt diese Methode die zuletzt registrierte zurück.

> [!NOTE]
>  Die ANSI-Codepages können sich auf verschiedenen Computern unterscheiden, oder Sie können für einen einzelnen Computer geändert werden, was zu Daten Beschädigungen führt. Um möglichst konsistente Ergebnisse zu erzielen, sollten Sie Unicode verwenden, z. b. UTF-8 (Codepage 65001) oder UTF-16 anstelle einer bestimmten Codepage.


 <xref:System.Text.Encoding.GetEncoding%2A> gibt eine zwischengespeicherte-Instanz mit Standardeinstellungen zurück. Verwenden Sie die Konstruktoren abgeleiteter Klassen, um eine Instanz mit unterschiedlichen Einstellungen zu erhalten. Beispielsweise stellt die <xref:System.Text.UTF32Encoding>-Klasse einen Konstruktor bereit, mit dem Sie die Fehlererkennung aktivieren können.

## Examples
 Im folgenden Beispiel werden zwei Instanzen derselben Codierung abgerufen (eine nach Codepage und eine andere nach Namen) und ihre Gleichheit überprüft.

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist kein gültiger Codepagename.

- oder -

Die durch <paramref name="name" /> angegebene Codepage wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">Der Codepagebezeichner der bevorzugten Codierung. Mögliche Werte sind in der Codepage-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.

- oder -

0 (null), um die Standardcodierung zu verwenden.</param>
        <param name="encoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn ein Zeichen nicht mit der aktuellen Codierung codiert werden kann.</param>
        <param name="decoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn eine Bytefolge nicht mit der aktuellen Codierung decodiert werden kann.</param>
        <summary>Gibt die dem angegebenen Codepagebezeichner zugeordnete Codierung zurück. Parameter geben einen Fehlerhandler für Zeichen an, die nicht codiert werden können, und für Bytefolgen, die nicht decodiert werden können.</summary>
        <returns>Die Codierung, die der angegebenen Codepage zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  Einige nicht unterstützte Codepages bewirken, dass die Ausnahme <xref:System.ArgumentException> ausgelöst wird, während andere zu <xref:System.NotSupportedException>führen. Der Code muss daher alle Ausnahmen abfangen, die im Abschnitt "Ausnahmen" angegeben sind.

In der .NET Framework basiert die <xref:System.Text.Encoding.GetEncoding%2A>-Methode auf der zugrunde liegenden Plattform, um die meisten Codepages zu unterstützen. Allerdings unterstützt die .NET Framework nativ einige Codierungen. Eine Liste der Codepages finden Sie im Thema <xref:System.Text.Encoding>-Klasse. In .net Core gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode die Codierungen zurück, die von .net Core unterstützt werden. Bei beiden .net-Implementierungen können Sie die <xref:System.Text.Encoding.GetEncodings%2A>-Methode zum Abrufen eines Arrays von <xref:System.Text.EncodingInfo> Objekten, das Informationen zu allen verfügbaren Codierungen enthält, abrufen.

 Zusätzlich zu den Codierungen, die in .net Core nativ verfügbar sind oder auf einer bestimmten Platt Form Version der .NET Framework intrinsisch unterstützt werden, gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode alle zusätzlichen Codierungen zurück, die durch das Registrieren eines-<xref:System.Text.EncodingProvider> verfügbar gemacht werden. Objekt. Wenn dieselbe Codierung von mehreren <xref:System.Text.EncodingProvider> Objekten registriert wurde, gibt diese Methode die zuletzt registrierte zurück.

Sie können auch den Wert 0 für das `codepage` Argument angeben. Das genaue Verhalten hängt davon ab, ob Codierungen verfügbar gemacht wurden, indem ein <xref:System.Text.EncodingProvider> Objekt registriert wird:

- Wenn mindestens ein Codierungs Anbieter registriert wurde, wird die Codierung des letzten registrierten Anbieters zurückgegeben, der eine Codierung zurückgegeben hat, wenn der <xref:System.Text.Encoding.GetEncoding%2A> Methode ein `codepage` Argument 0 (null) überlassen wird.

- Wenn auf der .NET Framework kein Codierungs Anbieter registriert wurde und der <xref:System.Text.CodePagesEncodingProvider> der registrierte Codierungs Anbieter ist, oder wenn kein registrierter Codierungs Anbieter einen `codepage` Wert von 0 verarbeitet, wird die aktive Codepage zurückgegeben.

- Wenn in .net Core kein Codierungs Anbieter registriert wurde oder wenn kein registrierter Codierungs Anbieter einen `codepage` Wert von 0 verarbeitet, wird die <xref:System.Text.UTF8Encoding> Codierung zurückgegeben.

> [!NOTE]
>  Die ANSI-Codepages können sich auf verschiedenen Computern unterscheiden und können auf einem einzelnen Computer geändert werden, was zu Daten Beschädigungen führt. Aus diesem Grund wird, wenn die aktive Codepage eine ANSI-Codepage ist, das Codieren und Decodieren von Daten mithilfe der Standard Codepage, die von `Encoding.GetEncoding(0)` zurückgegeben wird, nicht empfohlen. Um möglichst konsistente Ergebnisse zu erzielen, sollten Sie Unicode verwenden, z. b. UTF-8 (Codepage 65001) oder UTF-16 anstelle einer bestimmten Codepage.

 Zum Abrufen der Codierung, die der aktiven Codepage zugeordnet ist, können Sie entweder den Wert 0 für das `codepage` Argument angeben oder, wenn der Code auf der .NET Framework auf dem Windows-Desktop ausgeführt wird, den Wert der <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>-Eigenschaft abrufen. Um die aktuelle aktive Codepage zu ermitteln, müssen Sie die Windows [GetACP-](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Funktion aus dem .NET Framework auf dem Windows-Desktop aufrufen.

 <xref:System.Text.Encoding.GetEncoding%2A> gibt eine zwischengespeicherte-Instanz mit Standardeinstellungen zurück. Verwenden Sie die Konstruktoren abgeleiteter Klassen, um eine Instanz mit unterschiedlichen Einstellungen zu erhalten. Beispielsweise stellt die <xref:System.Text.UTF32Encoding>-Klasse einen Konstruktor bereit, mit dem Sie die Fehlererkennung aktivieren können.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> Methode.

 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codepage" /> ist kleiner als 0 (null) oder größer als 65535.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" /> wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" /> wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Codepagename der bevorzugten Codierung. Jeder von der <see cref="P:System.Text.Encoding.WebName" />-Eigenschaft zurückgegebene Wert ist gültig. Mögliche Werte sind in der Name-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.</param>
        <param name="encoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn ein Zeichen nicht mit der aktuellen Codierung codiert werden kann.</param>
        <param name="decoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn eine Bytefolge nicht mit der aktuellen Codierung decodiert werden kann.</param>
        <summary>Gibt die dem angegebenen Codepagenamen zugeordnete Codierung zurück. Parameter geben einen Fehlerhandler für Zeichen an, die nicht codiert werden können, und für Bytefolgen, die nicht decodiert werden können.</summary>
        <returns>Die Codierung, die der angegebenen Codepage zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

In der .NET Framework basiert die <xref:System.Text.Encoding.GetEncoding%2A>-Methode auf der zugrunde liegenden Plattform, um die meisten Codepages zu unterstützen. Allerdings unterstützt die .NET Framework nativ einige Codierungen. Eine Liste der Codepages finden Sie im Thema <xref:System.Text.Encoding>-Klasse. In .net Core gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode die Codierungen zurück, die von .net Core unterstützt werden. Bei beiden .net-Implementierungen können Sie die <xref:System.Text.Encoding.GetEncodings%2A>-Methode zum Abrufen eines Arrays von <xref:System.Text.EncodingInfo> Objekten, das Informationen zu allen verfügbaren Codierungen enthält, abrufen.

 Zusätzlich zu den Codierungen, die in .net Core nativ verfügbar sind oder auf einer bestimmten Platt Form Version der .NET Framework intrinsisch unterstützt werden, gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode alle zusätzlichen Codierungen zurück, die durch das Registrieren eines-<xref:System.Text.EncodingProvider> verfügbar gemacht werden. Objekt. Wenn dieselbe Codierung von mehreren <xref:System.Text.EncodingProvider> Objekten registriert wurde, gibt diese Methode die zuletzt registrierte zurück.

> [!NOTE]
>  Die ANSI-Codepages können sich auf verschiedenen Computern unterscheiden und können auf einem einzelnen Computer geändert werden, was zu Daten Beschädigungen führt. Um möglichst konsistente Ergebnisse zu erzielen, sollten Sie eine Unicode-Codierung, z. b. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage verwenden.

 <xref:System.Text.Encoding.GetEncoding%2A> gibt eine zwischengespeicherte-Instanz mit Standardeinstellungen zurück. Verwenden Sie die Konstruktoren abgeleiteter Klassen, um eine Instanz mit unterschiedlichen Einstellungen zu erhalten. Beispielsweise stellt die <xref:System.Text.UTF32Encoding>-Klasse einen Konstruktor bereit, mit dem Sie die Fehlererkennung aktivieren können.



## Examples
 Das folgende Beispiel veranschaulicht die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> Methode.

 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist kein gültiger Codepagename.

- oder -

Die durch <paramref name="name" /> angegebene Codepage wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array zurück, das alle Codierungen enthält.</summary>
        <returns>Ein Array, das alle Codierungen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode gibt eine Liste der unterstützten Codierungen zurück, die durch die Codepage eindeutig unterschieden werden. Eine Tabelle, in der die unterstützten Codierungen aufgeführt sind, finden Sie im Thema <xref:System.Text.Encoding>-Klasse.

> [!NOTE]
>  Die Liste der unterstützten Codierungen, die von der <xref:System.Text.Encoding.GetEncodings%2A>-Methode zurückgegeben werden, umfasst keine zusätzlichen Codierungen, die von <xref:System.Text.EncodingProvider> Implementierungen bereitgestellt werden, die durch Aufrufe der <xref:System.Text.Encoding.RegisterProvider%2A>-Methode registriert wurden.

 Auf der .NET Framework sind die Codierungen 50220 und 50222 mit dem Namen "ISO-2022-JP" verknüpft, sind jedoch nicht identisch. Codierung 50220 konvertiert Katakana-Zeichen mit halber Breite in Katakana-Zeichen mit voller Breite, während die Codierung 50222 eine UMSCHALT-in/UMSCHALT-out-Sequenz verwendet, um Katakana-Zeichen mit halber Breite zu codieren. Der Anzeige Name für die Codierung 50222 lautet "Japanisch (JIS-Allow 1 Byte Kana-so/SI)", um ihn von der Codierung 50220 mit dem anzeigen Amen "Japanese (JIS)" zu unterscheiden.

 Wenn Sie den Codierungs Namen "ISO-2022-JP" anfordern, gibt der .NET Framework Encoding 50220 zurück. Die für Ihre APP geeignete Codierung hängt jedoch von der bevorzugten Behandlung der Katakana-Zeichen mit halber Breite ab.

 Um eine bestimmte Codierung zu erhalten, sollten Sie die <xref:System.Text.Encoding.GetEncoding%2A>-Methode verwenden.

 <xref:System.Text.Encoding.GetEncodings%2A> wird manchmal verwendet, um dem Benutzer eine Liste der Codierungen im Dialogfeld Datei **Speichern** unter zu präsentieren. Viele nicht-Unicode-Codierungen sind jedoch entweder unvollständig und übersetzen viele Zeichen in "?" oder verfügen über ein unterschiedliches Verhalten auf verschiedenen Plattformen. Verwenden Sie als Standard UTF-8 oder UTF-16.



## Examples
 Im folgenden Beispiel werden die Werte der booleschen Eigenschaften der einzelnen Codierungen überprüft.

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für die aktuelle Instanz zurück.</summary>
        <returns>Der Hashcode für die aktuelle Instanz.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die maximale Anzahl der Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt werden.</summary>
        <returns>Die maximale Anzahl an Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der `charCount`-Parameter gibt tatsächlich die Anzahl der <xref:System.Char> Objekte an, die die zu codierende Unicode-Zeichen darstellen, da .NET intern UTF-16 verwendet, um Unicode-Zeichen darzustellen. Folglich können die meisten Unicode-Zeichen durch ein <xref:System.Char> Objekt dargestellt werden, aber ein Unicode-Zeichen, das durch ein Ersatz Zeichenpaar dargestellt wird, erfordert beispielsweise zwei <xref:System.Char> Objekte.

 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, sollten Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode verwenden. Verwenden Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode, um die maximale Array Größe zu berechnen. Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 <xref:System.Text.Encoding.GetMaxByteCount%2A> Ruft die Nummer des ungünstigsten Falls ab, einschließlich des ungünstigsten Falls für den aktuell ausgewählten <xref:System.Text.EncoderFallback>. Wenn ein Fall Back mit einer potenziell großen Zeichenfolge ausgewählt wird, werden von <xref:System.Text.Encoding.GetMaxByteCount%2A> große Werte abgerufen, insbesondere in Fällen, in denen der schlechteste Fall für die Codierung das Wechseln von Modi für jedes Zeichen einschließt. Dies kann z. b. bei ISO-2022-JP der Fall sein. Weitere Informationen finden Sie im Blogbeitrag "[Was ist mit Encoding. GetMaxByteCount () und Encoding. GetMaxCharCount ()?](https://blogs.msdn.microsoft.com/shawnste/2005/03/02/whats-with-encoding-getmaxbytecount-and-encoding-getmaxcharcount/)".

 In den meisten Fällen ruft diese Methode angemessene Werte für kleine Zeichen folgen ab. Bei großen Zeichen folgen müssen Sie möglicherweise zwischen der Verwendung sehr großer Puffer und dem Abfangen von Fehlern in seltenen Fällen wählen, wenn ein sinnvoller Puffer zu klein ist. Möglicherweise möchten Sie auch einen anderen Ansatz mit <xref:System.Text.Encoding.GetByteCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>in Erwägung gezogen.

 Wenn Sie <xref:System.Text.Encoding.GetMaxByteCount%2A>verwenden, sollten Sie den Ausgabepuffer basierend auf der maximalen Größe des Eingabe Puffers zuordnen. Wenn die Größe des Ausgabepuffers eingeschränkt ist, können Sie die <xref:System.Text.Encoding.Convert%2A>-Methode verwenden.

 Beachten Sie, dass <xref:System.Text.Encoding.GetMaxByteCount%2A> potenzielle Ersatz Zeichen von einem vorherigen Decoder-Vorgang berücksichtigt. Aufgrund des Decoders wird durch Übergeben des Werts 1 an die-Methode 2 für eine Einzel Byte Codierung, z. b. ASCII, abgerufen. Wenn diese Informationen erforderlich sind, sollten Sie die <xref:System.Text.ASCIIEncoding.IsSingleByte%2A>-Eigenschaft verwenden.

> [!NOTE]
>  `GetMaxByteCount(N)` ist nicht notwendigerweise derselbe Wert wie `N* GetMaxByteCount(1)`.



## Examples
 Im folgenden Beispiel wird die Anzahl der Bytes bestimmt, die zum Codieren eines Zeichen Arrays erforderlich sind, die Zeichen codiert und die resultierenden Bytes angezeigt werden.

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <block subset="none" type="overrides"><para>Alle <see cref="T:System.Text.Encoding" /> Implementierungen müssen sicherstellen, dass keine Pufferüberlauf Ausnahmen auftreten, wenn Puffer entsprechend den Ergebnissen der Berechnungen dieser Methode vergrößert werden.</para></block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die maximale Anzahl an Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</summary>
        <returns>Die maximale Anzahl von Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, sollten Sie die <xref:System.Text.Encoding.GetCharCount%2A>-Methode verwenden. Verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode, um die maximale Array Größe zu berechnen. Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.

 <xref:System.Text.Encoding.GetMaxCharCount%2A> Ruft die Nummer des ungünstigsten Falls ab, einschließlich des ungünstigsten Falls für den aktuell ausgewählten <xref:System.Text.DecoderFallback>. Wenn ein Fall Back mit einer potenziell großen Zeichenfolge ausgewählt wird, ruft <xref:System.Text.Encoding.GetMaxCharCount%2A> große Werte ab.

 In den meisten Fällen ruft diese Methode angemessene Zahlen für kleine Zeichen folgen ab. Bei großen Zeichen folgen müssen Sie möglicherweise zwischen der Verwendung sehr großer Puffer und dem Abfangen von Fehlern wählen, wenn ein sinnvoller Puffer zu klein ist. Möglicherweise möchten Sie auch einen anderen Ansatz mit <xref:System.Text.Encoding.GetCharCount%2A> oder <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>in Erwägung gezogen.

 <xref:System.Text.Encoding.GetMaxCharCount%2A> hat keine Beziehung zu <xref:System.Text.Encoding.GetBytes%2A>. Wenn Sie eine ähnliche Funktion benötigen, die mit <xref:System.Text.Encoding.GetBytes%2A>verwendet werden soll, sollten Sie <xref:System.Text.Encoding.GetMaxByteCount%2A>verwenden.

 Wenn Sie <xref:System.Text.Encoding.GetMaxCharCount%2A>verwenden, sollten Sie den Ausgabepuffer basierend auf der maximalen Größe des Eingabe Puffers zuordnen. Wenn die Größe des Ausgabepuffers eingeschränkt ist, können Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode verwenden.

 Beachten Sie, dass <xref:System.Text.Encoding.GetMaxCharCount%2A> den ungünstigsten Fall für übrig gebliebene Bytes aus einem vorherigen Codierungs Vorgang berücksichtigt. Bei den meisten Codepages ruft der Wert 0 (null) an diese Methode Werte ab, die größer oder gleich 1 sind.

> [!NOTE]
>  `GetMaxCharCount(N)` ist nicht notwendigerweise derselbe Wert wie `N* GetMaxCharCount(1)`.



## Examples
 Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann in ein Zeichen Array decodiert.

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <block subset="none" type="overrides"><para>Alle <see cref="T:System.Text.Encoding" /> Implementierungen müssen sicherstellen, dass keine Pufferüberlauf Ausnahmen auftreten, wenn Puffer entsprechend den Ergebnissen der Berechnungen dieser Methode vergrößert werden.</para></block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge zurückgegeben, die die verwendete Codierung angibt.</summary>
        <returns>Ein Bytearray, das eine Bytefolge enthält, in der die verwendete Codierung angegeben ist.

 - oder -

 Ein Bytearray der Länge 0 (null), wenn keine Präambel erforderlich ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das <xref:System.Text.Encoding>-Objekt stellt optional eine Präambel bereit, bei der es sich um ein Bytearray handelt, dem die Byte Sequenz vorangestellt werden kann, die sich aus dem Codierungsprozess ergibt. Wenn die Präambel eine Byte Reihenfolge-Markierung (in Unicode, Codepunkt U + FEFF) enthält, unterstützt Sie der Decoder dabei, die Byte Reihenfolge und das Transformations Format oder UTF zu bestimmen.

 Die Unicode-Byte Reihenfolge Markierung (BOM) wird wie folgt serialisiert (in Hexadezimal):

-   UTF-8: EF BB BF

-   UTF-16 Big-Endian-Byte Reihenfolge: FE FF

-   UTF-16 Little-Endian-Byte Reihenfolge: FF FE

-   UTF-32 Big Endian-Byte Reihenfolge: 00 00 FE FF

-   UTF-32 Little-Endian-Byte Reihenfolge: FF FE 00 00

 Sie sollten die BOM verwenden, da Sie fast eine bestimmte Identifizierung einer Codierung für Dateien bereitstellt, die andernfalls einen Verweis auf das <xref:System.Text.Encoding> Objekt verloren haben, z. b. nicht markierte oder nicht ordnungsgemäß markierte Webdaten oder Zufalls Textdateien, die gespeichert wurden, wenn ein Unternehmen nicht über Internationale Belange oder andere Daten. Häufig können Benutzer Probleme vermieden werden, wenn die Daten konsistent und ordnungsgemäß gekennzeichnet sind, vorzugsweise in UTF-8 oder UTF-16.

 Bei Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant. Sie kann jedoch verwendet werden, um einem Server zu helfen, den richtigen Codierungs Header zu senden. Alternativ kann es als Fall Back für den Fall verwendet werden, dass die Codierung andernfalls verloren geht.

 Es gibt einige Nachteile bei der Verwendung einer BOM. Beispielsweise kann das Einschränken der Datenbankfelder, die eine BOM verwenden, schwierig sein. Die Verkettung von Dateien kann auch ein Problem darstellen, z. b. wenn Dateien so zusammengeführt werden, dass ein unnötiges Zeichen in der Mitte der Daten enden kann. Trotz der wenigen Nachteile wird die Verwendung einer BOM dringend empfohlen.

 Weitere Informationen zur Byte Reihenfolge und zur Byte Reihenfolge-Markierung finden Sie im Unicode-Standard auf der [Unicode-Homepage](https://go.microsoft.com/fwlink/?LinkId=37123).

> [!CAUTION]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie codierte Bytes mit einer Präambel versehen. Bei den meisten Codierungen wird jedoch keine Präambel bereitgestellt. Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie eine Unicode-Codierung verwenden, d. h., <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>oder <xref:System.Text.UTF32Encoding>mit einer Präambel.



## Examples
 Im folgenden Beispiel wird die Byte Reihenfolge der Codierung basierend auf der Präambel bestimmt.

 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge in eine Zeichenfolge decodiert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden alle Bytes im angegebenen Bytearray in eine Zeichenfolge decodiert.</summary>
        <returns>Eine Zeichenfolge, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie das <xref:System.Text.Decoder> Objekt verwenden, das von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode einer abgeleiteten klassi.

 Weitere Informationen zu Decodierungs Techniken und-Überlegungen finden Sie im Abschnitt "Hinweise" des <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Referenz Themas.

 Beachten Sie, dass das genaue Verhalten der <xref:System.Text.Encoding.GetString%2A> Methode für eine bestimmte <xref:System.Text.Encoding> Implementierung von der Fall Back Strategie abhängt, die für dieses <xref:System.Text.Encoding> Objekt definiert ist. Weitere Informationen finden Sie im Abschnitt "Auswählen einer Fall Back Strategie" des Themas [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md) .



## Examples
 Im folgenden Beispiel wird eine UTF-8-codierte Zeichenfolge aus einer Binärdatei gelesen, die von einem <xref:System.IO.FileStream>-Objekt dargestellt wird. Bei Dateien, die kleiner als 2.048 Bytes sind, liest der Inhalt der gesamten Datei in ein Bytearray und ruft die <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29>-Methode auf, um die Decodierung auszuführen. Bei größeren Dateien liest Sie jeweils 2.048 Bytes in ein Bytearray, ruft die <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>-Methode auf, um zu bestimmen, wie viele Zeichen im Array enthalten sind, und ruft dann die <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType>-Methode auf, um die Decodierung auszuführen.

 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]

 Im Beispiel wird der folgende Text verwendet, der in einer UTF-8-codierten Datei mit dem Namen Utf8Example. txt gespeichert werden soll.

```

This is a UTF-8-encoded file that contains primarily Latin text, although it
does list the first twelve letters of the Russian (Cyrillic) alphabet:

А б в г д е ё ж з и й к

The goal is to save this file, then open and decode it as a binary stream.

```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Bytearray enthält ungültige Unicode-Codepunkte.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">Eine schreibgeschützte Spanne, die in eine Unicode-Zeichenfolge decodiert werden soll.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden alle Bytes in der angegebenen Bytespanne in eine Zeichenfolge decodiert.</summary>
        <returns>Eine Zeichenfolge, die die decodierten Bytes aus der bereitgestellten schreibgeschützten Spanne enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.Encoding.GetString%2A>-Methode wurde entwickelt, um die Leistung zu optimieren. Anstatt ein verwaltetes Bytearray zu erstellen und anschließend zu decodieren, können Sie stattdessen diese Methode aufrufen, ohne zwischen Objekte erstellen zu müssen.

 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie das <xref:System.Text.Decoder> Objekt verwenden, das von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode einer abgeleiteten klassi.

 Weitere Informationen zu Decodierungs Techniken und-Überlegungen finden Sie im Abschnitt "Hinweise" des <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Referenz Themas.

 Beachten Sie, dass das genaue Verhalten der <xref:System.Text.Encoding.GetString%2A> Methode für eine bestimmte <xref:System.Text.Encoding> Implementierung von der Fall Back Strategie abhängt, die für dieses <xref:System.Text.Encoding> Objekt definiert ist. Weitere Informationen finden Sie im Abschnitt "Auswählen einer Fall Back Strategie" des Themas [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md) .

 ]]></format>
        </remarks>

      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf ein Bytearray.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine angegebene Anzahl von Bytes ab einer angegebenen Adresse in eine Zeichenfolge decodiert.</summary>
        <returns>Eine Zeichenfolge, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.Encoding.GetString%2A>-Methode wurde entwickelt, um die Leistung zu optimieren, wenn Sie einen systemeigenen Zeiger auf ein Bytearray haben. Anstatt ein verwaltetes Bytearray zu erstellen und anschließend zu decodieren, können Sie stattdessen diese Methode aufrufen, ohne zwischen Objekte erstellen zu müssen.

 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie das <xref:System.Text.Decoder> Objekt verwenden, das von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode einer abgeleiteten klassi.

 Weitere Informationen zu Decodierungs Techniken und-Überlegungen finden Sie im Abschnitt "Hinweise" des <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Referenz Themas.

 Beachten Sie, dass das genaue Verhalten der <xref:System.Text.Encoding.GetString%2A> Methode für eine bestimmte <xref:System.Text.Encoding> Implementierung von der Fall Back Strategie abhängt, die für dieses <xref:System.Text.Encoding> Objekt definiert ist. Weitere Informationen finden Sie im Abschnitt "Auswählen einer Fall Back Strategie" des Themas [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md) .

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist ein NULL-Zeiger</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md))

- und -

 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge aus dem angegebenen Bytearray in eine Zeichenfolge decodiert.</summary>
        <returns>Eine Zeichenfolge, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die vom bereitgestellten <xref:System.Text.Encoder> verwenden <xref:System.Text.Encoding.GetDecoder%2A> Methode bzw. die <xref:System.Text.Encoding.GetEncoder%2A> Methode einer abgeleiteten Klasse.

 Weitere Informationen zu Decodierungs Techniken und-Überlegungen finden Sie im Abschnitt "Hinweise" des <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Referenz Themas.



## Examples
 Im folgenden Beispiel wird eine UTF-8-codierte Zeichenfolge aus einer Binärdatei gelesen, die durch ein <xref:System.IO.FileStream>-Objekt dargestellt wird. Bei Dateien, die kleiner als 2.048 Bytes sind, liest der Inhalt der gesamten Datei in ein Bytearray und ruft die <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Methode auf, um die Decodierung auszuführen. Bei größeren Dateien liest Sie jeweils 2.048 Bytes in ein Bytearray, ruft die <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>-Methode auf, um zu bestimmen, wie viele Zeichen im Array enthalten sind, und ruft dann die <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType>-Methode auf, um die Decodierung auszuführen.

 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]

 Im Beispiel wird der folgende Text verwendet, der in einer UTF-8-codierten Datei mit dem Namen Utf8Example. txt gespeichert werden soll.

```

This is a UTF-8-encoded file that contains primarily Latin text, although it
does list the first twelve letters of the Russian (Cyrillic) alphabet:

А б в г д е ё ж з и й к

The goal is to save this file, then open and decode it as a binary stream.

```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Bytearray enthält ungültige Unicode-Codepunkte.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.

- oder -

 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erklärung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).

- und -

 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Name für die aktuelle Codierung abgerufen, die mit den Header-Tags des E-Mail-Agenten verwendet werden kann.</summary>
        <value>Ein Name für die aktuelle <see cref="T:System.Text.Encoding" />, die für die Header-Tags des E-Mail-Agenten verwendet werden kann.

- oder -

Eine leere Zeichenfolge (""), wenn das aktuelle <see cref="T:System.Text.Encoding" /> nicht verwendet werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn Sie eine Codierung für einen Header Namen benötigen, sollten Sie die <xref:System.Text.Encoding.GetEncoding%2A>-Methode mit der <xref:System.Text.Encoding.HeaderName%2A>-Eigenschaft aufzurufen. Häufig wird von der-Methode eine andere Codierung von der im-Befehl bereitgestellten Test Codierung abgerufen. Im Allgemeinen müssen nur e-Mail-Anwendungen eine solche Codierung abrufen.

 In einigen Fällen entspricht der Wert der <xref:System.Text.Encoding.BodyName%2A>-Eigenschaft dem internationalen Standard, der diese Codierung definiert. Dies bedeutet nicht, dass die Implementierung vollständig mit diesem Standard übereinstimmt.

 Beachten Sie, dass <xref:System.Text.Encoding.WebName%2A> den Namen zurückgibt, der zum Beschreiben einer Codierung verwendet wird. Die <xref:System.Text.Encoding.HeaderName%2A>-Eigenschaft definiert eine andere Codierung, die möglicherweise für eine e-Mail-Anwendung besser geeignet ist, beispielsweise. Die Verwendung der-Eigenschaft zum Definieren der Codierung wird jedoch nicht empfohlen.



## Examples
 Im folgenden Beispiel werden die anderen Namen für die einzelnen Codierungen abgerufen und die Codierungen mit einem oder mehreren Namen angezeigt, die sich von <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>unterscheiden. Es wird <xref:System.Text.Encoding.EncodingName%2A> angezeigt, aber nicht mit diesem verglichen.

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle Codierung immer normalisiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle Codierung immer normalisiert ist. Es wird die Standardnormalisierungsform verwendet.</summary>
        <returns><see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" />-Klasse immer normalisiert ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die Standard normalisierungs Form ist <xref:System.Text.NormalizationForm.FormC>, bei der die vollständige kanonische Zerlegung verwendet wird, gefolgt von der Ersetzung von Sequenzen durch ihre primären Verbund, wenn möglich.

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="form">Einer der <see cref="T:System.Text.NormalizationForm" />-Werte.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung immer normalisiert ist. Hierzu wird die angegebene Normalisierungsform verwendet.</summary>
        <returns><see langword="true" />, wenn das aktuelle <see cref="T:System.Text.Encoding" />-Objekt immer mit dem angegebenen <see cref="T:System.Text.NormalizationForm" />-Wert normalisiert wird, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die Standard normalisierungs Form ist <xref:System.Text.NormalizationForm.FormC>, bei der die vollständige kanonische Zerlegung verwendet wird, gefolgt von der Ersetzung von Sequenzen durch ihre primären Verbund, wenn möglich.

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Browserclients zum Anzeigen des Inhalts verwendet werden kann.</summary>
        <value><see langword="true" /> wenn das aktuelle <see cref="T:System.Text.Encoding" /> von Browserclients verwendet werden kann, um Inhalt anzuzeigen; andernfalls, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel werden die Werte der booleschen Eigenschaften der einzelnen Codierungen überprüft.

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Browserclients zum Speichern von Inhalt verwendet werden kann.</summary>
        <value><see langword="true" /> wenn das aktuelle <see cref="T:System.Text.Encoding" /> von Browserclients verwendet werden kann, um Inhalt zu speichern; andernfalls, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel werden die Werte der booleschen Eigenschaften der einzelnen Codierungen überprüft.

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Mail- und Newsclients zum Anzeigen von Inhalt verwendet werden kann.</summary>
        <value><see langword="true" /> wenn die aktuelle <see cref="T:System.Text.Encoding" />-Klasse von Mail- und Newsclients verwendet werden kann, um Inhalt anzuzeigen; andernfalls, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel werden die Werte der booleschen Eigenschaften der einzelnen Codierungen überprüft.

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Mail- und Newsclients zum Speichern von Inhalt verwendet werden kann.</summary>
        <value><see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> von Mail- und Newsclients verwendet werden kann, um Inhalt zu speichern, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Im folgenden Beispiel werden die Werte der booleschen Eigenschaften der einzelnen Codierungen überprüft.

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob die aktuelle Codierung schreibgeschützt ist.</summary>
        <value><see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> schreibgeschützt ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob die aktuelle Codierung Einzelbyte-Codepunkte verwendet.</summary>
        <value><see langword="true" />, wenn das aktuelle <see cref="T:System.Text.Encoding" /> Einzelbyte-Codepunkte verwendet; andernfalls, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Bei einer Single-Byte-Codierung, z. b. <xref:System.Text.ASCIIEncoding>, ruft diese Eigenschaft `true`ab.

> [!CAUTION]
>  Sie sollten mit dem Wert für <xref:System.Text.Encoding.IsSingleByte%2A>vorsichtig vorgehen. Eine Annahme, wie eine Codierung fortgesetzt wird, ist möglicherweise trotzdem falsch. Windows-1252 hat z. b. den Wert `true` für <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, aber Encoding. GetMaxByteCount (1) gibt 2 zurück. Dies liegt daran, dass die-Methode potenzielle Ersatz Zeichen aus einem vorherigen Decoder-Vorgang berücksichtigt.



## Examples
 Im folgenden Beispiel werden die Werte der booleschen Eigenschaften der einzelnen Codierungen überprüft.

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Spanne mit der Bytefolge zurückgegeben, die die verwendete Codierung angibt.</summary>
        <returns>Eine Bytespanne mit einer Bytefolge, die die verwendete Codierung angibt, oder eine Spanne der Länge 0 (null), wenn keine Präambel erforderlich ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das <xref:System.Text.Encoding>-Objekt stellt optional eine Präambel bereit, bei der es sich um eine Byte Sequenz handelt, die den Bytes vorangestellt werden kann, die sich aus dem Codierungsprozess ergeben. Wenn die Präambel eine Byte Reihenfolge-Markierung (in Unicode, Codepunkt U + FEFF) enthält, unterstützt Sie der Decoder dabei, die Byte Reihenfolge und das Transformations Format oder UTF zu bestimmen.

 Die Unicode-Byte Reihenfolge Markierung (BOM) wird wie folgt serialisiert (in Hexadezimal):

-   UTF-8: EF BB BF

-   UTF-16 Big-Endian-Byte Reihenfolge: FE FF

-   UTF-16 Little-Endian-Byte Reihenfolge: FF FE

-   UTF-32 Big Endian-Byte Reihenfolge: 00 00 FE FF

-   UTF-32 Little-Endian-Byte Reihenfolge: FF FE 00 00

 Sie sollten die BOM verwenden, da Sie fast eine bestimmte Identifizierung einer Codierung für Dateien bereitstellt, die andernfalls einen Verweis auf das <xref:System.Text.Encoding> Objekt verloren haben, z. b. nicht markierte oder nicht ordnungsgemäß markierte Webdaten oder Zufalls Textdateien, die gespeichert wurden, wenn ein Unternehmen nicht über Internationale Belange oder andere Daten. Häufig können Benutzer Probleme vermieden werden, wenn die Daten konsistent und ordnungsgemäß gekennzeichnet sind, vorzugsweise in UTF-8 oder UTF-16.

 Bei Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant. Sie kann jedoch verwendet werden, um einem Server zu helfen, den richtigen Codierungs Header zu senden. Alternativ kann es als Fall Back für den Fall verwendet werden, dass die Codierung andernfalls verloren geht.

 Es gibt einige Nachteile bei der Verwendung einer BOM. Beispielsweise kann das Einschränken der Datenbankfelder, die eine BOM verwenden, schwierig sein. Die Verkettung von Dateien kann auch ein Problem darstellen, z. b. wenn Dateien so zusammengeführt werden, dass ein unnötiges Zeichen in der Mitte der Daten enden kann. Trotz der wenigen Nachteile wird jedoch dringend empfohlen, eine BOM zu verwenden.

 Weitere Informationen zur Byte Reihenfolge und zur Byte Reihenfolge-Markierung finden Sie im Unicode-Standard auf der [Unicode-Homepage](https://home.unicode.org/).

> [!CAUTION]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie codierte Bytes mit einer Präambel versehen. Bei den meisten Codierungen wird jedoch keine Präambel bereitgestellt. Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie eine Unicode-Codierung verwenden, d. h., <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>oder <xref:System.Text.UTF32Encoding>mit einer Präambel.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Eine Unterklasse von <see cref="T:System.Text.EncodingProvider" />, die Zugriff auf zusätzliche Zeichencodierungen bietet.</param>
        <summary>Registriert einen Codierungsanbieter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.Encoding.RegisterProvider%2A>-Methode ermöglicht es Ihnen, eine von <xref:System.Text.EncodingProvider> abgeleitete Klasse zu registrieren, die Zeichen Codierungen auf einer Plattform zur Verfügung stellt, von der Sie andernfalls nicht unterstützt werden. Nachdem der Codierungs Anbieter registriert wurde, können die Codierungen, die er unterstützt, durch Aufrufen beliebiger <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> Überladungen abgerufen werden. Wenn mehrere Codierungs Anbieter vorhanden sind, versucht die <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> Methode, eine angegebene Codierung von jedem Anbieter abzurufen, beginnend mit dem zuletzt registrierten.

Durch das Registrieren eines Codierungs Anbieters mithilfe der <xref:System.Text.Encoding.RegisterProvider%2A>-Methode wird auch das Verhalten der Methoden [Encoding. GetEncoding (Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) und [encodingprovider. GetEncoding (Int32, EncoderFallback, DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) geändert, wenn ein Argument übermittelt wurde. `0`:

- Wenn der registrierte Anbieter die <xref:System.Text.CodePagesEncodingProvider>ist, gibt die Methode die Codierung zurück, die mit der aktiven System Codepage übereinstimmt, wenn Sie unter dem Windows-Betriebssystem ausgeführt wird.

- Ein benutzerdefinierter Codierungs Anbieter kann auswählen, welche Codierung zurückgegeben werden soll, wenn einer dieser <xref:System.Text.Encoding.GetEncoding%2A> Methoden Überladungen ein Argument von `0`übertragen wird. Der Anbieter kann auch auswählen, dass keine Codierung zurückgegeben wird, wenn die <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType>-Methode `null`zurückgibt.

Beginnend mit dem .NET Framework 4,6 umfasst der .NET Framework einen Codierungs Anbieter, <xref:System.Text.CodePagesEncodingProvider>, der die Codierungen verfügbar macht, die im vollständigen .NET Framework vorhanden sind, aber nicht im universelle Windows-Plattform verfügbar sind. Standardmäßig unterstützt die universelle Windows-Plattform nur die Unicode-Codierungen, ASCII und Codepage 28591.

 Wenn derselbe Codierungs Anbieter in mehreren Aufrufen der <xref:System.Text.Encoding.RegisterProvider%2A>-Methode verwendet wird, registriert nur der erste Methodenaufruf den Anbieter. Nachfolgende Aufrufe werden ignoriert.

 Wenn die <xref:System.Text.Encoding.RegisterProvider%2A>-Methode aufgerufen wird, um mehrere Anbieter zu registrieren, die dieselbe Codierung verarbeiten, wird der zuletzt registrierte Anbieter für alle Codierungs-und Decodierungs Vorgänge verwendet. Alle zuvor registrierten Anbieter werden ignoriert.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="provider" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-16-Format in der Little-Endian-Bytereihenfolge ab.</summary>
        <value>Eine Codierung für das UTF-16-Format mit Little-Endian-Bytereihenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Informationen zu den von .NET unterstützten Codierungen und eine Erörterung der zu verwendenden Unicode-Codierung finden Sie unter [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md).

 Das <xref:System.Text.UnicodeEncoding> Objekt, das von dieser Eigenschaft zurückgegeben wird, verfügt möglicherweise nicht über das entsprechende Verhalten für Ihre APP. Er verwendet einen Ersatz Fall Back, um jede Zeichenfolge zu ersetzen, die nicht codiert werden kann, und jedes Byte, das nicht mit einem Fragezeichen ("?") decodiert werden kann. Stattdessen können Sie den <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>-Konstruktor zum Instanziieren eines kleinen Enumeration<xref:System.Text.UnicodeEncoding> Objekts, dessen Fall Back entweder <xref:System.Text.EncoderFallbackException> oder <xref:System.Text.DecoderFallbackException>ist, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]



## Examples
 Im folgenden Beispiel wird die Anzahl der Bytes bestimmt, die zum Codieren eines Zeichen Arrays erforderlich sind, die Zeichen codiert und die resultierenden Bytes angezeigt werden.

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-32-Format in der Little-Endian-Bytereihenfolge ab.</summary>
        <value>Ein Codierungsobjekt für das UTF-32-Format mit Little-Endian-Bytereihenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das <xref:System.Text.UTF32Encoding> Objekt, das von dieser Eigenschaft zurückgegeben wird, verfügt möglicherweise nicht über das entsprechende Verhalten für Ihre APP. Er verwendet einen Ersatz Fall Back, um jede Zeichenfolge zu ersetzen, die nicht codiert werden kann, und jedes Byte, das nicht mit dem Unicode-Ersetzungs Zeichen (U + FFFE) decodiert werden kann. Stattdessen können Sie den <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>-Konstruktor aufzurufen, um ein <xref:System.Text.UTF32Encoding> Objekt zu instanziieren, dessen Fall Back entweder eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>ist, wie im folgenden Beispiel veranschaulicht.

 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]

 Eine Erläuterung der Little-Endian-Byte Reihenfolge finden Sie im Thema <xref:System.Text.Encoding>-Klasse.

 Weitere Informationen zu den von .NET unterstützten Codierungen und eine Erörterung der zu verwendenden Unicode-Codierung finden Sie unter [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md).



## Examples
 Im folgenden Beispiel wird die Anzahl der Bytes bestimmt, die zum Codieren eines Zeichen Arrays erforderlich sind, die Zeichen codiert und die resultierenden Bytes angezeigt werden.

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-7-Format ab.</summary>
        <value>Eine Codierung für das UTF-7-Format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 UTF-7-Codierung wird hauptsächlich in Umgebungen verwendet, die in der Vergangenheit auf 7 Bits beschränkt waren, wie z. b. NNTP und einige e-Mail-Anwendungen. Aufgrund von Problemen mit Stabilität und Sicherheit sollten Sie UTF7 Encoding nicht in 8-Bit-Umgebungen verwenden, in denen stattdessen UTF-8-Codierung verwendet werden kann.



## Examples
 Im folgenden Beispiel wird die Anzahl der Bytes bestimmt, die zum Codieren eines Zeichen Arrays erforderlich sind, die Zeichen codiert und die resultierenden Bytes angezeigt werden.

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-8-Format ab.</summary>
        <value>Eine Codierung für das UTF-8-Format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Eigenschaft gibt ein <xref:System.Text.UTF8Encoding> Objekt zurück, das Unicode-Zeichen (UTF-16-codierte Zeichen) in eine Sequenz von einem bis vier Bytes pro Zeichen codiert und ein UTF-8-codiertes Bytearray in Unicode-Zeichen (UTF-16-codiert) decodiert. Informationen zu den von .NET unterstützten Zeichen Codierungen und eine Erörterung der zu verwendenden Unicode-Codierung finden Sie unter [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md).

 Das <xref:System.Text.UTF8Encoding> Objekt, das von dieser Eigenschaft zurückgegeben wird, verfügt möglicherweise nicht über das entsprechende Verhalten für Ihre APP.

-   Es gibt ein <xref:System.Text.UTF8Encoding> Objekt zurück, das eine Unicode-Byte Reihenfolge Markierung (BOM) bereitstellt. Um eine UTF8-Codierung zu instanziieren, die keine BOM bereitstellt, müssen Sie eine beliebige Überladung des <xref:System.Text.UTF8Encoding.%23ctor%2A> Konstruktors aufrufen.

-   Es gibt ein <xref:System.Text.UTF8Encoding> Objekt zurück, das den Ersatz Fall Back verwendet, um jede Zeichenfolge zu ersetzen, die nicht codiert werden kann, und jedes Byte, das nicht mit einem Fragezeichen ("?") decodiert werden kann. Stattdessen können Sie den <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>-Konstruktor aufzurufen, um ein <xref:System.Text.UTF8Encoding> Objekt zu instanziieren, dessen Fall Back entweder eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>ist, wie im folgenden Beispiel veranschaulicht.

     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]



## Examples
 Im folgenden Beispiel wird ein Array definiert, das aus den folgenden Zeichen besteht:

-   Latin Small Letter Z (U + 007A)

-   Lateinisch Kleinbuchstabe A (U + 0061)

-   Kombinieren von Breve (U + 0306)

-   Lateinisch kleiner Buchstabe Ae mit akut (U + 01fd)

-   Griechisch Small Letter Beta (U + 03b2)

-   Ein Ersatz Zeichenpaar (u + D800 und u + DD54), das griechisch-acrophonische Dachboden 1000-Status (u + 10154) bildet.

 Es zeigt die UTF-16-Code Einheiten der einzelnen Zeichen an und bestimmt die Anzahl von Bytes, die von einem UTF-8-Encoder zum Codieren des Zeichen Arrays benötigt werden. Anschließend werden die Zeichen codiert und die resultierenden UTF-8-codierten Bytes angezeigt.

 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird der Name für die aktuelle Codierung bei der Internet Assigned Numbers Authority (IANA) registriert.</summary>
        <value>Der IANA-Name für die aktuelle <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Text.Encoding.WebName%2A>-Eigenschaft ist identisch mit der <xref:System.Text.EncodingInfo.Name%2A>-Eigenschaft.

 Beachten Sie, dass <xref:System.Text.Encoding.WebName%2A> einen IANA-registrierten Namen für die Codierung zurückgibt. Wenn der Wert dem Namen eines Standards entspricht, entspricht die Implementierung der Codierung möglicherweise nicht vollständig dem Standard. Die <xref:System.Text.Encoding.HeaderName%2A>-Eigenschaft definiert eine andere Codierung, die für e-Mail-Header besser geeignet ist. Allerdings sollten die meisten apps stattdessen <xref:System.Text.Encoding.WebName%2A> verwenden.

 Weitere Informationen zu IANA finden Sie unter [www.iana.org](https://www.iana.org/).

 Der <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> ist identisch mit dem von <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>zurückgegebenen <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Einige Webnamen sind Duplikate. Weitere Informationen finden Sie in den Hinweisen zum <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>.



## Examples
 Das folgende Beispiel schließt die <xref:System.Text.Encoding.WebName%2A> in einen HTML-Header ein.

 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]

 Im folgenden Beispiel werden die anderen Namen für die einzelnen Codierungen abgerufen und die Codierungen mit einem oder mehreren Namen angezeigt, die sich von <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>unterscheiden. Es wird <xref:System.Text.Encoding.EncodingName%2A> angezeigt, aber nicht mit diesem verglichen.

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird die Codepage des Betriebssystems Windows abgerufen, die der aktuellen Codierung am ehesten entspricht.</summary>
        <value>Die Codepage des Betriebssystems Windows, die der aktuellen <see cref="T:System.Text.Encoding" /> am ehesten entspricht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Eigenschaft wird aus Gründen der Kompatibilität mit den MLang-APIs (Windows Multilanguage) bereitgestellt, z. b. beim Bestimmen von Schriftfamilien. Bei der Globalisierung wird stattdessen die Verwendung einer der Unicode-Codierungen empfohlen. Außerdem wird empfohlen, anstelle von <xref:System.Text.Encoding.WindowsCodePage%2A> <xref:System.Text.Encoding.WebName%2A> zu verwenden, um die Codepage zu identifizieren.



## Examples
 Im folgenden Beispiel wird die Windows-Codepage festgelegt, die den einzelnen Codierungen am ehesten entspricht.

 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>
